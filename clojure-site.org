#+TITLE: Clojure website in org-mode
#+AUTHOR: Tony aldon
#+DATE: <2021-11-23 Tue>
#+VERSION: 0.1

#+LINK: clojure    ./clojure/src/clj/clojure/
#+LINK: spec.alpha ./spec.alpha/src/main/clojure/
#+LINK: core.async ./core.async/src/main/clojure/

# REPOSITORY_CLOJURE_SITE         https://github.com/clojure/clojure-site
# REPOSITORY_CLOJURE              https://github.com/clojure/clojure
# REPOSITORY_CLOJURE_SPEC_ALPHA   https://github.com/clojure/spec.alpha
# REPOSITORY_CLOJURE_CORE_ASYNC   https://github.com/clojure/core.async
# COMMIT_CLOJURE                  b8132f92
# COMMIT_CLOJURE_SITE             4a084a8
# COMMIT_CLOJURE_SPEC_ALPHA       23a6070
# COMMIT_CLOJURE_CORE_ASYNC       b7ddeaf

# Regarding the link to the files of clojure-site used in the property
# drawers, we assume that you have cloned it under the directory ./clojure-site/

# Following links are used in the cheatsheet section only

#+LINK: core.rrb-vector   ./core.rrb-vector/src/main/clojure/
#+LINK: data.avl          ./data.avl/src/main/clojure/
#+LINK: data.int-map      ./data.int-map/src/main/clojure/
#+LINK: data.priority-map ./data.priority-map/src/main/clojure/
#+LINK: tools.reader      ./tools.reader/src/main/clojure/
#+LINK: ordered           ./ordered/src/
#+LINK: useful            ./useful/src/

# REPOSITORY_CLOJURE_TOOLS_READER       https://github.com/clojure/tools.reader
# REPOSITORY_CLOJURE_CORE_RRB-VECTOR    https://github.com/clojure/core.rrb-vector
# REPOSITORY_CLOJURE_DATA_AVL           https://github.com/clojure/data.avl
# REPOSITORY_CLOJURE_DATA_INT_MAP       https://github.com/clojure/data.int-map
# REPOSITORY_CLOJURE_DATA_PRIORITY_MAP  https://github.com/clojure/data.priority-map
# REPOSITORY_CLJ_COMMONS_ORDERED        https://github.com/clj-commons/ordered
# REPOSITORY_CLJ_COMMONS_USEFUL         https://github.com/clj-commons/useful
# COMMIT_CLOJURE_TOOLS_READER           6918abc
# COMMIT_CLOJURE_CORE_RRB-VECTOR        88c2f81
# COMMIT_CLOJURE_DATA_AVL               e5a3985
# COMMIT_CLOJURE_DATA_INT_MAP           84a2cb8
# COMMIT_CLOJURE_DATA_PRIORITY_MAP      603d69e
# COMMIT_CLJ_COMMONS_ORDERED            cdf54bb
# COMMIT_CLJ_COMMONS_USEFUL             dc5cdeb

* About
** Rationale
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/rationale.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/rationale
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:NEXTPAGE_CUSTOM_ID: content/about/history
:CUSTOM_ID: content/about/rationale
:END:

Customers and stakeholders have substantial investments in, and are
comfortable with the performance, security and stability of,
industry-standard platforms like the JVM. While Java developers may envy
the succinctness, flexibility and productivity of dynamic languages,
they have concerns about running on customer-approved infrastructure,
access to their existing code base and libraries, and performance. In
addition, they face ongoing problems dealing with concurrency using
native threads and locking. Clojure is an effort in pragmatic dynamic
language design in this context. It endeavors to be a general-purpose
language suitable in those areas where Java is suitable. It reflects the
reality that, for the concurrent programming future, pervasive,
unmoderated mutation simply has to go.

Clojure meets its goals by: embracing an industry-standard, open
platform - the JVM; modernizing a venerable language - Lisp; fostering
functional programming with immutable persistent data structures; and
providing built-in concurrency support via software transactional memory
and asynchronous agents. The result is robust, practical, and fast.

Clojure has a distinctive approach to [[#content/about/state][state and identity]].

*** Why Clojure?

Why did I write yet another programming language? Basically because I
wanted:

- A Lisp
- for Functional Programming
- symbiotic with an established Platform
- designed for Concurrency

and couldn't find one. Here's an outline of some of the motivating ideas
behind Clojure.

*** Lisp is a good thing

- Often emulated/pillaged, still not duplicated
- Lambda calculus yields an extremely small core
- Almost no syntax
- Core advantage still code-as-data and syntactic abstraction
- What about the standard Lisps (Common Lisp and Scheme)?
  - Slow/no innovation post standardization
  - Core data structures mutable, not extensible
  - No concurrency in specs
  - Good implementations already exist for JVM (ABCL, Kawa, SISC et al)
  - Standard Lisps are their own platforms
- Clojure is a Lisp not constrained by backwards compatibility
  - Extends the code-as-data paradigm to maps and vectors
  - Defaults to immutability
  - Core data structures are extensible abstractions
  - Embraces a platform (JVM)

*** Functional programming is a good thing

- Immutable data + first-class functions
- Could always be done in Lisp, by discipline/convention
  - But if a data structure /can/ be mutated, dangerous to presume it
    won't be
  - In traditional Lisp, only the list data structure is structurally
    recursive
- Pure functional languages tend to strongly static types
  - Not for everyone, or every task
- Clojure is a functional language with a dynamic emphasis
  - All data structures immutable & persistent, supporting recursion
  - Heterogeneous collections, return types
  - Dynamic polymorphism

*** Languages and Platforms

- VMs, not OSes, are the platforms of the future, providing:
  - Type system
    - Dynamic enforcement and safety
  - Libraries
    - Abstract away OSes
    - /Huge/ set of facilities
    - Built-in and 3rd-party
  - Memory and other resource management
    - GC is platform, not language, facility
  - Bytecode + JIT compilation
    - Abstracts away hardware
- Language as platform vs. language + platform
  - Old way - each language defines its own runtime
    - GC, bytecode, type system, libraries etc
  - New way (JVM, .Net)
    - Common runtime independent of language
- Language built for platform vs language ported-to platform
  - Many new languages still take 'Language as platform' approach
  - When ported, have platform-on-platform issues
    - Memory management, type-system, threading issues
    - Library duplication
    - If original language based on C, some extension libraries
      written in C don't come over
- Platforms are dictated by clients
  - 'Must run on JVM' or .Net vs 'must run on Unix' or Windows
  - JVM has established track record and trust level
    - Now also open source
  - Interop with other code required
    - C linkage insufficient these days
- Java/JVM /is/ language + platform
  - Not the original story, but other languages for JVM always
    existed, now embraced by Sun
  - Java can be tedious, insufficiently expressive
    - Lack of first-class functions, no type inference, etc
  - Ability to call/consume Java is critical
- Clojure is the language, JVM the platform

*** Object Orientation is overrated

- Born of simulation, now used for everything, even when inappropriate
  - Encouraged by Java/C# in all situations, due to their lack of
    (idiomatic) support for anything else
- Mutable stateful objects are the new spaghetti code
  - Hard to understand, test, reason about
  - Concurrency disaster
- Inheritance is /not/ the only way to do polymorphism
- "It is better to have 100 functions operate on one data structure
  than to have 10 functions operate on 10 data structures." - Alan J.
  Perlis
- Clojure models its data structures as immutable objects represented
  by interfaces, and otherwise does not offer its own class system.
- Many functions defined on few primary data structures (seq, map,
  vector, set).
- Write Java in Java, consume and extend Java from Clojure.

*** Polymorphism is a good thing

- Switch statements, structural matching etc yield brittle systems
- Polymorphism yields extensible, flexible systems
- Clojure multimethods decouple polymorphism from OO and types
  - Supports multiple taxonomies
  - Dispatches via static, dynamic or external properties, metadata,
    etc

*** Concurrency and the multi-core future

- Immutability makes much of the problem go away
  - Share freely between threads
- But changing state a reality for simulations and for in-program
  proxies to the outside world
- Locking is too hard to get right over and over again
- Clojure's software transactional memory and agent systems do the hard
  part

In short, I think Clojure occupies a unique niche as a functional Lisp
for the JVM with strong concurrency support. Check out some of the
[[#content/about/features][features]] or [[#content/guides/getting_started][get started with Clojure]].

** History
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/history.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/history
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2020-06-04
:PREVPAGE_CUSTOM_ID: content/about/rationale
:NEXTPAGE_CUSTOM_ID: content/about/state
:CUSTOM_ID: content/about/history
:END:

The [[https://hopl4.sigplan.org/track/hopl-4-papers#History-of-HOPL][History of Programming Languages conference series]] produces
accurate historical records and descriptions of programming language
design, development, and philosophy. It is infrequently held: the
first three were in 1978, 1993, and 2007.

2020 is the time for [[https://hopl4.sigplan.org][HOPL-IV]], and I'm very excited and honored to have
a paper on Clojure be [[https://dl.acm.org/toc/pacmpl/2020/4/HOPL][accepted]]. I want to thank Guy Steele and Richard
Gabriel, co-chairs of HOPL IV, as well as the reviewers and shepherds
for their support and guidance. Clojure is not the product of
traditional research and (as may be evident) writing a paper for this
setting was a different and challenging exercise. I hope the paper
provides some insight into why Clojure is the way it is and the
process and people behind its creation and development.

Rich

#+CAPTION: A History of Clojure
[[./assets/images/content/about/preview.png]]

From HOPL IV in June 2021:

#+CAPTION: HOPL IV conference talk and Q&A
[[./assets/images/content/about/hopl-video.png]]

** Values and Change: Clojure's approach to Identity and State
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/state.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/state
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/history
:NEXTPAGE_CUSTOM_ID: content/about/spec
:CUSTOM_ID: content/about/state
:END:

Many people come to Clojure from an imperative language and find
themselves out of their element when faced with Clojure's approach to
doing things, while others are coming from a more functional background
and assume that once they leave Clojure's functional subset, they will
be faced with the same story re: state as is found in Java. This essay
intends to illuminate Clojure's approach to the problems faced by
imperative and functional programs in modeling the world.

*** Imperative programming

An imperative program manipulates its world (e.g. memory) directly. It
is founded on a now-unsustainable single-threaded premise - that the
world is stopped while you look at or change it. You say "do this" and
it happens, "change that" and it changes. Imperative programming
languages are oriented around saying do this/do that, and changing
memory locations.

This was never a great idea, even before multithreading. Add concurrency
and you have a real problem, because "the world is stopped" premise is
simply no longer true, and restoring that illusion is extremely
difficult and error-prone. Multiple participants, each of which acts as
though they were omnipotent, must somehow avoid destroying the
presumptions and effects of the others. This requires mutexes and locks,
to cordon off areas for each participant to manipulate, and a lot of
overhead to propagate changes to shared memory so they are seen by other
cores. It doesn't work very well.

*** Functional programming

Functional programming takes a more mathematical view of the world, and
sees programs as functions that take certain values and produce others.
Functional programs eschew the external 'effects' of imperative
programs, and thus become easier to understand, reason about, and test,
since the activity of functions is completely local. To the extent a
portion of a program is purely functional, concurrency is a non-issue,
as there is simply no change to coordinate.

*** Working Models and Identity

While some programs are merely large functions, e.g. compilers or
theorem provers, many others are not - they are more like working
models, and as such need to support what I'll refer to in this
discussion as *identity.* By identity I mean *a stable logical entity
associated with a series of different values over time*. Models need
identity for the same reasons humans need identity - to represent the
world. How could it work if identities like 'today' or 'America' had to
represent a single constant value for all time? Note that by identities
I don't mean names (I call my mother Mom, but you wouldn't).

So, for this discussion, an identity is an entity that has a state,
which is its value at a point in time. And *a value is something that
doesn't change*. 42 doesn't change. June 29th 2008 doesn't change.
Points don't move, dates don't change, no matter what some bad class
libraries may cause you to believe. Even aggregates are values. The set
of my favorite foods doesn't change, i.e. if I prefer different foods in
the future, that will be a different set.

Identities are mental tools we use to superimpose continuity on a world
which is constantly, functionally, creating new values of itself.

*** Object Oriented programming (OO)

OO is, among other things, an attempt to provide tools for modeling
identity and state in programs (as well as associating behavior with
state, and hierarchical classification, both ignored here). OO typically
unifies identity and state, i.e. an object (identity) is a pointer to
the memory that contains the value of its state. There is no way to
obtain the state independent of the identity other than copying it.
There is no way to observe a stable state (even to copy it) without
blocking others from changing it. There is no way to associate the
identity's state with a different value other than in-place memory
mutation. In other words, *typical OO has imperative programming baked
into it!* OO doesn't have to be this way, but, usually, it is
(Java/C++/Python/Ruby etc).

People accustomed to OO conceive of their programs as mutating the
values of objects. They understand the true notion of a value, say, 42,
as something that would never change, but usually don't extend that
notion of value to their object's state. That is a failure of their
programming language. These languages use the same constructs for
modeling values as they do for identities, objects, and default to
mutability, causing all but the most disciplined programmers to create
many more identities than they should, creating identities out of things
that should be values etc.

*** Clojure programming

There is another way, and that is to separate identity and state (once
again, indirection saves the day in programming). We need to move away
from a notion of state as "the content of this memory block" to one of
"the *value* currently associated with this identity". Thus an
identity can be in different states at different times, but /the state
itself doesn't change/. That is, an identity is not a state, an identity
*has* a state. Exactly one state at any point in time. And that state
is a true value, i.e. it never changes. If an identity appears to
change, it is because it becomes associated with different state values
over time. This is the Clojure model.

In Clojure's model, value calculation is purely functional. Values
never change. New values are functions of old, not mutations. But
logical identity is well supported, via atomic references to values
([[#content/reference/refs][Refs]] and [[#content/reference/agents][Agents]]). Changes to references are controlled/coordinated by
the system - i.e. cooperation is not optional and not manual. The
world moves forward due to the cooperative efforts of its participants
and the programming language/system, Clojure, is in charge of world
consistency management. The value of a reference (state of an
identity) is always observable without coordination, and freely
shareable between threads.

It is worth constructing programs this way even when there is only one
participant (thread). Programs are easier to understand/test when
functional value calculation is independent of identity/value
association. And it's easy to add other participants when they are
(inevitably) needed.

**** Concurrency

Dealing with concurrency means giving up the illusion of omnipotence. A
program must recognize there will be other participants, and the world
will keep changing. So a program must understand that if it observes the
values of the states of some identities, the best it can get is a
snapshot, as they can subsequently acquire new states. But often that is
good enough for decision making or reporting purposes. We humans do
quite well with the snapshots provided by our sensory systems. The nice
thing is any such state value won't change in hand during the
processing, as it is immutable.

On the other hand, changing state to a new value requires access to the
'current' value and the identity. Clojure's Refs and Agents handle this
automatically. In the case of Refs, any interaction you do must occur
within a transaction (else Clojure will throw an exception), all such
interaction will see a consistent view of the world as of a point in
time, and no changes will proceed unless the states to be changed
haven't been changed by other participants in the meantime. Transactions
support synchronous change to multiple Refs. Agents, OTOH, offer
asynchronous change to a single reference. You pass a function and
values, and, at some point in the future, that function will be passed
the current state of the Agent and the return value of the function will
become the Agent's new state.

In all cases the program will see stable views of the values in the
world, as those values can't change, and sharing them among cores is
fine. The trick is, "values never change" means that making new values
from old ones must be efficient, and it is in Clojure, due to its
persistent data structures. They allow you to finally follow the
oft-proffered advice to favor immutability. So you set the state of an
identity to a new state by reading its current value, calling a pure
function on that value to create a new value, and setting that value
as the new state. These composite operations are made easy and atomic
by the [[clojure:core.clj::(defn alter][alter]], [[clojure:core.clj::(defn commute][commute]] and [[clojure:core.clj::2115][send]] functions.

*** Message Passing and Actors

There are other ways to model identity and state, one of the more
popular of which is the message-passing [[https://en.wikipedia.org/wiki/Actor_model][actor model]]. In an actor
model, state is encapsulated in an actor (identity) and can only be
affected/seen via the passing of messages (values). In an asynchronous
system, reading some aspect of an actor's state requires sending a
request message, waiting for a response, and the actor sending a
response. It is important to understand that /the actor model was
designed to address the problems of *distributed* programs/. And the
problems of distributed programs are much harder - there are multiple
worlds (address spaces), direct observation is not possible,
interaction occurs over possibly unreliable channels, etc. The actor
model supports transparent distribution. If you write all of your code
this way, you are not bound to the actual location of the other
actors, allowing a system to be spread over multiple
processes/machines without changing the code.

I chose not to use the actor model for same-process state management in
Clojure for several reasons:

- It is a much more complex programming model, requiring 2-message
  conversations for the simplest data reads, and forcing the use of
  blocking message receives, which introduce the potential for
  deadlock. Programming for the failure modes of distribution means
  utilizing timeouts etc. It causes a bifurcation of the program
  protocols, some of which are represented by functions and others by
  the values of messages.
- It doesn't let you fully leverage the efficiencies of being in the
  same process. It is quite possible to efficiently directly share a
  large immutable data structure between threads, but the actor model
  forces intervening conversations and, potentially, copying. Reads and
  writes get serialized and block each other, etc.
- It reduces your flexibility in modeling - this is a world in which
  everyone sits in a windowless room and communicates only by mail.
  Programs are decomposed as piles of blocking switch statements. You
  can only handle messages you anticipated receiving. Coordinating
  activities involving multiple actors is very difficult. You can't
  observe anything without its cooperation/coordination - making ad-hoc
  reporting or analysis impossible, instead forcing every actor to
  participate in each protocol.
- It is often the case that taking something that works well locally
  and transparently distributing it doesn't work out - the conversation
  granularity is too chatty or the message payloads are too large or
  the failure modes change the optimal work partitioning, i.e.
  transparent distribution isn't transparent and the code has to change
  anyway.

Clojure may eventually support the actor model for distributed
programming, paying the price only when distribution is required, but I
think it is quite cumbersome for same-process programming. YMMV of
course.

*** Summary

Clojure is a functional language that explicitly supports programs as
models and provides robust and easy-to-use facilities for managing
identity and state in a single process in the face of concurrency.

In coming to Clojure from an OO language, you can use one of its
[[#content/reference/data_structures][persistent collections]], e.g. maps, instead of objects. Use values as
much as possible. And for those cases where your objects are truly
modeling identities (far fewer cases than you might realize until you
start thinking about it this way), you can use a Ref or Agent with
e.g. a map as its state in order to model an identity with changing
state. If you want to encapsulate or abstract away the details of your
values, a good idea if they are non-trivial, write a set of functions
for viewing and manipulating them. If you want polymorphism, use
Clojure's multimethods.

In the local case, since Clojure does not have mutable local
variables, instead of building up values in a mutating loop, you can
instead do it functionally with [[#content/reference/special_forms#recur][recur]] or [[clojure:core.clj::(defn reduce][reduce]].

** clojure.spec - Rationale and Overview
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/spec.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/spec
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/state
:NEXTPAGE_CUSTOM_ID: content/about/dynamic
:CUSTOM_ID: content/about/spec
:END:
*** Problems
**** Docs are not enough

Clojure is a dynamic language. Among other things this means that type
annotations are not required for code to run. While Clojure has some
support for type hints, they are not an enforcement mechanism, nor
comprehensive, and are limited to communicating information to the
compiler to aid in efficient code generation. Clojure gets runtime
checking of a richer set of types by the JVM itself.

However it has always been a guiding principle of Clojure, widely valued
and practiced by the community, to simply represent information as data.
Thus important properties of Clojure systems are represented and
conveyed by the shape and other predicative properties of the data, not
captured or checked anywhere since the runtime types are
indistinguishable heterogeneous maps and vectors.

Documentation strings can be used to communicate with human consumers,
but they can't be leveraged by programs or tests, i.e. they have
minimal power. Users have turned to various libraries such as [[https://github.com/plumatic/schema][Schema]]
and [[https://github.com/miner/herbert][Herbert]] to get more powerful specifications.

**** Map specs should be of keysets only

Most systems for specifying structures conflate the specification of the
key set (e.g. of keys in a map, fields in an object) with the
specification of the values designated by those keys. I.e. in such
approaches the schema for a map might say :a-key's type is x-type and
:b-key's type is y-type. This is a major source of rigidity and
redundancy.

In Clojure we gain power by dynamically composing, merging and building
up maps. We routinely deal with optional and partial data, data produced
by unreliable external sources, dynamic queries etc. These maps
represent various sets, subsets, intersections and unions of the same
keys, and in general ought to have the same semantic for the same key
wherever it is used. Defining specifications of every
subset/union/intersection, and then redundantly stating the semantic of
each key is both an antipattern and unworkable in the most dynamic
cases.

**** Manual parsing and error reporting is not good enough

Many users, especially beginners, are frustrated and challenged by the
error messages produced by hand-written parsing and destructuring code,
especially in macros where there are two contexts of execution (the
macro runs at compile time and its expansion at runtime, either of which
could fail due to user error). This has led to a call for 'macro
grammars', but in fact macros are just functions of data→data and any
solution for data validation and destructuring should work as well for
them as for any other functions. I.e. macros are an instance of the
problems above.

**** Generative testing and robustness

Finally, in all languages, dynamic or not, tests are essential to
quality. Too many critical properties are not captured by common type
systems. But manual testing has a very low effectiveness/effort ratio.
Property-based, generative testing, as implemented for Clojure in
[[https://github.com/clojure/test.check][test.check]], has proved to be far more powerful than manually written
tests.

Yet property based testing requires the definition of properties, which
require extra effort and expertise to produce, and which, at the
function-level, have substantial overlap with function specifications.
Many interesting properties at the function level would already be
captured by structural+predicative specs. Ideally, specs should
integrate with generative testing and provide certain categories of
generative tests 'for free'.

**** A standard approach is needed

In short, Clojure has no standard, expressive, powerful and integrated
system for specification and testing.

~clojure.spec~ aims to provide it.

*** Objectives
**** Communication

#+BEGIN_QUOTE
*Note*

Species - appearance, form, sort, kind, equivalent to spec (ere) to look, regard
        + -iēs abstract noun suffix

Specify - species + -ficus -fic (make)
#+END_QUOTE

A specification is about how something 'looks', but is, most
importantly, something that is looked at. Specs should be readable,
composed of 'words' (predicate functions) programmers are already using,
and integrated in documentation.

**** Unify specification in its various contexts

Specs for data structures, attribute values and functions should all be
the same and live in a globally-namespaced directory.

**** Maximize leverage from specification effort

Writing a spec should enable /automatic/:

- Validation
- Error reporting
- Destructuring
- Instrumentation
- Test-data generation
- Generative test generation

**** Minimize intrusion

Don't require that people e.g. define their functions differently. Minor
modifications to ~doc~ and ~macroexpand~ will allow independently
written specs to adorn fn/macro behavior without redefinition.

**** Decomplect maps/keys/values

Keep map (keyset) specs separate from attribute (key→value) specs.
Encourage and support attribute-granularity specs of namespaced keyword
to value-spec. Combining keys into sets (to specify maps) becomes
orthogonal, and checking becomes possible in the fully-dynamic case,
i.e. even when no map spec is present, attributes (key-values) can be
checked.

**** Enable and start a dialog about semantic change and compatibility

Programmers suffer greatly when they redefine things while keeping the
names the same. Yet some changes are compatible and some are breaking,
and most tools can't distinguish. Use constructs like set membership and
regular expressions for which compatibility can be determined, and
provide tools for compatibility checking (while leaving general
predicate equality out of scope).

*** Guidelines
**** Mistakes will be made

We don't (and couldn't) live in a world where we can't make mistakes.
Instead, we periodically check that we haven't. Amazon doesn't send you
your TV via a ~UPS<Trucks<Boxes<TV>>>~. So occasionally you might get a
microwave, but the supply chain isn't burdened with correctness proof.
Instead we check at the edges and run tests.

**** expressivity > proof

There is no reason to limit our specifications to what we can prove, yet
that is primarily what type systems do. There is so much more we want to
communicate and verify about our systems. This goes beyond
structural/representational types and tagging to predicates that e.g.
narrow domains or detail relationships between inputs or between inputs
and output. Additionally, the properties we care most about are often
those of the runtime values, not some static notion. Thus ~spec~ is not
a type system.

**** Names are important

All programs use names, even when the type systems don't, and they
capture important semantics. ~Int x Int x Int~ just isn't good enough
(is it length/width/height or height/width/depth?). So ~spec~ will not
have unlabeled sequence components or untagged union bindings. The
utility of this becomes evident when ~spec~ needs to talk to users about
specs, e.g. in error reporting, and vice versa, e.g. when users want to
override generators in specs. When all branches are named, you can talk
about parts of specs using /paths/.

**** Global (namespaced) names are more important

Clojure supports namespaced keywords and symbols. Note here we are just
talking about namespace-qualified names, not Clojure namespace objects.
These are tragically underutilized and convey important benefits because
they can always co-reside in dictionaries/dbs/maps/sets without
conflict. ~spec~ will allow (only) namespace-qualified keywords and
symbols to name specs. People using namespaced keys for their
informational maps (a practice we'd like to see grow) can register the
specs for those attributes directly under those names. This
categorically changes the self-description of maps, particularly in
dynamic contexts, and encourages composition and consistency.

**** Don't further add to/overload the (reified) namespaces of Clojure

Nothing will be attached to vars, metadata etc. All functions have
namespaced names which can serve as keys to their related data (e.g.
spec) that is stored elsewhere.

**** Code is data (not vice versa)

In Lisps (and thus Clojure), code is data. But data is not code until
you define a language around it. Many DSLs in this space drive at a data
representation for schemas. But predicative specs have an open and large
vocabulary, and most of the useful predicates already exist and are well
known as functions in the core and other namespaces, or can be written
as simple expressions. Having to 'datafy', possibly renaming, all of
these predicates adds little value, and has a definite cost in
understanding precise semantics. ~spec~ instead leverages the fact that
the original predicates and expressions are data in the first place and
captures that data for use in communicating with the users in
documentation and error reporting. Yes, this means that more of the
surface area of ~clojure.spec~ will be macros, but specs are
overwhelmingly written by people and, when composed, manually so.

**** Sets (maps) are about membership, that's it

As per above, maps defining the details of the values at their keys is a
fundamental complecting of concerns that will not be supported. Map
specs detail required/optional keys (i.e. set membership things) and
keyword/attr/value semantics are independent. Map checking is two-phase,
required key presence then key/value conformance. The latter can be done
even when the (namespace-qualified) keys present at runtime are not in
the map spec. This is vital for composition and dynamicity.

**** Informational vs implementational

Invariably, people will try to use a specification system to detail
implementation decisions, but they do so to their detriment. The best
and most useful specs (and interfaces) are related to purely information
aspects. Only information specs work over wires and across systems. We
will always prioritize, and where there is a conflict, prefer, the
information approach.

**** K.I.S.S.

There are very few bottom notions in this space and we will endeavor to
stick to them. There are few distinct structural notions - a handful of
atomic types, sequential things, sets and maps. Unsurprisingly, these
are the Clojure data types and fundamental ops will be provided only for
these. Similarly there are mathematical tools for talking about these -
set logic for maps and regular expressions for sequences - that have
valuable properties. We will prefer these over ad hoc solutions.

**** Build on test.check but don't require knowledge of it

The generative testing underpinning of ~spec~ will leverage ~test.check~
and not reinvent it. But spec users should not need to know anything
about ~test.check~ until and unless they want to write their own
generators or supplement ~spec~'s generated tests with further
property-based tests of their own. There should be no production runtime
dependency on ~test.check~.

*** Features
**** Overview
***** Predicative specs

The basic idea is that specs are nothing more than a logical composition
of predicates. At the bottom we are talking about the simple boolean
predicates you are used to like ~int?~ or ~symbol?~, or expressions you
build yourself like ~#(< 42 % 66)~. ~spec~ adds logical ops like
~spec/and~ and ~spec/or~ which combine specs in a logical way and offer
deep reporting, generation and conform support and, in the case of
~spec/or~, tagged returns.

***** Maps

Specs for map keysets provide for the specification of required and
optional key sets. A spec for a map is produced by calling ~keys~ with
~:req~ and ~:opt~ keyword arguments mapping to vectors of key names.

~:req~ keys support the logical operators ~and~ and ~or~.

#+BEGIN_SRC clojure
(spec/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])
#+END_SRC

One of the most visible differences between ~spec~ and other systems is
that there is no place in that map spec for specifying the /values/ e.g.
~::x~ can take. It is the (enforced) opinion of ~spec~ that the
specification of values associated with a namespaced keyword, like
~:my.ns/k~, should be registered under that keyword itself, and applied
in any map in which that keyword appears. There are a number of
advantages to this:

- It ensures consistency for all uses of that keyword in an application
  where all uses should share a semantic
- It similarly ensures consistency between a library and its consumers
- It reduces redundancy, since otherwise many map specs would need to
  make matching declarations about k
- Namespaced keyword specs can be checked even when no map spec
  declares those keys

This last point is vital when dynamically building up, composing, or
generating maps. Creating a spec for every map subset/union/intersection
is unworkable. It also facilitates fail-fast detection of bad data -
when it is introduced vs when it is consumed.

Of course, many existing map-based interfaces take non-namespaced keys.
To support connecting them to properly namespaced and reusable specs,
~keys~ supports ~-un~ variants of ~:req~ and ~:opt~

#+BEGIN_SRC clojure
(spec/keys :req-un [:my.ns/a :my.ns/b])
#+END_SRC

This specs a map that requires the unqualified keys ~:a~ and ~:b~ but
validates and generates them using specs (when defined) named ~:my.ns/a~
and ~:my.ns/b~ respectively. Note that this cannot convey the same power
to unqualified keywords as have namespaced keywords - the resulting maps
are not self-describing.

***** Sequences

Specs for sequences/vectors use a set of standard regular expression
operators, with the standard semantics of regular expressions:

- ~cat~ - a concatenation of predicates/patterns
- ~alt~ - a choice of one among a set of predicates/patterns
- ~*~ - zero or more occurrences of a predicate/pattern
- ~+~ - one or more
- ~?~ - one or none
- ~&~ - takes a regex op and further constrains it with one or more
  predicates

These nest arbitrarily to form complex expressions.

Note that ~cat~ and ~alt~ require all of their components be labeled,
and the return value of each is a map with the keys corresponding to the
matched components. In this way ~spec~ regexes act as destructuring and
parsing tools.

#+BEGIN_SRC clojure
user=> (require '[clojure.spec.alpha :as s])
(s/def ::even? (s/and integer? even?))
(s/def ::odd? (s/and integer? odd?))
(s/def ::a integer?)
(s/def ::b integer?)
(s/def ::c integer?)
(def s (s/cat :forty-two #{42}
              :odds (s/+ ::odd?)
              :m (s/keys :req-un [::a ::b ::c])
              :oes (s/* (s/cat :o ::odd? :e ::even?))
              :ex (s/alt :odd ::odd? :even ::even?)))
user=> (s/conform s [42 11 13 15 {:a 1 :b 2 :c 3} 1 2 3 42 43 44 11])
{:forty-two 42,
 :odds [11 13 15],
 :m {:a 1, :b 2, :c 3},
 :oes [{:o 1, :e 2} {:o 3, :e 42} {:o 43, :e 44}],
 :ex {:odd 11}}
#+END_SRC

***** conform/explain

As you can see above, the basic operation for using specs is ~conform~,
which takes a spec and a value and returns the conformed value or
~:clojure.spec.alpha/invalid~ if the value did not conform. When the
value does not conform you can call ~explain~ or ~explain-data~ to find
out why it didn't.

**** Defining specs

The primary operations for defining specs are s/def, s/and, s/or, s/keys
and the regex ops. There is a ~spec~ function that can take a predicate
function or expression, a set, or a regex op, and can also take an
optional generator which would override the generator implied by the
predicate(s).

Note however, that ~def, and, or, keys~ spec fns and the regex ops can
all take and use predicate functions and sets directly - and do not need
them to be wrapped by ~spec~. ~spec~ should only be needed when you want
to override a generator or to specify that a nested regex starts anew,
vs being included in the same pattern.

***** Data spec registration

In order for a spec to be reusable by name, it has to be registered via
~def~. ~def~ takes a namespace-qualified keyword/symbol and a
spec/predicate expression. By convention, specs for data should be
registered under keywords and attribute values should be registered
under their attribute name keyword. Once registered, the name can be
used anywhere a spec/predicate is called for in any of the ~spec~
operations.

***** Function spec registration

A function can be fully specified via three specs - one for the args,
one for the return, and one for the operation of the function relating
the args to the return.

The args spec for a fn is always going to be a regex that specs the
arguments as if they were a list, i.e. the list one would pass to
~apply~ the function. In this way, a single spec can handle functions
with multiple arities.

The return spec is an arbitrary spec of a single value.

The (optional) fn spec is a further specification of the relationship
between the arguments and the return, i.e. the function of the function.
It will be passed (e.g. during testing) a map containing
~{:args conformed-args :ret conformed-ret}~ and will generally contain
predicates that relate those values - e.g. it could ensure that all keys
of an input map are present in the returned map.

You can fully specify all three specs of a function in a single call to
~fdef~, and recall the specs via ~fn-specs~.

**** Using specs
***** Documentation

Functions specs defined via ~fdef~ will appear when you call ~doc~ on
the fn name. You can call ~describe~ on specs to get descriptions as
forms.

***** Parsing/destructuring

You can use ~conform~ directly in your implementations to get its
destructuring/parsing/error-checking. ~conform~ can be used e.g. in
macro implementations and at I/O boundaries.

***** During development

You can selectively instrument functions and namespaces with
~instrument~, which swaps out the fn var with a wrapped version of the
fn that tests the ~:args~ spec. ~unstrument~ returns a fn to its
original version. You can generate data for interactive testing with
~gen/sample~.

***** For testing

You can run a suite of spec-generative tests on an entire ns with
~check~. You can get a test.check compatible generator for a spec by
calling ~gen~. There are built-in associations between many of the
~clojure.core~ data predicates and corresponding generators, and the
composite ops of ~spec~ know how to build generators atop those. If you
call ~gen~ on a spec and it is unable to construct a generator for some
subtree, it will throw an exception that describes where. You can pass
generator-returning fns to ~spec~ in order to supply generators for
things spec does not know about, and you can pass an override map to
~gen~ in order to supply alternative generators for one or more subpaths
of a spec.

***** At runtime

In addition to the destructuring use cases above, you can make calls to
~conform~ or ~valid?~ anywhere you want runtime checking, and can make
lighter-weight internal-only specs for tests you intend to run in
production.

Please see the [[#content/guides/spec][spec Guide]] and [[https://clojure.github.io/spec.alpha/index.html][API docs]] for more examples and usage
information.

*** Glossary
**** predicates

Many parts of the spec API call for 'predicates' or 'preds'. These
arguments can be satisfied by:

- predicate (boolean) fns
- sets
- registered names of specs
- specs (the return values of ~spec~, ~and~, ~or~, ~keys~)
- regex ops (the return values of ~cat~, ~alt~, ~*~, ~+~, ~?~, ~&~)

Note that if you want to nest an independent regex predicate within a
regex you will have to wrap it in a call to ~spec~, else it will be
considered a nested pattern.

**** specs

The return values of ~spec~, ~and~, ~or~ and ~keys~.

**** regex ops

The return values of ~cat~, ~alt~, ~*~, ~+~, ~?~, ~&~. When nested these
form a single expression.

**** conform

~conform~ is the basic operation for consuming specs, and does both
validation and conforming/destructuring. Note that conforming is 'deep'
and flows through all of the spec and regex operations, map specs etc.
Since ~nil~ and ~false~ are legitimate conformed values, conform returns
the distinguished ~:clojure.spec.alpha/invalid~ when a value cannot be
made to conform. ~valid~? can be used instead as a fully-boolean
predicate.

**** explain

When a value fails to conform to a spec you can call ~explain~ or
~explain-data~ with the same spec+value to find out why. These
explanations are not produced during ~conform~ because they might
perform additional work and there is no reason to incur that cost for
non-failing inputs or when no report is desired. An important component
of explanations is the /path/. ~explain~ extends the path as it
navigates through e.g. nested maps or regex patterns, so you get better
information than just the entire or leaf value. ~explain-data~ will
return a map of paths to problems.

**** paths

Due to the fact that all /branching/ points in specs are labeled, i.e.
map ~keys~, choices in ~or~ and ~alt~, and (possibly elided) elements of
~cat~, every subexpression in a spec can be referred to via a /path/
(vector of keys) naming the parts. These paths are used in ~explain~,
~gen~ overrides and various error reporting.

*** Prior Art

Almost nothing about spec is novel. See all the libraries mentioned
above, [[https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/][RDF]], as well as all the work done on various contract systems,
such as [[https://docs.racket-lang.org/guide/contracts.html][Racket's contracts]].

*I hope you find spec useful and powerful.*

Rich Hickey

*** More information

- [[#content/guides/spec][spec Guide]]
- [[https://clojure.github.io/spec.alpha][API Docs]]
- [[https://github.com/clojure/spec.alpha][Project]]
- [[resources#spec][spec Resources]]

** Dynamic Development
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/dynamic.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/dynamic
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/spec
:NEXTPAGE_CUSTOM_ID: content/about/functional_programming
:CUSTOM_ID: content/about/dynamic
:END:

First and foremost, Clojure is dynamic. That means that a Clojure
program is not just something you compile and run, but something with
which you can interact. Clojure is not a language abstraction, but an
environment, where almost all of the language constructs are reified,
and thus can be examined and changed. This leads to a substantially
different experience from running a program, examining its results (or
failures) and trying again. In particular, you can grow your program,
with data loaded, adding features, fixing bugs, testing, in an unbroken
stream.

*** The REPL

While Clojure can be embedded in a Java application, or used as a
scripting language, the primary programming interface is the
Read-Eval-Print-Loop (REPL). This is a simple console interface that
allows you to enter and execute commands, and examine their results. You
can start the Clojure REPL like this, and then follow along trying the
samples in this feature tour:

#+BEGIN_SRC clojure
java -cp clojure.jar clojure.main
#+END_SRC

This will give you a prompt like this:

#+BEGIN_SRC clojure
user=>
#+END_SRC

Most Clojure commands take the form (command arguments*). Try it:

#+BEGIN_SRC clojure
(def x 6)
-> #'user/x
(def y 36)
-> #'user/y
(+ x y)
-> 42
#+END_SRC

*** Basics

Clojure has arbitrary precision integers, strings, ratios, doubles,
characters, symbols, keywords.

#+BEGIN_SRC clojure
(* 12345678 12345678)
-> 152415765279684
"string"
-> "string"
22/7
-> 22/7
3.14159
-> 3.14159
\a
-> \a
'symbol
-> symbol
:keyword
-> :keyword
;a comment
#+END_SRC

*** Dynamic Compilation

Clojure is a compiled language, so one might wonder when you have to run
the compiler. You don't. Anything you enter into the REPL or load using
load-file is automatically compiled to JVM bytecode on the fly.
Compiling ahead-of-time is also possible, but not required.
** Functional Programming
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/functional_programming.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/functional_programming
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/dynamic
:NEXTPAGE_CUSTOM_ID: content/about/lisp
:CUSTOM_ID: content/about/functional_programming
:END:

Clojure is a functional programming language. It provides the tools to
avoid mutable state, provides functions as first-class objects, and
emphasizes recursive iteration instead of side-effect based looping.
Clojure is /impure/, in that it doesn't force your program to be
referentially transparent, and doesn't strive for 'provable' programs.
The philosophy behind Clojure is that most parts of most programs should
be functional, and that programs that are more functional are more
robust.

*** First-class functions

[[#content/reference/special_forms#fn][fn]] creates a
function object. It yields a value like any other - you can store it in
a var, pass it to functions etc.

#+BEGIN_SRC clojure
(def hello (fn [] "Hello world"))
-> #'user/hello
(hello)
-> "Hello world"
#+END_SRC

[[clojure:core.clj::defn (fn defn][defn]] is a macro that makes defining functions a little
simpler. Clojure supports arity overloading in a /single/ function
object, self-reference, and variable-arity functions using ~&~:

#+BEGIN_SRC clojure
;trumped-up example
(defn argcount
  ([] 0)
  ([x] 1)
  ([x y] 2)
  ([x y & more] (+ (argcount x y) (count more))))
-> #'user/argcount
(argcount)
-> 0
(argcount 1)
-> 1
(argcount 1 2)
-> 2
(argcount 1 2 3 4 5)
-> 5
#+END_SRC

You can create local names for values inside a function using [[clojure:core.clj::(defmacro let][let]].

The scope of any local names is lexical, so a function created in the
scope of local names will close over their values:

#+BEGIN_SRC clojure
(defn make-adder [x]
  (let [y x]
    (fn [z] (+ y z))))
(def add2 (make-adder 2))
(add2 4)
-> 6
#+END_SRC

*Locals created with [[clojure:core.clj::(defmacro let][let]] are not variables. Once created their values
never change!*

*** Immutable Data Structures

The easiest way to avoid mutating state is to use immutable [[#content/reference/data_structures][data
structures]].

Clojure provides a set of immutable lists, vectors, sets and maps. Since
they can't be changed, 'adding' or 'removing' something from an
immutable collection means creating a new collection just like the old
one but with the needed change. /Persistence/ is a term used to describe
the property wherein the old version of the collection is still
available after the 'change', and that the collection maintains its
performance guarantees for most operations. Specifically, this means
that the new version can't be created using a full copy, since that
would require linear time. Inevitably, persistent collections are
implemented using linked data structures, so that the new versions can
share structure with the prior version. Singly-linked lists and trees
are the basic functional data structures, to which Clojure adds a hash
map, set and vector both based upon array mapped hash tries. The
collections have readable representations and common interfaces:

#+BEGIN_SRC clojure
(let [my-vector [1 2 3 4]
      my-map {:fred "ethel"}
      my-list (list 4 3 2 1)]
  (list
    (conj my-vector 5)
    (assoc my-map :ricky "lucy")
    (conj my-list 5)
    ;the originals are intact
    my-vector
    my-map
    my-list))
-> ([1 2 3 4 5] {:ricky "lucy", :fred "ethel"} (5 4 3 2 1) [1 2 3 4] {:fred "ethel"} (4 3 2 1))
#+END_SRC

Applications often need to associate attributes and other data about
data that is orthogonal to the logical value of the data. Clojure
provides direct support for this [[#content/reference/metadata][metadata]]. Symbols, and all of the
collections, support a metadata map. It can be accessed with the [[clojure:core.clj::meta (fn][meta]]
function. Metadata does /not/ impact equality semantics, nor will
metadata be seen in operations on the value of a collection. Metadata
can be read, and can be printed.

#+BEGIN_SRC clojure
(def v [1 2 3])
(def attributed-v (with-meta v {:source :trusted}))
(:source (meta attributed-v))
-> :trusted
(= v attributed-v)
-> true
#+END_SRC

*** Extensible Abstractions

Clojure uses Java interfaces to define its core data structures. This
allows for extensions of Clojure to new concrete implementations of
these interfaces, and the library functions will work with these
extensions. This is a big improvement vs. hardwiring a language to the
concrete implementations of its data types.

A good example of this is the [[#content/reference/sequences][seq]] interface. By making the core Lisp
list construct into an abstraction, a wealth of library functions are
extended to any data structure that can provide a sequential interface
to its contents. All of the Clojure data structures can provide
seqs. Seqs can be used like iterators or generators in other
languages, with the significant advantage that seqs are immutable and
persistent. Seqs are extremely simple, providing a ~first~ function,
which return the first item in the sequence, and a ~rest~ function which
returns the rest of the sequence, which is itself either a seq or
nil.

#+BEGIN_SRC clojure
(let [my-vector [1 2 3 4]
      my-map {:fred "ethel" :ricky "lucy"}
      my-list (list 4 3 2 1)]
  [(first my-vector)
   (rest my-vector)
   (keys my-map)
   (vals my-map)
   (first my-list)
   (rest my-list)])
-> [1 (2 3 4) (:ricky :fred) ("lucy" "ethel") 4 (3 2 1)]
#+END_SRC

Many of the Clojure library functions produce and consume seqs /lazily/:

#+BEGIN_SRC clojure
;cycle produces an 'infinite' seq!
(take 15 (cycle [1 2 3 4]))
-> (1 2 3 4 1 2 3 4 1 2 3 4 1 2 3)
#+END_SRC

You can define your own lazy seq-producing functions using the [[clojure:core.clj::(defmacro
lazy-seq][lazy-seq]]
macro, which takes a body of expressions that will be called on demand
to produce a list of 0 or more items. Here's a simplified [[clojure:core.clj::(defn
take][take]]:

#+BEGIN_SRC clojure
(defn take [n coll]
  (lazy-seq
    (when (pos? n)
      (when-let [s (seq coll)]
       (cons (first s) (take (dec n) (rest s)))))))
#+END_SRC

*** Recursive Looping

In the absence of mutable local variables, looping and iteration must
take a different form than in languages with built-in ~for~ or ~while~
constructs that are controlled by changing state. In functional
languages looping and iteration are replaced/implemented via recursive
function calls. Many such languages guarantee that function calls made
in tail position do not consume stack space, and thus recursive loops
utilize constant space. Since Clojure uses the Java calling
conventions, it cannot, and does not, make the same tail call
optimization guarantees. Instead, it provides the [[#content/reference/special_forms#recur][recur special
operator]], which does constant-space recursive looping by rebinding and
jumping to the nearest enclosing loop or function frame. While not as
general as tail-call-optimization, it allows most of the same elegant
constructs, and offers the advantage of checking that calls to recur
can only happen in a tail position.

#+BEGIN_SRC clojure
(defn my-zipmap [keys vals]
  (loop [my-map {}
         my-keys (seq keys)
         my-vals (seq vals)]
    (if (and my-keys my-vals)
      (recur (assoc my-map (first my-keys) (first my-vals))
             (next my-keys)
             (next my-vals))
      my-map)))
(my-zipmap [:a :b :c] [1 2 3])
-> {:b 2, :c 3, :a 1}
#+END_SRC

For situations where mutual recursion is called for, recur can't be
used. Instead, [[clojure:core.clj::(defn trampoline][trampoline]] may be a good option.

** Clojure as a Dialect of Lisp
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/lisp.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/lisp
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/functional_programming
:NEXTPAGE_CUSTOM_ID: content/about/runtime_polymorphism
:CUSTOM_ID: content/about/lisp
:END:

Clojure is a member of the Lisp family of languages. Many of the
features of Lisp have made it into other languages, but Lisp's
approach to code-as-data and its [[#content/reference/macros][macro system]] still set it
apart. Clojure extends the code-as-data system beyond parenthesized
lists (s-expressions) to vectors and maps. Thus vectors and maps can
be used in macro syntax, have literal reader representations etc.

Lisp data, and thus Lisp code, is read by the [[#content/reference/reader][reader]]. The result of
reading is the data structure represented by the forms. Clojure can
compile data structures that represent code, and as part of that
process it looks for calls to macros. When it sees one, it calls the
macro, passing the forms themselves as arguments, then uses the return
value of the macro in place of the macro itself. Thus macros are
functions that are called at compile time to perform transformations
of code. Since code is data, all of the Clojure library is available
to assist in the transformation.  Thus macros allow Lisps, and
Clojure, to support syntactic abstraction.  You use macros for the
same reasons you use functions - to eliminate repetition in your
code. Macros should be reserved for situations for which functions are
insufficient, e.g. when you need to control evaluation, generate
identifiers etc. Many of the core constructs of Clojure are not
built-in primitives but macros just like users can define. Here's ~and~:

#+BEGIN_SRC clojure
(defmacro and
  ([] true)
  ([x] x)
  ([x & rest]
    `(let [and# ~x]
       (if and# (and ~@rest) and#))))
#+END_SRC

Note the use of syntax-quote (`), which makes it easy to define macros
whose forms mimic the forms they generate.

** Runtime Polymorphism
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/runtime_polymorphism.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/runtime_polymorphism
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/lisp
:NEXTPAGE_CUSTOM_ID: content/about/concurrent_programming
:CUSTOM_ID: content/about/runtime_polymorphism
:END:

Systems that utilize runtime polymorphism are easier to change and
extend. Clojure supports polymorphism in several ways:

- Most core infrastructure data structures in the Clojure runtime are
  defined by Java interfaces.
- Clojure supports the generation of implementations of Java
  interfaces in Clojure using [[clojure:core_proxy.clj::(defmacro proxy][proxy]] ([[#content/about/jvm_hosted][see JVM Hosted]]).
- The Clojure language supports polymorphism along both class and
  custom hierarchies with [[#content/reference/multimethods][multimethod]]s.
- The Clojure language also supports a faster form of polymorphism
  with [[#content/reference/protocols][protocols]] (but limited only to class polymorphism to take
  advantage of the JVMs existing capabilities for invocation).

Clojure multimethods are a simple yet powerful mechanism for runtime
polymorphism that is free of the trappings of OO, types and
inheritance.  The basic idea behind runtime polymorphism is that a
single function designator dispatches to multiple
independently-defined function definitions based upon some value of
the call. For traditional single-dispatch OO languages that value is
the type of the 'receiver' or 'this'. CLOS generic functions extend
dispatch value to a composite of the type or value of multiple
arguments, and are thus multimethods.  Clojure multimethods go further
still to allow the dispatch value to be the result of an arbitrary
function of the arguments. Clojure does not support implementation
inheritance.

Multimethods are defined using [[clojure:core.clj::(defmacro defmulti][defmulti]], which takes the name of the
multimethod and the dispatch function.  Methods are independently
defined using [[clojure:core.clj::(defmacro defmethod][defmethod]], passing the multimethod name, the dispatch
/value/ and the function body.

#+BEGIN_SRC clojure
(defmulti encounter (fn [x y] [(:Species x) (:Species y)]))
(defmethod encounter [:Bunny :Lion] [b l] :run-away)
(defmethod encounter [:Lion :Bunny] [l b] :eat)
(defmethod encounter [:Lion :Lion] [l1 l2] :fight)
(defmethod encounter [:Bunny :Bunny] [b1 b2] :mate)
(def b1 {:Species :Bunny :other :stuff})
(def b2 {:Species :Bunny :other :stuff})
(def l1 {:Species :Lion :other :stuff})
(def l2 {:Species :Lion :other :stuff})
(encounter b1 b2)
-> :mate
(encounter b1 l1)
-> :run-away
(encounter l1 b1)
-> :eat
(encounter l1 l2)
-> :fight
#+END_SRC

Multimethods are in every respect fns, e.g. can be passed to [[clojure:core.clj::(defn map][map]] etc.

Similar to interfaces, Clojure protocols define only function
specifications (no implementation) and allow types to implement multiple
protocols. Additionally, protocols are open to later dynamic extension
for new types. Protocols are limited just to dispatch on class type to
take advantage of the native Java performance of polymorphic method
calls. For more details, see the [[#content/reference/protocols][protocols]] page.

** Concurrent Programming
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/concurrent_programming.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/concurrent_programming
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/runtime_polymorphism
:NEXTPAGE_CUSTOM_ID: content/about/jvm_hosted
:CUSTOM_ID: content/about/concurrent_programming
:END:

Today's systems have to deal with many simultaneous tasks and leverage
the power of multi-core CPUs. Doing so with threads can be very
difficult due to the complexities of synchronization. Clojure simplifies
multi-threaded programming in several ways. Because the core data
structures are immutable, they can be shared readily between threads.
However, it is often necessary to have state change in a program.
Clojure, being a practical language, allows state to change but provides
mechanism to ensure that, when it does so, it remains consistent, while
alleviating developers from having to avoid conflicts manually using
locks etc. The [[#content/reference/refs][software transactional memory system]] (STM), exposed
through [[clojure:core.clj::(defmacro dosync][dosync]], [[clojure:core.clj::(defn ref][ref]], [[clojure:core.clj::(defn ref-set][ref-set]], [[clojure:core.clj::(defn alter][alter]], et al, supports /sharing/ changing
state between threads in a /synchronous/ and /coordinated/ manner. The
[[#content/reference/agents][agent]] system supports sharing changing state between threads in an
/asynchronous/ and /independent/ manner. The [[#content/reference/atoms][atoms]] system supports sharing
changing state between threads in a /synchronous/ and /independent/
manner. The [[#content/reference/vars][dynamic var system]], exposed through [[#content/reference/special_forms#def][def]], [[clojure:core.clj::(defmacro binding][binding]], et al,
supports isolating changing state within threads.

In all cases, Clojure does not replace the Java thread system, rather it
works with it. Clojure functions are java.util.concurrent.Callable,
therefore they work with the Executor framework etc.

Most of this is covered in more detail in the [[https://www.youtube.com/watch?v=nDAfZK8m5_8][concurrency screencast]].

[[#content/reference/refs][Refs]] are mutable references to objects. They can be [[clojure:core.clj::(defn ref-set][ref-set]] or [[clojure:core.clj::(defn alter][alter]]ed
to refer to different objects during transactions, which are delimited
by [[clojure:core.clj::(defmacro dosync][dosync]] blocks. All ref modifications within a transaction happen or
none do. Also, reads of refs within a transaction reflect a snapshot
of the reference world at a particular point in time, i.e. each
transaction is isolated from other transactions. If a conflict occurs
between 2 transactions trying to modify the same reference, one of
them will be retried. All of this occurs without explicit locking.

In this example a vector of Refs containing integers is created
(~refs~), then a set of threads are set up (~pool~) to run a number of
iterations of incrementing every Ref (~tasks~). This creates extreme
contention, but yields the correct result. No locks!

#+BEGIN_SRC clojure
(import '(java.util.concurrent Executors))

(defn test-stm [nitems nthreads niters]
  (let [refs  (map ref (repeat nitems 0))
        pool  (Executors/newFixedThreadPool nthreads)
        tasks (map (fn [t]
                      (fn []
                        (dotimes [n niters]
                          (dosync
                            (doseq [r refs]
                              (alter r + 1 t))))))
                   (range nthreads))]
    (doseq [future (.invokeAll pool tasks)]
      (.get future))
    (.shutdown pool)
    (map deref refs)))

(test-stm 10 10 10000)
-> (550000 550000 550000 550000 550000 550000 550000 550000 550000 550000)
#+END_SRC

In typical use refs can refer to Clojure collections, which, being
persistent and immutable, efficiently support simultaneous speculative
'modifications' by multiple transactions. Mutable objects should not be
put in refs.

By default Vars are static, but per-thread bindings for Vars defined
with [[#content/reference/metadata][metadata]] mark them as dynamic. [[#content/reference/vars][Dynamic vars]] are also mutable
references to objects. They have a (thread-shared) root binding which
can be established by [[#content/reference/special_forms#def][def]], and can be set using ~set!~, but only if they
have been bound to a new storage location thread-locally using [[clojure:core.clj::(defmacro
binding][binding]].

Those bindings and any subsequent modifications to those bindings will
only be seen /within/ the thread by code in the dynamic scope of the
binding block. Nested bindings obey a stack protocol and unwind as
control exits the binding block.

#+BEGIN_SRC clojure
(def ^:dynamic *v*)

(defn incv [n] (set! *v* (+ *v* n)))

(defn test-vars [nthreads niters]
  (let [pool (Executors/newFixedThreadPool nthreads)
        tasks (map (fn [t]
                     #(binding [*v* 0]
                        (dotimes [n niters]
                          (incv t))
                        ,*v*))
                   (range nthreads))]
      (let [ret (.invokeAll pool tasks)]
        (.shutdown pool)
        (map #(.get %) ret))))

(test-vars 10 1000000)
-> (0 1000000 2000000 3000000 4000000 5000000 6000000 7000000 8000000 9000000)
(set! *v* 4)
-> java.lang.IllegalStateException: Can't change/establish root binding of: *v* with set
#+END_SRC

Dynamic vars provide a way to communicate between different points on
the call stack without polluting the argument lists and return values
of the intervening calls. In addition, dynamic vars support a flavor
of context-oriented programming. Because fns defined with [[clojure:core.clj::defn (fn defn][defn]] are
stored in vars, they too can be dynamically rebound:

#+BEGIN_SRC clojure
(defn ^:dynamic say [& args]
  (apply str args))

(defn loves [x y]
  (say x " loves " y))

(defn test-rebind []
  (println (loves "ricky" "lucy"))
  (let [say-orig say]
    (binding [say (fn [& args]
                      (println "Logging say")
                      (apply say-orig args))]
      (println (loves "fred" "ethel")))))

(test-rebind)

ricky loves lucy
Logging say
fred loves ethel
#+END_SRC

** Hosted on the JVM
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/jvm_hosted.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/jvm_hosted
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/concurrent_programming
:NEXTPAGE_CUSTOM_ID: content/about/clojurescript
:CUSTOM_ID: content/about/jvm_hosted
:END:

Clojure is designed to be a hosted language, sharing the JVM type
system, GC, threads etc. It compiles all functions to JVM bytecode.
Clojure is a great Java library consumer, offering the
dot-target-member notation for calls to Java. Class names can be
referenced in full, or as non-qualified names after being
imported. Clojure supports the dynamic implementation of Java
interfaces and classes using [[clojure:core_deftype.clj::(defmacro reify][reify]] and [[clojure:core_proxy.clj::(defmacro proxy][proxy]]:

Tapping into a Java class is as easy as:

#+BEGIN_SRC clojure
(import '[java.time LocalDate])

(defn add-week ^LocalDate [^LocalDate date]
  (.plusDays date 7))

(defn day->str [^LocalDate date]
  (format "%s %s, %s" (.getMonth date) (.getDayOfMonth date) (.getYear date)))

;; infinite sequence of weekly dates, starting from today
(def future-weeks (iterate add-week (LocalDate/now)))

(map day->str (take 4 future-weeks))
;; ("JULY 24, 2017" "JULY 31, 2017" "AUGUST 7, 2017" "AUGUST 14, 2017")
#+END_SRC

Here's a small Swing app as a more involved example:

#+BEGIN_SRC clojure
(import '(javax.swing JFrame JLabel JTextField JButton)
        '(java.awt.event ActionListener)
        '(java.awt GridLayout))
(defn celsius []
  (let [frame (JFrame. "Celsius Converter")
        temp-text (JTextField.)
        celsius-label (JLabel. "Celsius")
        convert-button (JButton. "Convert")
        fahrenheit-label (JLabel. "Fahrenheit")]
    (.addActionListener
     convert-button
     (reify ActionListener
            (actionPerformed
             [_ evt]
             (let [c (Double/parseDouble (.getText temp-text))]
               (.setText fahrenheit-label
                         (str (+ 32 (* 1.8 c)) " Fahrenheit"))))))
    (doto frame
      (.setLayout (GridLayout. 2 2 3 3))
      (.add temp-text)
      (.add celsius-label)
      (.add convert-button)
      (.add fahrenheit-label)
      (.setSize 300 80)
      (.setVisible true))))
(celsius)
#+END_SRC

[[./assets/images/content/about/celsius.png]]

** ClojureScript
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/clojurescript.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/clojurescript
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/jvm_hosted
:NEXTPAGE_CUSTOM_ID: content/about/clojureclr
:CUSTOM_ID: content/about/clojurescript
:END:

[[https://clojurescript.org][ClojureScript]] is a compiler for Clojure that targets JavaScript. It is
designed to emit JavaScript code which is compatible with the advanced
compilation mode of the [[https://developers.google.com/closure/][Google Closure]] optimizing compiler.

- [[https://github.com/clojure/clojurescript][ClojureScript Home]]

** Clojure CLR
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/clojureclr.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/clojureclr
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/about/clojurescript
:CUSTOM_ID: content/about/clojureclr
:END:

This project is a native implementation of Clojure on the Common
Language Runtime (CLR), the execution engine of Microsoft's .Net
Framework.

ClojureCLR is programmed in C# (and Clojure itself) and makes use of
Microsoft's Dynamic Language Runtime (DLR).

- [[https://github.com/clojure/clojure-clr][ClojureCLR Home]]
- [[https://github.com/clojure/clojure-clr/wiki/Getting-binaries][Downloading Binaries]]

** ----
** Features
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/about/features.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/about/features
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/about/features
:END:

Clojure has a set of useful features that together form a simple,
coherent, and powerful tool. In Clojure you'll find ideas from Lisp, ML,
Haskell, and others, but the end result is unique. This section is a
brief, non-comprehensive tour of some of the features of Clojure.
Consult the [[#content/reference/documentation][reference]] for more details.

- [[#content/about/dynamic][Dynamic Development]]
- [[#content/about/functional_programming][Functional Programming]]
- [[#content/about/lisp][Lisp]]
- [[#content/about/runtime_polymorphism][Runtime Polymorphism]]
- [[#content/about/concurrent_programming][Concurrent Programming]]
- [[#content/about/jvm_hosted][Hosted on the JVM]]

* Api
** Cheatsheet
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/api/cheatsheet.html]]
:CLOJURE_SITE_PAGE: https://clojure.org/api/cheatsheet
:CUSTOM_ID: content/api/cheatsheet
:CHEATSHEET_VERSION: v52
:CHEATSHEET_REPOSITORY: http://github.com/jafingerhut/clojure-cheatsheets
:CHEATSHEET_REPOSITORY_COMMIT: 5019a17
:END:

Clojure 1.10 Cheat Sheet (v52)

[[https://github.com/jafingerhut/clojure-cheatsheets/blob/master/pdf/cheatsheet-usletter-color.pdf?raw=true][Download PDF version]] / [[https://jafingerhut.github.io/][Source repo]]

Many thanks to Steve Tayon for creating it and Andy Fingerhut for
ongoing maintenance.

*** Documentation

| clojure.repl/         | [[clojure:repl.clj::(defmacro doc][doc]], [[clojure:repl.clj::(defn find-doc][find-doc]], [[clojure:repl.clj::(defn apropos][apropos]], [[clojure:repl.clj::(defmacro dir][dir]], [[clojure:repl.clj::(defmacro source][source]], [[clojure:repl.clj::(defn pst][pst]] |
|-----------------------+------------------------------------------|
| clojure.java.javadoc/ | [[clojure:java/javadoc.clj::(defn javadoc][javadoc]]                                  |

*** Primitives
**** Numbers
| Literals   | [[https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html][Long]]: 7, hex 0xff, oct 017, base 22 r1011,               |
|            | base 36 36rCRAZY, BigInt: 7N,                            |
|            | Ratio: -22/7, 2.78, -1.2e-5, [[https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html][BigDecimal]]: 4.2M            |
|------------+----------------------------------------------------------|
| Arithmetic | [[clojure:core.clj::986][+]], [[clojure:core.clj::1045][-]], [[clojure:core.clj::1010][*]], [[clojure:core.clj::(defn /][ /]], [[clojure:core.clj::(defn quot][quot]], [[clojure:core.clj::(defn rem][rem]], [[clojure:core.clj::(defn mod][mod]], [[clojure:core.clj::924][inc]], [[clojure:core.clj::1144][dec]], [[clojure:core.clj::(defn max][max]], [[clojure:core.clj::(defn min][min]],         |
|            | [[clojure:core.clj::(defn +'][+']], [[clojure:core.clj::(defn -'][-']], [[clojure:core.clj::(defn *'][*']], [[clojure:core.clj::(defn inc'][inc']], [[clojure:core.clj::(defn dec'][dec']]                                     |
|------------+----------------------------------------------------------|
| Compare    | [[clojure:core.clj::(defn ==][==]], [[clojure:core.clj::(defn <][<]], [[clojure:core.clj::(defn >][>]], [[clojure:core.clj::(defn <=][<=]], [[clojure:core.clj::(defn >=][>=]], [[clojure:core.clj::(defn compare][compare]]                                |
|------------+----------------------------------------------------------|
| Bitwise    | [[clojure:core.clj::(defn bit-and][bit-and]], [[clojure:core.clj::(defn bit-or][bit-or]], [[clojure:core.clj::(defn bit-xor][bit-xor]], [[clojure:core.clj::(defn bit-not][bit-not]], [[clojure:core.clj::(defn bit-flip][bit-flip]], [[clojure:core.clj::(defn bit-set][bit-set]],    |
|            | [[clojure:core.clj::(defn bit-shift-right][bit-shift-right]], [[clojure:core.clj::(defn bit-shift-left][bit-shift-left]], [[clojure:core.clj::(defn bit-and-not][bit-and-not]], [[clojure:core.clj::(defn bit-clear][bit-clear]], |
|            | [[clojure:core.clj::(defn bit-test][bit-test]], [[clojure:core.clj::(defn unsigned-bit-shift-right][unsigned-bit-shift-right]]                       |
|            | (see [[https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html][BigInteger]] for integers larger than Long)           |
|------------+----------------------------------------------------------|
| Cast       | [[clojure:core.clj::(defn byte][byte]], [[clojure:core.clj::(defn short][short]], [[clojure:core.clj::(defn int][int]], [[clojure:core.clj::(defn long][long]], [[clojure:core.clj::(defn float][float]], [[clojure:core.clj::3480][double]], [[clojure:core.clj::(defn bigdec][bigdec]], [[clojure:core.clj::(defn bigint][bigint]],   |
|            | [[clojure:core.clj::(defn num][num]], [[clojure:core.clj::(defn rationalize][rationalize]], [[clojure:core.clj::(defn biginteger][biginteger]]                             |
|------------+----------------------------------------------------------|
| Test       | [[clojure:core.clj::(defn zero?][zero?]], [[clojure:core.clj::(defn pos?][pos?]], [[clojure:core.clj::(defn neg?][neg?]], [[clojure:core.clj::(defn even?][even?]], [[clojure:core.clj::(defn odd?][odd?]], [[clojure:core.clj::(defn number?][number?]], [[clojure:core.clj::(defn rational?][rational?]],      |
|            | [[clojure:core.clj::(defn integer?][integer?]], [[clojure:core.clj::(defn ratio?][ratio?]], [[clojure:core.clj::(defn decimal?][decimal?]], [[clojure:core.clj::(defn float?][float?]], (1.9) [[clojure:core.clj::(defn double?][double?]],       |
|            | [[clojure:core.clj::(defn int?][int?]], [[clojure:core.clj::(defn nat-int?][nat-int?]], [[clojure:core.clj::(defn neg-int?][neg-int?]], [[clojure:core.clj::(defn pos-int?][pos-int?]]                       |
|------------+----------------------------------------------------------|
| Random     | [[clojure:core.clj::(defn rand][rand]], [[clojure:core.clj::(defn rand-int][rand-int]]                                           |
|------------+----------------------------------------------------------|
| BigDecimal | [[clojure:core.clj::(defmacro with-precision][with-precision]]                                           |
|------------+----------------------------------------------------------|
| Unchecked  | [[clojure:core.clj::(add-doc-and-meta *unchecked-math*][*unchecked-math*]], [[clojure:core.clj::1200][unchecked-add]], [[clojure:core.clj::1172][unchecked-dec]],          |
|            | [[clojure:core.clj::1158][unchecked-inc]], [[clojure:core.clj::1228][unchecked-multiply]],                       |
|            | [[clojure:core.clj::1186][unchecked-negate]], [[clojure:core.clj::1214][unchecked-subtract]]                     |

**** Strings
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#strings
:END:

| Create  | [[clojure:core.clj::(defn str][str]], [[clojure:core.clj::(defn format][format]], [[#content/reference/reader#literals][a string]]:                                         |
|         | ~"escapes \b\f\n\t\r\" octal \377 hex \ucafe"~                   |
|         | See also [[#content/api/cheatsheet#io][IO/to string section]]                                  |
|---------+----------------------------------------------------------------|
| Use     | [[clojure:core.clj::(defn count][count]], [[clojure:core.clj::(defn get][get]], [[clojure:core.clj::(defn subs][subs]], [[clojure:core.clj::(defn compare][compare]]                                      |
|         | (~clojure.string/~) [[clojure:string.clj::(defn ^String join][join]], [[clojure:string.clj::(defn ^String escape][escape]], [[clojure:string.clj::(defn split][split]], [[clojure:string.clj::(defn split-lines][split-lines]], [[clojure:string.clj::(defn ^String replace][replace]],   |
|         | [[clojure:string.clj::(defn ^String replace-first][replace-first]], [[clojure:string.clj::(defn ^String reverse][reverse]] (1.8) [[clojure:string.clj::(defn index-of][index-of]], [[clojure:string.clj::(defn last-index-of][last-index-of]]           |
|---------+----------------------------------------------------------------|
| [[http://www.regular-expressions.info][Regex]]   | [[https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html][#"pattern"]], [[clojure:core.clj::(defn re-find][re-find]], [[clojure:core.clj::(defn re-seq][re-seq]], [[clojure:core.clj::(defn re-matches][re-matches]], [[clojure:core.clj::(defn re-pattern][re-pattern]],           |
|         | [[clojure:core.clj::(defn re-matcher][re-matcher]], [[clojure:core.clj::(defn re-groups][re-groups]]                                          |
|         | (~clojure.string/~) [[clojure:string.clj::(defn ^String replace][replace]], [[clojure:string.clj::(defn ^string replace-first][replace-first]], [[clojure:string.clj::(defn ^string re-quote-replacement][re-quote-replacement]] |
|         | Note: ~\~ in ~#""~ is not escape char.                             |
|         | ~(re-pattern "\\s*\\d+")~ can be written ~#"\s*\d+"~               |
|---------+----------------------------------------------------------------|
| Letters | (~clojure.string/~) [[clojure:string.clj::(defn ^String capitalize][capitalize]], [[clojure:string.clj::(defn ^String lower-case][lower-case]], [[clojure:string.clj::(defn ^String upper-case][upper-case]]           |
|---------+----------------------------------------------------------------|
| Trim    | (~clojure.string/~) [[clojure:string.clj::(defn ^String trim][trim]], [[clojure:string.clj::(defn ^String trim-newline][trim-newline]], [[clojure:string.clj::(defn ^String triml][triml]], [[clojure:string.clj::(defn ^String trimr][trimr]]             |
|---------+----------------------------------------------------------------|
| Test    | [[clojure:core.clj::string? (fn ^:static string?][string?]], (~clojure.string/~) [[clojure:string.clj::(defn blank?][blank?]],                             |
|         | (1.8) [[clojure:string.clj::(defn starts-with?][starts-with?]], [[clojure:string.clj::(defn ends-with?][ends-with?]], [[clojure:string.clj::(defn includes?][includes?]]                      |

**** Other
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#primitives-other
:END:

| Characters | [[clojure:core.clj::(defn char][char]], [[clojure:core.clj::char? (fn ^:static char?][char?]], [[clojure:core_print.clj::char-name-string][char-name-string]], [[clojure:core_print.clj::char-escape-string][char-escape-string]]    |
|            | [[#content/reference/reader#literals][literals]]: ~\a \newline~                                |
|------------+------------------------------------------------------|
| Keywords   | [[clojure:core.clj::616][keyword]], [[clojure:core.clj::(defn keyword?][keyword?]], [[clojure:core.clj::(defn find-keyword][find-keyword]]                      |
|            | [[#content/reference/reader#literals][literals]]: ~:kw~, ~:my.name.space/kw~,                    |
|            | ~::in-cur-namespace~, ~::namespace-alias/kw~             |
|------------+------------------------------------------------------|
| Symbols    | [[clojure:core.clj::591][symbol]], [[clojure:core.clj::(defn symbol?][symbol?]], [[clojure:core.clj::(defn gensym][gensym]], [[#content/reference/reader#literals][literals]]: ~my-sym~, ~my.ns/foo~ |
|------------+------------------------------------------------------|
| Misc       | [[#content/reference/reader#literals][literals]]: ~true~, ~false~, ~nil~                           |

*** Collections
**** Collections

| Generic ops   | [[clojure:core.clj::(defn count][count]], [[clojure:core.clj::(defn empty][empty]], [[clojure:core.clj::(defn not-empty][not-empty]], [[clojure:core.clj::6928][into]], [[clojure:core.clj::conj (fn ^:static][conj]],                        |
|               | (~clojure.walk/~) [[clojure:walk.clj::(defn walk][walk]], [[clojure:walk.clj::(defn prewalk][prewalk]], [[clojure:walk.clj::(defn prewalk-demo][prewalk-demo]],                |
|               | [[clojure:walk.clj::(defn prewalk-replace][prewalk-replace]], [[clojure:walk.clj::(defn postwalk][postwalk]], [[clojure:walk.clj::(defn postwalk-demo][postwalk-demo]], [[clojure:walk.clj::(defn postwalk-replace][postwalk-replace]], |
|               | (1.9) [[clojure:core.clj::(defn bounded-count][bounded-count]]                                         |
|---------------+-------------------------------------------------------------|
| Content tests | [[clojure:core.clj::(defn distinct?][distinct?]], [[clojure:core.clj::(defn empty?][empty?]], [[clojure:core.clj::(defn every?][every?]], [[clojure:core.clj::not-every? (comp not][not-every?]], [[clojure:core.clj::2696][some]], [[clojure:core.clj::not-any? (comp not][not-any?]]       |
|---------------+-------------------------------------------------------------|
| Capabilities  | [[clojure:core.clj::(defn sequential?][sequential?]], [[clojure:core.clj::(defn associative?][associative?]], [[clojure:core.clj::(defn sorted?][sorted?]], [[clojure:core.clj::(defn counted?][counted?]], [[clojure:core.clj::(defn reversible?][reversible?]]   |
|---------------+-------------------------------------------------------------|
| Type tests    | [[clojure:core.clj::(defn coll?][coll?]], [[clojure:core.clj::(defn list?][list?]], [[clojure:core.clj::vector? (fn ^:static vector?][vector?]], [[clojure:core.clj::(defn set?][set?]], [[clojure:core.clj::map? (fn ^:static map?][map?]], [[clojure:core.clj::seq? (fn ^:static seq?][seq?]], [[clojure:core_deftype.clj::(defn record?][record?]]            |
|               | (1.8) [[clojure:core.clj::(defn map-entry?][map-entry?]]                                            |

**** Lists (conj, pop, & peek at beginning)
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#lists
:END:

| Create   | ~()~ [[clojure:core.clj::list (. clojure.lang.PersistentList][list]], [[clojure:core.clj::(defn list*][list*]]                           |
|----------+------------------------------------------|
| Examine  | [[clojure:core.clj::first (fn ^:static first][first]], [[clojure:core.clj::(defn nth][nth]], [[clojure:core.clj::(defn peek][peek]], [[https://docs.oracle.com/javase/8/docs/api/java/util/List.html#indexOf-java.lang.Object-][.indexOf]], [[https://docs.oracle.com/javase/8/docs/api/java/util/List.html#lastIndexOf-java.lang.Object-][.lastIndexOf]] |
|----------+------------------------------------------|
| 'Change' | [[clojure:core.clj::cons (fn* ^:static cons][cons]], [[clojure:core.clj::conj (fn ^:static conj][conj]], [[clojure:core.clj::rest (fn ^:static rest][rest]], [[clojure:core.clj::(defn pop][pop]]                    |

**** Vectors (conj, pop, & peek at end)
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#vectors
:END:

| Create   | ~[]~ [[clojure:core.clj::(defn vector][vector]], [[clojure:core.clj::369][vec]], [[clojure:gvec.clj::(defn vector-of][vector-of]], [[clojure:core.clj::(defn mapv][mapv]], [[clojure:core.clj::(defn filterv][filterv]],          |
|          | (~clojure.core.rrb-vector/~) [[core.rrb-vector:clojure/core/rrb_vector.clj::(defn vector][vector]], [[core.rrb-vector:clojure/core/rrb_vector.clj::114][vec]], [[core.rrb-vector:clojure/core/rrb_vector.clj::(defn vector-of][vector-of]]  |
|----------+----------------------------------------------------|
| Examine  | ~(my-vec idx)~ → ~(nth my-vec idx)~                    |
|          | [[clojure:core.clj::(defn get][get]], [[clojure:core.clj::(defn peek][peek]], [[https://docs.oracle.com/javase/8/docs/api/java/util/List.html#indexOf-java.lang.Object-][.indexOf]], [[https://docs.oracle.com/javase/8/docs/api/java/util/List.html#lastIndexOf-java.lang.Object-][.lastIndexOf]]                  |
|----------+----------------------------------------------------|
| 'Change' | [[clojure:core.clj::(fn ^:static assoc][assoc]], [[clojure:core.clj::(defn assoc-in][assoc-in]], [[clojure:core.clj::(defn pop][pop]], [[clojure:core.clj::(defn subvec][subvec]], [[clojure:core.clj::(defn replace][replace]], [[clojure:core.clj::conj (fn ^:static conj][conj]], [[clojure:core.clj::(defn rseq][rseq]], |
|          | [[clojure:core.clj::6211][update]], [[clojure:core.clj::(defn update-in][update-in]]                                  |
|----------+----------------------------------------------------|
| Ops      | [[clojure:core.clj::(defn reduce-kv][reduce-kv]]                                          |

**** Sets
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#sets
:END:

| Create unsorted | ~{}~, [[clojure:core.clj::4093][set]], [[clojure:core.clj::(defn hash-set][hash-set]]                                       |
|-----------------+---------------------------------------------------------|
| Create sorted   | [[clojure:core.clj::(defn sorted-set][sorted-set]], [[clojure:core.clj::(defn sorted-set-by][sorted-set-by]],                              |
|                 | (~clojure.data.avl/~) [[data.avl:clojure/data/avl.clj::(defn sorted-set][sorted-set]], [[data.avl:clojure/data/avl.clj::(defn sorted-set-by][sorted-set-by]],          |
|                 | (~flatland.ordered.set/~) [[ordered:flatland/ordered/set.clj::(defn ordered-set][ordered-set]],                    |
|                 | (~clojure.data.int-map/~) [[data.int-map:clojure/data/int_map.clj::(defn int-set][int-set]], [[data.int-map:clojure/data/int_map.clj::(defn dense-int-set][dense-int-set]]          |
|-----------------+---------------------------------------------------------|
| Examine         | ~(my-set item)~ → ~(get my-set item)~                       |
|                 | [[clojure:core.clj::(defn contains?][contains?]]                                               |
|-----------------+---------------------------------------------------------|
| 'Change'        | [[clojure:core.clj::conj (fn ^:static conj][conj]], [[clojure:core.clj::(defn disj][disj]]                                              |
|-----------------+---------------------------------------------------------|
| Set ops         | (~clojure.set/~) [[clojure:set.clj::(defn union][union]], [[clojure:set.clj::(defn difference][difference]], [[clojure:set.clj::(defn intersection][intersection]], [[clojure:set.clj::(defn select][select]], |
|                 | See also [[#content/api/cheatsheet#relations][Relations section]]                              |
|-----------------+---------------------------------------------------------|
| "Test"          | (~clojure.set/~) [[clojure:set.clj::(defn subset?][subset?]], [[clojure:set.clj::(defn superset?][superset?]]                       |
|-----------------+---------------------------------------------------------|
| Sorted sets     | [[clojure:core.clj::(defn rseq][rseq]], [[clojure:core.clj::(defn subseq][subseq]], [[clojure:core.clj::(defn rsubseq][rsubseq]]                                   |

**** Maps
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#maps
:END:

| Create unsorted | ~{}~, [[clojure:core.clj::(defn hash-map][hash-map]], [[clojure:core.clj::(defn array-map][array-map]], [[clojure:core.clj::(defn zipmap][zipmap]], [[clojure:core_proxy.clj::(defn bean][bean]], [[clojure:core.clj::(defn frequencies][frequencies]], |
|                 | [[clojure:core.clj::(defn group-by][group-by]], [[clojure:set.clj::(defn index][clojure.set/index]]                         |
|-----------------+-----------------------------------------------------|
| Create sorted   | [[clojure:core.clj::(defn sorted-map][sorted-map]], [[clojure:core.clj::(defn sorted-map-by][sorted-map-by]],                          |
|                 | (~clojure.data.avl/~) [[data.avl:clojure/data/avl.clj::(defn sorted-map][sorted-map]], [[data.avl:clojure/data/avl.clj::(defn sorted-map-by][sorted-map-by]],      |
|                 | (~flatland.ordered.set/~) [[ordered:flatland/ordered/map.clj::(defn ordered-map][ordered-map]]                 |
|                 | (~clojure.data.priority-map/~) [[data.priority-map:clojure/data/priority_map.clj::(defn priority-map][priority-map]]           |
|                 | (~flatland.useful.map/~) [[useful:flatland/useful/map.clj::(defn ordering-map][ordering-map]]                 |
|                 | (~clojure.data.int-map/~) [[data.int-map:clojure/data/int_map.clj::(defn int-map][int-map]]                     |
|-----------------+-----------------------------------------------------|
| Examine         | ~(my-map k)~ → ~(get my-app k)~,                        |
|                 | also: ~(:key my-map)~ → ~(get my-map :key)~             |
|                 | [[clojure:core.clj::(defn get-in][get-in]], [[clojure:core.clj::(defn contains?][contains?]], [[clojure:core.clj::1536][find]], [[clojure:core.clj::(defn keys][keys]], [[clojure:core.clj::(defn vals][vals]]                 |
|-----------------+-----------------------------------------------------|
| 'Change'        | [[clojure:core.clj::(fn ^:static assoc][assoc]], [[clojure:core.clj::(defn assoc-in][assoc-in]], [[clojure:core.clj::(defn dissoc][dissoc]], [[clojure:core.clj::(defn merge][merge]], [[clojure:core.clj::(defn merge-with][merge-with]],         |
|                 | [[clojure:core.clj::(defn select-keys][select-keys]], [[clojure:core.clj::6211][update]], [[clojure:core.clj::(defn update-in][update-in]],                     |
|                 | (~clojure.set/~) [[clojure:set.clj::(defn rename-keys][rename-keys]], [[clojure:set.clj::(defn map-invert][map-invert]],             |
|                 | GitHub: [[https://github.com/weavejester/medley][Medley]]                                      |
|-----------------+-----------------------------------------------------|
| Ops             | [[clojure:core.clj::(defn reduce-kv][reduce-kv]]                                           |
|-----------------+-----------------------------------------------------|
| Entry           | [[clojure:core.clj::1569][key]], [[clojure:core.clj::1576][val]]                                            |
|-----------------+-----------------------------------------------------|
| Sorted maps     | [[clojure:core.clj::(defn rseq][rseq]], [[clojure:core.clj::(defn subseq][subseq]], [[clojure:core.clj::(defn rsubseq][rsubseq]]                               |

**** Queues (conj at end, peek & pop from beginning)

| Create   | ~clojure.lang.PersistentQueue/EMPTY~    |
|          | (no literal syntax or constructor fn) |
|----------+---------------------------------------|
| Examine  | [[clojure:core.clj::(defn peek][peek]]                                  |
|----------+---------------------------------------|
| 'Change' | [[clojure:core.clj::conj (fn ^:static][conj]], [[clojure:core.clj::(defn pop][pop]]                             |

**** Relations (set of maps, each with same keys, aka rels)
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#relations
:END:

| Rel algebra | (~clojure.set/~) [[clojure:set.clj::(defn join][join]], [[clojure:set.clj::(defn select][select]], [[clojure:set.clj::(defn project][project]], [[clojure:set.clj::(defn union][union]], |
|             | [[clojure:set.clj::(defn difference][difference]], [[clojure:set.clj::(defn intersection][intersection]], [[clojure:set.clj::(defn index][index]], [[clojure:set.clj::89][rename]]      |

**** Transients ([[#content/reference/transients][reference/transients]])

| Create | [[clojure:core.clj::(defn transient][transient]], [[clojure:core.clj::(defn persistent!][persistent!]]                  |
|--------+-----------------------------------------|
| Change | [[clojure:core.clj::(defn conj!][conj!]], [[clojure:core.clj::(defn pop!][pop!]], [[clojure:core.clj::(defn assoc!][assoc!]], [[clojure:core.clj::(defn dissoc!][dissoc!]], [[clojure:core.clj::(defn disj!][disj!]]     |
|        | Note: always use return value for later |
|        | changes, never original!"               |

**** Misc

| Compare | [[clojure:core.clj::(defn =][=]], [[clojure:core.clj::(defn identical?][identical?]], [[clojure:core.clj::(defn not=][not=]], [[clojure:core.clj::(defn not][not]], [[clojure:core.clj::(defn compare][compare]] [[clojure:data.clj::(defn diff][clojure.data/diff]] |
|---------+-----------------------------------------------------|
| Test    | [[clojure:core.clj::(defn true?][true?]], [[clojure:core.clj::(defn false?][false?]], [[clojure:core.clj::(defn instance?][instance?]], [[clojure:core.clj::(defn nil?][nil?]], [[clojure:core.clj::(defn some?][some?]]               |

*** Sequences
**** Creating a Lazy Seq

| From collection  | [[clojure:core.clj::seq (fn ^:static seq][seq]], [[clojure:core.clj::(defn vals][vals]], [[clojure:core.clj::(defn keys][keys]], [[clojure:core.clj::(defn rseq][rseq]], [[clojure:core.clj::(defn subseq][subseq]], [[clojure:core.clj::(defn rsubseq][rsubseq]], [[clojure:core.clj::(defn sequence][sequence]]     |
|------------------+------------------------------------------------------|
| From producer fn | [[clojure:core.clj::(defmacro lazy-seq][lazy-seq]], [[clojure:core.clj::(defn repeatedly][repeatedly]], [[clojure:core.clj::(defn iterate][iterate]]                        |
|------------------+------------------------------------------------------|
| From constant    | [[clojure:core.clj::(defn repeat][repeat]], [[clojure:core.clj::(defn range][range]]                                        |
|------------------+------------------------------------------------------|
| From other       | [[clojure:core.clj::(defn file-seq][file-seq]], [[clojure:core.clj::(defn line-seq][line-seq]], [[clojure:core.clj::(defn resultset-seq][resultset-seq]], [[clojure:core.clj::(defn re-seq][re-seq]], [[clojure:core.clj::(defn tree-seq][tree-seq]], |
|                  | [[clojure:core.clj::(defn xml-seq][xml-seq]], [[clojure:core.clj::(defn iterator-seq][iterator-seq]], [[clojure:core.clj::(defn enumeration-seq][enumeration-seq]]               |
|------------------+------------------------------------------------------|
| From seq         | [[clojure:core.clj::(defn keep][keep]], [[clojure:core.clj::(defn keep-indexed][keep-indexed]]                                   |

**** Seq in, Seq out

| Get shorter   | [[clojure:core.clj::(defn distinct][distinct]], [[clojure:core.clj::(defn filter][filter]], [[clojure:core.clj::2830 ][remove]], [[clojure:core.clj::(defn take-nth][take-nth]], [[clojure:core.clj::(defmacro for][for]],              |
|               | [[clojure:core.clj::(defn dedupe][dedupe]], [[clojure:core.clj::(defn random-sample][random-sample]]                                 |
|---------------+-------------------------------------------------------|
| Get longer    | [[clojure:core.clj::cons (fn* ^:static cons][cons]], [[clojure:core.clj::conj (fn ^:static][conj]], [[clojure:core.clj::(defn concat][concat]], [[clojure:core.clj::(defmacro lazy-cat][lazy-cat]], [[clojure:core.clj::(defn mapcat][mapcat]], [[clojure:core.clj::(defn cycle][cycle]],          |
|               | [[clojure:core.clj::(defn interleave][interleave]], [[clojure:core.clj::(defn interpose][interpose]]                                 |
|---------------+-------------------------------------------------------|
| Tail-items    | [[clojure:core.clj::rest (fn ^:static rest][rest]], [[clojure:core.clj::(defn nthrest][nthrest]], [[clojure:core.clj::next (fn ^:static next][next]], [[clojure:core.clj::fnext (fn ^:static fnext][fnext]], [[clojure:core.clj::nnext (fn ^:static nnext][nnext]], [[clojure:core.clj::(defn drop][drop]],              |
|               | [[clojure:core.clj::(defn drop-while][drop-while]], [[clojure:core.clj::(defn take-last][take-last]], [[clojure:core.clj::(defmacro for][for]]                            |
|---------------+-------------------------------------------------------|
| Head-items    | [[clojure:core.clj::(defn take][take]], [[clojure:core.clj::(defn take-while][take-while]], [[clojure:core.clj::(defn butlast][butlast]], [[clojure:core.clj::(defn drop-last][drop-last]], [[clojure:core.clj::(defmacro for][for]]             |
|---------------+-------------------------------------------------------|
| 'Change'      | [[clojure:core.clj::conj (fn ^:static][conj]], [[clojure:core.clj::(defn concat][concat]], [[clojure:core.clj::(defn distinct][distinct]], [[clojure:core.clj::(defn flatten][flatten]], [[clojure:core.clj::(defn group-by][group-by]], [[clojure:core.clj::(defn partition][partition]], |
|               | [[clojure:core.clj::(defn partition-all][partition-all]], [[clojure:core.clj::(defn partition-by][partition-by]], [[clojure:core.clj::(defn split-at][split-at]], [[clojure:core.clj::(defn split-with][split-with]],    |
|               | [[clojure:core.clj::(defn filter][filter]], [[clojure:core.clj::2830 ][remove]], [[clojure:core.clj::(defn replace][replace]], [[clojure:core.clj::(defn shuffle][shuffle]]                      |
|---------------+-------------------------------------------------------|
| Rearrange     | [[clojure:core.clj::(defn reverse][reverse]], [[clojure:core.clj::3090][sort]], [[clojure:core.clj::(defn sort-by][sort-by]], [[clojure:core.clj::(defn compare][compare]]                       |
|---------------+-------------------------------------------------------|
| Process items | [[clojure:core.clj::2731][map]], [[clojure:core.clj::(defn pmap][pmap]], [[clojure:core.clj::(defn map-indexed][map-indexed]], [[clojure:core.clj::(defn mapcat][mapcat]], [[clojure:core.clj::(defmacro for][for]], [[clojure:core.clj::(defn replace][replace]], [[clojure:core.clj::5409][seque]]   |

**** Using a Seq

| Extract item     | [[clojure:core.clj::first (fn ^:static first][first]], [[clojure:core.clj::second (fn ^:static second][second]], [[clojure:core.clj::last (fn ^:static last][last]], [[clojure:core.clj::rest (fn ^:static rest][rest]], [[clojure:core.clj::next (fn ^:static next][next]], [[clojure:core.clj::ffirst (fn ^:static ffirst][ffirst]], [[clojure:core.clj::nfirst (fn ^:static nfirst][nfirst]],  |
|                  | [[clojure:core.clj::fnext (fn ^:static fnext][fnext]], [[clojure:core.clj::nnext (fn ^:static nnext][nnext]], [[clojure:core.clj::(defn nth][nth]], [[clojure:core.clj::(defn nthnext][nthnext]], [[clojure:core.clj::(defn rand-nth][rand-nth]], [[clojure:core.clj::(defmacro when-first][when-first]], |
|                  | [[clojure:core.clj::(defn max-key][max-key]], [[clojure:core.clj::(defn min-key][min-key]]                                  |
|------------------+---------------------------------------------------|
| Construct coll   | [[clojure:core.clj::(defn zipmap][zipmap]], [[clojure:core.clj::6928][into]], [[clojure:core.clj::6846][reduce]], [[clojure:core.clj::(defn reductions][reductions]], [[clojure:core.clj::4093][set]], [[clojure:core.clj::369][vec]],       |
|                  | [[clojure:core.clj::(defn into-array][into-array]], [[clojure:core.clj::(defn to-array-2d][to-array-2d]], [[clojure:core.clj::(defn mapv][mapv]], [[clojure:core.clj::(defn filterv][filterv]]            |
|------------------+---------------------------------------------------|
| Pass to fn       | [[clojure:core.clj::(defn apply][apply]]                                             |
|------------------+---------------------------------------------------|
| Search           | [[clojure:core.clj::2696][some]], [[clojure:core.clj::(defn filter][filter]]                                      |
|------------------+---------------------------------------------------|
| Force evaluation | [[clojure:core.clj::(defmacro doseq][doseq]], [[clojure:core.clj::(defn dorun][dorun]], [[clojure:core.clj::(defn doall][doall]], [[clojure:core.clj::(defn run!][run!]]                         |
|------------------+---------------------------------------------------|
| Check for forced | [[clojure:core.clj::(defn realized?][realized?]]                                         |

*** Transducers

| Off the shelf     | [[clojure:core.clj::2731][map]], [[clojure:core.clj::(defn mapcat][mapcat]], [[clojure:core.clj::(defn filter][filter]], [[clojure:core.clj::2830][remove]], [[clojure:core.clj::(defn take][take]], [[clojure:core.clj::(defn take-while][take-while]],     |
|                   | [[clojure:core.clj::(defn take-nth][take-nth]], [[clojure:core.clj::(defn drop][drop]], [[clojure:core.clj::(defn drop-while][drop-while]], [[clojure:core.clj::(defn replace][replace]], [[clojure:core.clj::(defn partition-by][partition-by]], |
|                   | [[clojure:core.clj::(defn partition-all][partition-all]], [[clojure:core.clj::(defn keep][keep]], [[clojure:core.clj::(defn keep-indexed][keep-indexed]], [[clojure:core.clj::(defn map-indexed][map-indexed]],    |
|                   | [[clojure:core.clj::(defn distinct][distinct]], [[clojure:core.clj::(defn interpose][interpose]], [[clojure:core.clj::(defn cat][cat]], [[clojure:core.clj::(defn dedupe][dedupe]], [[clojure:core.clj::(defn random-sample][random-sample]],   |
|                   | (1.9) [[clojure:core.clj::(defn halt-when][halt-when]]                                    |
|-------------------+----------------------------------------------------|
| Create your own   | [[clojure:core.clj::(defn completing][completing]], [[clojure:core.clj::(defn ensure-reduced][ensure-reduced]], [[clojure:core.clj::(defn unreduced][unreduced]],             |
|                   | See also [[#content/api/cheatsheet#concurrency][Concurrency/Volatiles section]]             |
|-------------------+----------------------------------------------------|
| Use               | [[clojure:core.clj::6928][into]], [[clojure:core.clj::(defn sequence][sequence]], [[clojure:core.clj::(defn transduce][transduce]], [[clojure:core.clj::(defn eduction][eduction]]                |
|-------------------+----------------------------------------------------|
| Early termination | [[clojure:core.clj::(defn reduced][reduced]], [[clojure:core.clj::(defn reduced?][reduced?]], [[clojure:core.clj::(defn deref][deref]]                           |

*** Spec ([[#content/about/spec][rationale]], [[#content/guides/spec][guide]])
**** Spec (~clojure.spec.alpha/~)

| Operations       | [[spec.alpha:clojure/spec/alpha.clj::(defn valid?][valid?]], [[spec.alpha:clojure/spec/alpha.clj::(defn conform][conform]], [[spec.alpha:clojure/spec/alpha.clj::(defn unform][unform]], [[spec.alpha:clojure/spec/alpha.clj::267][explain]], [[spec.alpha:clojure/spec/alpha.clj::(defn explain-data][explain-data]], |
|                  | [[spec.alpha:clojure/spec/alpha.clj::(defn explain-str][explain-str]], [[spec.alpha:clojure/spec/alpha.clj::(defn explain-out][explain-out]], [[spec.alpha:clojure/spec/alpha.clj::(defn form][form]], [[spec.alpha:clojure/spec/alpha.clj::(defn describe][describe]],       |
|                  | [[spec.alpha:clojure/spec/alpha.clj::(defmacro assert][assert]], [[spec.alpha:clojure/spec/alpha.clj::(defn check-asserts][check-asserts]], [[spec.alpha:clojure/spec/alpha.clj::(defn check-asserts?][check-asserts?]]           |
|------------------+-------------------------------------------------|
| Generator ops    | [[spec.alpha:clojure/spec/alpha.clj::(defn gen][gen]], [[spec.alpha:clojure/spec/alpha.clj::(defn exercise][exercise]], [[spec.alpha:clojure/spec/alpha.clj::(defn exercise-fn][exercise-fn]]                      |
|------------------+-------------------------------------------------|
| Defn. & registry | [[spec.alpha:clojure/spec/alpha.clj::(defmacro def][def]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro fdef][fdef]], [[spec.alpha:clojure/spec/alpha.clj::(defn registry][registry]], [[spec.alpha:clojure/spec/alpha.clj::(defn get-spec][get-spec]], [[spec.alpha:clojure/spec/alpha.clj::(defn spec?][spec?]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro spec][spec]],     |
|                  | [[spec.alpha:clojure/spec/alpha.clj::(defn with-gen][with-gen]]                                        |
|------------------+-------------------------------------------------|
| Logical          | [[spec.alpha:clojure/spec/alpha.clj::(defmacro and][and]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro or][or]]                                         |
|------------------+-------------------------------------------------|
| Collection       | [[spec.alpha:clojure/spec/alpha.clj::(defmacro coll-of][coll-of]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro map-of][map-of]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro every][every]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro every-kv][every-kv]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro keys][keys]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro merge][merge]]   |
|------------------+-------------------------------------------------|
| Regex            | [[spec.alpha:clojure/spec/alpha.clj::(defmacro cat][cat]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro alt][alt]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro *][*]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro +][+]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro ?][?]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro &][&]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro keys*][keys*]]                     |
|------------------+-------------------------------------------------|
| Range            | [[spec.alpha:clojure/spec/alpha.clj::(defmacro int-in][int-in]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro inst-in][inst-in]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro double-in][double-in]], [[spec.alpha:clojure/spec/alpha.clj::(defn int-in-range?][int-in-range?]],      |
|                  | [[spec.alpha:clojure/spec/alpha.clj::(defn inst-in-range?][inst-in-range?]]                                  |
|------------------+-------------------------------------------------|
| Other            | [[spec.alpha:clojure/spec/alpha.clj::(defmacro nilable][nilable]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro multi-spec][multi-spec]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro fspec][fspec]], [[spec.alpha:clojure/spec/alpha.clj::(defmacro conformer][conformer]]           |
|------------------+-------------------------------------------------|
| Custom explain   | [[spec.alpha:clojure/spec/alpha.clj::(defn explain-printer][explain-printer]], [[spec.alpha:clojure/spec/alpha.clj::(def ^:dynamic *explain-out* explain-printer][*explain-out*]]                  |

**** Predicates with test.check generators

| Numbers           | [[clojure:core.clj::(defn number?][number?]], [[clojure:core.clj::(defn rational?][rational?]], [[clojure:core.clj::(defn integer?][integer?]], [[clojure:core.clj::(defn ratio?][ratio?]], [[clojure:core.clj::(defn decimal?][decimal?]],       |
|                   | [[clojure:core.clj::(defn float?][float?]], [[clojure:core.clj::(defn zero?][zero?]], (1.9) [[clojure:core.clj::(defn double?][double?]], [[clojure:core.clj::(defn int?][int?]], [[clojure:core.clj::(defn nat-int?][nat-int?]],         |
|                   | [[clojure:core.clj::(defn neg-int?][neg-int?]], [[clojure:core.clj::(defn pos-int?][pos-int?]]                                    |
|-------------------+-------------------------------------------------------|
| Symbols, keywords | [[clojure:core.clj::(defn keyword?][keyword?]], [[clojure:core.clj::(defn symbol?][symbol?]], (1.9) [[clojure:core.clj::(defn ident?][ident?]], [[clojure:core.clj::(defn qualified-ident?][qualified-ident?]],    |
|                   | [[clojure:core.clj::(defn qualified-keyword?][qualified-keyword?]], [[clojure:core.clj::(defn qualified-symbol?][qualified-symbol?]], [[clojure:core.clj::(defn simple-ident?][simple-ident?]], |
|                   | [[clojure:core.clj::(defn simple-keyword?][simple-keyword?]], [[clojure:core.clj::(defn simple-symbol?][simple-symbol?]]                       |
|-------------------+-------------------------------------------------------|
| Other scalars     | [[clojure:core.clj::string? (fn ^:static string?][string?]], [[clojure:core.clj::(defn true?][true?]], [[clojure:core.clj::(defn false?][false?]], [[clojure:core.clj::(defn nil?][nil?]], [[clojure:core.clj::(defn some?][some?]], (1.9) [[clojure:core.clj::(defn boolean?][boolean?]],  |
|                   | [[clojure:core.clj::(defn bytes?][bytes?]], [[clojure:core.clj::(defn inst?][inst?]], [[clojure:core.clj::(defn uri?][uri?]], [[clojure:core.clj::(defn uuid?][uuid?]]                            |
|-------------------+-------------------------------------------------------|
| Collections       | [[clojure:core.clj::(defn list?][list?]], [[clojure:core.clj::map? (fn ^:static map?][map?]], [[clojure:core.clj::(defn set?][set?]], [[clojure:core.clj::vector? (fn ^:static vector?][vector?]], [[clojure:core.clj::(defn associative?][associative?]], [[clojure:core.clj::(defn coll?][coll?]],      |
|                   | [[clojure:core.clj::(defn sequential?][sequential?]], [[clojure:core.clj::seq? (fn ^:static seq?][seq?]], [[clojure:core.clj::(defn empty?][empty?]], (1.9) [[clojure:core.clj::(defn indexed?][indexed?]], [[clojure:core.clj::(defn seqable?][seqable?]]   |
|-------------------+-------------------------------------------------------|
| Other             | (1.9) [[clojure:core.clj::(defn any?][any?]]                                            |

*** IO
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#io
:END:

| to/from ...  | [[clojure:core.clj::(defn spit][spit]], [[clojure:core.clj::(defn slurp][slurp]] (to writer/from reader, Socket, |
|              | string with file name, URI, etc.)           |
|--------------+---------------------------------------------|
| to ~*out*~     | [[clojure:core.clj::7965][pr]], [[clojure:core.clj::(defn prn][prn]], [[clojure:core.clj::(defn print][print]], [[clojure:core.clj::(defn printf][printf]], [[clojure:core.clj::(defn println][println]], [[clojure:core.clj::(defn newline][newline]],   |
|              | [[clojure:pprint/print_table.clj::(defn print-table][clojure.pprint/print-table]]                  |
|--------------+---------------------------------------------|
| to writer    | (~clojure.pprint/~) [[clojure:pprint/pprint_base.clj::(defn pprint][pprint]], [[clojure:pprint/cl_format.clj::(defn cl-format][cl-format]]         |
|              | also: ~(binding [*out* writer] ...)~          |
|--------------+---------------------------------------------|
| to string    | [[clojure:core.clj::(defn format][format]], [[clojure:core.clj::(defmacro with-out-str][with-out-str]], [[clojure:core.clj::(defn pr-str][pr-str]], [[clojure:core.clj::(defn prn-str][prn-str]],      |
|              | [[clojure:core.clj::(defn print-str][print-str]], [[clojure:core.clj::(defn println-str][println-str]]                      |
|--------------+---------------------------------------------|
| from ~*in*~    | [[clojure:core.clj::(defn read-line][read-line]], [[clojure:edn.clj::(defn read][clojure.edn/read]],                |
|              | [[tools.reader:clojure/tools/reader/edn.clj::(defn read][clojure.tools.reader.edn/read]]               |
|--------------+---------------------------------------------|
| from reader  | [[clojure:core.clj::(defn line-seq][line-seq]], [[clojure:edn.clj::(defn read][clojure.edn/read]],                 |
|              | [[tools.reader:clojure/tools/reader/edn.clj::(defn read][clojure.tools.reader.edn/read]]               |
|              | also: ~(binding [*in* reader] ...)~,          |
|              | [[https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html][java.io.Reader]]                              |
|--------------+---------------------------------------------|
| from string  | [[clojure:core.clj::(defmacro with-in-str][with-in-str]], [[clojure:edn.clj::(defn read-string][clojure.edn/read-string]],       |
|              | [[tools.reader:clojure/tools/reader/edn.clj::(defn read-string][clojure.tools.reader.edn/read-string]]        |
|--------------+---------------------------------------------|
| Open         | [[clojure:core.clj::(defmacro with-open][with-open]], (~clojure.java.io/~)               |
|              | text: [[clojure:java/io.clj::(defn ^Reader reader][reader]], [[clojure:java/io.clj::(defn ^Writer writer][writer]]                        |
|              | binary: [[clojure:java/io.clj::(defn ^InputStream input-stream][input-stream]], [[clojure:java/io.clj::(defn ^OutputStream output-stream][output-stream]]         |
|--------------+---------------------------------------------|
| Binary       | ~(.write ostream byte-arr)~,                  |
|              | ~(.read istream byte-arr)~                    |
|              | [[https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html][java.io.OutputStream]], [[https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html][java.io.InputStream]],  |
|              | GitHub: [[https://github.com/ztellman/gloss][gloss]], [[https://github.com/rosejn/byte-spec][byte-spec]]                    |
|--------------+---------------------------------------------|
| Misc         | [[clojure:core.clj::(defn flush][flush]], ~(.close s)~, [[clojure:core.clj::(defn file-seq][file-seq]], [[clojure:core.clj::(add-doc-and-meta *in*][*in*]], [[clojure:core.clj::(add-doc-and-meta *out*][*out*]],   |
|              | [[clojure:core.clj::(add-doc-and-meta *err*][*err*]], (~clojure.java.io/~) [[clojure:java/io.clj::(defn ^File file][file]], [[clojure:java/io.clj::(defn copy][copy]],       |
|              | [[clojure:java/io.clj::(defn delete-file][delete-file]], [[clojure:java/io.clj::(defn ^URL resource][resource]], [[clojure:java/io.clj::(defprotocol ^{:added "1.2"} Coercions][as-file]], [[clojure:java/io.clj::(defprotocol ^{:added "1.2"} Coercions][as-url]],     |
|              | [[clojure:java/io.clj::(defn ^String as-relative-path][as-relative-path]], GitHub: [[https://github.com/funcool/fs][fs]]                |
|--------------+---------------------------------------------|
| Data readers | [[clojure:core.clj::(def ^{:added "1.4" :dynamic true} *data-readers*][*data-readers*]], [[clojure:core.clj::(def ^{:added "1.4"} default-data-readers][default-data-readers]],       |
|              | [[clojure:core.clj::(def ^{:added "1.5" :dynamic true} *default-data-reader-fn*][*default-data-reader-fn*]]                    |
|--------------+---------------------------------------------|
| tap          | (1.10) [[clojure:core.clj::(defn tap>][tap>]], [[clojure:core.clj::(defn add-tap][add-tap]], [[clojure:core.clj::(defn remove-tap][remove-tap]]            |

*** Functions

| Create | [[clojure:core.clj::fn (fn* fn][fn]], ~defn~, [[clojure:core.clj::(defmacro defn-][defn-]], [[clojure:core.clj::(defmacro definline][definline]], [[clojure:core.clj::(defn identity][identity]], [[clojure:core.clj::(defn constantly][constantly]],      |
|        | [[clojure:core.clj::(defmacro memfn][memfn]], [[clojure:core.clj::2561][comp]], [[clojure:core.clj::(defn complement][complement]], [[clojure:core.clj::(defn partial][partial]], [[clojure:core.clj::(defn juxt][juxt]], [[clojure:core.clj::(defn memoize][memoize]], [[clojure:core.clj::(defn fnil][fnil]], |
|        | [[clojure:core.clj::(defn every-pred][every-pred]], [[clojure:core.clj::(defn some-fn][some-fn]]                                    |
|--------+--------------------------------------------------------|
| Call   | [[clojure:core.clj::(defn apply][apply]], [[clojure:core.clj::(defmacro ->][->]], [[clojure:core.clj::(defmacro ->>][->>]], [[clojure:core.clj::(defn trampoline][trampoline]], [[clojure:core.clj::(defmacro as->][as->]], [[clojure:core.clj::(defmacro cond->][cond->]], [[clojure:core.clj::(defmacro cond->>][cond->>]],     |
|        | [[clojure:core.clj::(defmacro some->][some->]], [[clojure:core.clj::(defmacro some->>][some->>]]                                        |
|--------+--------------------------------------------------------|
| Test   | [[clojure:core.clj::(defn fn?][fn?]], [[clojure:core.clj::(defn ifn?][ifn?]]                                              |

*** Abstractions ([[https://github.com/cemerick/clojure-type-selection-flowchart][Clojure type selection flowchart]])
**** Protocols ([[#content/reference/protocols][reference/protocols]])

| Define      | [[clojure:core_deftype.clj::(defmacro defprotocol][defprotocol]], ~(defprotocol Slicey (slice [at]))~            |
|-------------+-----------------------------------------------------------|
| Extend      | [[clojure:core_deftype.clj::(defmacro extend-type][extend-type]], ~(extend-type String Slicey (slice [at] ...))~ |
|-------------+-----------------------------------------------------------|
| Extend null | [[clojure:core_deftype.clj::(defmacro extend-type][extend-type]], ~(extend-type nil Slicey (slice [_] nil))~     |
|-------------+-----------------------------------------------------------|
| Reify       | [[clojure:core_deftype.clj::(defmacro reify][reify]], ~(reify Slicey (slice [at] ...))~                    |
|-------------+-----------------------------------------------------------|
| Test        | [[clojure:core_deftype.clj::(defn satisfies?][satisfies?]], [[clojure:core_deftype.clj::(defn extends?][extends?]]                                      |
|-------------+-----------------------------------------------------------|
| Other       | [[clojure:core_deftype.clj::768][extend]], [[clojure:core_deftype.clj::(defmacro extend-protocol][extend-protocol]], [[clojure:core_deftype.clj::(defn extenders][extenders]]                        |

**** Records ([[#content/reference/datatypes][reference/datatypes]])

| Define | [[clojure:core_deftype.clj::(defmacro defrecord][defrecord]], ~(defrecord Pair [h t])~ |
|--------+-----------------------------------|
| Access | ~(:h (Pair. 1 2))~ → ~1~              |
|--------+-----------------------------------|
| Create | ~Pair.~, ~->Pair~, ~map->Pair~          |
|--------+-----------------------------------|
| Test   | [[clojure:core_deftype.clj::(defn record?][record?]]                           |

**** Types ([[#content/reference/datatypes][reference/datatypes]])

| Define       | [[clojure:core_deftype.clj::(defmacro deftype][deftype]], ~(deftype Pair [h t])~                                       |
|--------------+---------------------------------------------------------------------|
| Access       | ~(.h (Pair. 1 2))~ → ~1~                                                |
|--------------+---------------------------------------------------------------------|
| Create       | ~Pair.~, ~->Pair~                                                       |
|--------------+---------------------------------------------------------------------|
| With methods | [[clojure:core_deftype.clj::(defmacro deftype][deftype]],                                                            |
|              | ~(deftype Pair [h t] Object (toString [this] (str "<" h "," t ">")))~ |

**** Multimethods ([[#content/reference/multimethods][reference/multimethods]])

| Define        | [[clojure:core.clj::(defmacro defmulti][defmulti]], ~(defmulti my-mm dispatch-fn)~                   |
|---------------+----------------------------------------------------------|
| Method define | [[clojure:core.clj::(defmacro defmethod][defmethod]], ~(defmethod my-mm :dispatch-value [args] ...)~  |
|---------------+----------------------------------------------------------|
| Dispatch      | [[clojure:core.clj::(defn get-method][get-method]], [[clojure:core.clj::(defn methods][methods]]                                      |
|---------------+----------------------------------------------------------|
| Remove        | [[clojure:core.clj::(defn remove-method][remove-method]], [[clojure:core.clj::(defn remove-all-methods][remove-all-methods]]                        |
|---------------+----------------------------------------------------------|
| Prefer        | [[clojure:core.clj::(defn prefer-method][prefer-method]], [[clojure:core.clj::(defn prefers][prefers]]                                   |
|---------------+----------------------------------------------------------|
| Relation      | [[clojure:core.clj::(defn derive][derive]], [[clojure:core.clj::(defn underive][underive]], [[clojure:core.clj::(defn isa?][isa?]], [[clojure:core.clj::(defn parents][parents]], [[clojure:core.clj::(defn ancestors][ancestors]], [[clojure:core.clj::(defn descendants][descendants]], |
|               | [[clojure:core.clj::(defn make-hierarchy][make-hierarchy]]                                           |

*** Datafy ([[https://corfield.org/blog/2018/12/03/datafy-nav][article]])

| Datafy | (~clojure.datafy/~) [[clojure:datafy.clj::(defn datafy][datafy]], [[clojure:datafy.clj::(defn nav][nav]] |

*** Macros

| Create  | [[clojure:core.clj::defmacro (fn][defmacro]], [[clojure:core.clj::(defmacro definline][definline]]                                       |
|---------+-----------------------------------------------------------|
| Debug   | [[clojure:core.clj::(defn macroexpand-1][macroexpand-1]], [[clojure:core.clj::4014][macroexpand]], [[clojure:walk.clj::(defn macroexpand-all][clojure.walk/macroexpand-all]]  |
|---------+-----------------------------------------------------------|
| Branch  | [[clojure:core.clj::(defmacro and][and]], [[clojure:core.clj::(defmacro or][or]], [[clojure:core.clj::(defmacro when][when]], [[clojure:core.clj::(defmacro when-not][when-not]], [[clojure:core.clj::(defmacro when-let][when-let]], [[clojure:core.clj::(defmacro when-first][when-first]], [[clojure:core.clj::(defmacro if-not][if-not]],    |
|         | [[clojure:core.clj::(defmacro if-let][if-let]], [[clojure:core.clj::(defmacro cond][cond]], [[clojure:core.clj::(defmacro condp][condp]], [[clojure:core.clj::(defmacro case][case]], [[clojure:core.clj::(defmacro when-some][when-some]], [[clojure:core.clj::(defmacro if-some][if-some]]             |
|---------+-----------------------------------------------------------|
| Loop    | [[clojure:core.clj::(defmacro for][for]], [[clojure:core.clj::(defmacro doseq][doseq]], [[clojure:core.clj::(defmacro dotimes][dotimes]], [[clojure:core.clj::(defmacro while][while]]                                |
|---------+-----------------------------------------------------------|
| Arrange | [[clojure:core.clj::(defmacro ..][..]], [[clojure:core.clj::(defmacro doto][doto]], [[clojure:core.clj::(defmacro ->][->]], [[clojure:core.clj::(defmacro ->>][->>]], [[clojure:core.clj::(defmacro as->][as->]], [[clojure:core.clj::(defmacro cond->][cond->]], [[clojure:core.clj::(defmacro cond->>][cond->>]], [[clojure:core.clj::(defmacro some->][some->]], [[clojure:core.clj::(defmacro some->>][some->>]] |
|---------+-----------------------------------------------------------|
| Scope   | [[clojure:core.clj::(defmacro binding][binding]], [[clojure:core.clj::(defmacro locking][locking]], [[clojure:core.clj::(defmacro time][time]], [[clojure:core.clj::(defmacro with-in-str][with-in-str]], [[clojure:core.clj::(defmacro with-local-vars][with-local-vars]],     |
|         | [[clojure:core.clj::(defmacro with-open][with-open]], [[clojure:core.clj::(defmacro with-out-str][with-out-str]], [[clojure:core.clj::(defmacro with-precision][with-precision]], [[clojure:core.clj::(defmacro with-redefs][with-redefs]],     |
|         | [[clojure:core.clj::(defn with-redefs-fn][with-redefs-fn]]                                            |
|---------+-----------------------------------------------------------|
| Lazy    | [[clojure:core.clj::(defmacro lazy-cat][lazy-cat]], [[clojure:core.clj::(defmacro lazy-seq][lazy-seq]], [[clojure:core.clj::(defmacro delay][delay]]                                 |
|---------+-----------------------------------------------------------|
| Doc.    | [[clojure:core.clj::(defmacro assert][assert]], [[clojure:core.clj::(defmacro comment][comment]], [[clojure:repl.clj::(defmacro doc][clojure.repl/doc]]                         |

*** Special Characters ([[#content/reference/reader#macro-characters][reference/reader]], [[content/guides/weird_characters][guide]])

| ~,~             | Comma reads as white space.  Often used between        |
|               | map key/value pairs for readability.                   |
|---------------+--------------------------------------------------------|
| ~'~             | [[#content/reference/reader#quote][quote]]: ~'form~ → ~(quote form)~                            |
|---------------+--------------------------------------------------------|
| ~/~             | Namespace separator (see [[#content/api/cheatsheet#primitives-other][Primitives/Other section]])     |
|---------------+--------------------------------------------------------|
| ~\\~            | Character literal (see [[#content/api/cheatsheet#primitives-other][Primitives/Other section]])       |
|---------------+--------------------------------------------------------|
| ~:~             | Keyword (see [[#content/api/cheatsheet#primitives-other][Primitives/Other section]])                 |
|---------------+--------------------------------------------------------|
| ~;~             | Single line comment                                    |
|---------------+--------------------------------------------------------|
| ~^~             | Metadata (see [[#content/api/cheatsheet#metadata][Metadata section]])                        |
|---------------+--------------------------------------------------------|
| ~*foo*~         | 'earmuffs' - convention to indicate [[#content/reference/vars][dynamic vars]],      |
|               | compiler warns if not dynamic                          |
|---------------+--------------------------------------------------------|
| ~@~             | Deref: ~@form~ → ~(deref form)~                            |
|---------------+--------------------------------------------------------|
| ~`~             | [[#content/reference/reader#syntax-quote][Syntax-quote]]                                           |
|---------------+--------------------------------------------------------|
| ~foo#~          | [[#content/reference/reader#syntax-quote]['auto-gensym']], consistently replaced with same         |
|               | auto-generated symbol everywhere inside same ~`( ... )~  |
|---------------+--------------------------------------------------------|
| ~~~             | [[#content/reference/reader#syntax-quote][Unquote]]                                                |
|---------------+--------------------------------------------------------|
| ~~@~            | [[#content/reference/reader#syntax-quote][Unquote-splicing]]                                       |
|---------------+--------------------------------------------------------|
| ~->~            | 'thread first' macro [[clojure:core.clj::(defmacro ->][->]]                                |
|---------------+--------------------------------------------------------|
| ~->>~           | 'thread last' macro [[clojure:core.clj::(defmacro ->>][-->]]                                |
|---------------+--------------------------------------------------------|
| ~>!! <!! >! <!~ | [[#content/guides/weird_characters#core.async-channel-macros][core.async channel macros]]: [[core.async:clojure/core/async.clj::(defblockingop >!!][>!!]] [[core.async:clojure/core/async.clj::(defblockingop <!!][<!!]] [[core.async:clojure/core/async.clj::(defn >!][>!]] [[core.async:clojure/core/async.clj::(defn <!][<!]]               |
|---------------+--------------------------------------------------------|
| ~(~             | List literal (see [[#content/api/cheatsheet#lists][Collections/Lists section]])           |
|---------------+--------------------------------------------------------|
| ~[~             | Vector literal (see [[#content/api/cheatsheet#vectors][Collections/Vectors section]])       |
|---------------+--------------------------------------------------------|
| ~{~             | Map literal (see [[#content/api/cheatsheet#maps][Collections/Maps section]])             |
|---------------+--------------------------------------------------------|
| ~#'~            | Var-quote: ~#'x~ → ~(var x)~                               |
|---------------+--------------------------------------------------------|
| ~#"~            | ~#"p"~ reads as regex pattern ~p~                          |
|               | (see [[#content/api/cheatsheet#strings][Strings/Regex section]])                            |
|---------------+--------------------------------------------------------|
| ~#{~            | Set literal (see [[#content/api/cheatsheet#sets][Collections/Sets section]])             |
|---------------+--------------------------------------------------------|
| ~#(~            | [[#content/reference/reader#dispatch][Anonymous function literal]]: ~#(...)~ → ~(fn [args] (...))~ |
|---------------+--------------------------------------------------------|
| ~%~             | [[#content/reference/reader#dispatch][Anonymous function argument]]: ~%N~ is value of            |
|               | anonymous function arg ~N~. ~%~ short for ~%1~.              |
|               | ~%&~ for rest args.                                      |
|---------------+--------------------------------------------------------|
| ~#?~            | [[#content/reference/reader#reader-conditionals][Reader conditional]]: ~#?(:clj x :cljs y)~ reads           |
|               | as ~x~ on JVM, ~y~ in ClojureScript, nothing elsewhere.    |
|               | Other keys: ~:cljr :default~                             |
|---------------+--------------------------------------------------------|
| ~#?@~           | [[#content/reference/reader#reader-conditionals][Splicing reader conditional]]:                           |
|               | ~[1 #?@(:clj [x y] :cljs [w z]) 3]~                      |
|               | reads as ~[1 x y 3]~ on JVM, ~[1 w z 3]~ in ClojureScript, |
|               | ~[1 3]~ elsewhere.                                       |
|---------------+--------------------------------------------------------|
| ~#foo~          | [[#content/reference/reader#tagged-literals][tagged literal]] e.g. ~#inst~ ~#uuid~                      |
|---------------+--------------------------------------------------------|
| ~#:~            | [[#content/reference/reader#map-namespace-syntax][map namespace syntax]] e.g. ~#:foo{:a 1}~ is               |
|               | equal to ~{:foo/a 1}~                                    |
|---------------+--------------------------------------------------------|
| ~##~            | (1.9) symbolic values: ~##Inf ##-Inf ##NaN~              |
|---------------+--------------------------------------------------------|
| ~$~             | ~JavaContainerClass$InnerClass~                          |
|---------------+--------------------------------------------------------|
| ~foo?~          | conventional ending for a predicate, e.g.:             |
|               | [[clojure:core.clj::(defn zero?][zero?]] [[clojure:core.clj::vector? (fn ^:static vector?][vector?]] [[clojure:test.clj::(defmethod assert-expr 'instance?][instance?]] (unenforced)                   |
|---------------+--------------------------------------------------------|
| ~foo!~          | conventional ending for an unsafe operation, e.g.:     |
|               | ~set!~ [[clojure:core.clj::(defn swap!][swap!]] [[clojure:core.clj::(defn alter-meta!][alter-meta!]] (unenforced)                    |
|---------------+--------------------------------------------------------|
| ~_~             | conventional name for an unused value (unenforced)     |
|---------------+--------------------------------------------------------|
| ~#_~            | Ignore next form                                       |

*** Metadata ([[#content/reference/reader#metadata][reference/reader]], [[#content/reference/special_forms][reference/special_forms]])
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#metadata
:END:

| General  | ~^{:key1 val1 :key2 val2 ...}~                     |
|----------+--------------------------------------------------|
| Abbrevs  | ~^Type → ^{:tag Type}~,                            |
|          | ~^:key → ^{:key true}~                             |
|----------+--------------------------------------------------|
| Common   | ~^:dynamic ^:private ^:doc ^:const~                |
|----------+--------------------------------------------------|
| Examples | ~(defn ^:private ^String my-fn ...)~,              |
|          | ~(def ^:dynamic *dyn-var* val)~                    |
|----------+--------------------------------------------------|
| On Vars  | [[clojure:core.clj::meta (fn ^:static meta][meta]] [[clojure:core.clj::with-meta (fn ^:static with-meta][with-meta]] [[clojure:core.clj::(defn vary-meta][vary-meta]] [[clojure:core.clj::(defn alter-meta!][alter-meta!]] [[clojure:core.clj::(defn reset-meta!][reset-meta!]] |
|          | [[clojure:repl.clj::(defmacro doc][clojure.repl/doc]] [[clojure:repl.clj::(defn find-doc][clojure.repl/find-doc]] [[clojure:core.clj::(defn test][test]]      |

*** Special Forms ([[#content/reference/special_forms][reference/special_forms]])

~def~, ~if~, ~do~, ~let~, ~letfn~, ~quote~, ~var~, ~fn~, ~loop~,
~recur~, ~set!~, ~throw~, ~try~, ~monitor-enter~, ~monitor-exit~.

| Binding Forms / Destructuring | ([[#content/reference/special_forms#binding-forms][examples]]) ~let~ [[clojure:core.clj::fn (fn* fn][fn]], [[clojure:core.clj::defn (fn defn][defn]], [[clojure:core.clj::defmacro (fn][defmacro]], |
|                               | [[clojure:core.clj::(defmacro loop][loop]], [[clojure:core.clj::(defmacro for][for]], [[clojure:core.clj::(defmacro doseq][doseq]], [[clojure:core.clj::(defmacro if-let][if-let]],          |
|                               | [[clojure:core.clj::(defmacro when-let][when-let]], [[clojure:core.clj::(defmacro if-some][if-some]], [[clojure:core.clj::(defmacro when-some][when-some]]       |

*** Vars and global environment ([[#content/reference/vars][reference/vars]])

| Def variants   | ~def~, [[clojure:core.clj::defn (fn defn][defn]], [[clojure:core.clj::(defmacro defn-][defn-]], [[clojure:core.clj::(defmacro definline][definline]], [[clojure:core.clj::defmacro (fn][defmacro]], [[clojure:core.clj::(defmacro defmethod][defmethod]],  |
|                | [[clojure:core.clj::(defmacro defmulti][defmulti]], [[clojure:core.clj::(defmacro defonce][defonce]], [[clojure:core_deftype.clj::(defmacro defrecord][defrecord]]                       |
|----------------+----------------------------------------------------|
| Interned vars  | [[clojure:core.clj::(defmacro declare][declare]], [[clojure:core.clj::(defn intern][intern]], [[clojure:core.clj::(defmacro binding][binding]], [[clojure:core.clj::(defn find-var][find-var]], ~var~            |
|----------------+----------------------------------------------------|
| Var objects    | [[clojure:core.clj::(defmacro with-local-vars][with-local-vars]], [[clojure:core.clj::(defn var-get][var-get]], [[clojure:core.clj::(defn var-set][var-set]], [[clojure:core.clj::(defn alter-var-root][alter-var-root]], |
|                | [[clojure:core.clj::(defn var?][var?]], [[clojure:core.clj::(defn bound?][bound?]], [[clojure:core.clj::(defn thread-bound?][thread-bound?]]                        |
|----------------+----------------------------------------------------|
| Var validators | [[clojure:core.clj::(defn set-validator!][set-validator!]], [[clojure:core.clj::(defn get-validator][get-validator]]                      |

*** Namespace

| Current       | ~*ns*~                                                 |
|---------------+------------------------------------------------------|
| Create/Switch | ([[https://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html][tutorial]]) [[clojure:core.clj::(defmacro ns][ns]], [[clojure:core.clj::alter-meta! #'in-ns assoc][in-ns]], [[clojure:core.clj::(defn create-ns][create-ns]]                      |
|---------------+------------------------------------------------------|
| Add           | [[clojure:core.clj::(defn alias][alias]], ~def~, [[clojure:core.clj::(defmacro import][import]], [[clojure:core.clj::(defn intern][intern]], [[clojure:core.clj::(defn refer][refer]]                    |
|---------------+------------------------------------------------------|
| Find          | [[clojure:core.clj::(defn all-ns][all-ns]], [[clojure:core.clj::(defn find-ns][find-ns]]                                      |
|---------------+------------------------------------------------------|
| Examine       | [[clojure:core.clj::(defn ns-name][ns-name]], [[clojure:core.clj::(defn ns-aliases][ns-aliases]], [[clojure:core.clj::(defn ns-map][ns-map]], [[clojure:core.clj::(defn ns-interns][ns-interns]], [[clojure:core.clj::(defn ns-publics][ns-publics]], |
|               | [[clojure:core.clj::(defn ns-refers][ns-refers]], [[clojure:core.clj::(defn ns-imports][ns-imports]]                                |
|---------------+------------------------------------------------------|
| From symbol   | [[clojure:core.clj::(defn resolve][resolve]], [[clojure:core.clj::(defn ns-resolve][ns-resolve]], [[clojure:core.clj::(defn namespace][namespace]], [[clojure:core.clj::(defn the-ns][the-ns]],              |
|               | (1.10) [[clojure:core.clj::(defn requiring-resolve][requiring-resolve]]                             |
|---------------+------------------------------------------------------|
| Remove        | [[clojure:core.clj::(defn ns-unalias][ns-unalias]], [[clojure:core.clj::(defn ns-unmap][ns-unmap]], [[clojure:core.clj::(defn remove-ns][remove-ns]]                      |

*** Loading

| Load libs   | ([[https://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html][tutorial]]) [[clojure:core.clj::(defn require][require]], [[clojure:core.clj::(defn use][use]], [[clojure:core.clj::(defmacro import][import]], [[clojure:core.clj::(defn refer][refer]]    |
|-------------+-------------------------------------------|
| List loaded | [[clojure:core.clj::(defn loaded-libs][loaded-libs]]                               |
|-------------+-------------------------------------------|
| Load misc   | [[clojure:core.clj::6132][load]], [[clojure:core.clj::alter-meta! #'load-file assoc][load-file]], [[clojure:core.clj::(defn load-reader][load-reader]], [[clojure:core.clj::(defn load-string][load-string]] |

*** Concurrency
:PROPERTIES:
:CUSTOM_ID: content/api/cheatsheet#concurrency
:END:
**** Concurrency

| Atoms     | [[clojure:core.clj::(defn atom][atom]], [[clojure:core.clj::(defn swap!][swap!]], [[clojure:core.clj::(defn reset!][reset!]], [[clojure:core.clj::(defn compare-and-set!][compare-and-set!]],                   |
|           | (1.9) [[clojure:core.clj::(defn swap-vals!][swap-vals!]], [[clojure:core.clj::(defn reset-vals!][reset-vals!]]                            |
|-----------+----------------------------------------------------------|
| Futures   | [[clojure:core.clj::(defmacro future][future]], [[clojure:core.clj::(defn future-call][future-call]], [[clojure:core.clj::(defn future-done?][future-done?]], [[clojure:core.clj::(defn future-cancel][future-cancel]],        |
|           | [[clojure:core.clj::(defn future-cancelled?][future-cancelled?]], [[clojure:core.clj::(defn future?][future?]]                               |
|-----------+----------------------------------------------------------|
| Threads   | [[clojure:core.clj::(defmacro bound-fn][bound-fn]], [[clojure:core.clj::(defn bound-fn*][bound-fn*]], [[clojure:core.clj::(defn get-thread-bindings][get-thread-bindings]],                |
|           | [[clojure:core.clj::(defn push-thread-bindings][push-thread-bindings]], [[clojure:core.clj::(defn pop-thread-bindings][pop-thread-bindings]], [[clojure:core.clj::(defn thread-bound?][thread-bound?]] |
|-----------+----------------------------------------------------------|
| Volatiles | [[clojure:core.clj::(defn volatile!][volatile!]], [[clojure:core.clj::(defn vreset!][vreset!]], [[clojure:core.clj::(defmacro vswap!][vswap!]], [[clojure:core.clj::(defn volatile?][volatile?]]                    |
|-----------+----------------------------------------------------------|
| Misc      | [[clojure:core.clj::(defmacro locking][locking]], [[clojure:core.clj::(defn pcalls][pcalls]], [[clojure:core.clj::(defmacro pvalues][pvalues]], [[clojure:core.clj::(defn pmap][pmap]], [[clojure:core.clj::5409][seque]], [[clojure:core.clj::(defn promise][promise]], [[clojure:core.clj::(defn deliver][deliver]]  |

**** Refs and Transactions ([[#content/reference/refs][reference/refs]])

| Create         | [[clojure:core.clj::(defn ref][ref]]                                                 |
|----------------+-----------------------------------------------------|
| Examine        | [[clojure:core.clj::(defn deref][deref]], ~@~, (~@form~ → ~(deref form)~)                    |
|----------------+-----------------------------------------------------|
| Transaction    | [[clojure:core.clj::(defmacro sync][sync]], [[clojure:core.clj::(defmacro dosync][dosync]], [[clojure:core.clj::(defmacro io!][io!]]                                   |
|----------------+-----------------------------------------------------|
| In transaction | [[clojure:core.clj::(defn ensure][ensure]], [[clojure:core.clj::(defn ref-set][ref-set]], [[clojure:core.clj::2447][alter]], [[clojure:core.clj::(defn commute][commute]]                     |
|----------------+-----------------------------------------------------|
| Validators     | [[clojure:core.clj::(defn set-validator!][set-validator!]], [[clojure:core.clj::(defn get-validator][get-validator]]                       |
|----------------+-----------------------------------------------------|
| History        | [[clojure:core.clj::(defn ref-history-count][ref-history-count]], [[clojure:core.clj::(defn ref-min-history][ref-min-history]], [[clojure:core.clj::(defn ref-max-history][ref-max-history]] |

**** Agents and Asynchronous Actions ([[#content/reference/agents][reference/agents]])

| Create          | [[clojure:core.clj::(defn agent][agent]]                                          |
|-----------------+------------------------------------------------|
| Examine         | [[clojure:core.clj::(defn agent-error][agent-error]]                                    |
|-----------------+------------------------------------------------|
| Change state    | [[clojure:core.clj::2115][send]], [[clojure:core.clj::(defn send-off][send-off]], [[clojure:core.clj::(defn restart-agent][restart-agent]], [[clojure:core.clj::(defn send-via][send-via]],       |
|                 | [[clojure:core.clj::(defn set-agent-send-executor!][set-agent-send-executor!]],                      |
|                 | [[clojure:core.clj::(defn set-agent-send-off-executor!][set-agent-send-off-executor!]]                   |
|-----------------+------------------------------------------------|
| Block waiting   | [[clojure:core.clj::(defn await][await]], [[clojure:core.clj::(defn await-for][await-for]]                               |
|-----------------+------------------------------------------------|
| Ref validators  | [[clojure:core.clj::(defn set-validator!][set-validator!]], [[clojure:core.clj::(defn get-validator][get-validator]]                  |
|-----------------+------------------------------------------------|
| Watchers        | [[clojure:core.clj::(defn add-watch][add-watch]], [[clojure:core.clj::(defn remove-watch][remove-watch]]                        |
| Thread handling | [[clojure:core.clj::(defn shutdown-agents][shutdown-agents]]                                |
|-----------------+------------------------------------------------|
| Error           | [[clojure:core.clj::(defn error-handler][error-handler]], [[clojure:core.clj::(defn set-error-handler!][set-error-handler!]], [[clojure:core.clj::(defn error-mode][error-mode]], |
|                 | [[clojure:core.clj::(defn set-error-mode!][set-error-mode!]]                                |
|-----------------+------------------------------------------------|
| Misc            | [[clojure:core.clj::alter-meta! #'*agent* assoc][*agent*]], [[clojure:core.clj::(defn release-pending-sends][release-pending-sends]]                 |

*** Java Interoperation ([[#content/reference/java_interop][reference/java_interop]])
**** General, Cast, Exceptions

| General    | [[clojure:core.clj::(defmacro ..][..]], [[clojure:core.clj::(defmacro doto][doto]], ~Classname/~, ~Classname.~, ~new~, [[clojure:core_proxy.clj::(defn bean][bean]],               |
|            | [[clojure:core.clj::(defn comparator][comparator]], [[clojure:core.clj::(defn enumeration-seq][enumeration-seq]], [[clojure:core.clj::(defmacro import][import]], [[clojure:core.clj::(defn iterator-seq][iterator-seq]],         |
|            | [[clojure:core.clj::(defmacro memfn][memfn]], ~set!~, [[clojure:core.clj::(defn class][class]], [[clojure:core.clj::(defn class?][class?]], [[clojure:core.clj::(defn bases][bases]], [[clojure:core.clj::(defn supers][supers]], [[clojure:core.clj::(defn type][type]],           |
|            | [[clojure:genclass.clj::(defmacro gen-class][gen-class]], [[clojure:genclass.clj::(defmacro gen-interface][gen-interface]], [[clojure:core_deftype.clj::(defmacro definterface][definterface]]                     |
|------------+------------------------------------------------------------|
| Cast       | [[clojure:core.clj::1607][boolean]], [[clojure:core.clj::3492][byte]], [[clojure:core.clj::(defn short][short]], [[clojure:core.clj::(defn char][char]], [[clojure:core.clj::(defn int][int]], [[clojure:core.clj::(defn long][long]], [[clojure:core.clj::(defn float][float]], [[clojure:core.clj::(defn double][double]],      |
|            | [[clojure:core.clj::(defn bigdec][bigdec]], [[clojure:core.clj::(defn bigint][bigint]], [[clojure:core.clj::(defn num][num]], [[clojure:core.clj::(defn cast][cast]], [[clojure:core.clj::(defn biginteger][biginteger]]                      |
|------------+------------------------------------------------------------|
| Exceptions | ~throw~, ~try~, ~catch~, ~finally~, [[clojure:repl.clj::(defn pst][clojure.repl/pst]],              |
|            | [[clojure:core.clj::(defn ex-info][ex-info]], [[clojure:core.clj::(defn ex-data][ex-data]], [[clojure:core_print.clj::(defn Throwable->map][Throwable->map]],                          |
|            | (1.9) [[clojure:core_print.clj::(defn StackTraceElement->vec][StackTraceElement->vec]], (1.10) [[clojure:core.clj::(defn ex-cause][ex-cause]], [[clojure:core.clj::(defn ex-message][ex-message]], |
|            | (~clojure.main/~) [[clojure:main.clj::(defn ex-triage][ex-triage]], [[clojure:main.clj::(defn ex-str][ex-str]], [[clojure:main.clj::(defn err->msg][err->msg]], [[clojure:main.clj::(defn report-error][report-error]]  |

**** Arrays

| Create | [[clojure:core.clj::(defn make-array][make-array]], [[clojure:core.clj::(defn object-array][object-array]], [[clojure:core.clj::(defn boolean-array][boolean-array]], [[clojure:core.clj::(defn byte-array][byte-array]],         |
|        | [[clojure:core.clj::(defn short-array][short-array]], [[clojure:core.clj::(defn char-array][char-array]], [[clojure:core.clj::(defn int-array][int-array]], [[clojure:core.clj::(defn long-array][long-array]], [[clojure:core.clj::(defn float-array][float-array]], |
|        | [[clojure:core.clj::(defn double-array][double-array]], [[clojure:core.clj::(defn aclone][aclone]], [[clojure:core.clj::(defn to-array][to-array]], [[clojure:core.clj::(defn to-array-2d][to-array-2d]], [[clojure:core.clj::(defn into-array][into-array]]      |
|--------+--------------------------------------------------------------|
| Use    | [[clojure:core.clj::(defn aget][aget]], [[clojure:core.clj::(defn aset][aset]], [[clojure:core.clj::aset-boolean setBoolean][aset-boolean]], [[clojure:core.clj::aset-byte setByte][aset-byte]], [[clojure:core.clj::aset-short setShort][aset-short]],             |
|        | [[clojure:core.clj::aset-char setChar][aset-char]], [[clojure:core.clj::aset-int setInt][aset-int]], [[clojure:core.clj::aset-long setLong][aset-long]], [[clojure:core.clj::aset-float setFloat][aset-float]], [[clojure:core.clj::aset-double setDouble][aset-double]],     |
|        | [[clojure:core.clj::(defn alength][alength]], [[clojure:core.clj::(defmacro amap][amap]], [[clojure:core.clj::(defmacro areduce][areduce]]                                       |
|--------+--------------------------------------------------------------|
| Cast   | [[clojure:core.clj::(definline booleans][booleans]], [[clojure:core.clj::(definline bytes][bytes]], [[clojure:core.clj::(definline shorts][shorts]], [[clojure:core.clj::(definline chars][chars]], [[clojure:core.clj::(definline ints][ints]], [[clojure:core.clj::(definline longs][longs]], [[clojure:core.clj::(definline floats][floats]], [[clojure:core.clj::(definline doubles][doubles]] |

**** Proxy ([[https://github.com/cemerick/clojure-type-selection-flowchart][Clojure type selection flowchart]])

| Create | [[clojure:core_proxy.clj::(defmacro proxy][proxy]], [[clojure:core_proxy.clj::(defn get-proxy-class][get-proxy-class]], [[clojure:core_proxy.clj::(defn construct-proxy][construct-proxy]], [[clojure:core_proxy.clj::(defn init-proxy][init-proxy]] |
|--------+-----------------------------------------------------|
| Misc   | [[clojure:core_proxy.clj::(defn proxy-mappings][proxy-mappings]], [[clojure:core_proxy.clj::(defmacro proxy-super][proxy-super]], [[clojure:core_proxy.clj::(defn update-proxy][update-proxy]]           |

*** Zippers (~clojure.zip/~)

| Create   | [[clojure:zip.clj::(defn zipper][zipper]], [[clojure:zip.clj::(defn seq-zip][seq-zip]], [[clojure:zip.clj::(defn vector-zip][vector-zip]], [[clojure:zip.clj::(defn xml-zip][xml-zip]]                 |
|----------+------------------------------------------------------|
| Get loc  | [[clojure:zip.clj::(defn up][up]], [[clojure:zip.clj::(defn down][down]], [[clojure:zip.clj::(defn left][left]], [[clojure:zip.clj::(defn right][right]], [[clojure:zip.clj::(defn leftmost][leftmost]], [[clojure:zip.clj::(defn rightmost][rightmost]]           |
|----------+------------------------------------------------------|
| Get seq  | [[clojure:zip.clj::(defn lefts][lefts]], [[clojure:zip.clj::(defn rights][rights]], [[clojure:zip.clj::(defn path][path]], [[clojure:zip.clj::(defn children][children]]                        |
|----------+------------------------------------------------------|
| 'Change' | [[clojure:zip.clj::(defn make-node][make-node]], [[clojure:zip.clj::(defn replace][replace]], [[clojure:zip.clj::(defn edit][edit]], [[clojure:zip.clj::(defn insert-child][insert-child]], [[clojure:zip.clj::(defn insert-left][insert-left]], |
|          | [[clojure:zip.clj::(defn insert-right][insert-right]], [[clojure:zip.clj::(defn append-child][append-child]], [[clojure:zip.clj::(defn remove][remove]]                   |
|----------+------------------------------------------------------|
| Move     | [[clojure:zip.clj::(defn next][next]], [[clojure:zip.clj::(defn prev][prev]]                                           |
|----------+------------------------------------------------------|
| Misc     | [[clojure:zip.clj::(defn root][root]], [[clojure:zip.clj::(defn node][node]], [[clojure:zip.clj::(defn branch?][branch?]], [[clojure:zip.clj::(defn end?][end?]]                            |

*** Other

| XML             | [[clojure:xml.clj::(defn parse][clojure.xml/parse]], [[clojure:core.clj::(defn xml-seq][xml-seq]]                         |
|-----------------+----------------------------------------------------|
| REPL            | [[clojure:core.clj::6302][*1]], [[clojure:core.clj::6307][*2]], [[clojure:core.clj::6312][*3]], [[clojure:core.clj::6317][*e]], [[clojure:core.clj::(add-doc-and-meta *print-dup*][*print-dup*]], [[clojure:core_print.clj::^{:doc "*print-length*][*print-length*]],       |
|                 | [[clojure:core_print.clj::^{:doc "*print-level*][*print-level*]], [[clojure:core.clj::(add-doc-and-meta *print-meta*][*print-meta*]], [[clojure:core.clj::(add-doc-and-meta *print-readably*][*print-readably*]]      |
|-----------------+----------------------------------------------------|
| Code            | [[clojure:core.clj::(add-doc-and-meta *compile-files*][*compile-files*]], [[clojure:core.clj::(add-doc-and-meta *compile-path*][*compile-path*]], [[clojure:core.clj::(add-doc-and-meta *file*][*file*]],           |
|                 | [[clojure:core.clj::(add-doc-and-meta *warn-on-reflection*][*warn-on-reflection*]], [[clojure:core.clj::(defn compile][compile]], [[clojure:core.clj::(defn loaded-libs][loaded-libs]], [[clojure:core.clj::(defn test][test]]   |
|-----------------+----------------------------------------------------|
| Misc            | [[clojure:core.clj::(defn eval][eval]], [[clojure:core.clj::(defn force][force]], [[clojure:core.clj::5177][hash]], [[clojure:core.clj::(defn name][name]], [[clojure:core.clj::(add-doc-and-meta *clojure-version*][*clojure-version*]],        |
|                 | [[clojure:core.clj::(defn clojure-version][clojure-version]], [[clojure:core.clj::(defn add-doc-and-meta *command-line-args*][*command-line-args*]]               |
|-----------------+----------------------------------------------------|
| Browser / Shell | (~clojure.java.browse/~) [[clojure:java/browse.clj::(defn browse-url][browse-url]],                 |
|                 | (~clojure.java.shell/~) [[clojure:java/shell.clj::(defn sh][sh]], [[clojure:java/shell.clj::(defmacro with-sh-dir][with-sh-dir]], [[clojure:java/shell.clj::(defmacro with-sh-env][with-sh-env]] |

** API Documentation
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/api/api.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/api/api
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-01-15
:CUSTOM_ID: content/api/api
:END:
*** Clojure API

- [[https://clojure.github.io/clojure/][Clojure API]]
- [[https://clojure.github.io/clojure/javadoc/][Clojure Java API]] - for calling from Java into Clojure
- [[#content/api/cheatsheet][Clojure cheatsheet]]

*** ClojureScript API

- [[https://cljs.info/cheatsheet/][ClojureScript Cheatsheet]]

*** Clojure Contrib Libraries

Documentation for Clojure [[#content/dev/contrib_libs][contrib libraries]]:

- [[https://clojure.github.io/][Contrib APIs]]

*** Other resources

- [[https://clojuredocs.org][ClojureDocs]] - community provided example repository
- [[https://cljdoc.org/][cljdoc]] - library documentation

*** Deprecated (pre Clojure 1.3)

- [[https://clojure.github.io/clojure-contrib/][Clojure Contrib API]]

* Community
** Clojure Forum
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/ask.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/ask
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-07-24
:CUSTOM_ID: content/community/ask
:END:

The [[https://ask.clojure.org][Clojure Q&A]] site is maintained by the Clojure team as an official
place to ask questions about Clojure, ClojureScript, ClojureCLR,
Clojure contrib libraries, and any other Clojure topic.

*** Access

Anyone may view the content on the site, but you must have an account to
ask questions or provide answers. Authentication is currently done using
your GitHub account. Other authentication providers may be added in the
future. When you have logged in, please click your user name in the
upper right corner and review your profile. If you wish to receive email
notifications, please add an email address.

*** Categories and tags

Questions have both *categories* and *tags*. Categories (on the right
sidebar) are a fixed set of language or project topics for those
projects. At least a top level category must be selected when asking a
question.

Tags are an open and extensible set of attributes that can be applied to
questions. There are some special tags:

- problem - describe a problem in the language or library
- request - describe a request for enhancement in the language or
  library
- jira - used when a problem or request has a matching jira for
  development - the link will be included in an answer

When problems or requests are logged, developers can assess and, if
needed, create a corresponding jira for development.

*** Voting

Users may vote on both questions and answers. Votes will be used to
inform decisions about future releases of Clojure, ClojureScript,
libraries, etc.

** Books
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/books.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/books
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-02-15
:CUSTOM_ID: content/community/books
:END:

Please support these fine books about Clojure.

/Listed in order of descending release date of newest edition./

| Web Development with Clojure    | [[https://www.amazon.com/dp/168050682X][Web Development with Clojure, 3rd edition]]            |
|                                 | by Dmitri Sotnikov, Scot Brown                       |
|                                 | July 29, 2021                                        |
|---------------------------------+------------------------------------------------------|
| Numerical Linear Algebra for    | [[https://aiprobook.com/numerical-linear-algebra-for-programmers/][Numerical Linear Algebra for Programmers]]             |
| Programmers: An Interactive     | by Dragan Djuric                                     |
| Tutorial with GPU               | Jan 15, 2021                                         |
|---------------------------------+------------------------------------------------------|
| Deep Learning for Programmers   | [[https://aiprobook.com/deep-learning-for-programmers/][Deep Learning for Programmers]]                        |
|                                 | by Dragan Djuric                                     |
|                                 | Dec 21, 2020                                         |
|---------------------------------+------------------------------------------------------|
| The Clojure Workshop            | [[https://www.amazon.com/dp/B082FJ9ZLY][The Clojure Workshop]]                                 |
|                                 | by Joseph Fahey, Thomas Haratyk,                     |
|                                 | Scott McCaughie, Yehonathan Sharvit,                 |
|                                 | Konrad Szydlo                                        |
|                                 | Jan 29, 2020                                         |
|---------------------------------+------------------------------------------------------|
| Hands-On Reactive Programming   | [[https://amzn.com/B07N7525GX][Reactive Programming with Clojure]]                    |
| with Clojure                    | by Konrad Szydlo, Leonardo Borges                    |
|                                 | Jan 25, 2019                                         |
|---------------------------------+------------------------------------------------------|
| Elements of Clojure             | [[https://leanpub.com/elementsofclojure][Elements of Clojure]]                                  |
|                                 | by Zachary Tellman                                   |
|                                 | Nov 30, 2018                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Polymorphism            | [[https://www.packtpub.com/programming/clojure-polymorphism][Clojure Polymorphism]]                                 |
|                                 | by Paul Stadig                                       |
|                                 | Nov 15, 2019                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Extended: Java interop  | [[https://leanpub.com/clojure-java-interop/][Clojure Extended: Java interop]]                       |
|                                 | by Ivan Grishaev                                     |
|                                 | Aug 31, 2018                                         |
|---------------------------------+------------------------------------------------------|
| Getting Clojure                 | [[https://pragprog.com/book/roclojure/getting-clojure][Getting Clojure]]                                      |
|                                 | by Russ Olsen                                        |
|                                 | May 19, 2018                                         |
|---------------------------------+------------------------------------------------------|
| Programming Clojure 3rd edition | [[https://a.co/bSxW6A6][Programming Clojure 3rd edition]]                      |
|                                 | by Alex Miller, Stuart Halloway, Aaron Bedra         |
|                                 | Feb 21, 2018                                         |
|---------------------------------+------------------------------------------------------|
| Microservices with Clojure      | [[https://www.packtpub.com/application-development/microservices-clojure][Microservices with Clojure]]                           |
|                                 | by Anuj Kumar                                        |
|                                 | Jan 25, 2018                                         |
|---------------------------------+------------------------------------------------------|
| ClojureScript Unraveled         | [[https://a.co/cDfN4n4][Quick Clojure: Effective Functional Programming]]      |
|                                 | by Mark McDonnell                                    |
|                                 | Aug 23, 2017                                         |
|---------------------------------+------------------------------------------------------|
| ClojureScript Unraveled         | [[https://leanpub.com/clojurescript-unraveled][ClojureScript Unraveled]]                              |
|                                 | by Andrey Antukh, Alejandro Gómez                    |
|                                 | Jul 25, 2016                                         |
|---------------------------------+------------------------------------------------------|
| Learning ClojureScript          | [[https://a.co/2X3MJn2][Learning ClojureScript]]                               |
|                                 | by W. David Jarvis, Rafik Naccache,                  |
|                                 | Allen Rohner                                         |
|                                 | Jun 30, 2016                                         |
|---------------------------------+------------------------------------------------------|
| Professional Clojure            | [[https://a.co/bSHZ7X3][Professional Clojure]]                                 |
|                                 | by Jeremy Anderson, Michael Gaare,                   |
|                                 | Justin Holguín, Nick Bailey, and                     |
|                                 | Timothy Pratley                                      |
|                                 | Jun 7, 2016                                          |
|---------------------------------+------------------------------------------------------|
| Mastering Clojure               | [[https://a.co/bTLhJ2d][Mastering Clojure]]                                    |
|                                 | by Akhil Wali                                        |
|                                 | Mar 28, 2016                                         |
|---------------------------------+------------------------------------------------------|
| Clojure for Java Developers     | [[https://a.co/029aVrm][Clojure for Java Developers]]                          |
|                                 | by Eduardo Diaz                                      |
|                                 | Feb 23, 2016                                         |
|---------------------------------+------------------------------------------------------|
| Clojure for Finance             | [[https://a.co/fbHnhEM][Clojure for Finance]]                                  |
|                                 | by Timothy Washington                                |
|                                 | Jan 11, 2016                                         |
|---------------------------------+------------------------------------------------------|
| Clojure In Action               | [[https://a.co/a4hDbTn][Clojure In Action]]                                    |
|                                 | by Amit Rathore                                      |
|                                 | Jan 1, 2016                                          |
|---------------------------------+------------------------------------------------------|
| Clojure for the Brave and True  | [[https://a.co/bsviqV7][Clojure for the Brave and True]]                       |
|                                 | by Daniel Higginbotham                               |
|                                 | Oct 23, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Recipes                 | [[https://a.co/clSHVQi][Clojure Recipes]]                                      |
|                                 | by Julian Gamble                                     |
|                                 | Oct 23, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Applied                 | [[https://a.co/1HL2XPF][Clojure Applied: From Practice to Practitioner]]       |
|                                 | by Ben Vandgrift, Alex Miller                        |
|                                 | Sept 6, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Clojure for Data Science        | [[https://a.co/idtKjhS][Clojure for Data Science]]                             |
|                                 | by Henry Garner                                      |
|                                 | Sept 3, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Clojure High Performance        | [[https://a.co/7adcmsl][Clojure High Performance Programming]]                 |
| Programming                     | by Shantanu Kumar                                    |
|                                 | Sept 1, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Data Structures         | [[https://a.co/g7JAFAS][Clojure Data Structures and Algorithms]]               |
| and Algorithms                  | by Rafik Naccache                                    |
|                                 | Aug 19, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Living Clojure                  | [[https://a.co/1m2Zt4p][Living Clojure]]                                       |
|                                 | by Carin Meier                                       |
|                                 | Apr 30, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Reactive Programming    | [[https://a.co/fhyaFka][Clojure Reactive Programming]]                         |
|                                 | by Leonardo Borges                                   |
|                                 | Mar 24, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Web Development         | [[https://a.co/2FlRxd5][Clojure Web Development Essentials]]                   |
| Essentials                      | by Ryan Baldwin                                      |
|                                 | Feb 16, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Data Analysis Cookbook  | [[https://a.co/gIwPEkt][Clojure Data Analysis Cookbook]]                       |
|                                 | by Eric Rochester                                    |
|                                 | Jan 22, 2015                                         |
|---------------------------------+------------------------------------------------------|
| Mastering Clojure Macros        | [[https://a.co/4VjjiQJ][Mastering Clojure Macros]]                             |
|                                 | by Colin Jones                                       |
|                                 | Sept 5, 2014                                         |
|---------------------------------+------------------------------------------------------|
| The Joy of Clojure              | [[https://a.co/evdNcOs][The Joy of Clojure]]                                   |
|                                 | by Michael Fogus, Chris Houser                       |
|                                 | Jun 13, 2014                                         |
|---------------------------------+------------------------------------------------------|
| Mastering Clojure Data Analysis | [[https://a.co/bYwhMwH][Mastering Clojure Data Analysis]]                      |
|                                 | by Eric Rochester                                    |
|                                 | May 26, 2014                                         |
|---------------------------------+------------------------------------------------------|
| Clojure for Machine Learning    | [[https://a.co/7PRmDOK][Clojure for Machine Learning]]                         |
|                                 | by Akhil Wali                                        |
|                                 | Apr 24, 2014                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Cookbook                | [[https://a.co/1K6SZSI][Clojure Cookbook]]                                     |
|                                 | by Luke VanderHart and Ryan Neufeld                  |
|                                 | Mar 24, 2014                                         |
|---------------------------------+------------------------------------------------------|
| Clojure for Domain-specific     | [[https://a.co/3rwXJkx][Clojure for Domain-specific Languages]]                |
| Languages                       | by Ryan Kelker                                       |
|                                 | Dec 18, 2013                                         |
|---------------------------------+------------------------------------------------------|
| Functional Programming          | [[https://a.co/2J3jvLX][Functional Programming Patterns in Scala and Clojure]] |
| Patterns in Scala and Clojure   | by Michael Bevilacqua-Linn                           |
|                                 | Nov 2, 2013                                          |
|---------------------------------+------------------------------------------------------|
| ClojureScript: Up and Running   | [[https://a.co/74IUDUu][ClojureScript: Up and Running]]                        |
|                                 | by Stuart Sierra, Luke VanderHart                    |
|                                 | Nov 10, 2012                                         |
|---------------------------------+------------------------------------------------------|
| Clojure Programming             | [[https://a.co/jiaX8tX][Clojure Programming]]                                  |
|                                 | by Chas Emerick, Brian Carper, Christophe Grand      |
|                                 | Apr 22, 2012                                         |
|---------------------------------+------------------------------------------------------|
| Clojure                         | [[https://www.amazon.de/dp/389864684X][Clojure]]                                              |
|                                 | by Stefan Kamphausen, Tim Oliver Kaiser              |
|                                 | Sep 20, 2010                                         |
|---------------------------------+------------------------------------------------------|
| Practical Clojure               | [[https://a.co/fWbYqs5][Practical Clojure]]                                    |
|                                 | by Luke VanderHart, Stuart Sierra                    |
|                                 | Jun 1, 2010                                          |

** Community Stories
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/community_stories.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/community_stories
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-04-04
:CUSTOM_ID: content/community/community_stories
:END:

If you'd like to share your Clojure story, please [[https://docs.google.com/forms/d/e/1FAIpQLSf0Wx6sOVxPeeob45VqJXqRYKM9K_-Mzir-DYFbnXZ1lR_BGg/viewform][complete this form]].

** Companies
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/companies.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/companies
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-03-15
:CUSTOM_ID: content/community/companies
:END:

Below is a partial list of some companies using Clojure or
ClojureScript. Most of this information comes from direct contacts,
presentations, or other online resources. If you would like to be
added or removed from this list, please contact /clojure@cognitect.com/
or submit a pull request to the [[https://github.com/clojure/clojure-site][site repository]].

Also, check out the [[#content/community/success_stories][Clojure Success Stories]] and [[#content/community/community_stories][Community Stories]]
pages!

- 3e.eu
- 8th Light
- aclaimant
- Active Group GmbH
- Adaptly
- AdGoji
- Adobe
- AdStage
- Advance Auto Parts
- Adzerk
- AGA
- AgentsMutual/OnTheMarket
- Agiliway
- Airloyal
- Ajira
- Akamai
- Akvo Foundation
- Amazon
- Amperity
- Animalia
- Annadale Technologies
- Answers.com
- Anywhere.com
- Apex Data Solutions
- Apple
- AppsFlyer
- AppSmiths
- Appsnsites
- Arc Studio Pro
- Ardoq
- ATA LLC
- Atomist
- Attendify
- Audience Republic
- Australia Post
- Autheos
- BandSquare
- Banzai
- baresquare
- Barracuda
- BaseFEX
- Beanstalk
- Beary Innovative
- BeOpinion
- bevuta
- BGPworks
- BillFront
- BIMwelt Systems
- Bloom
- BookWell
- Boundless Geo
- Brainsfeed
- Braintree Payments (acquired by PayPal)
- Breeze EHR
- BrickAlloy
- Brightin
- BroadbandUK
- BroadPeak
- Buddy
- BUGS Bioscience
- Buy Happy
- buzzlers.com
- CambioScience
- Cambium Consulting
- Capital One
- cardforcoin
- Carousel Apps
- Cars.co.za
- carwow
- CA Technologies
- Cellusys
- Centriq
- CENX
- Cerner
- Cervest Ltd.
- CFPB (Credit Financial Protection Bureau)
- Chariot Solutions
- Chartbeat
- Cicayda
- CircleCI
- Cisco
- Citi
- ClanHR
- ClearCoin
- Climate Corp (acquired by Monsanto)
- Clockworks
- CloudGears
- CloudRepo
- Clubhouse
- Code54
- codecentric
- Co(de)factory
- CodeScene
- Codurance
- Cognician
- Cognitect
- CollBox
- Collective Digital Studio
- Commonwealth Robotics
- Commsor
- Compute Software
- Condense
- Consumer Reports
- CREATE.21st century
- Crossbeam
- Crossref
- CROWD
- Cryptowerk
- Curbside
- Cycloid
- CyCognito
- Daily Mail MailOnline
- Database Labs
- Datacraft
- DataSnap.io
- Datomic
- DBS Bank
- Debreuck Neirynck (DN)
- Deep Impact
- Degree9
- Democracy Works
- Deps
- Designedly
- Deutsche Bank
- Devatics
- Dewise
- Diagnosia
- Discendum ltd
- Dividend Finance
- DocSolver
- Doctor Evidence
- Doctronic
- DOV-E
- dploy.io
- Dream to Learn
- DRW Trading Group
- Dyne.org
- eBay
- Ekata
- Element 84
- Empear
- English Language iTutoring
- Enterlab
- Entrepreneur First
- Event Fabric
- Eventum
- Evolta
- Exoscale
- Eyeota
- Facebook
- Facjure
- Factual
- FarBetter
- Fierce.
- Finalist
- Finity AI
- Flexiana
- Flocktory
- Flowa
- Flybot
- FORMCEPT
- Framed Data
- Freshcode
- FullContact
- Functional Works
- Funding Circle
- Futurice
- Fy!
- GetContented
- GetSet
- Gmaven
- GoCatch
- Gofore
- Goizper Group
- GO-JEK
- GoldFynch
- Goodhertz
- GoOpti
- Gracenote
- Grammarly
- GreenPowerMonitor
- Groupon
- Guaranteed Rate
- handcheque
- HappyMoney
- Hashrocket
- healthfinch
- HealthSamurai
- Helpshift
- Hendrick Automotive Group
- Hero Marketing
- Heroku
- Hexawise
- #Homescreen
- Huobi Global
- IB5k
- ICM Consulting
- IG
- Imatic
- Immute
- Indaba Music
- InnoQ
- Inspire Fitness
- instadeq
- Intent Media
- InterWare
- Intropica
- Intuit
- iPlant Collaborative
- IPRally Technologies
- IRIS.TV
- J.Crew
- JESI
- JustOn GmbH
- JUXT
- Kane LPI
- Kasta
- Kepler 16
- Kira
- Klarna
- Kleene.ai
- Knowledge E
- Kodemaker
- Kwelia
- Ladder
- Ladders
- LambdaWerk
- Latacora
- Leancloud.cn
- Leanheat
- Lemmings
- LemonPI
- LendUp
- Level Money
- Lifebooker
- Liftoff
- LightMesh
- Likely
- LINE
- LinguaTrip
- Linkfluence
- Listora
- LiveOps
- LivingSocial
- Localize.city
- Locarise
- Logic Soft Pvt. Ltd.
- LonoCloud (acquired by ViaSat)
- LookingGlass Cyber Solutions
- Loway
- Lucid IT Consulting LLC
- Lumanu
- Luminare
- LunchBox Sessions
- Macrofex
- MACROFEX LLC
- Madriska Inc.
- Magnet
- Main Street Genome
- Makimo
- Marktbauer/Comida da gente
- Mastodon C
- Mayvenn
- Mazira
- Mediquest
- MeeWee
- Merantix
- Metabase
- Metail
- Metosin
- Minoro
- Mixpanel
- MixRadio
- modelogiq
- Moleque de Ideias
- Motiva AI
- MoveNation
- Multis
- Mysema
- nemCV.com
- Netflix
- Neustar
- nexonit.com
- NextAngles
- Nextjournal
- nilenso
- Nitor
- NLG
- NomNom Insights
- Norled
- NowMedia Tech
- NSD - Norwegian Centre for Research Data
- Nubank
- Nukomeet
- Numerical Brass Computing
- Obrizum Group Ltd.
- Oche Dart
- Oiiku
- OkLetsPlay
- Omnyway Inc
- Ona
- Onfido
- OnlineCasinoInformatie
- OnTheMarket
- OpenCompany
- OpenSensors.io
- OpenTable
- Oracle
- OrgSync
- Orkli
- Oscaro
- Otto
- OurHub
- Outpace
- Outpost Games
- Owsy
- Oyster Lab by Alpiq
- PaddleGuru
- Panacea Systems
- Pandora
- paper.li
- ParcelBright
- PartsBox
- PassivSystems
- Path
- PayGarden
- PayGo
- Payoff
- PennyMac
- Pilloxa
- Pisano
- Pitch
- Pivotal Labs
- PKC
- Point Slope
- Pol.is
- Postmark
- PractiTest
- Precursor
- Premium Business Consultants BV
- Prime.vc
- Print.IO
- projectmaterials.com
- Projexsys
- ProtoPie
- Publizr
- Puppet Labs
- PurposeFly
- Quartet Health
- Quintype
- Qvantel
- Radiant Labs
- RADIOactive
- Reaktor
- Red Hat
- Red Pineapple Media
- Reify Health
- RentPath
- Ride Health
- Rio de Janeiro Botanical Garden
- RJMetrics
- Rōmr
- Rocket Fuel
- ROKT
- Room Key
- Roomstorm
- Rowdy Labs
- ROXIMITY
- RTS
- Salesforce
- Sallie Mae
- SAP
- SAP Concur
- Sapiens Sapiens
- Schibsted
- SEB (Skandinaviska Enskilda Banken)
- Shareablee
- Sharetribe
- shore.li
- Signafire
- Signal
- Siili Solutions
- Silicon Valley Bank
- Silverline Mobile
- Silverpond
- Simple
- Simply
- Sinapsi
- SIOS Technology Corp.
- SixSq
- Skipp
- Smilebooth
- SMX
- Social Superstore
- Solita
- Soundcloud
- SoYouLearn
- SparkFund
- Spatial Informatics Group
- Spinney
- Splash Financial
- Spotify
- SquareVenue
- Staples Exchange
- Staples Sparx
- Starcity
- Stardog
- Status
- Status Research & Development GmbH
- Stitch
- StreetLinx (acquired by Symphony)
- Structured Dynamics
- Studio71
- Studyflow
- Stylitics
- Suiteness
- Suprematic
- SwiftKey (Microsoft)
- Swirrl
- Swym
- Synple
- Synqrinus
- Taiste
- Takeoff Technologies
- TalentAds
- Tapp Commerce
- TCGplayer
- TechnoIdentity
- Teradata
- Test Double
- The Climate Corporation
- ThinkTopic
- Thinstripe
- ThoughtWorks
- ThreatGRID (acquired by Cisco)
- TODAQ Financial
- TokenMill
- Tool2Match
- TopMonks
- TouK
- TOYOKUMO
- Trainline
- T-Rank
- TriOptima
- Troy-West
- Trucker Path
- Two Sigma
- Udviklings- og forenklingsstyrelsen
- Unacast
- Unbounce
- Unfold
- University Health Network
- University Leipzig - Research Centre for Civilization Diseases (LIFE)
- UpLift
- Upworthy
- Urban Dictionary
- Ustream
- uSwitch
- VakantieDiscounter
- Veltio
- Very
- VeryBigThings
- Vetd
- Verrency
- Viasat
- Vigiglobe
- Vilect
- Vire
- Virool
- Vital Labs
- Vodori
- Walmart Labs
- Weave
- WeFarm
- WeShop
- Whibse
- Whitepages
- Wikidocs (acquired by Atlassian)
- Wildbit
- Wit.ai (acquired by Facebook)
- Work & Co
- work.co
- Workframe
- Workinvoice
- WorksHub
- World Singles Networks
- Xapix GmbH
- Xcoo Inc.
- XN Logic
- Yeller
- Yet Analytics
- Yieldbot
- Yousee IT Innovation Labs
- YouView
- Yummly
- Yuppiechef
- Zalando
- Zendesk
- Zen Finance
- Zoona

** Contributing
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/contributing.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/contributing
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-05-01
:CUSTOM_ID: content/community/contributing
:END:
*** Ways to Contribute

There are many ways to make a meaningful contribution to the Clojure
community:

- Advocate for the use of Clojure in your organization
- Use Clojure and share your experience via talks, blogs, etc
- Start or join a local meetup
- Answer questions in [[https://ask.clojure.org][Ask Clojure]]
- Help new Clojure users in Slack or other forums
- Create or provide patches to open source libraries
- Create or improve Clojure tools
- Write guides or reference documentation for libraries
- Write intros or getting started guides for tools
- Create Clojure podcasts, screencasts, or videos
- Give a talk at a conference
- Write an article or book
- Start a Clojure podcast
- Start a Clojure conference or join the organization team for an
  existing one
- Test alpha or beta releases of Clojure on your code base and provide
  feedback

**** Editing this Site

If you are writing a guide, making an event, or creating a resource,
please consider contributing to this web site, clojure.org. All of the
content is [[https://github.com/clojure/clojure-site][stored in GitHub]] and pull requests and issues are
accepted. For more information on how to contribute, see the page on
[[#content/community/contributing_site][contributing to the site]]. Every page has a link to the corresponding
source file in the bottom right corner. If you have an idea for a new
guide or updated documentation, please [[https://github.com/clojure/clojure-site/issues][file an issue]] for discussion.

*** Reporting Problems and Requesting Enhancements
:PROPERTIES:
:CUSTOM_ID: content/community/contributing#reporting-problems-and-requesting-enhancements
:END:

The Clojure team provides a [[#content/community/ask][forum]] where users can ask questions,
submit potential problems, and request enhancements to Clojure,
ClojureScript, or Clojure contrib libraries. For all of these cases,
please ask a question on the [[#content/community/ask][forum]]. Mark the question with tag ~problem~
for potential problems and ~request~ for enhancements. The community and
core team will assess the issue and determine whether to file an issue
in the jira tracker. If an issue is filed, the link will be added to
the question and it will be tagged with ~jira~.

If you are looking to provide feedback on an issue in jira, please
search the [[https://ask.clojure.org][forum]] for the equivalent issue by title and add your
feedback there as an "answer" instead.

The development teams for these languages and libs will use the question
votes to prioritize their work in jira towards the next release.

*** Development

Clojure was created by Rich Hickey and is developed by a core team of
developers at [[https://cognitect.com][Cognitect]], which supports this work. The Clojure
development team values a measured and thoughtful approach to language
evolution with a strong emphasis on maintaining backward
compatibility. See [[#content/dev/dev][Development]] for more information on Clojure
development.

If you would like to provide a patch on a specific ticket in the jira
tracker, please follow the [[#content/dev/dev][process]] to become a contributor.

** Contributing to This Site
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/contributing_site.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/contributing_site
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2015-10-15
:CUSTOM_ID: content/community/contributing_site
:END:

This web site is an open-source repository of content about the
Clojure programming language and its greater ecosystem, hosted at
[[https://clojure.org]].

If you wish to point out an issue in the site or propose a new page,
you can do so by filing a GitHub issue at
[[https://github.com/clojure/clojure-site/issues]].

If you wish to make a contribution (typo, modification, or new content),
you must become a contributor and use the processes described below:

- [[#content/community/contributing_site#how-to-become-a-contributor][How To Become a Contributor]]
- [[#content/community/contributing_site#submitting-small-changes][Submitting Small Changes]]
- [[#content/community/contributing_site#submitting-large-changes][Submitting Large Changes]]
- [[#content/community/contributing_site#building-and-previewing-changes][Building and Previewing Changes]]
- [[#content/community/contributing_site#style-and-navigation-changes][Style and Navigation Changes]]
- [[#content/community/contributing_site#how-contributions-are-reviewed-and-deployed][How Contributions are Reviewed and Deployed]]

*** How To Become a Contributor
:PROPERTIES:
:CUSTOM_ID: content/community/contributing_site#how-to-become-a-contributor
:END:

Contributors must sign the Clojure Contributor Agreement prior to
submitting changes. The [[https://secure.na1.echosign.com/public/hostedForm?formid=95YMDL576B336E][Contributor Agreement]] (CA) gives Rich Hickey
and the contributor joint copyright interests: the contributor retains
copyrights while also granting those rights to Rich Hickey as the open
source project sponsor.

The CA is derived from the Oracle Contributor Agreement (OCA), used
for OpenJDK, Netbeans and OpenSolaris projects and others. There is a
good [[http://www.oracle.com/technetwork/oca-faq-405384.pdf][OCA FAQ]] answering many questions.

By executing the CA, contributors protect the Clojure site content and
protect the flexibility to adapt the project to the changing demands of
the community. In order for the CA to be effective, the Clojure project
must obtain an assignment for all contributions. Please review the CA
for a complete understanding of its terms and conditions. By
contributing source code or other material to Clojure, you represent
that you have a CA with Rich Hickey for such contributions. In order to
track contributors, you understand that your full name and username may
be posted on a web page listing authorized contributors that is
accessible via a public URL.

To complete the agreement, fill out and submit the [[https://secure.na1.echosign.com/public/hostedForm?formid=95YMDL576B336E][Contributor
Agreement]] (an online e-form).

Note that if you have already signed the Clojure Contributor Agreement
to supply patches to the Clojure source code, you do not need to sign it
again as it is the same agreement.

*** Submitting Small Changes
:PROPERTIES:
:CUSTOM_ID: content/community/contributing_site#submitting-small-changes
:END:

Small changes can be proposed directly in the GitHub web interface:

1. Go to the content repository [[https://github.com/clojure/clojure-site]]
2. Navigate to the page you wish to update under content/ - the url
   should match the file base name. For example, this file's content is
   at [[https://github.com/clojure/clojure-site/blob/master/content/community/contributing_site.adoc]].
3. Click the edit (pencil) icon.
4. Content is written using the asciidoc format, which is similar to
   Markdown. The [[#content/community/editing][Editing]] page lists examples of
   the most common things you will encounter when editing content on
   this site. Make your changes in the text box. You can preview your
   changes using the "Preview changes" tab. GitHub understands asciidoc
   format and will provide a formatted preview of your changes.
5. Write a concise description of the change in the bottom section of
   the page then click "Propose file change". This will fork the
   original repository into your own version of the repository with the
   change applied.
6. You will then be shown a "Comparing changes" page - all of the
   information should be filled out automatically and a summary of your
   changes will be at the bottom - this is a good time to look them over
   one more time. Assuming it all looks correct, you can propose the
   change back to the original repository by clicking "Create pull
   request". You'll then be able to add a comment to the pull request
   itself then click "Create pull request".

*** Submitting Large Changes
:PROPERTIES:
:CUSTOM_ID: content/community/contributing_site#submitting-large-changes
:END:

#+BEGIN_QUOTE
*Important*

For any major changes, *please* open an [[https://github.com/clojure/clojure-site/issues][issue]] first and discuss the
change before spending time on it.
#+END_QUOTE

If you are going to create an entirely new page or make significant
changes requiring multiple commits, you will likely find it easier to
work using command line tools.

To create a local environment for working on a bigger change:

1. Fork the content repository
   [[https://github.com/clojure/clojure-site]] - this will create a
   version of the site content under your own user id.
2. ~git clone~ the forked repository in your local terminal and ~cd
   clojure-site~.
3. ~git checkout -b <branchname>~ - create a new branch to work on your
   change. You'll use this branch to submit a pull request.
4. Make one or more commits on this branch, modifying or adding one or
   more files. See the section below on how to build and preview
   changes locally. The [[#content/community/editing][Editing]] page lists examples of the most common
   things you will encounter when editing content on this site.
5. Use ~git push~ to push your changes to the branch.
6. Go to https://github.com/username/clojure-site/tree/branchname.
7. Click the green button to "Compare, review, and create a pull
   request" and proceed through the prompts to submit the pull
   request.

To actively contribute to the site, it's important to keep your own
fork up-to-date with this repository. To do that:

1. Add this repository to your remote urls: ~git remote add upstream
   https://github.com/clojure/clojure-site.git~.
2. Before every contribution:
  - fetch the content of upstream: ~git fetch upstream~ ;
  - move to your master branch: ~git checkout master~ (in case you
    aren't already there);
  - clean your master branch of any unplanned modifications by
    reseting the HEAD to the fetched branch: ~git reset --hard
    upstream/master~; and
  - create a new branch as explained above: ~git checkout -b
    <branchname>~

*** Building and Previewing Changes
:PROPERTIES:
:CUSTOM_ID: content/community/contributing_site#building-and-previewing-changes
:END:

When working on bigger changes it's useful to build the site locally.
The site is built using [[http://jbake.org/][JBake]].

To [[https://jbake.org/docs/2.6.5/#installation][install]] JBake 2.6.5:

1. ~curl -L -O https://dl.bintray.com/jbake/binary/jbake-2.6.5-bin.zip~
  (or download this file with your browser)
2. ~unzip -o jbake-2.6.5-bin.zip~
3. Add jbake-2.6.5-bin/bin to your system PATH

To build the site:

Retrieve the content:

1. ~git clone https://github.com/clojure/clojure-site.git~ (or your own
   fork)
2. ~cd clojure-site~

Retrieve and install the current theme assets (these don't change very
often so you don't need to do this every time):

1. ~curl -O https://clojure.org/clojuretheme.zip~ (or download this file
   with your browser to the clojure-site directory)
2. ~unzip -o clojuretheme.zip~

Generate the pages:

1. ~jbake -b~ - this will create the static site in the output directory
2. To view the static files, open ~output/index~ in your browser
3. To view a live preview, run ~jbake -s~ and go to [[http://localhost:8820/index]]

*** Style and Navigation Changes
:PROPERTIES:
:CUSTOM_ID: content/community/contributing_site#style-and-navigation-changes
:END:

We are not currently looking for changes in the overall site styling,
navigation, or infrastructure. There is ongoing work in that area that
will be visible in the near future.

If you have an issue in these areas, please open an [[https://github.com/clojure/clojure-site/issues][issue]] rather than
a pull request.

*** How Contributions are Reviewed and Deployed
:PROPERTIES:
:CUSTOM_ID: content/community/contributing_site#how-contributions-are-reviewed-and-deployed
:END:

After submitting a pull request, a contribution will be waiting for
review.

For each pull request, one more of the reviewers will take action:

- Mark the comment with the Reviewed label. This indicates the
  reviewer approves of the changes and requests that an Editor merges
  those changes.
- Comment on the pull request suggesting additional changes. You may
  address these changes with further commits on your local branch.
- Close the pull request with a comment indicating why the change is
  not appropriate.

*** Thanks!

Thanks for your contributions!

*** Terms of Use

Copyright © 2019 Rich Hickey and contributors

All documentation contained in this repository is licensed by Rich
Hickey under the [[http://www.eclipse.org/legal/epl-v10.html][Eclipse Public License v1.0]] unless otherwise noted.

** Editing
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/editing.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/editing
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2015-09-29
:CUSTOM_ID: content/community/editing
:END:

This page covers helpful Asciidoc editing tips for writing content on
this site. It does not cover every feature of Asciidoc, just the ones
that have come up most commonly while writing content on this site.

*** File metadata

Every file should start with a metadata block that looks like this:

#+BEGIN_EXAMPLE
= Mechanical Computing
Ada Lovelace
2015-12-31
:jbake-type: page
:toc: macro
#+END_EXAMPLE

The first lines indicate the title, author, and creation date. The last
two lines are necessary boilerplate metadata attributes.

*** Headers
**** h2

#+BEGIN_EXAMPLE
== h2
#+END_EXAMPLE

***** h3

#+BEGIN_EXAMPLE
=== h3
#+END_EXAMPLE

****** h4

#+BEGIN_EXAMPLE
==== h4
#+END_EXAMPLE

*** Text markup

| markup                | effect          |
|-----------------------+-----------------|
| ~_italic_~              | /italic/          |
| ~*bold*~                | *bold*            |
| ~_**italic and bold**_~ | italic and bold |
| ~`inline code`~         | ~inline code~     |
| ~(C) (R) (TM)~          | © ® ™           |
| ~-- ...~                | — ...​           |
| ~-> <- => <=~           | → ← ⇒ ⇐         |

To get a line break without a paragraph change, append + to the end of
the line:

#+BEGIN_EXAMPLE
force +
line break
#+END_EXAMPLE

If you have many lines in a row that will need breaks you can prefix
them with [%hardbreaks]:

#+BEGIN_EXAMPLE
[%hardbreaks]
first line
second line
#+END_EXAMPLE

There are a number of ways to handle escaping in Asciidoc but one of the
most helpful is to omit all formatting by using:

#+BEGIN_EXAMPLE
pass:[*ns*]
#+END_EXAMPLE

*** Links

Create an anchor in a page:

#+BEGIN_EXAMPLE
[[dot]]
#+END_EXAMPLE

Link to another internal page (note the trailing # after the page - this
is required in our generator!):

#+BEGIN_EXAMPLE
<<resources#,Resources>>
#+END_EXAMPLE

There is a bug in the parser used in the current version of JBake for
links to a page in a parent directory. For example, to link to a page at
~../reference/java_interop.adoc~, you can use a link like this:

#+BEGIN_EXAMPLE
<<xref/../../reference/java_interop#,Java Interop>>
#+END_EXAMPLE

This goes to a (fictitious) subdirectory xref, then back a directory,
and then finally the path you wish to follow. While the choice of "xref"
here is arbitrary, please use only this string so that we can more
easily find and update these upward cross references later when there is
a version that fixes this issue.

Link to an anchor in an internal page:

#+BEGIN_EXAMPLE
<<resources#books,Books>>
#+END_EXAMPLE

Link to an external page:

#+BEGIN_EXAMPLE
https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defn[defn]
#+END_EXAMPLE

*** Images

Images should be placed in the assets/images/content directory in a
subdirectory corresponding to the page location.

Reference the image in a page as follows:

#+BEGIN_EXAMPLE
image::/images/content/reference/transducers/xf.png[Nested transformations]
#+END_EXAMPLE

*** Code blocks

You can insert a Clojure formatted code block as follows:

#+BEGIN_EXAMPLE
[source,clojure]
----
(defn hey
  []
  (println "hey"))
----
#+END_EXAMPLE

#+BEGIN_SRC clojure
(defn hey
  []
  (println "hey"))
#+END_SRC

*** Lists

There are a lot of options for creating lists. Only the most common ones
are shown here:

Bulleted lists:

#+BEGIN_EXAMPLE
,* first
,* second
,** nested
,*** more nested
#+END_EXAMPLE

Ordered lists:

#+BEGIN_EXAMPLE
. a
. b
.. b.1
... b.1.a
#+END_EXAMPLE

Mixed lists:

#+BEGIN_EXAMPLE
,* a
. a.1
. a.2
,* b
. b.1
. b.2
#+END_EXAMPLE

Use the line break advice from the text formatting section to create
lists with multi-line items.

*** Tables

Tables are another large Asciidoc topic with extensive formatting
options. This is a basic table example however:

#+BEGIN_EXAMPLE
[options="header"]
|===
| col1 | col2
| a | b
| b | c
|===
#+END_EXAMPLE

*** Other

Horizontal rule:

#+BEGIN_EXAMPLE
''''
#+END_EXAMPLE

Insert table of contents, which should generally be done at the top of
your file (the page template will position this appropriately):

#+BEGIN_EXAMPLE
toc::[]
#+END_EXAMPLE

*** More resources

Asciidoc is an extensive language and there is likely some way to do
anything you want to do. Below are some more Asciidoc resources to
answer more advanced questions.

- [[http://powerman.name/doc/asciidoc][Asciidoc cheat sheet]]
- [[http://asciidoctor.org/docs/user-manual][Asciidoctor user manual]]

** Etiquette
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/etiquette.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/etiquette
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2011-10-15
:CUSTOM_ID: content/community/etiquette
:END:

Clojure and its communication forums are run by, and for, people who
make things. Most messages should have one of these forms:

- I made something - here is my contribution
- I am trying to use the thing someone made and am having trouble,
  please help.
- I can help you with that thing someone made.
- I am trying to make something and am having trouble, please help.
- I can help you make something.

They are not the place for opinion pieces and diatribes.

They are not the place for advocacy about what 'ought' to be made. If
you think something ought to be made, then make it. Otherwise, respect
others peoples' right to choose what they do with their time.

Occasionally, there may be disagreements about how something has been,
or will be, made. These disagreements should take the form of technical
arguments. To make a technical argument that gets (and gives!) respect:

- Keep it short
- Stick to the facts
- Use logic
- Leave people out of it
- Avoid rhetorical devices:
  - Superfluous or opinion-laden adjectives
  - Claims to speak for the community, or that everyone agrees with
    you.
  - Threats of what will happen unless things go your way
  - Any flavor of 'the sky is falling'

If you are not the one making something, you should restrict your input
to very short technical arguments supporting your position. If someone
has already made your point, just +1 it.

Please keep your posts short.

Ignoring these guidelines fails to respect the time and effort of people
who make things, which you should care about if you intend to be one.

/Adapted from Rich's [[https://groups.google.com/forum/#!msg/clojure/t0pGIuoyB7I/RQtuuAOhes8J][post]] to the Clojure mailing list./

** Upcoming Clojure Events
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/events.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/events
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-01-15
:CUSTOM_ID: content/community/events
:END:
** Clojure Libraries
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/libraries.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/libraries
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/community/libraries
:END:

There are many Clojure libraries available. Additionally, Clojure can
use any Java library via Java interop. Together, this provides a vast
ecosystem of libraries at your disposal.

*** Library search

- [[https://www.clojure-toolbox.com/][Clojure Toolbox]] - categorized Clojure libs
- [[https://clojars.org/][Clojars]] - community repo for Clojure libs
- [[https://search.maven.org][Maven Central]] - searchable repo of Java and Clojure libs
- [[https://github.com/search?language=Clojure][GitHub]] - search by language

*** Library collections

These are groups of open source libraries maintained with common
infrastructure, people, or goals:

- [[#content/dev/contrib_libs][Clojure contrib libs]] - open source libs under the Clojure umbrella project
- [[https://clj-commons.org/][clj-commons]]
- [[http://clojurewerkz.org/][ClojureWerkz]]

** License
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/license.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/license
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/community/license
:END:

The use and distribution terms for this software are covered by the
[[http://opensource.org/licenses/eclipse-1.0.php][Eclipse Public License 1.0]], which can be found in the file
epl-v10.html at the root of this distribution. By using this software
in any fashion, you are agreeing to be bound by the terms of this
license. You must not remove this notice, or any other, from this
software.

** Community Resources
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/resources.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/resources
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-02-15
:CUSTOM_ID: content/community/resources
:END:
*** Clojure Discussion

- [[https://ask.clojure.org][Q&A Forum]] (official)
- [[https://groups.google.com/group/clojure][Clojure Google Group]] (official)
- [[http://clojurians.net][Clojurians Slack Chat]]
- [[https://clojurians.zulipchat.com][Clojurians Zulip Chat]]
- [[https://clojureverse.org][Clojureverse]]
- [[https://clojure.org/community/user_groups][Clojure User Groups]]
- [[http://planet.clojure.in/][Planet Clojure]] blog aggregator
- #clojure IRC channel on [[https://libera.chat][Libera.Chat]]
- [[https://discord.gg/discljord][Discljord Clojure Discord Server]]
- [[https://discord.gg/MsejPv9JNG][Clojurians Discord Server]]

*** Tutorials and Learning Materials

Official:

- [[https://clojure.github.io/clojure/][Clojure API Docs]]
- [[https://clojure.github.io/][Clojure Contrib Library API Docs]]
- [[#content/reference/documentation][Clojure Reference Docs]] - official reference information
- [[#content/api/cheatsheet][Clojure Cheatsheet]] - helpful categorization of most core functions
- Source - [[https://github.com/clojure/clojure][Clojure]], [[https://github.com/clojure/clojurescript][ClojureScript]], [[https://github.com/clojure/clojure-clr][ClojureCLR]]
- Issues - [[https://clojure.atlassian.net/projects/CLJ][Clojure]], [[https://clojure.atlassian.net/projects/CLJS][ClojureScript]], [[https://clojure.atlassian.net/projects/CLJCLR][ClojureCLR]]
- [[https://archive.clojure.org/design-wiki/display/design/Home.html][Design wiki archive]]

Community:

- [[#content/community/books][Books]]
- [[http://www.braveclojure.com/][Clojure for the Brave and True]] - a beginner book by Daniel
  Higginbotham
- [[http://aphyr.com/posts/301-clojure-from-the-ground-up-welcome][Clojure from the ground up]] - a series of intro articles by Kyle
  Kingsbury
- [[https://kimh.github.io/clojure-by-example][Clojure By Example]]
- [[https://practicalli.github.io/][Practicalli]] - books and video tutorials on developing with Clojure,
  it's tooling and workflow
- [[https://github.com/ClojureBridge/curriculum][ClojureBridge Curriculum]]
- [[https://clojuredocs.org][ClojureDocs]] - community provided example repository
- [[http://clojure-doc.org/][Clojure Documentation]] - community-driven documentation site
- [[http://clojurekoans.com/][Clojure Koans]] ([[http://clojurescriptkoans.com/][online]])
- [[http://exercism.io/][exercism.io]] - crowd-source code reviews (supports Clojure)
- [[https://guide.clojure.style/][Clojure Style Guide]]
- [[https://www.maria.cloud/][Maria]] - a coding environment for beginners

<<resources#spec>>

Spec:

- [[https://clojure.org/news/2016/05/23/introducing-clojure-spec][Introducing clojure.spec]] - Rich Hickey
- [[https://www.youtube.com/watch?v=YR5WdGrpoug]["Maybe Not"]] - Rich Hickey
- [[https://www.youtube.com/watch?v=oyLBGkS5ICk]["Spec-ulation"]] - Rich Hickey
- [[https://vimeo.com/195711510][Rich Hickey on Clojure Spec]] - LispNYC
- [[https://www.cognitect.com/cognicast/103][Clojure spec with Rich Hickey]] - Cognicast Episode 103
- [[https://www.youtube.com/playlist?list=PLZdCLR02grLrju9ntDh3RGPpWSWBvjwXg][Spec Screencasts]]
- [[https://corfield.org/blog/2019/09/13/using-spec/][How do you use clojure.spec]] - Sean Corfield
- [[https://www.pixelated-noise.com/blog/2020/09/10/what-spec-is/][What Clojure spec is and what you can do with it (an illustrated guide)]] - Stathis Sideris

Newsletters:

- [[http://therepl.net][The REPL]]
- [[http://insideclojure.org][Inside Clojure]] - weekly journals about development of Clojure
- [[https://purelyfunctional.tv/newsletter][PurelyFunctional.tv Newsletter]]
- [[https://us19.campaign-archive.com/home/?u=f5dea183eae58baf7428a4425&id=ef5512dc35][Clojure Weekly]] - curated links from various sources about all things
  Clojure and ClojureScript

Videos and presentations:

- [[https://www.youtube.com/user/ClojureTV/videos][ClojureTV]] - talks by Rich Hickey and presentations from Clojure/conj
  and Clojure/west
- [[http://www.infoq.com/Clojure/presentations/][InfoQ Clojure Presentations]] - from a variety of conferences
- [[https://github.com/matthiasn/talk-transcripts][Talk transcripts]] - Rich Hickey, David Nolen, Stuart Sierra, and
  others
- [[http://www.parens-of-the-dead.com/][Parens of the Dead]] - a screencast series writing a game from scratch
  with Clojure and ClojureScript
- [[https://www.youtube.com/c/+practicalli][Practicalli Clojure Study Guide]] - weekly live broadcasts on
  developing with Clojure and ClojureScript

Podcasts:

- [[https://soundcloud.com/defn-771544745][defn]] - The world's greatest vegetarian Clojure podcast hosted by
  Vijay Kiran and Ray McDermott
- [[https://www.therepl.net/episodes/][The REPL]] - A podcast diving into Clojure programs and libraries by
  Daniel Compton
- [[https://clojurescriptpodcast.com/][ClojureScript Podcast]] - Join Jacek Schae and explore an unusually
  expressive programming language with Lisp roots
- [[https://lispcast.com/category/podcast/][Thoughts on Functional Programming by Eric Normand]] - An off-the-cuff
  stream of Functional Programming ideas, skills, patterns, and news
  from Functional Programming expert Eric Normand
- [[https://clojuredesign.club/][Functional Design in Clojure]] - Christoph and Nate discuss software
  design problems and how they might be solved using functional
  principles and the Clojure programming language.
- [[http://blog.cognitect.com/cognicast][Audio - Cognitect Blog]] - A podcast by Cognitect, Inc. about software
  and the people that create it
- [[https://anchor.fm/dosync-radio][(dosync radio)]] - A podcast to discuss Clojure matters in Japanese.
- [[https://anchor.fm/lostinlambduhhs][Lost in Lambduhhs]] - Jordan Miller interviews a myriad of guests from
  all sectors of tech with a special focus on Clojure and
  Clojurescript

Video training (commercial):

- [[http://www.purelyfunctional.tv/intro-to-clojure][Introduction to Clojure]] - Eric Normand (LispCast)
- [[http://www.purelyfunctional.tv/web-dev-in-clojure][Web Development in Clojure]] - Eric Normand (LispCast)
- [[http://shop.oreilly.com/product/0636920030409.do][Clojure Inside Out]] - Stuart Halloway, Neal Ford (O'Reilly)
- [[http://shop.oreilly.com/product/0636920041474.do][Communicating Sequential Processes with core.async]] - Timothy
  Baldridge (O'Reilly)
- [[http://www.infiniteskills.com/training/building-microservices-with-clojure.html][Building Microservices with Clojure]] - Scott Rehorn (O'Reilly)
- [[http://www.infiniteskills.com/training/learning-clojure.html][Learning Clojure]] - Adam Bard
- [[http://www.infiniteskills.com/training/learning-clojurescript.html][Learning ClojureScript]] - David Eisenberg
- [[https://www.pluralsight.com/courses/clojure-fundamentals-part-one][Clojure Fundamentals]] - Alan Dipert (PluralSight)
- [[https://www.pluralsight.com/courses/clojure-concurrency-tutorial][Clojure Concurrency]] - Craig Andera (PluralSight)
- [[https://www.packtpub.com/web-development/building-web-applications-clojure-video][Building Web Applications with Clojure]] - Tomek Lipski (Packt)
- [[https://lambdaisland.com/][Lambda Island]] - Screencast series about ClojureScript and Clojure
- [[https://www.learnreagent.com/][Learn Reagent]] - Jacek Schae
- [[https://www.learnreframe.com/][Learn re-frame]] - Jacek Schae

*** Conferences

- [[http://clojure-conj.org/][Clojure/conj]] (usually in November)
- [[http://www.clojurebridge.org/][ClojureBridge]] - beginner workshops for women
- [[https://clojutre.org][ClojuTRE]] - A Clojure conference in Tampere/Helsinki, Finland
- [[https://reclojure.org][re:Clojure]] - A yearly community-driven Clojure conference, hosted
  online and with a worldwide attendance
- [[https://clojured.de/][clojureD]] - A Clojure conference in Berlin, Germany
- [[https://heartofclojure.eu/][Heart of Clojure]] - A Clojure conference in Leuven, Belgium
- [[https://clojuredays.org/][Dutch Clojure Days]] - A Clojure conference in Amsterdam, the
  Netherlands
- [[https://clojure-south.com/][Clojure/South]] - A Clojure conference in Sao Paulo, Brazil

** Start Group
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/start_group.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/start_group
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/community/start_group
:END:
*** Tips on Starting a Clojure User Group

Starting a user group is a great way to improve your Clojure skills and
find others interested in Clojure in your area. If you've never run a
user group before, that's ok! Anyone can do it.

A user group needs the following elements:

1. *A meeting place.* Finding a regular meeting place is sometimes the
   biggest hurdle a group faces when getting off the ground. Often the
   ideal option is finding a company that can host a group after-hours.
   If that's not an option, some other choices include libraries,
   churches, or coffee shops.
2. *A meeting time.* It's important to establish a rhythm to keep a
   group going. Pick a night (like the 2nd Tuesday of the month) and try
   as much as possible to have your meeting on that same night every
   month.
3. *A home on the web.* It's important to have an address on the web
   that can be found by a search engine. There are lots of ways to put
   together a web page for free or cheap - see below for some tools you
   can use.
4. *People!* You can't have a meeting without people. Ask around at
   other mailing lists or user groups in your area for people that might
   be interested.

*** Tools

- Google Calendar - [[http://www.google.com/calendar]]
- Wordpress - [[http://wordpress.com]] - free blog and web site
- Meetup - [[http://meetup.com/][http://meetup.com]] - meeting discovery, calendar, user
  network (75% discount available)
- Google Groups - [[http://groups.google.com]] - free mailing list
- Yahoo Groups - [[http://groups.yahoo.com]] - free mailing list
- Wikispaces - [[http://wikispaces.com/][http://wikispaces.com]] - free wiki
- YouTube - [[http://youtube.com]] - video hosting

*** Common problems

/"We have a group but it's hard to find enough speakers."/ or /"The same people always give talks."/

Not every meeting has to have a speaker that gives a prepared talk.
Think creatively about other ways to have a meeting that gives value.
Some ideas:

- *Lightning talks* - do 5 or 10 minute talks on small subjects.
  Paradoxically, doing more shorter talks at a meeting is sometimes
  easier than scheduling one big talk. Each presenter has to prepare
  less material and meetings have a smaller risk of a bad meeting due
  to one inexperienced speaker. Try doing two or three talks per
  meeting.
- *Live coding session* - start with a small problem (it's hard to
  start too small for this) and let the group drive the evolution of
  the solution.
- *Code review* - bring some code and walk through it. Explain the
  code, take comments on style, performance, etc. Rewrite parts of it
  to make it better.
- *Contribute* - pick a bug from the Clojure bug tracker and work on it
  together. Or review the documentation and figure out some
  improvements. Even providing a list of things confusing to newcomers
  is useful.
- *Review a paper* - there are tons of great books and papers on Lisp,
  Clojure, functional programming, persistent data structures, etc.
  Pick one and lead a discussion about the merits or flaws of the
  paper.
- *Book study group* - review a classic book like /Structure and
  Interpretation of Computer Programs/
  ([[http://mitpress.mit.edu/sicp/][SICP]]) or some other
  [[http://www.amazon.com/Clojure-Bookshelf/lm/R3LG3ZBZS4GCTH][classic]]
- *Competition* - have everyone bring a solution to the same problem in
  Clojure or other languages and compare the result.

/"We have a mailing list but no one ever uses it."/

The best way to get people talking on a mailing list is to talk on it
yourself. Post your meeting announcements, meeting recaps, articles of
interest, code snippets, etc. Ask people to introduce themselves on the
list - people love to talk about themselves. Mailing lists require some
bootstrapping. Eventually, the mailing list will become self-maintaining
but it takes some work at the beginning or if there is a lull.

/"Recruiters have joined our mailing list and keep posting job ads."/

It's important to have a policy for recruiters and job postings. Decide
on your policy, document it, and refer people to it. Some common
policies are: "job postings are allowed", "only job postings pertinent
to the group are allowed", "only approved job postings are allowed",
etc. Some groups have a separate mailing list only for jobs and
recruiting.

/"I can't find enough people to have a meeting."/

If you can't find enough people to start a Clojure group, perhaps you
can broaden the scope to find others that might like to talk about
Clojure some of the time. Are there people interested in a functional
programming group? A programming languages group? A JVM-based languages
group? A programmer's club?

** Success Stories
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/success_stories.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/success_stories
:CLOJURE_SITE_AUTHOR: Justin Gehtland
:CLOJURE_SITE_DATE: 2017-03-22
:CUSTOM_ID: content/community/success_stories
:END:

Here are just some of the public success stories from companies using
Clojure. If you'd like to be added to this list, please [[https://goo.gl/forms/eBOzyNESFNf9DxJa2][complete this
form]].

Walmart used Clojure to create a robust data management system that
supports over 5,000 stores and integrates online and mobile
data. Learn how Walmart is running Clojure at Scale.

#+BEGIN_QUOTE
"Our Clojure system just handled its first Walmart black Friday and
came out without a scratch." - via Twitter, 11/28/2014
Anthony Marcar
Senior Architect
#+END_QUOTE

Chartbeat uses Kafka and Clojure to build a contextual site overlay
which tracks internal traffic at a rate of over one million clicks per
minute in real time. Watch Devon discuss how they use Clojure to
process a stream of activity of tens of millions of users.

#+BEGIN_QUOTE
When we needed to extract insights from hundreds of thousands of
requests per second in realtime, we knew Clojure was the answer.
Clojure is really awesome for general stream processing.
Devon Peticolas, Sr.
Backend Engineer and Team Lead
#+END_QUOTE

8th Light worked with a new-to-Clojure client team to complete their
first Clojure project in just a month, from design to deployment. Read
about why they consider Clojure a boring technology, and why that's a
good thing.

#+BEGIN_QUOTE
Clojure's flexibility, interactive development, and tooling have
helped us to iterate and continuously deliver a product our clients
can be proud of.
Colin Jones
CTO
#+END_QUOTE

Consumer Reports chose Clojure and Datomic to bring together all their
underlying backend systems and databases. Their new enterprise-wide
container service enables developers to create applications providing
the data consumers are searching for quickly with decreased risk and
effort. Watch Paul deGrandis discuss Unlocking Data-driven
Systems. Cicayda used Clojure, Datomic, and ClojureScript to build a
robust, multi-tenant cloud hosted SaaS that allows clients to manage
diverse data and load profiles. Learn how they used the familiar
principles of Clojure to build this legal data service.

#+BEGIN_QUOTE
ClojureScript has provided us with a unified development environment
on both sides of the wire and has helped us push toward a
data-oriented UI.
Jonathan Boston
Software Developer
#+END_QUOTE

Puppet use Clojure to build Trapperkeeper (and more), relying on
Clojure's simplicity to build an agile, scalable platform. Read about
Trapperkeeper. Or Dig deeper. Or read about PuppetDB.

#+BEGIN_QUOTE
Clojure is a functional programming language from top to bottom. This
means that code written in Clojure is very modular, composable,
reusable and easy to reason about.
Chris Price
Software Engineer
#+END_QUOTE

Beanstalk switches to Clojure to speed up caching by 20x. Read about
the love.

#+BEGIN_QUOTE
Yesterday we deployed to production a rewrite of Beanstalk's caching
system written in Clojure. It is 20 times faster than the previous
version ... and allowed us to bring the latency between committing a
change to a repo and seeing the update in Beanstalk's UI to an average
of 20 ms.
Dima Sabanin
#+END_QUOTE

MailOnline.com rebuilds publishing platform in Clojure. Read about
Clojure at a newspaper.

#+BEGIN_QUOTE
Yet fundamentally we hadn't written much code. I raised this
sheepishly with the CTO and his response was: “that's how I know it's
the right solution”. Clojure is the winner here.
Jon Pither
Co-founder, Juxt.pro
#+END_QUOTE

DRW Trading Group has adopted Clojure with great success. Watch Jay
discuss why DRW chose Clojure.

#+BEGIN_QUOTE
Clojure wasn't the first language that I've introduced to an
organization; however, it's unquestionably the most successful
adoption I've ever been a part of. The use of Clojure has had many
impacts on the firm: culturally, politically, and technically.
Jay Fields
Software Engineer
#+END_QUOTE

IOOF worked with Thoughtworks to quickly replace and improve a
critical component of their financial services platform. Read about
recreating their superannuation services.

#+BEGIN_QUOTE
The project was a discrete module and allowed us to build it as a
service which fits with our architecture goals. Importantly it
required integration with our core administration system and that
posed no challenge. Clojure allowed us to quickly and easily implement
all the changes required to bring this custody function back in-house.
Andrew Todd
CIO
#+END_QUOTE

Thoughtworks leverages Clojure to accelerate a Java team. Read about
using Clojure to deliver early and under budget.

#+BEGIN_QUOTE
We discussed the existing Clojure community, the maturity of the
language itself and the momentum we saw in the industry. Companies are
seeing speed to market deliveries, that are based on Clojure.
Dave Eilman
#+END_QUOTE

The Climate Corporation uses Clojure to help the world's farmers
sustainably protect and care for their crops. Read about how they used
Clojure to build a versioned weather datastore .

#+BEGIN_QUOTE
All our models, datastores, and services are built in Clojure. We find
that Clojure's support for parallelism makes it easy to run complex
models with low latency.
Leon Barrett
Software Engineer
#+END_QUOTE

Precursor is real-time collaborative prototyping for teams built with
Clojure, ClojureScript, and Datomic. Read about how Precursor uses
ClojureScript to make designers productive .

#+BEGIN_QUOTE
Learning to use ClojureScript, Om, and React finally made me feel like
I was taking ownership of my design work from beginning to end.
Danny King
Co-Founder/Designer
#+END_QUOTE

Sonian has been using Clojure in production at a large scale to
develop a common foundation for back-end services. Read about how
Sonian stays SAFE .

#+BEGIN_QUOTE
Clojure gives us a performance boost at both ends of the software
development lifecycle: we can build new features as quick as any
Python or Ruby shop, and when we ship it to production it runs as fast
as any Java application.
Ron Toland
Clojure Engineer
#+END_QUOTE

Appsflyer develops in Clojure for scalability and for the business
agility it enables. They can grow and adapt as fast as the mobile
advertising market. For more about Appsflyer, visit their website. And
check out their blog post about using Clojure in end-to-end production
.

#+BEGIN_QUOTE
When we transitioned from millions of daily events to billions, we
knew that Clojure was the answer.
Reshef Mann
CTO
#+END_QUOTE

Atlassian is using Clojure to build realtime collaboration features
into both new and existing products. Leonardo Borges explains why
Atlassian chose Clojure and the exciting results the team has achieved
in his recent presentation at EuroClojure 2015. Base2 used Clojure to
develop a feature-rich onboard diagnostic system for the Boeing 737
MAX. They structured the application with a service framework and
message queues to enable communication between disparate parts of the
service while preserving separation of concerns. Watch Donevan discuss
the development of this onboard application in this Clojure/west 2016
presentation .

#+BEGIN_QUOTE
We picked Clojure for this project due to its ability to run parallel
processes well, the strength of the available libraries, and because
Clojure, which is a Boeing approved language, uses the JVM.
Donevan Dolby
Software Engineer
#+END_QUOTE

Room Key works with Cognitect and leverages Clojure and Datomic to
build a rapidly scalable, highly agile cloud-based hotel search
engine. Read about 60,000% growth using Clojure and AWS. Or a case
study about our collaboration. Or about how they use Datomic.

#+BEGIN_QUOTE
[We] knew Cognitect would provide the kind of support we needed. They
have been our partner in every sense of the word. They resolved most
of the few problems we encountered before I got to them.
Colin Steele
CTO
#+END_QUOTE

Greenius chose Clojure and Datomic to build a scalable, agile platform
for gardeners to collaborate and share ideas. Learn about their
ClojureScript integration roadmap.

#+BEGIN_QUOTE
[We designed our software] with just immutable data structures and
pure functions (with much less code than traditional OO languages)
allowing us to focus on our core business requirements rather than
inherent technological problems.
Asier Galdos
Co-founder/developer
#+END_QUOTE

Funding Circle uses Clojure to write their exchange and accounting
systems. Learn about how they use Clojure for perfomance sensitive
back-end services.

#+BEGIN_QUOTE
Clojure is remarkably malleable. We write stream processors, API
servers, and web applications in Clojure and it's a natural fit. We
can focus on our data and solving problems unique to our business.
Rob Crim
Chief Architect
#+END_QUOTE

Kidblog uses Clojure to provide safe student publishing for K-12
teachers and students. Learn about how they use Clojure in their
platform .

#+BEGIN_QUOTE
Clojure makes our code more enjoyable to write, pleasant to read, and
easier to review.
Matt Hardy
Founder
#+END_QUOTE

LendUp uses Clojure to build enterprise financial software that helps
provide anyone with a path to better financial health. LendUp uses
Clojure to power data pipelines and core real-time decisioning &
servicing infrastructure.

#+BEGIN_QUOTE
Clojure is elegant and pragmatic; it helps me focus more on solving
business problems.
Mengxi Lu
Data Engineering Lead
#+END_QUOTE

Zimpler, being a payment company, strives to deliver a smooth payment
experience. For achieving this we use ClojureScript in all our user
facing applications. Watch as Zimplers CTO tells the tale about
ClojureScript in production at a payment company.

#+BEGIN_QUOTE
Working with Clojure and ClojureScript has allowed us to collaborate
more easily and iterate faster.
Jean-Louis Giordano
CTO
#+END_QUOTE

CloudRepo is a cloud based repository manager for storing and sharing
your software libraries (Leiningen, Boot, Maven, etc). CloudRepo's
founder discusses the choice to use a Clojure stack.

#+BEGIN_QUOTE
Simplified development, building a complete product with a very small
team, and zero customer impacting outages. That's just in our first
year of working with Clojure!
Chris Shellenbarger
Founder, CloudRepo
#+END_QUOTE

AnyChart chose Clojure and ClojureScript to power their JavaScript
(HTML5) charting libraries' technical documentation ecosystem: user's
guide, API reference, and chart playground. Read about how how the
AnyChart team uses Clojure and why.

#+BEGIN_QUOTE
We love Clojure for the ability to use Java libraries, writing shared
code for the backend and the frontend, and for the inherent boost to
the speed of development it provides.
Vitaly Radionov
Head of R&D, AnyChart
#+END_QUOTE

At GO-JEK , we rewrote our Allocation Engine in Clojure which enabled
us to serve millions of customers to find a suitable driver for
them. Watch Abhinav and Kartik discuss at EuroClojure 2017.

#+BEGIN_QUOTE
We were looking for a language which allows us to express our domain
beautifully at the heart of our matchmaking system. Clojure was a way
to go which allowed us to write high-level abstraction for matching
drivers and customers.
Shobhit Srivastava
Head of Technology
#+END_QUOTE

Pisano's empowering & innovative customer experience platform uses
Clojure, ClojureScript and Datomic. Read why Pisano is so happy with
using the Clojure platform.

#+BEGIN_QUOTE
Modelling our system state with data structure was a gratifying
experience which seems organic, as it should be.
Ertuğrul Çetin
Software Engineer & Team Lead
#+END_QUOTE

Freshcode provides Web solutions using Clojure as a core
technology. Read about why our developers choose Clojure and when
Clojure development matters.

#+BEGIN_QUOTE
Why Clojure? Because: live reload, extreme development speed,
metaprogramming, macros, DSL, map/filter/reduce
Artem Barmin
Co-Founder at Freshcode
#+END_QUOTE

The French digital administration provides digital infrastructure and
resources for the ministries and public agencies. Etalab, the
department responsible for open data in France, is using Clojure to
publish the list of public source codes.

#+BEGIN_QUOTE
Clojure was used to develop a modest web site, and we appreciate how
it allows us to quickly react to feature requests.
Bastien Guerry
Free Software Officer at the French digital administration
#+END_QUOTE

** Swag
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/swag.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/swag
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/community/swag
:END:
*** Official Clojure Gear

The [[http://www.zazzle.com/clojureappreciation][Clojure Appreciation store]] is the only place to get authorized
gear. Proceeds go to Rich Hickey, the creator of Clojure.

**** Stickers

[[http://rlv.zcache.com/clojure_stickers_3_sheet_of_6-p217097870517528844en8u1_125.jpg]]
Clojure Stickers 3" - Sheet of 6

[[http://rlv.zcache.com/clojure_stickers_1_5_sheet_of_20-p217379761338416613en8u1_125.jpg]]
Clojure Stickers 1.5" - Sheet of 20

Browse other [[http://www.zazzle.com/clojure+stickers?rf=238716329365496646][Clojure Stickers]] by [[http://www.zazzle.com/clojureappreciation*][ClojureAppreciation]].

**** T Shirts

Note: You can customize the color and shirt style, get hoodies, jerseys
etc. If ordering a light shirt you'll need to set the font color to
something dark.

[[https://rlv.zcache.com/clojure_t_large_logo_t_shirt-raf7c54b4b4ec4537afd1e5cb1824168d_joa8u_324.jpg]]
Clojure T, Large Logo

[[https://rlv.zcache.com/clojure_t_small_logo_t_shirt-rda2f449605144baf8631399aa19d8c63_joa8u_324.jpg]]
Clojure T, Small Logo

** Clojure Tools
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/tools.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/tools
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-01-11
:CUSTOM_ID: content/community/tools
:END:

Community volunteers maintain [[#content/guides/getting_started][Getting Started]] documentation for a
number of different tools and approaches. Some of the most commonly
used tools include:

*** Editors
:PROPERTIES:
:CUSTOM_ID: content/community/tools#editors
:END:

- [[https://www.gnu.org/software/emacs/][Emacs]]
  - [[https://cider.mx/][CIDER]] - extends Emacs with support for interactive programming in
    Clojure. The features are centered around cider-mode, an Emacs
    minor-mode that complements clojure-mode - [[https://github.com/clojure-emacs/cider][project]]
  - [[https://github.com/clojure-emacs/clojure-mode][clojure-mode]] - an Emacs major mode that provides font-lock (syntax
    highlighting), indentation, navigation and refactoring support for
    the Clojure(Script)
  - [[https://github.com/clojure-emacs/inf-clojure][inf-clojure]] - provides basic interaction with a Clojure subprocess
    (REPL), based on ideas from the popular inferior-lisp package
  - Installation and configuration guides
    - [[http://clojure-doc.org/articles/tutorials/emacs.html][clojure-doc installation guide]]
    - [[https://www.braveclojure.com/basic-emacs/][Clojure for the Brave and True installation guide]]
    - [[https://practicalli.github.io/spacemacs/][Practicalli guide to Spacemacs]]
  - Distributions and Clojure-friendly configuration setups
    - [[https://www.spacemacs.org/][Spacemacs]]
    - [[https://prelude.emacsredux.com/en/latest/][Prelude]]
    - [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
- [[https://code.visualstudio.com][Visual Studio Code]] with [[https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva][Calva]]
  - [[https://calva.io][docs]], [[https://github.com/BetterThanTomorrow/calva][project]]
- [[https://www.jetbrains.com/idea/][IntelliJ]] with [[https://cursiveclojure.com/][Cursive]]
- [[https://www.vim.org/][Vim]] with [[https://github.com/tpope/vim-fireplace][Fireplace]] or [[https://liquidz.github.io/vim-iced/][Vim-Iced]]
- [[https://neovim.io/][Neovim]] with [[https://github.com/Olical/conjure][Conjure]]
- [[https://atom.io][Atom]] with [[https://atom.io/packages/chlorine][Chlorine]] - [[https://github.com/mauricioszabo/atom-chlorine][project]]
- [[http://www.lighttable.com/][Light Table]]
- [[https://www.sublimetext.com/][Sublime Text]] with [[https://github.com/wuub/SublimeREPL][SublimeREPL]]
- [[https://doc.ccw-ide.org/][Eclipse Counterclockwise]] (inactive)
- [[https://sekao.net/nightcode/][Nightcode]] (inactive)

*** Dependency management

- [[#content/guides/deps_and_cli][clj and deps.edn]] - clj is a tool for managing dependencies, running
  a REPL, and executing Clojure programs, built by the Clojure core
  team
- [[https://leiningen.org/][Leiningen]] - an extensible build tool that provides dependency
  management, REPL support, testing, packaging, deployment, and many
  other capabilities
- [[https://boot-clj.github.io/][Boot]] - build tooling for Clojure: instead of a special-purpose DSL,
  Boot supplies abstractions and libraries you can use to automate
  nearly any build scenario with the full power of the Clojure
  language

*** Library repositories and catalogs

- [[https://clojars.org/][Clojars]] - Clojure-focused Maven repository
- [[http://www.clojure-toolbox.com/][Clojure Toolbox]] - a categorized index of Clojure libraries

** Training
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/training.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/training
:CLOJURE_SITE_AUTHOR: Timothy Pratley
:CLOJURE_SITE_DATE: 2018-03-06
:CUSTOM_ID: content/community/training
:END:
*** For teams

Adding Clojure to your company's capabilities? Give your employees a
head start! Here is list of companies and individuals that offer Clojure
training courses.

| Company             | Location                   | Courses               | Link                                                 | contact                   |
|---------------------+----------------------------+-----------------------+------------------------------------------------------+---------------------------|
| Cognitect           | North America              | All levels            | [[https://cognitect.com/services.html]]                  | [[mailto:sales@cognitect.com][sales@cognitect.com]]       |
|                     |                            |                       |                                                      | +1 919.283.2748           |
|---------------------+----------------------------+-----------------------+------------------------------------------------------+---------------------------|
| BraveAndTrue        | North America              | All levels            | [[https://www.braveclojure.com/training]]                | [[mailto:daniel@braveclojure.com][daniel@braveclojure.com]]   |
|---------------------+----------------------------+-----------------------+------------------------------------------------------+---------------------------|
| Nilenso             | India                      | Enterprise Clojure    | [[https://nilenso.com]]                                  | [[mailto:hello@nilenso.com][hello@nilenso.com]]         |
|                     |                            |                       |                                                      | tel:+918040937123         |
|---------------------+----------------------------+-----------------------+------------------------------------------------------+---------------------------|
| Starweaver          | Global                     | Clojure in a Nutshell | [[https://www.starweaver.com]]                           | USA: +1-646-883-1460      |
|                     |                            |                       |                                                      | UK: +44 20 3289 3277      |
|                     |                            |                       |                                                      | [[mailto:helpdesk@starweaver.com][helpdesk@starweaver.com]]   |
|---------------------+----------------------------+-----------------------+------------------------------------------------------+---------------------------|
| Peter Taoussanis    | Europe                     | Enterprise Clojure    | [[https://www.taoensso.com]]                             | [[mailto:ptaoussanis@taoensso.com][ptaoussanis@taoensso.com]]  |
|---------------------+----------------------------+-----------------------+------------------------------------------------------+---------------------------|
| Adam Bard           | North America              | Clojure Training      | [[http://clojuretraining.ca]]                            | [[mailto:learnclojure@adambard.com][learnclojure@adambard.com]] |
|---------------------+----------------------------+-----------------------+------------------------------------------------------+---------------------------|
| Mark Engelberg      | North America (west coast) | Customized Training   | [[https://www.linkedin.com/in/mark-engelberg-0a09a88a/]] | [[mailto:mark.engelberg@gmail.com][mark.engelberg@gmail.com]]  |
|---------------------+----------------------------+-----------------------+------------------------------------------------------+---------------------------|
| Klipse Technologies | Worldwide                  | Clojure Training      | [[https://www.getprogrammingwithclojure.com/workshop]]   | [[mailto:viebel@gmail.com][viebel@gmail.com]]          |

*** For individuals

Looking for a curated curriculum to jump start your learning? Several
courses are offered.

**** Online courses

| Link                                   | Short description                           |
|----------------------------------------+---------------------------------------------|
| [[https://lambdaisland.com]]               | A series of video tutorial about web        |
|                                        | development using ClojureScript and Clojure |
|----------------------------------------+---------------------------------------------|
| [[https://purelyfunctional.tv]]            | Our mission is to help people thrive        |
|                                        | with Functional Programming                 |
|----------------------------------------+---------------------------------------------|
| [[https://www.udemy.com/learning-clojure]] | Will teach you how to write Clojure         |
|                                        | code and structure Clojure products         |
|----------------------------------------+---------------------------------------------|
| [[https://learnreframe.com]]               | Learn ClojureScript and re-frame            |
|                                        | by building CHEFFY; AirBnB for chefs.       |
|----------------------------------------+---------------------------------------------|
| [[https://learnreagent.com]]               | Learn ClojureScript and Reagent by building |
|                                        | GIGGIN an app that showcase local gigs.     |

**** ClojureBridge

[[http://www.clojurebridge.org][ClojureBridge]] aims to increase diversity within the Clojure community
by offering free, beginner-friendly Clojure programming workshops for
underrepresented groups in tech. ClojureBridge holds free training
events for women and minorities. Typically these are 1 day events
hosted by one or more sponsors.

**** Conferences

For conferences and upcoming events, check the upcoming [[#content/community/events][Events]] list.

*** Resources for trainers

- [[https://github.com/cognitect/clojure-lab]]
- [[https://github.com/braveclojure/training]]
- [[https://github.com/timothypratley/enterprise-clojure-training]]

*** Maintenance

If you would like to be added or removed from this list, please contact
/clojure@cognitect.com/ or submit a pull request.

** Clojure user groups
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/community/user_groups.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/community/user_groups
:CLOJURE_SITE_AUTHOR: Erik Assum
:CLOJURE_SITE_DATE: 2018-04-06
:CUSTOM_ID: content/community/user_groups
:END:

Do you wish there was a Clojure User Group in your area? Check out our
page of [[#content/community/start_group][tips for starting your own]].

If you'd like to have your group listed here, please submit a PR
against the [[https://github.com/clojure/clojure-site][clojure-site]] github repo.

[ [[#content/community/user_groups#americas][Americas]] ] [ [[#content/community/user_groups#europe][Europe]] ] [ [[#content/community/user_groups#asia][Asia]] ] [ [[#content/community/user_groups#australia-new-zealand][Australia / New Zealand]] ]

*** Americas
:PROPERTIES:
:CUSTOM_ID: content/community/user_groups#americas
:END:

- Argentina [[https://www.meetup.com/ClojureBA/][Clojure User Group Buenos Aires]] (Twitter: [[https://twitter.com/ClojureBA][@ClojureBA]])
- Brazil [[https://www.meetup.com/clj-sp/][Grupo de Usuários Clojure de São Paulo e Rio de Janeiro]]
- Canada
  - [[https://groups.google.com/forum/#!forum/montreal-clojure-user-group][Montreal
    Clojure User Group]]
  - [[https://clojureto.github.io][Clojure Toronto]]
  - [[https://www.meetup.com/Vancouver-Clojure][Vancouver Clojure]]
- United states
  - Northeast
    - [[https://www.meetup.com/Boston-Clojure-Group/][Boston Clojure Group]]
    - Functional Programming Connoisseurs (Western Massachusetts &
      surroundings) Welcoming all FP-ers
      (Erlang/Scheme/Scala/Haskell/etc etc etc), but Clojure fans
      generally form a plurality.
    - [[https://www.meetup.com/Clojure-NYC/][NYC Clojure Users Group]] (Twitter: [[https://twitter.com/ClojureNYC][@ClojureNYC]])
    - ClojureScript NYC (Twitter: [[https://twitter.com/ClojureNYC][@ClojureNYC]])
    - [[https://www.meetup.com/Clojadelphia/][Clojadelphia - The Philadelphia User Group]]
    - Pittsburgh Clojure Users Group is part of [[http://www.codeandsupply.co/][Pittsburgh Code & Supply]]
  - Midwest
    - [[https://www.meetup.com/Chicago-Clojure/][Chicago]]
    - [[https://cincyfp.wordpress.com/][Cincy Functional Programmers Group]]
    - Detroit Clojure Group
    - [[https://www.meetup.com/clojure-mke/][Clojure MKE - Milwaukee, WI]]
    - [[https://www.meetup.com/Madison-Clojure-Meetup/][Madison Clojure Meetup]] - Madison, WI
    - [[http://clojure.mn/][Minnesota Clojure Users Group]]
    - [[https://www.meetup.com/stl-clojure][St. Louis Clojure Meetup]]
    - [[http://www.columbusclojure.com][Columbus Clojure User Group]]
  - South
    - [[https://www.meetup.com/Baltimore-Clojure/][Baltimore Clojure Meetup]]
    - [[https://www.meetup.com/Cap-Clug/][National Capital Area Clojure Users Group]] - Reston, VA
    - ClojureDC - Washington, DC
    - [[https://meetup.com/TriClojure/][TriClojure Meetup]]
    - [[https://www.meetup.com/Atl-Clj/][Atlanta Clojure User Group]]
    - [[https://groups.google.com/group/clj-houston][Clojure Houston User Group]]
    - Dallas/Fort Worth Clojure Interest Group ([[https://groups.google.com/forum/#topic/clojure/Cym7oiViFoQ][See mailing list thread for more info]])
    - [[https://www.meetup.com/Clojure-Mid-Cities/][DFW-Southlake Clojure Mid-Cities Meetup]]
    - [[https://www.meetup.com/Austin-Clojure-Meetup/][Austin Clojure Meetup]]
    - Greenville Clojure Users Group (and [[https://groups.google.com/forum/#!forum/greenville-clojure][mailing list]])
    - [[https://www.meetup.com/Clojure-Co-Lab/][Clojure Co-Lab]] - Columbia, South Carolina
  - West
    - [[http://seajure.github.io][Seajure - Seattle Clojure Group]]
    - [[https://www.meetup.com/clojerks/][Clojure user group in Portland]]
    - [[https://www.meetup.com/The-Bay-Area-Clojure-User-Group/][Bay Area Clojure User Group]] - San Francisco (monthly meetup plus
      monthly dojo); San Mateo (monthly meetup)
    - [[https://www.meetup.com/Denver-Clojure-Meetup/][Denver Clojure Meetup]]
    - [[https://www.meetup.com/Los-Angeles-Clojure-Users-Group/][Los Angeles Clojure Users Group]] and [[https://groups.google.com/forum/#!forum/clj-la][mailing list]]
    - Santa Barbara Clojure Users Group
    - [[https://groups.google.com/forum/#!forum/clj-phx][Phoenix Clojure User Group]]
    - [[https://www.meetup.com/San-Diego-Clojure-Users-Group/][San Diego Clojure Users Group]]

*** Europe
:PROPERTIES:
:CUSTOM_ID: content/community/user_groups#europe
:END:

- Austria
  - [[https://www.meetup.com/clojure-vienna/][Vienna Clojure User Group]]
- Belgium
  - [[http://www.beclojure.org][BeClojure]] (Twitter: [[https://twitter.com/beclojure][@beclojure]])
- Bulgaria
  - [[https://www.meetup.com/Lambda-Dojo-Sofia/][Lambda Dojo Sofia]]
- Czech Republic
  - [[https://plus.google.com/communities/110902954360410928675][Lambda Meetup Ostrava]]
  - [[https://www.meetup.com/Lambda-Meetup-Group/][Prague Lambda Meetup]]
- Denmark
  - [[https://www.meetup.com/aarhusclj/][Aarhus Clojure Meetup]] (Twitter: [[https://twitter.com/aarhusclj][@aarhusclj]])
  - [[https://www.meetup.com/Copenhagen-Clojure-Meetup/][Copenhagen Clojure Meetup]] - meetings every 6 weeks
- Finland
  - [[https://groups.google.com/forum/#%21forum/clojure-finland][Clojure Finland]]
- France
  - [[https://groups.google.com/group/clojure-fr/][French community mailing list]]
  - [[https://www.meetup.com/fr-FR/Paris-Clojure-User-Group/][Paris Clojure Meetup]]
  - [[http://clojure-lyon.eventbrite.fr/][Clojure Lyon EventBrite (France)]]- local meetups registration
  - [[https://www.meetup.com/riviera-scala-clojure][Riviera Clojure]] (Join with Riviera Scala, (Twitter:
    [[https://twitter.com/riviera_func][@riviera_func]])
- Germany
  - [[https://www.meetup.com/Clojure-Berlin/][Berlin Clojure User Group]] and [[https://groups.google.com/forum/#!forum/clojure-user-group-berlin][mailing list]]
  - [[http://www.cugb.de][Bonn Clojure User Group]]
  - [[https://www.meetup.com/de-DE/Clojure-Usergroup-Franken/][Clojure Usergroup Franken]]
  - [[https://www.meetup.com/clojure-cologne/][Cologne Clojure User Group]]
  - [[https://www.meetup.com/de-DE/Dusseldorf-Clojure-Meetup/][Düsseldorf Clojure User Group]]
  - [[https://www.meetup.com/ClojureUserGroupHH/][Hamburg Clojure User Group]]
- Hungary
  - [[https://www.meetup.com/Budapest-Clojure-User-Group/][Budapest
    Clojure User Group]]
- Ireland
  - [[https://www.meetup.com/Clojure-Ireland/][Clojure Ireland]]
- Italia
  - [[https://groups.google.com/group/clojure-italy][Italian Clojure User Group]]
- Netherlands
  - [[http://amsclj.nl/][The Dutch Clojure Meetup]] (Twitter: [[https://twitter.com/amsclj][@amsclj]])
- Norway
  - [[https://www.meetup.com/Oslo-Clojure-Meetup/][Oslo Clojure
    Meetup]]
- Russia
  - [[https://plus.google.com/u/0/communities/114227952963737516047][Clojure
    Russia]]
- Slovakia
  - [[https://groups.google.com/group/bratislava-clojure/][Bratislava
    Clojure]]
- Sweden
  - [[https://www.meetup.com/got-lambda][Got.λ - Göteborg Functional Programming Group]]
  - [[https://groups.google.com/group/stockholm-clojure-user-group][Stockholm Clojure User Group]] (Twitter: [[https://twitter.com/sclojug][@sclojug]])
- Switzerland
  - [[https://www.meetup.com/zh-clj-Zurich-Clojure-User-Group/][Zürich Clojure User Group]]
- UK
  - [[https://www.meetup.com/London-Clojurians/][London Clojurians]] ([[https://londonclojurians.org/][website]], [[https://twitter.com/ldnclj][@ldnclj]], [[https://www.youtube.com/c/LondonClojurians][YouTube]], [[https://opencollective.com/london-clojurians][Sponsors]])
  - Manchester Clojure Dojo
  - [[https://www.meetup.com/Cambridge-NonDysFunctional-Programmers/][Cambridge NonDysFunctional Programmers]] and [[https://groups.google.com/forum/#!forum/camclj][Cambridge Clojure User
    Group]] mailing list
  - [[https://www.meetup.com/Bristol-Clojurians/][Bristol Clojurians]]
  - [[https://groups.google.com/forum/#!forum/edinburgh-clojurians][Edinburgh Clojurians]]
  - [[https://groups.google.com/forum/#!forum/glasgow-clojurians][Glasgow
    Clojurians]]

*** Asia
:PROPERTIES:
:CUSTOM_ID: content/community/user_groups#asia
:END:

- [[https://groups.google.com/group/bangalore-clj][Bangalore Clojure Group]]
- [[https://groups.google.com/group/cn-clojure][Chinese Clojure Group]]
- [[http://clojure-china.org/][Clojure China]] and [[http://weibo.com/clojurechina]]
- [[https://www.meetup.com/Clojure-Israel/][Clojure Israel]]
- [[https://groups.google.com/forum/#!forum/clojuresg][Singapore Clojure User Group]]
- [[https://www.facebook.com/groups/defnclojure][Clojure Korea]]
- [[http://clojure.tw][Clojure Taiwan]]

*** Australia / New Zealand
:PROPERTIES:
:CUSTOM_ID: content/community/user_groups#australia-new-zealand
:END:

- [[http://www.meetup.com/clj-syd/][Sydney Clojure User Group]]
- [[http://www.meetup.com/clj-melb/][Melbourne Clojure User Group]]
- [[http://www.meetup.com/Auckland-Clojure/][Auckland Clojure User Group]]

* Dev
** Contrib History
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/contrib_history.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/contrib_history
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-04-24
:CUSTOM_ID: content/dev/contrib_history
:END:

This page is a historical document about the splitting of the old
"monolithic" contrib in the Clojure 1.2 timeframe when many of the
initial contrib libraries were created. This info is no longer
maintained and may be out of date. See [[#content/dev/contrib_libs][Contrib Libs]] for up to date
info.

If a clojure.contrib namespace is listed here but has no migration
details, that means no one has volunteered to maintain that namespace.
Part of the rationale for modular contrib is that there should be an
active maintainer going forward so that the library can be kept
compatible with new versions of Clojure. All the new modular contrib
libraries are compatible with Clojure 1.2.0 thru 1.4.0 (and are also
being automatically tested with Clojure 1.5 as it is being developed -
as well as being tested with a number of different JDKs!).

If a clojure.contrib namespace is not listed here, it is most likely
an old namespace that was either migrated somewhere else or deprecated
as part of Clojure 1.2 (e.g., clojure.contrib.duck-streams mostly
migrated to clojure.java.io, clojure.contrib.pprint migrated to
clojure.pprint, clojure.contrib.shell and clojure.contrib.shell-out
migrated to clojure.java.shell, clojure.contrib.string migrated to
clojure.string, clojure.contrib.http.agent was deprecated - [[https://github.com/dakrone/clj-http][clj-http]].

*** Clojure.Contrib Namespaces

This section aims to document how to migrate from "old" contrib to "new"
contrib.

- clojure.contrib.accumulators
- clojure.contrib.agent-utils
- clojure.contrib.base64
  - Replaced by [[https://github.com/clojure/data.codec/][clojure.data.codec]] - lead Alex Taggart.
- clojure.contrib.classpath
  - Migrated to [[https://github.com/clojure/java.classpath/][clojure.java.classpath]]
    - lead Stuart Sierra.
- clojure.contrib.combinatorics
  - Migrated to [[https://github.com/clojure/math.combinatorics/][clojure.math.combinatorics]]
    - lead Mark Engelberg.
- clojure.contrib.command-line
  - Replaced by [[https://github.com/clojure/tools.cli/][clojure.tools.cli]] (based on the clargon library) -
    lead Gareth Jones.
- clojure.contrib.complete
- clojure.contrib.complex-numbers
- clojure.contrib.cond
- clojure.contrib.condition
  - Replaced by [[https://github.com/scgilardi/slingshot][Slingshot]]
    - Lead Steve Gilardi
- clojure.contrib.core
  - Partly migrated to [[https://github.com/clojure/core.incubator/][clojure.core.incubator]]
    - lead Rich Hickey.
- clojure.contrib.dataflow
- clojure.contrib.datalog
  - Michael Fogus has a project [[https://github.com/fogus/bacwn][bacwn]] on Github based on this
    library.
- clojure.contrib.def
  - Partly migrated to [[https://github.com/clojure/core.incubator/][clojure.core.incubator]]
    - lead Rich Hickey.
  - Notes:
    - ~defvar~: as of Clojure 1.3, you can specify a docstring in a
      ~def~ form: ~(def my-var "This is my docstring" some-value)~
- clojure.contrib.error-kit
  - Replaced by [[https://github.com/scgilardi/slingshot][Slingshot]]
    - Lead Steve Gilardi
- clojure.contrib.except
- clojure.contrib.fcase
  - fcase replaced by Clojure 1.3 ~clojure.core/condp~. Other macros
    easily implemented using ~condp~ if desired.
- clojure.contrib.find-namespaces
  - Migrated to [[https://github.com/clojure/tools.namespace/][clojure.tools.namespace]]
    - lead Stuart Sierra.
- clojure.contrib.fnmap
- clojure.contrib.gen-html-docs
- clojure.contrib.generic
  - Migrated to [[https://github.com/clojure/algo.generic/][clojure.algo.generic]]
    - lead Konrad Hinsen.
- clojure.contrib.graph
  - Migrated to [[https://github.com/clojure/algo.generic/][clojure.algo.graph]] - lead Timothy Baldridge.
- clojure.contrib.greatest-least
- clojure.contrib.import-static
- clojure.contrib.jar
- clojure.contrib.java-utils
- clojure.contrib.jmx
  - Migrated to [[https://github.com/clojure/java.jmx/][clojure.java.jmx]] - lead Stuart Halloway.
- clojure.contrib.json
  - Migrated to [[https://github.com/clojure/data.json/][clojure.data.json]] - lead Stuart Sierra.
- clojure.contrib.lazy-seqs
- clojure.contrib.lazy-xml
  - Migrated to [[https://github.com/clojure/data.xml][clojure.data.xml]] - lead Alan Malloy.
- clojure.contrib.load-all
- clojure.contrib.logging
  - Migrated to [[https://github.com/clojure/tools.logging][clojure.tools.logging]]
    - lead Alex Taggart.
- clojure.contrib.macro-utils
  - Migrated to [[https://github.com/clojure/tools.macro][clojure.tools.macro]] - lead Konrad Hinsen.
- clojure.contrib.macros
  - Migrated to [[https://github.com/clojure/tools.macro][clojure.tools.macro]] - lead Konrad Hinsen.
- clojure.contrib.map-utils
- clojure.contrib.math
  - Migrated to [[https://github.com/clojure/math.numeric-tower][clojure.math.numeric-tower]]
    - lead Mark Engelberg.
- clojure.contrib.miglayout
- clojure.contrib.mmap
- clojure.contrib.mock
- clojure.contrib.monadic-io-streams
- clojure.contrib.monads
  - Migrated to [[https://github.com/clojure/algo.monads/][clojure.algo.monads]] - lead Konrad Hinsen.
- clojure.contrib.ns-utils
- clojure.contrib.parent
- clojure.contrib.priority-map
  - Migrated to [[https://github.com/clojure/data.priority-map/][clojure.data.priority-map]]
    - lead Mark Engelberg.
- clojure.contrib.probabilities
- clojure.contrib.profile
- clojure.contrib.prxml
- clojure.contrib.reflect
- clojure.contrib.repl-ln
- clojure.contrib.repl-utils
  - Migrated to ~clojure.repl~ and ~clojure.java.javadoc~. ~show~
    functionality similar to ~clojure.reflect/reflect~. Any equivalents for
    these? ~expression-info~, ~run~, ~run*~
- clojure.contrib.seq
- clojure.contrib.server-socket
- clojure.contrib.set
  - Migrated to ~clojure.set~, except ~proper-subset?~ and
    ~proper-superset?~, which are easily implemented using ~subset?~ and
    ~superset?~
- clojure.contrib.singleton
- clojure.contrib.sql
  - Migrated to [[https://github.com/clojure/java.jdbc/][clojure.java.jdbc]] - lead Sean Corfield.
- clojure.contrib.standalone
- clojure.contrib.stream-utils
- clojure.contrib.strint
  - Migrated to [[https://github.com/clojure/core.incubator/][clojure.core.incubator]]
    - lead Rich Hickey.
- clojure.contrib.swing-utils
- clojure.contrib.trace
  - Migrating to [[https://github.com/clojure/tools.trace/][clojure.tools.trace]] - lead Luc Prefontaine
- clojure.contrib.types
- clojure.contrib.with-ns
- clojure.contrib.zip-filter
  - Migrated to [[https://github.com/clojure/data.zip/][clojure.data.zip]] - lead Aaron Bedra.

*** New Contrib Namespaces

This section lists new contrib namespaces that do not correspond to old contrib namespaces and is provided for completeness / documentation purposes.

- [[https://github.com/clojure/core.async/][clojure.core.async]]
  - A Clojure library designed to provide facilities for async
    programming and communication. - lead Rich Hickey.
- [[https://github.com/clojure/core.cache/][clojure.core.cache]] Extensible caching - lead Michael Fogus.
- [[https://github.com/clojure/core.contracts/][clojure.core.contracts]]
  - Contract programming - lead Michael Fogus.
- [[https://github.com/clojure/core.rrb-vector/][clojure.core.rrb-vector]]
  - An implementation of the confluently persistent vector data
    structure introduced in Bagwell, Rompf, "RRB-Trees: Efficient
    Immutable Vectors", EPFL-REPORT-169879, September, 2011. - lead
    Michał Marczyk
- [[https://github.com/clojure/core.logic/][clojure.core.logic]]
  - Logic programming - lead David Nolen.
- [[https://github.com/clojure/core.match/][clojure.core.match]]
  - Structural pattern matching - lead David Nolen.
- [[https://github.com/clojure/core.memoize/][clojure.core.memoize]]
  - Pluggable memoization, builds on core.cache - lead Michael Fogus.
- [[https://github.com/clojure/core.typed/][clojure.core.typed]]
  - Optional type checking for Clojure - lead Ambrose Bonnaire-Sergeant
- [[https://github.com/clojure/core.unify/][clojure.core.unify]]
  - Unification (like Prolog) - lead Michael Fogus.
- [[https://github.com/clojure/data.csv/][clojure.data.csv]]
  - Comma-Separated-Value file processing; formerly cljcsv - lead Jonas Enlund.
- [[https://github.com/clojure/data.finger-tree/][clojure.data.finger-tree]]
  - Finger tree persistent data structures - lead Chris Houser.
- [[https://github.com/clojure/data.fressian/][clojure.data.fressian]]
  - Read and write fressian data. See
    [[https://github.com/Datomic/fressian/wiki]]
- [[https://github.com/clojure/data.generators/][clojure.data.generators]]
  - Data generators (extracted from clojure.test.generative) - lead
    Stuart Halloway.
- [[https://github.com/clojure/java.data/][clojure.java.data]]
  - Java Beans and properties support - lead Cosmin Stejerean.
- [[https://github.com/clojure/test.benchmark/][clojure.test.benchmark]]
  - Benchmark (and regression) suite for Clojure - lead Stuart
    Halloway.
- [[https://github.com/clojure/test.generative/][clojure.test.generative]]
  - Testing library based on data generation (see
    clojure.data.generators) - lead Stuart Halloway.
- [[https://github.com/clojure/tools.nrepl/][clojure.tools.nrepl]]
  - REPL client and server - lead Chas Emerick.
- [[https://github.com/clojure/tools.reader/][clojure.tools.reader]]
  - Clojure reader in Clojure - lead Nicola Mometto.
- [[https://github.com/clojure/tools.analyzer/][clojure.tools.analyzer]]
  - An analyzer for Clojure code, host agnostic - lead Nicola Mometto
- [[https://github.com/clojure/tools.analyzer.jvm/][clojure.tools.analyzer.jvm]]
  - An analyzer for Clojure on the JVM code, written on top of
    tools.analyzer - lead Nicola Mometto
- [[https://github.com/clojure/tools.analyzer.js/][clojure.tools.analyzer.js]]
  - DEAD
  - An analyzer for Clojurescript code, written on top of
    tools.analyzer - lead Nicola Mometto
- [[https://github.com/clojure/tools.emitter.jvm/][clojure.tools.emitter.jvm]]
  - A JVM bytecode generator, using tools.analyzer.jvm as frontend -
    lead Nicola Mometto

** Contrib How-To
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/contrib_howto.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/contrib_howto
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-04-23
:CUSTOM_ID: content/dev/contrib_howto
:END:
*** Readmes

Contrib library readmes should contain:

- Instructions for including the library as a dependency in Maven /
  Leiningen
- Links to the library's pages on Jenkins and JIRA
- Links to the available releases on Maven Central and oss.sonatype.org
- Link to generated API documentation, if available
- General usage instructions (should mention which namespace to
  use/require)
- Developer Information: links to GitHub project, Bug Tracker,
  Continuous Integration, Compatibility Test Matrix
- Change log of all releases (may also be in separate file)

*** Committer Guidelines

Things you should do if you are a Clojure Contrib committer:

- maintain your library and respond to questions/issues that arise
- do your work on the master branch, or (if you are working on a
  significant chunk you want to keep temporarily separate) on a
  feature-specific branch that you create yourself
- use the Maven Release option on build.clojure.org to make releases
- coordinate with other committers before making changes to their
  libraries
- accept contributions from others only if they have [[#content/dev/contributors][signed the CA]]

Things to avoid:

- please do not push to the release branches (names like 1.2.x)
- do not take non-contributor patches
- please do not take pull requests from contributors. Patches only.
- do not change the version number in pom.xml - use the Maven Release
  process mentioned above

Here's the process outline for what it takes to become a committer:

- Get your [[#content/dev/contributor_agreement][CA]] on file
- Join the [[http://groups.google.com/group/clojure-dev][clojure-dev]] mailing list
- Create a [[https://clojure.atlassian.net/projects/CLJ][JIRA account]]
- Let Clojure core team know your github username and JIRA username so
  they can set up the correct permissions
- Clojure core team need to create your account on build.clojure.org as
  well - see below

Moving an existing project into contrib:

- All past contributors must:
  - Submit a Clojure Contributor Agreement
  - Send an email to the clojure-dev mailing list granting permission,
    such as: "I, (NAME), give my permission to release my
    contributions to (PROJECT) under the Clojure Contributor
    Agreement."

Setting up a new contrib project:

- Email clojure-dev mailing list to get new project approved and admin
  privileges in GitHub, Jira, and Jenkins.
- Ask for a new GitHub repo under the clojure [[https://github.com/clojure][organization]]
  - Specify project name (must be approved by Clojure core)
  - Specify description
  - Collaborators - add Team: Contrib Commit which includes:
    - clojure-build - for Jenkins to tag releases, build autodocs,
      etc
  - Disable Issues tab (we use JIRA instead)
  - Project structure (see existing projects for example)
    - /README.md - readme, see above
    - /CHANGES.md - changelog
    - /CONTRIBUTING.md - example
    - /epl.html - EPL license information
    - /pom.xml - according to the [[https://github.com/clojure/build.poms][build.poms]] instructions - used for
      build/deploy
    - /src/main/clojure - Clojure sources
    - /src/test/clojure - Clojure tests
    - /src/main/cljs - ClojureScript sources
    - /src/test/cljs - ClojureScript tests
    - /src/main/java - Java sources, if needed
- Create a new JIRA project (requires JIRA admin privileges):
  - Specify name (same as GitHub project name)
  - Specify key (approved by Clojure core, derived from project name)
    - should usually be first char of first part with up to 5 chars of
    second part - TBENCH, DJSON, etc.
  - Specify project lead's JIRA account
  - Edit project to add url and description (same as GitHub project)
  - Set notification scheme - usually "Default scheme plus notify
    project lead"
- Setting up builds (requires Jenkins admin privileges, except step 2):
  - Create Jenkins user account for authors
  - Edit ~ci_data.clj~ in the [[https://github.com/clojure/build.ci][build.ci]] repo add the new project /
    update authors (so they can run builds / cut releases)
  - Request on clojure-dev mailing list to run build.ci Jenkins job -
    this will recreate all Jenkins job definition files!
  - Force Jenkins to reload its configuration files
- Autodoc
  - WIP
- Performing releases
  - Snapshot releases are automatically created every time the job
    builds (triggered by any source change)
    - To use snapshots, see Maven Settings and Repositories
  - Perform a release according to How to Make Releases section below

*** How to Make Releases

Prep

- Your project must have a pom.xml file with a -SNAPSHOT version
- The pom.xml file must specify a parent, the latest released version
  of pom.contrib in [[https://github.com/clojure/build.poms][build.poms]]

How to make a -SNAPSHOT release

- Your project must have a pom.xml file with a -SNAPSHOT version
- Push to "master" branch on GitHub
- Jenkins polls GitHub and builds automatically
- Or you can click "Build Now" on the project page
- Jenkins builds and uploads a uniquely-numbered JAR file to the
  [[https://oss.sonatype.org/][Sonatype OSS Snapshot Repository]]

How to make a numbered release

- The "master" branch in GitHub must have a pom.xml file with a
  -SNAPSHOT version, not a bare version number
- Log in to [[https://build.clojure.org][Jenkins]]
- Navigate to your project's job
- Click "Perform Maven Release" link on the left
- On the "Perform Maven Release" page:
  - Select "Specify one version for all modules"
  - In the "Release Version" field, enter the version number for this
    release of your project
    - This will normally be the current development version with the
      "-SNAPSHOT" suffix removed
  - In the "Development version" field, enter the version number for
    the subsequent development version of your project
    - This will end with "-SNAPSHOT"
  - Click "Schedule Maven Release Build"
- After the build completes successfully:
  - ~git pull~ on your development machine to get the new release tags
  - The release JAR file will be uploaded to the Sonatype OSS staging
    repository
  - The release will automatically be copied to the Maven Central
    repository within 24 hours (usually within 15 minutes)
- Don't forget to update the project README if it recommends a version
  to users.

Contrib Release Numbering Policy

- major.minor.patch
- Follow guidelines for accretion and fixation, not breakage, if at all
  possible

*** Coding Guidelines
:PROPERTIES:
:CUSTOM_ID: content/dev/contrib_howto#coding-guidelines
:END:

Disclaimer:

- Rules are made to be broken. Know the standards, but do not treat
  them as absolutes.

The Standards:

- Get the name and signature right. Rich strongly respects Java's
  commitment to not break existing code. In practice, that means we can
  tweak the implementation forever, but once we publish a name and
  signature we need to stick with it. (In practice I think this means
  that we want many people to review the name and sig, even if they
  don't review the implementation details.)
- Use type hints for functions that are likely to be on critical code;
  otherwise keep code simple and hint-free.
  - Only use type hints that matter. If you are not certain a type
    hint helps, don't add it.
- Use good names, and don't be afraid to collide with names in other
  namespaces. That's what the flexible namespace support is there for.
  - OTOH, using the same name with a different signature or semantics
    begs the question as to whether one of them is less than ideal.
- Be explicit and minimalist about dependencies on other packages.
  (Prefer :require :refer to :use)
- Don't use a macro when a function can do the job. If a macro is
  important for ease-of-use, expose the function version as well.
- If you are sure you have all the information at compile time, use a
  macro where it would improve performance sensitive code.
- Provide a library-level docstring.
- Provide automated tests.
- Use '?' suffix for predicates, and return booleans.
- Use '_' for destructuring targets and formal arguments names whose
  value will be ignored by the code at hand.
- Include a docstring.
- When in doubt, expose the performant version. Clojure goes to great
  lengths to enable performance when you need it, and lib should too.
  (That's why we don't have multimethod + in core, for instance.) Users
  can always create more polymorphic APIs on their own, hijacking
  symbols if they want to.
- If you take a good name that collides with core, make sure your
  semantics are parallel (possibly minus laziness). Good example of
  this is string functions that shadow core seq functions.
- Use assert and pre- and post- conditions.
- Be lazy where possible.
- Follow clojure.core's example for idiomatic names like pred and coll.
  - in fns
    - f, g, h - function input
    - n - integer input usually a size
    - index - integer index
    - x, y - numbers
    - s - string input
    - coll - a collection
    - pred - a predicate closure
    - & more - variadic input
  - in macros
    - expr - an expression
    - body - a macro body
    - binding - a macro binding vector
- Do NOT follow idioms from clojure.core's preamble code. That code
  runs in a limited environment because Clojure is not bootstrapped
  yet.
- Decompose the pieces. If your name isn't Rich, don't write a form as
  long as, say, the definition of doseq.
- Use keyword-first syntax to access properties on objects:
  ~(:property object-like-map)~
- Use collection-first syntax to extract values from a collection (or
  use get if the collection might be nil): ~(collection-like-map key)~
  or ~(get collection-like-map key)~. Note that not all collections are
  keyed by keyword.
- Idiomatic code uses destructuring a lot. However, you should only
  destructure in the arg list if you want to communicate the
  substructure as part of the caller contract. Otherwise, destructure
  in a first-line let.
- Prefer updating over setting. Many reasons: the unified update model
  provides a simple standard way to do this. Helps you discover
  commutative operations. Reduces the surface area of assumptions you
  are making about the object you are updating.
- Don't support operations on the wrong collection type. If your
  algorithm is only performant with random access, then require an arg
  that has random access.
- Use ~*earmuffs*~ only for things intended for rebinding. Don't use a
  special notation for constants; everything is assumed a constant
  unless specified otherwise.
- Use the bang! only for things not safe in an STM transaction.
- Prefer sequence-library composition over explicit loop/recur.
- Rebindable vars should be paired with scoping macros, e.g. in and
  with-in-str.
- Lazy seqs should be exposed as functions that hold only the minimum
  state needed, a.k.a. "let go of your head." Let the caller decide how
  much local memory they want to use.
- Use Klass/staticField, (Klass/staticMethod), (Klass.) and (.method
  obj) interop styles with the only exception being in
  code-generating-code where the older (. obj method) style may be
  easier to produce.
- If you present an interface that implicitly passes a parameter via
  dynamic binding (e.g. db in sql), also provide an identical interface
  but with the parameter passed explicitly.
- When providing a default case for cond, use the keyword :else as a
  condition instead of true
- To access a private var (e.g. for testing), use the @#'some.ns/var
  form
- Protocols:
  - One should only extend a protocol to a type if they own either the
    type or the protocol.
  - If one breaks the previous rule, they should be prepared to
    withdraw, should the implementor of either provide a definition
  - If a protocol comes with Clojure itself, avoid extending it to
    types you don't own, especially e.g. java.lang.String and other
    core Java interfaces. Rest assured if a protocol should extend to
    it, it will, else lobby for it.
    - The motive is, as stated by Rich Hickey, to prevent "people
      extend protocols to types for which they don't make sense, e.g.
      for which the protocol authors considered but rejected an
      implementation due to a semantic mismatch.". "No extension will
      be there (by design), and people without sufficient
      understanding/skills might fill the void with broken ideas."

** Contrib Libraries
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/contrib_libs.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/contrib_libs
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-02-04
:CUSTOM_ID: content/dev/contrib_libs
:END:

Clojure is an umbrella level project that hosts many additional
libraries called /Clojure contrib/, which all exist under the
[[https://github.com/clojure][Clojure organization]] on GitHub.

These libraries use the same contribution model ([[#content/dev/contributor_agreement][Contributor
Agreement]], license, and copyright) as Clojure itself, and a shared
infrastructure maintained by the Clojure core team:

- Source control - Git libraries on GitHub
- Issues - [[https://clojure.atlassian.net/projects/CLJ][JIRA]]
- Development model - patches in JIRA, no PRs
- Continuous integration - [[https://build.clojure.org][Jenkins]]
- Doc generation and hosting - [[https://tomfaulhaber.github.io/autodoc/][Autodoc]] and GitHub [[https://clojure.github.io/][pages]]
- Builds - Maven with deployment to Maven Central under the groupId
  ~org.clojure~

Every project has one or more owners (often community members) who
determine the direction of their library, triage patches, etc. Project
owners have full commit rights and authenticated access to their project
on the build box for releases.

Contrib libraries are open source libraries, like any other open source
Clojure library. They vary widely in development activity and quality
and may or may not be the best alternative for their functionality in
the overall ecosystem. You should evaluate them before use as you would
any open source library you intend to use as a dependency.

If you find that active development for a library has ceased and you
would like to take over as owner, please contact
[[mailto:clojure@cognitect.com][clojure@cognitect.com]]. Good stewards for a library typically tend to
be those actively using the library and knowledgable about the goals
and alternatives of the functionality.

*** Contrib Libraries

Status legend:

- Active - under active regular development
- Stable - working but development is irregular
- Inactive - no longer in development, will not be worked on again

| Lib                | Description                                                 | Owner                           | Status   |
|--------------------+-------------------------------------------------------------+---------------------------------+----------|
| [[https://clojure.github.io/algo.generic/][algo.generic]]       | Generic versions of common functions                        | Konrad Hinsen                   | Stable   |
| [[https://clojure.github.io/algo.monads/][algo.monads]]        | Monad macros and Definitions                                | Konrad Hinsen                   | Stable   |
| [[https://clojure.github.io/core.async/][core.async]]         | Facilities for asynchronous programming and communication   | Rich Hickey                     | Active   |
| [[https://clojure.github.io/core.cache/][core.cache]]         | A caching library implementing various cache strategies     | Sean Corfield                   | Active   |
| [[https://clojure.github.io/core.contracts/][core.contracts]]     | Contracts programming in Clojure                            | Fogus                           | Inactive |
| [[https://clojure.github.io/core.incubator/][core.incubator]]     | Functions proposed for core inclusion                       |                                 | Inactive |
| [[https://clojure.github.io/core.logic/][core.logic]]         | A logic programming library based on miniKanren             | David Nolen                     | Stable   |
| [[https://clojure.github.io/core.match/][core.match]]         | Pattern match and predicate dispatch                        | David Nolen                     | Stable   |
| [[https://clojure.github.io/core.memoize/][core.memoize]]       | A manipulable, pluggable, memoization framework             | Sean Corfield                   | Active   |
| [[https://clojure.github.io/core.rrb-vector/][core.rrb-vector]]    | RRB-Tree-based vectors                                      | Michał Marczyk, Andy Fingerhut  | Active   |
| [[https://clojure.github.io/core.typed/][core.typed]]         | Gradual typing                                              | Ambrose Bonnaire-Sargent        | Active   |
| [[https://clojure.github.io/core.unify/][core.unify]]         | Unification library                                         | Fogus                           | Stable   |
| [[https://clojure.github.io/data.avl/][data.avl]]           | AVL trees                                                   | Michał Marczyk                  | Stable   |
| [[https://clojure.github.io/data.codec/][data.codec]]         | Native codec implementations                                | Alexander Taggart               | Stable   |
| [[https://clojure.github.io/data.csv/][data.csv]]           | Reading and writing CSV files                               | Jonas Enlund                    | Stable   |
| [[https://clojure.github.io/data.finger-tree/][data.finger-tree]]   | Finger trees                                                | Chouser                         | Stable   |
| [[https://clojure.github.io/data.fressian/][data.fressian]]      | Extensible binary Data Notation                             | Stuart Halloway                 | Stable   |
| [[https://clojure.github.io/data.generators/][data.generators]]    | Random data generators                                      | Stuart Halloway                 | Inactive |
| [[https://clojure.github.io/data.int-map/][data.int-map]]       | Maps and sets optimized for integer keys                    | Alex Miller                     | Stable   |
| [[https://clojure.github.io/data.json/][data.json]]          | JSON encoding / decoding                                    | Stuart Sierra                   | Stable   |
| [[https://clojure.github.io/data.priority-map/][data.priority-map]]  | Priority maps                                               | Mark Engelberg                  | Stable   |
| [[https://clojure.github.io/data.xml/][data.xml]]           | Lazy XML parsing                                            | Ryan Senior, Herwig Hochleitner | Stable   |
| [[https://clojure.github.io/data.zip/][data.zip]]           | Manipulating zippers                                        |                                 | Stable   |
| [[https://clojure.github.io/java.classpath/][java.classpath]]     | Classpath utilities                                         | Stuart Sierra                   | Stable   |
| [[https://clojure.github.io/java.data/][java.data]]          | Work with Java Beans                                        | Sean Corfield                   | Active   |
| [[https://clojure.github.io/java.jdbc/][java.jdbc]]          | JDBC-based SQL interface                                    | Sean Corfield                   | Stable   |
| [[https://clojure.github.io/java.jmx/][java.jmx]]           | JMX interface                                               | Nick Bailey                     | Stable   |
| [[https://clojure.github.io/math.combinatorics/][math.combinatorics]] | Lazy sequences for common combinatorial functions           | Mark Engelberg                  | Stable   |
| [[https://clojure.github.io/math.numeric-tower/][math.numeric-tower]] | Math functions and numeric tower                            | Mark Engelberg                  | Stable   |
| [[https://clojure.github.io/test.check/][test.check]]         | Property testing framework                                  | Alex Miller                     | Active   |
| [[https://clojure.github.io/test.generative/][test.generative]]    | Test data generation and execution harness                  | Stuart Halloway                 | Inactive |
| [[https://clojure.github.io/tools.analyzer/][tools.analyzer]]     | Analyzer framework for Clojure code                         | Nicola Mometto                  | Active   |
| [[https://clojure.github.io/tools.analyzer.jvm/][tools.analyzer.jvm]] | JVM-specific passes for tools.analyzer                      | Nicola Mometto                  | Active   |
| [[https://clojure.github.io/tools.build/][tools.build]]        | Functions for writing Clojure build programs                | Alex Miller                     | Active   |
| [[https://clojure.github.io/tools.cli/][tools.cli]]          | Command-line argument processor                             | Sean Corfield                   | Active   |
| [[https://clojure.github.io/tools.deps.alpha/][tools.deps.alpha]]   | Tools for dependency management and classpath construction  | Alex Miller                     | Active   |
| [[https://clojure.github.io/tools.deps.graph/][tools.deps.graph]]   | Create dependency graphs for deps.edn projects              | Alex Miller                     | Active   |
| [[https://clojure.github.io/tools.gitlibs/][tools.gitlibs]]      | Tools for retrieving, caching, and using git-based projects | Alex Miller                     | Active   |
| [[https://clojure.github.io/tools.emitter.jvm/][tools.emitter.jvm]]  | JVM bytecode generator                                      | Nicola Mometto                  | Active   |
| [[https://clojure.github.io/tools.logging/][tools.logging]]      | Logging tools                                               | Alexander Taggart               | Active   |
| [[https://clojure.github.io/tools.macro/][tools.macro]]        | Tools for macro writers                                     | Konrad Hinsen                   | Stable   |
| [[https://clojure.github.io/tools.namespace/][tools.namespace]]    | Tools for working with namespace declarations               | Stuart Sierra                   | Stable   |
| [[https://clojure.github.io/tools.nrepl/][tools.nrepl]]        | Network REPL                                                |                                 | Inactive |
| [[https://clojure.github.io/tools.reader/][tools.reader]]       | Clojure reader                                              | Nicola Mometto                  | Active   |
| [[https://clojure.github.io/tools.tools/][tools.tools]]        | A Clojure CLI tool for managing CLI tools                   | Alex Miller                     | Active   |
| [[https://clojure.github.io/tools.trace/][tools.trace]]        | Execution tracing                                           | Luc Prefontaine                 | Stable   |

*** Core Libraries

Additionally, the following libraries are dependencies of Clojure itself
managed directly by the core team. These libraries use the same shared
infrastructure as the Contrib libraries, so are largely the same in that
regard. Development in these libraries is often linked to development in
the core language itself.

- [[https://clojure.github.io/core.specs.alpha/][core.specs.alpha]] Specs for clojure.core
- [[https://clojure.github.io/spec.alpha/][spec.alpha]] Describing the structure of data and functions with specs
- [[https://clojure.github.io/spec-alpha2/][spec-alpha2]] In-development next version of spec

And finally, there are some repositories in the Clojure GitHub
organization that are not libraries at all:

- [[https://github.com/clojure/clojure-site/][clojure-site]] - this web site, see [[#content/community/contributing_site][Site Contributions]]
- [[https://github.com/clojure/clojurescript-site/][clojurescript-site]] - [[https://clojurescript.org]] web site
- [[https://github.com/clojure/brew-install/][brew-install]] - ~clj~ installer builds
- [[https://github.com/clojure/build.ci/][build.ci]] - Jenkins project builder for contrib
- [[https://github.com/clojure/build.poms/][build.poms]] - Maven super pom for contrib libs
- [[https://github.com/clojure/clojure-api-doc/][clojure-api-doc]] - Clojure api doc builder
- [[https://github.com/clojure/contrib-api-doc/][contrib-api-doc]] - contrib lib api doc builder

*** History

Prior to Clojure 1.3, Clojure had a single "batteries included"
library called clojure-contrib that consisted of many independent
helper namespaces contributed by the community. In the Clojure 1.3
timeframe, this library was split into the independent libraries that
exist today with independent owners. Some of the namespaces were seen
as experimental and not promoted into any public library. Stuart
Sierra recounts this in more detail in his [[#content/news/2012/02/17/clojure-governance][post]].

At the time there was an idea that some of the contrib libraries could
eventually be promoted into Clojure's core library itself. With time,
there has been a desire to keep Clojure's core library small and to
allow these independent libraries to stay independent and evolve at
their own pace.

Also see [[#content/dev/contrib_history][Contrib History]] for some legacy history of the contrib
split.

*** Contrib How-To

Some older content on participating or contributing to contrib can be
found at [[#content/dev/contrib_howto][Contrib How-To]].

** Contributor Agreement
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/contributor_agreement.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/contributor_agreement
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-01-15
:CUSTOM_ID: content/dev/contributor_agreement
:END:

Following the lead of other open source projects, the Clojure project
requires contributors to jointly assign their copyright on contributed
code. The [[https://secure.na1.echosign.com/public/hostedForm?formid=95YMDL576B336E][Contributor Agreement]] (CA) gives Rich Hickey and the
contributor joint copyright interests in the code: the contributor
retains copyrights while also granting those rights to Rich Hickey as
the open source project sponsor.

The CA is derived from the Oracle Contributor Agreement (OCA), used
for OpenJDK, Netbeans and OpenSolaris projects and others. There is a
good [[http://www.oracle.com/technetwork/oca-faq-405384.pdf][OCA FAQ]] answering many questions.

The CA does not change the rights or responsibilities of the Clojure
community under the [[http://opensource.org/licenses/eclipse-1.0.php][Eclipse Public License (EPL)]]. By executing the CA,
contributors protect the Clojure code base, enable alternative
licensing models, and protect the flexibility to adapt the project to
the changing demands of the community. In order for the CA to be
effective, the Clojure project must obtain an assignment for all
contributions. Please review the CA for a complete understanding of
its terms and conditions. By contributing source code or other
material to Clojure, you represent that you have a CA with Rich Hickey
for such contributions. In order to track contributors, you understand
that your full name and username may be posted on a web page listing
authorized contributors that is accessible via a public URL.

*** Instructions for submitting the agreement

- Fill out and submit the [[https://secure.na1.echosign.com/public/hostedForm?formid=95YMDL576B336E][Contributor Agreement]] (an online e-form)

*** Contributors

See the full [[#content/dev/contributors][list of contributors]] that have signed the Clojure
Contributor Agreement.

*** Contributed patches to Clojure:

- Aaron Bedra
- Aaron Cohen
- Achim Passen
- Adam Clements
- Alan Dipert
- Alan Malloy
- Alexander Yakushev
- Alex Miller
- Alex Osborne
- Alex Ott
- Alex Redington
- Alexander Kiel
- Alexander Taggart
- Alexander Yakushev
- Alf Kristian Stoyle
- Allen Rohner
- Ambrose Bonnaire-Sergeant
- Andrei Kleschinski
- Andrew Rosa
- Andy Fingerhut
- Andy Sheldon
- Anthony Grimes
- Aspasia Beneti
- Baishampayan Ghose
- Ben Bader
- Ben Smith-Mannschott
- Benjamin Teuber
- Blake West
- Bozhidar Batsov
- Brandon Bloom
- Brenton Ashworth
- Brian Hurt
- Brian Taylor
- Bruce Adams
- Cameron Desautels
- Cezary Kosko
- Chad Taylor
- Chas Emerick
- Chris Gray
- Chris Houser
- Chris Perkins
- Christoffer Sawicki
- Christophe Grand
- Christopher Redinger
- Clinton R. Nixon
- Colin Jones
- Cosmin Stejerean
- Daniel Compton
- Daniel Solano Gómez
- David Bürgin
- David Liebke
- David McNeil
- David Miller
- David Powell
- David Rupp
- David Santiago
- Devender Gollapally
- Devin Walters
- Dimitry Gashinsky
- Drew Raines
- Ed Bowler
- Eli Lindsey
- Eric Schoonover
- Erik Assum
- Eugene Kostenko
- Federico Brubacher
- Frantisek Sodomka
- Gabriel Horner
- Gary Fredericks
- George Jahad
- Gerrit Jansen Van Vuuren
- Ghadi Shayban
- Gijs Stuurman
- Gordon Syme
- Greg Leppert
- Herwig Hochleitner
- Howard Lewis Ship
- Hubert Iwaniuk
- Hugo Duncan
- Immo Heikkinen
- James Reeves
- Jarkko Oranen
- Jason Wolfe
- Jason Whitlark
- Jean Niklas L'orange
- Jeremy Heiler
- Joe Gallo
- Johan Mena
- John Szakmeister
- Jonas Enlund
- Jozef Wagner
- Juha Arpiainen
- Justin Balthrop
- Justin Kramer
- Karsten Schmidt
- Kevin Downey
- Konrad Hinsen
- Kurt Harriger
- Kwang Yul Seo
- Laurent Petit
- Lauri Pesonen
- Lee Yen-Chin
- Luke VanderHart
- Mark Simpson
- Matt Revelle
- Matthew Boston
- Matthew Gilliard
- Max Penet
- Meikel Brandmeyer
- Micah Martin
- Michael Blume
- Michael Fogus
- Michał Marczyk
- Michel Alexandre Salim
- Michiel Borkent
- Mike Anderson
- Mike Hinchey
- Nahuel Greco
- Nicola Mometto
- Nicolas Buduroi
- Nikita Prokopov
- Nola Stowe
- Oliver Caldwell
- Paul M Bauer
- Paul Stadig
- Pepijn de Vos
- Phil Hagelberg
- Philip Aston
- Philip Potter
- Piotr Zygielo
- Ragnar Dahlén
- Ralf Schmitt
- Rasmus Svensson
- Rich Hickey
- Richard Newman
- Robert Lachlan
- Ruslan Al-Fakikh
- Russ Olsen
- Scott Lowe
- Sean Corfield
- Sean Devlin
- Sebastien Martel
- Shogo Ohta
- Stefan Kamphausen
- Steffen Dienst
- Stephen C. Gilardi
- Steve Miner
- Steven Yi
- Stuart Halloway
- Stuart Sierra
- Tassilo Horn
- Tim Dysinger
- Tim McCormack
- Timothy Baldridge
- Timothy Pratley
- Toby Crawley
- Tom Faulhaber
- Tomasz Nurkiewicz
- Tsutomu Yano
- Vipul Amler
- Yanxiang Lou
- Yegor Timoshenko
- Zach Tellman
- Zhuang XiaoDan

*Many thanks for your contributions to Clojure!*

** Contributors
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/contributors.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/contributors
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-02-25
:CUSTOM_ID: content/dev/contributors
:END:

Below is a list of all signers of the Clojure [[#content/dev/contributor_agreement][Contributor Agreement]].

*** /Signed Contributor Agreement:/

| Name                                      | GitHub User                   |
|-------------------------------------------+-------------------------------|
| Sam Aaron                                 |                               |
| Marshall Abrams                           | mars0i                        |
| Earle Acosta                              | eacosta                       |
| William Acton                             | Lokeh                         |
| Ricardo J. Acuna                          | drakezhard                    |
| David Adair                               | adairdavid                    |
| Brandon J Adams                           | emidLn                        |
| Bruce Adams                               | bruceadams                    |
| Mark Addleman                             | markaddleman                  |
| Matthew Adereth                           | adereth                       |
| Rohit Aggarwal                            | ducky427                      |
| Ivan Alberto Perdomo Aguilar              | iperdomo                      |
| Gunnar Ahlberg                            |                               |
| Misha Akovantsev                          | akovantsev                    |
| Trent Albright                            | talbright                     |
| Aleksandr                                 | sherpc                        |
| J. Alex                                   | alexkyllo                     |
| Neill Alexander                           |                               |
| James Aley                                | jaley                         |
| Ruslan Al-Fakikh                          | metaruslan                    |
| Sean Allen                                |                               |
| Zachary Allaun                            | zachallaun                    |
| Jennifer Alons                            | jenniferalons                 |
| alejandro Alvarado                        | Aljendro                      |
| Raphaël Amìard                            | raph-amiard                   |
| Nada Amin                                 | Namin                         |
| Vipul Amler                               | vipulnsward                   |
| Lawrence An                               | lambda-alpha-omega            |
| Andre Luis Anastacio                      | ndrluis                       |
| Harold Ancell                             | hga                           |
| Craig Andera                              |                               |
| Jeremy Anderson                           | punkisdead                    |
| Matt Anderson                             | manderson202                  |
| Mike Anderson                             | mikera                        |
| Timothy Andrew                            | timothyandrew                 |
| Christopher Michael Andrews               | Chris-Andrews                 |
| Nguyen Tuan Anh                           | ubolonton                     |
| Takashi Aoki                              | federkasten                   |
| Nicholas Antonov                          | nicholasantonov               |
| Teemu Antti-Poika                         | anttipoi                      |
| Fredrik Appelberg                         |                               |
| Jeremy Apthorp                            | nornagon                      |
| Aleksandr Argunov                         | troglotit                     |
| Joshua Arnold                             |                               |
| Juha Arpiainen                            |                               |
| Steve Ashton                              | sashton                       |
| Brenton Ashworth                          |                               |
| Amir Askari                               | naha7789                      |
| Erik Assum                                | slipset                       |
| Philip Aston                              | phiipa, philipa               |
| Atamert                                   | muhuk                         |
| Aditya Athalye                            | adityaathalye                 |
| Thomas Athorne                            | thomasathorne                 |
| Aleh Atsman                               | atsman                        |
| Charlton G. Austin                        | charlton.austin               |
| Nate Austin                               |                               |
| Aggelos Avgerinos                         | eavgerinos                    |
| Avicenna                                  | mavbozo                       |
| Avichal                                   | avichalp                      |
| Francis Avilla                            | favilla                       |
| Santhos Baala RS                          | santhosballa                  |
| Ivan Babanin                              | babanin                       |
| Josep M. Bach                             | txus                          |
| Ben Bader                                 | benjamin-bader                |
| Nandan Bagchee                            |                               |
| Eric Bailey                               | yurrriq                       |
| Nick Bailey                               | nickmbailey                   |
| Andrew Baine                              |                               |
| Benjamin Baker-Smith                      | bbakersmith                   |
| Timothy Baldridge                         | halgari                       |
| Plinio M. Balduino                        | pbalduino                     |
| Scott Bale                                | scottbale                     |
| Donald Ball                               | dball                         |
| Joshua Ballanco                           | jballanc                      |
| Michael Ballantyne                        | michaelballantyne             |
| Justin Balthrop                           |                               |
| Ashish Banerjee                           | innomon                       |
| Alex Baranosky                            | abaranosky                    |
| Rafal Baranowicz                          | kmicu                         |
| Guy Barlow                                | rockbreaker                   |
| Max Barnash                               | arr-ee                        |
| Julio Barnes                              |                               |
| Luca Barozzi                              | icamts                        |
| Cameron Barre                             | cjbarre                       |
| Leon Barrett                              | leon-barrett                  |
| Tiago Barreto                             | tiagobarreto                  |
| Julio Barros                              |                               |
| Paul Barry                                |                               |
| Jake Basile                               | jakerbasile                   |
| Bozhidar Batsov                           | bbatsov                       |
| Paul Batum                                |                               |
| Denis Baudinot                            | dgb23                         |
| Paul Bauer                                |                               |
| Jochen Bedersdorfer                       | beders                        |
| Bradley Beck                              | bradbeck                      |
| Ulrich Becker                             | kassapo                       |
| Aaron Bedra                               |                               |
| Rick Beerendonk                           | rickbeerendonk                |
| Mikita Belahlazau                         | nbeloglazov                   |
| Simon Belak                               | sbelak                        |
| Daniel Bell                               | invaliduser                   |
| Adrian Bendel                             | abp                           |
| Aspasia Beneti                            | aspasia                       |
| Sebastian Bensusan                        | bensu                         |
| Jonah Benton                              | jonahbenton                   |
| Nicolas Berger                            | nberger                       |
| Julio Berina                              | julioberina                   |
| Paul Bernard                              |                               |
| Trevor Bernard                            | trevorbernard                 |
| Fabio Bernasconi                          | instilled                     |
| Francois Bernier                          | fbernier                      |
| Alec Berryman                             |                               |
| Ferdinand Beyer                           | ferdinand-beyer               |
| Hitesh Bhagchandani                       | hit023                        |
| Pranav Bhaskar                            | CoderPrans                    |
| Chris Johnson Bidler                      | hlprmnky                      |
| Bijoy                                     | bijoyv                        |
| Aysylu Biktimirova                        | aysylu                        |
| Chris Bilson                              | cbilson                       |
| Sifou Biri                                | bsifou                        |
| Pradeep Bishnoi                           | pradeepbishnoi                |
| Darrell Bishop                            |                               |
| Ian Bishop                                | ianbishop                     |
| Jordan Bisserkov                          | biserkov                      |
| Raju Bitter                               | raju-bitter                   |
| Matias Bjarland                           | mbjarland                     |
| Victor Bjelkhholm                         | victorb                       |
| Terje Sten Bjerkseth                      | Terjesb                       |
| Matthew Blair                             | mblair                        |
| Martin Blais                              |                               |
| Armando Blancas                           |                               |
| Austin Blatt                              | austb                         |
| Milan Blazek                              | skallet                       |
| John C Bledsoe                            | jcbledsoe                     |
| Donald Bleyl                              | dbleyl                        |
| Laurens BLoemen                           | TGThorax                      |
| Chris Blom                                | ChrisBlom                     |
| Jim Blomo                                 | jblomo                        |
| Brandon Bloom                             | brandonbloom                  |
| Nils Blum-Oeste                           | nblumoe                       |
| Michael Blume                             | MichaelBlume                  |
| Christian Blunden                         | christianblunden              |
| Marshall T. Bockrath-Vandegrift           | llasram                       |
| Stefan Bodewig                            | bodewig                       |
| Friedrich Boeckh                          | fbmnds                        |
| Joel Boehland                             | jolby                         |
| Sven Boekhoff                             | sboekhoff                     |
| Robin Bate Boerop                         | robinbb                       |
| Noah Bogart                               | NoahTheDuke                   |
| Kovas Boguta                              | kovasb                        |
| Vladimir Bokov                            | razum2um                      |
| Andrei Boltachev                          | andrewboltachev               |
| Bruno Bonacci                             | BrunoBonacci                  |
| Ambrose Bonnaire-Sergeant                 | frenchy64                     |
| Jeremy Bondeson                           |                               |
| Rinu Boney                                | rinuboney                     |
| Kuldeep Bora                              | kul                           |
| Renzo Borgatti                            | reborg                        |
| Leonardo Borges                           | leonafdoborges                |
| Michiel Borkent                           | borkdude                      |
| Berend Adam Bos                           | benbos67                      |
| Jonathan Boston                           | bostonou                      |
| Matthew Boston                            | bostonaholic                  |
| Ed Bowler                                 |                               |
| Brad Bowman                               |                               |
| Curtis Bowman                             | narwally                      |
| Michael Bradley                           | michaelsbradleyjr             |
| Lucas Bradstreet                          | lbradstreet                   |
| Stephen D. Brady                          | stephenbrady                  |
| Meikel Brandmeyer                         | mb, mikesh                    |
| Joshua Brandoff                           | EmergentBehavior              |
| Jamie Brandon                             | Jamii                         |
| Arne Brasseur                             | plexus                        |
| Stig Brautaset                            | stig                          |
| Pieter Willem Abram Breed                 | pieterbreed                   |
| Andrew Brehaut                            |                               |
| Miron Brezuleanu                          |                               |
| Lance Bradley                             |                               |
| Andreas Brenk                             |                               |
| Benjamin Brinckerhoff                     | bhb                           |
| Simon Brooke                              | simon-brooke                  |
| Aaron Brooks                              | abrooks                       |
| Timothy Brooks                            | tbrooks8                      |
| Christopher Brown                         | chbrown                       |
| Rob Browning                              | rlbdv                         |
| Vince Broz                                | apiology                      |
| Craig Brozefsky                           | craigbrozefsky/craigbro       |
| Federico Brubacher                        |                               |
| Michael Bruce                             | michaelbruce                  |
| Nicolas Brugneaux                         | nicolasbrugneaux              |
| Kendall Buchanan                          | kendagriff                    |
| Logan Buckley                             | loganmhb                      |
| Peter Buckley                             |                               |
| Timothy P. Buckley                        | timbuckley                    |
| Nicolas Buduroi                           |                               |
| Bogdan Bugarschi                          | boogie666                     |
| Jan-Paul Bultmann                         | ticking                       |
| Matt Burbridge                            | mmb90                         |
| David Burgin                              | glts                          |
| Alex Burka                                | durka                         |
| Christopher Burke                         | caburke                       |
| Daniel R. Burton                          | danburton                     |
| Kyle Burton                               |                               |
| Carlos Antonio Neira Bustos               | cneira                        |
| Paul Butcher                              | paulbutcher                   |
| Dylan C. Butman                           | pleasetrythisathome           |
| Fergal Byrne                              | fergalbyrne                   |
| Myles Byrne                               | quackingduck                  |
| David Cabana                              | drcabana                      |
| Stephan Cagle                             |                               |
| Bobby Calderwood                          |                               |
| Oliver Caldwell                           | Olical                        |
| Ricardo Martinez Calvo                    | rack don                      |
| Bahadir Cambel                            | bcambel                       |
| Michael Camilleri                         | pyrmont                       |
| Lance Campbell                            | lkcampbell                    |
| Stuart Campbell                           | harto                         |
| Renzo Italo Canepa Garay                  | rcanepa                       |
| Vincent Cantin                            | green-coder                   |
| James Carnegie                            | kipzter                       |
| Christopher W. Carpenter                  | mordocai                      |
| Brian Carper                              | briancarper                   |
| Kevin Casey                               | kevinjamescasey               |
| James Cash                                | jamesnrc                      |
| Eric Caspary                              | ERR                           |
| Charles Cassel                            | casselc                       |
| Andrew Cavallaro                          | andrewcavallaro               |
| Enzzo Cavallo                             | souenzzo                      |
| Marcus Cavanaugh                          |                               |
| Bruno Kim Medeiros Cesar                  | Brumokim                      |
| Andy Chambers                             | cddr                          |
| Austin Chamberlin                         | AustinC                       |
| David Chelimsky                           | dchelimsky                    |
| Jonathan Chen                             | dijonkitchen                  |
| Xi Chen                                   | zacharymorn                   |
| Dustin Cheng                              | DustinCheng                   |
| Kirill Chernyshov                         | DeLaGuardo                    |
| Prasant Chidella                          | prasant94                     |
| John Chijioke                             | johnbendi                     |
| Beura (Trey) A Childs III                 | treychilds                    |
| Alex Chin                                 |                               |
| Liu Chong                                 | liuchong                      |
| Burin Choomnuan                           | agilecreativity               |
| Antoine Choppin                           | japonophile                   |
| Eric Christensen                          | ecounysis                     |
| Russell Christopher                       | russellc                      |
| Nicholas Chubrich                         | nchubrich                     |
| Michael O. Church                         | michaelochurch                |
| Jonathan Claggett                         |                               |
| Matt Clark                                |                               |
| Casper Clausen                            | casperc                       |
| Martin Albert Clausen                     | maacl                         |
| Adam Clements                             | AdamClements                  |
| Tim Clemons                               | timclemons                    |
| Tobias Daniek Clemson                     | tobyclemson                   |
| Troy Clevenger                            | dethstryke                    |
| Salvador Cobian                           | salcobian                     |
| Christopher Codrington                    |                               |
| Aaron Cohen                               |                               |
| Ronen Cohen                               | nenorbot                      |
| Will Cohen                                | willcohen                     |
| Mike Coleman                              |                               |
| Drew Colthorp                             |                               |
| Josh Comer                                | jjcomer                       |
| Stephen Compall                           | S11001001                     |
| Daniel Compton                            | danielcompton                 |
| Eno Compton                               | enocom                        |
| Justin Conklin                            | jgpc42                        |
| Thomas Connors                            | tomconnors                    |
| James Conroy-Finn                         | jcf                           |
| Juan José Conti                           | jjconti                       |
| Ben Cook                                  | blx                           |
| Mary Rose Cook                            | maryrosecook                  |
| Brian L. Cooley                           | blcooley                      |
| Kyle Cordes                               |                               |
| Roger Corman                              |                               |
| Sean Corfield                             |                               |
| Giacomo Cosenza                           | magomimmo                     |
| Mark Countryman                           |                               |
| Jason Courcoux                            | jasoncourcoux                 |
| Matthew Courtney                          | macourtney                    |
| Alex Coventry                             |                               |
| Aaron Craelius                            | aaronc                        |
| Daniel Craig                              | danielmartincraig             |
| Thomas Crayford                           | tcrayford                     |
| Tobias Crawley                            | tobias                        |
| Dennis Crenshaw                           |                               |
| Jim Crossley                              | jcrossley3                    |
| Andrea Crotti                             | AndreaCrotti                  |
| Aaron Crow                                |                               |
| Robert Culliton                           | rcullito                      |
| Adrian Cumiskey                           | lambdachops                   |
| Paulo Cesar Cuneo                         | paulocesarcuneo               |
| Josué Cunha dos Santos                    | josuesantos1                  |
| Arlen Christian Mart Cuss                 | unnali                        |
| Artur Cygan                               | arcz                          |
| Terje Dahl                                | terjedahl                     |
| Ragner Dahlen                             | ragnard                       |
| Michael S. Daines                         | defndaines                    |
| Wilder Lucio da Silva                     | wilkerlucio                   |
| Tom Danielsen                             |                               |
| Robert Danitz                             | rdanitz                       |
| Nathan Dao                                | nathandao                     |
| Joshua Davey                              | jdavey                        |
| Matthew Davidson                          | kingMob                       |
| Gareth Davies                             | Taffowl                       |
| Charles M. Davis                          | mdavis-liaison                |
| Brian Dawn                                | brian-dawn                    |
| Marc Nevin Daya                           | sinstral                      |
| Daniel De Aguiar                          | ddeaguiar                     |
| Luis Guilherme P. de Almeida              | luiguip                       |
| Gary Leroy Deer                           | gdeer81                       |
| Paul deGrandis                            |                               |
| Steven Degutis                            | sdegutis                      |
| David Della Costa                         | ddellacosta                   |
| Ryan De La Torre                          | rdgelato                      |
| Mike DeLaurentis                          |                               |
| John Louis Del Rosario                    | john2x                        |
| Santiago de Pedro                         | xerp                          |
| Vincent De Munckm                         | vincent-dm                    |
| Lake Denman                               | ldenman                       |
| Steven Deobald                            | deobald                       |
| Mark Derricutt                            |                               |
| Cameron Desautels                         | camdez                        |
| Francois De Serres                        | justiniac                     |
| Adityo Deshmukh                           |                               |
| Gurudev Devanla                           | gdevanla                      |
| Sean Devlin                               |                               |
| Pepijn de Vos                             |                               |
| Sacha De Vos                              | cark                          |
| Jonas De Vuyst                            | jdevuyst                      |
| Suminda Sirinath Salpitikorala Dharmasena | sirinath                      |
| Dhruv                                     | dhruvp                        |
| Pietro Francesco Menna Ruiz Diaz          | pietromenna                   |
| Steffen Dienst                            | smee                          |
| Aaron Diep                                | hddmet                        |
| Jeffrey Dik                               |                               |
| Daniel Dillinger                          | ddillinger                    |
| Justin Dillon                             | level512mage                  |
| Tejas Dinkar                              | gja                           |
| Daniel Dinnyes                            | dadinn                        |
| Alan Dipert                               |                               |
| Jon Distad                                |                               |
| Alex Dixon                                | alex-dixon                    |
| Leandro Doctors                           | allentiak                     |
| Gal Dolber                                | galdolber                     |
| Andrew Dolby                              | adolby                        |
| Jose Donizetti de Brito Junior            | josedonizetti                 |
| Daniel Dorman                             | dandorman                     |
| Paul Dorman                               | PntBlnk                       |
| Mike Douglas                              | fanatico                      |
| Alex Dowad                                | alexdowad                     |
| Kevin Downey                              | hiredman                      |
| John Downs                                | munk                          |
| Brian Doyle                               | heyzeus23                     |
| Chris Drane                               | csdrane                       |
| Reid Draper                               | reiddraper                    |
| Benjamin Dreux                            | benzen                        |
| Martynas Drobulis                         | mdrobulis                     |
| Michael Drogalis                          |                               |
| Michael du Breuil                         | wickedshell                   |
| Eugen Dück                                |                               |
| Jim Duey                                  |                               |
| Charles Duffy                             |                               |
| Ionut Florin Duma                         | ahito89                       |
| Hugo Duncan                               |                               |
| Justin Michael Duncan                     | justind85                     |
| James Michael Dupont                      | h4ck3rm1k3                    |
| Baptiste Dupuch                           | dupuchba                      |
| Eudis Duran                               | eudisd                        |
| Holger Dürer                              | h.duerer                      |
| Bruce L. Durling                          | otfrom                        |
| Lydéric Dutillieux                        | lyderichti59                  |
| Francois du Toit                          | bluegray                      |
| Pieter du Toit                            | symfrog                       |
| Samuel Duursma                            | sdduursma                     |
| Venkata Deepankar Duvvuru                 | dvdreddy                      |
| Vijaya Kiran Duvvuri                      | vijaykiran                    |
| Eric Dvorsak                              | yenda                         |
| Mieczyslaw Daniel Dyba                    | dyba                          |
| Tim Dysinger                              |                               |
| Arthur Edelstein                          | arthuredelstein               |
| Lukas Eder                                | lukaseder                     |
| Vijay Edwin                               | vxe                           |
| Miles Egan                                |                               |
| Christian Egli                            | egli                          |
| Bobby Eickhoff                            | beickhoff                     |
| Oliver Eidel                              | olieidel                      |
| J. David Eisenberg                        | jdeisenburg                   |
| Bonnie Eisenman                           | boniee                        |
| Magnus Ekstrand                           |                               |
| Oussama el Arbaoui                        | oussamaelarbaoui              |
| Trevis Elser                              | telser                        |
| Julien Eluard                             | jeluard                       |
| Jacob Emcken                              | jacobemcken                   |
| Chas Emerick                              | cemerick                      |
| Chris Emerson                             | functionalhuman               |
| Alex Engelberg                            | aengleberg                    |
| Mark Engelberg                            | puzzler                       |
| Jeff Engebretsen                          | JeffEngebretsen               |
| Jamie English                             | english                       |
| Jonas Enlund                              | jonase                        |
| Ilya Epifanor                             | hajile                        |
| Balint Erdi                               | balint                        |
| Janos Erdos                               | erdos                         |
| Petter Eriksson                           | petterik                      |
| Robert Ernst                              | BobErnst                      |
| Samuel G. Estep                           | samestep                      |
| Paulus Esterhazy                          | pesterhazy                    |
| Daniel Estevez                            | danielef                      |
| Ian Eure                                  | ieure                         |
| Adam Eury                                 | aleury                        |
| Kenny Evitt                               | kenny-evitt                   |
| Robert Ewald                              | robewald                      |
| Tim Ewald                                 |                               |
| Robert C. Faber                           | bubskee                       |
| Juan Martin Munoz Facorro                 | jfacorro                      |
| Joseph Fahey                              | josf                          |
| Frank Failla                              |                               |
| Liam Falconer                             | lfn3                          |
| Bruce Fancher                             |                               |
| Julien Fantin                             | julienfantin                  |
| Matthew Farrell                           | farrellm                      |
| William K Farrell                         | wkf                           |
| Adam Feldman                              | adamfeldman                   |
| Ian Fernandez                             | ianffcs                       |
| Fabrizio Ferrai                           | ff-                           |
| Tom Faulhaber                             |                               |
| Graham Fawcett                            | gmfawcett                     |
| Benedek Fazekas                           | benedekfazekas                |
| Faraz Fazli                               | farazfazli                    |
| Edipo Luis Fedele                         | edipofederle                  |
| Mark Feeney                               | overthink                     |
| Jason Felice                              | eraserhd                      |
| Osbert Feng                               | osbert                        |
| Fabrizio Ferrai                           | ff-                           |
| Abe Fettig                                | abram                         |
| Adam Feuer                                |                               |
| Jeremy Field                              | jdf-id-au                     |
| Mike Fikes                                | mfikes                        |
| Hildeberto Mendonca Filho                 | htmfilho                      |
| Andy Fingerhut                            |                               |
| Aaron Fischer                             | f00886                        |
| Vincent Fitzgerald                        | esdoppio                      |
| Nathaniel Flath                           |                               |
| avi Flax                                  | aviflax                       |
| Colin Fleming                             | cmf                           |
| Josh Fleming                              | joshvfleming                  |
| Angus Fletcher                            | angusiguess                   |
| Benoit Fleury                             | benfle                        |
| Dirk Focken                               | timtellos                     |
| Eric Fode                                 | ericfode                      |
| Michael Fogleman                          | mwfogleman                    |
| Michael Fogus                             | fogus                         |
| Vincent Foley-Bourgon                     | gnuvince                      |
| Anton Fonarev                             | avfonarev                     |
| Remi Forax                                | forax                         |
| Christopher Ford                          | ctford                        |
| Alan Forrester                            | alanforr                      |
| Jared Fosyth                              | jaredly                       |
| Joshua Foster                             | jhawk28                       |
| Ryan Fowler                               | ryfow                         |
| Peter Fraenel                             | pnf                           |
| Matthew Frazier                           | leafstorm                     |
| Gary Fredericks                           | fredericksgary                |
| Mark Fredrickson                          |                               |
| Michael Frericks                          | frericksm                     |
| David Frese                               | dfrese                        |
| Adam Frey                                 | adamfrey                      |
| Chris Frisz                               | cjfrisz                       |
| Hiroyuki Fudaba                           | delihiros                     |
| Denis Fuenzalida                          | dfuenzalida                   |
| Keisuke Fukuda                            | keisukefukuda                 |
| Tayssir John Gabbour                      |                               |
| Eldar Gabdullin                           | eldargab                      |
| Artur Gadelshin                           | pondohva                      |
| Anthony Gaetani                           | tonygaetani                   |
| Anthony Galea                             | anthonygalea                  |
| Joseph Gallo                              |                               |
| Sebastian Galkin                          |                               |
| Julian Gamble                             | juliangamble                  |
| Peter Garbers                             | petergarbers                  |
| Timothy Gardner                           | timsgardner                   |
| Devin Garner                              | speige                        |
| Dimitry Gashinsky                         | digash                        |
| James Gatannah                            | JIMRTHY                       |
| Prajjwol Gautham                          | prajjwol                      |
| Jon Gauthier                              | hans                          |
| Mathieu Gauthron                          | matlux                        |
| Alex Gavrisco                             | Alexx-G                       |
| Paula Gearon                              | quoll                         |
| Unnikrishnan Geethagovindan               | krish8664                     |
| Justin Gehtland                           | jgehtland                     |
| Maria Geller                              | mneise                        |
| Marc Sabates Gelpi                        | marc-sabates-gelpi            |
| Christopher Genovese                      |                               |
| Fred George                               |                               |
| Daniel Gerigk                             | danielgerigk                  |
| Robert Gersak                             | kovacnica                     |
| Dustin Getz                               | dustingetz                    |
| Dirk Geurs                                | dirklectisch                  |
| Baishampayan Ghose                        | ghoseb                        |
| Sam Gibson                                | samfoo                        |
| Luca Gilardi                              | lucag                         |
| Stephen C. Gilardi                        | scgilardi                     |
| Timothy Gilbert                           | timgilbert                    |
| Matthew Gilliard                          | mjg123                        |
| Julian Gindi                              | juliangindi]                  |
| Esteban Ginez                             | eginez                        |
| Kylo Ginsberg                             | kylog                         |
| Mark Giovanetti                           | philip-doctor                 |
| Davide Giovannini                         | davideGiovannini              |
| Logan Girard                              | LoganGirard                   |
| Pedro Girardi                             | pedrogirardi                  |
| Petr Gladkikh                             | PetrGlad                      |
| Michael Glaesemann                        | grzm                          |
| Daniel Glauser                            | danielglauser                 |
| Joergen Gmeiner                           | spamless_j                    |
| Oliver Peter George                       | olivergeorge                  |
| Nikolas Göbel                             | comnik                        |
| G. Goet                                   | eval                          |
| Jochen Görtler                            | grtlr                         |
| Sophia Gold                               | Sophia-Gold                   |
| Vojimir Golem                             | vojkog                        |
| Buck Goleman                              | bukzor                        |
| Devender Gollapally                       | devender                      |
| Patrick Gombert                           | patrickgombert                |
| Alejandro Gomez                           | alejandrogomez                |
| Jose Gomex                                | feute                         |
| Jose Gomez                                | k13gomez                      |
| Roman Gonzalez                            | roman                         |
| Sidmant Gooiwala                          |                               |
| Heow Goodman                              |                               |
| Christopher Mark Gore                     | cgore                         |
| Brian Goslinga                            |                               |
| Jake Goulding                             | shepmaster                    |
| Irakli Gozhlishvili                       | Gozalh                        |
| Josip Gracin                              | jgracin                       |
| Christophe Gragnic                        | Grahack                       |
| Christophe Grand                          | grand                         |
| Christopher Granger                       | ibdknox                       |
| Leon Grapenthin                           | lgrapenthin                   |
| Raimon Grau                               | kidd                          |
| Chris Gray                                | chrismgray                    |
| Nahuel Greco                              | nahuel                        |
| David Greenberg                           |                               |
| Brian Gregg                               | baritonehands                 |
| Daniel L. Gregoire                        | semperos                      |
| Matjaz Gregoric                           | mtyaka                        |
| Josh Greenwood                            | joshtgreenwood                |
| Leonard Grey                              | speednoisemovement            |
| Charlie Griefer                           |                               |
| Tim Griesser                              | tgriesser                     |
| Dave Griffith                             |                               |
| Joshua B. Griffith                        | hadronzoo                     |
| David Griffiths                           |                               |
| Michael J. Griffiths                      | cichli                        |
| Dan Griffin                               | danjpgriffin                  |
| Daniel Grijuela                           | dgrijuela                     |
| Anthony Grimes                            | raynes                        |
| Ivan Grishaev                             | igrishaev                     |
| Jeremie Grodziski                         | jgrodziski                    |
| Lucas Groenendaal                         | lag13                         |
| Lynn Grogan                               | lynngrogan                    |
| Dmitry Groshev                            | si14                          |
| Ewen Grosjean                             | ewenG                         |
| Sean Grove                                | sgrove                        |
| Charles Gruenwald                         | charlesg3                     |
| Casey J. Guenthner                        | cguenthner                    |
| Bastien Guerry                            | bzg                           |
| Thad Guidry Sr.                           | thadguidry                    |
| Alexander Read Gunnarson                  | alexandergunnarson            |
| Chen Guo                                  | chenguo                       |
| Mikhail Gusarov                           | dottedmag                     |
| Gordon Gustafson                          | GordonGustafson               |
| Andrew Gwozdziewycz                       |                               |
| Akos Gyimesi                              | gyim                          |
| Austin Haas                               | austinhaas                    |
| Dany Haddad                               | dmh43                         |
| Phil Hagelberg                            | technomancy                   |
| Brent Hagany                              | bhagany                       |
| Faiz Halde                                | fhalde                        |
| Scott Haleen                              | scotthaleen                   |
| Stuart Halloway                           |                               |
| Peter Hanak                               | hanakpet                      |
| Manish Handa                              | hmanish                       |
| Marko Hantula                             | mhantula                      |
| Chris Hapgood                             | cch1                          |
| Jonathan Hartwell                         | jhartwell                     |
| Makota Hashimoto                          | tokomakoma123                 |
| Gregory M. Haskins                        | ghaskins                      |
| Elana Hashman                             | ehashman                      |
| Bruce Hauman                              | bhauman                       |
| Matthew Havener                           | matthavener                   |
| Robin Heggelund Hansen                    | Skinney                       |
| Pedro Henrique Marques Lira               | pedrohml                      |
| Iwo Herka                                 | IwoHerka                      |
| Frank Herrmann                            | 4gh                           |
| Vincent Heuken                            | vheuken                       |
| Elliot Hanser                             | eah13                         |
| Michael Hanson                            | mybuddymichael                |
| Mikko Harju                               | taiste                        |
| Gregory Harman                            |                               |
| Brandon Harper                            | devnalled                     |
| Martin Harrigan                           | harrigan                      |
| Kurt Harriger                             | kurtharriger                  |
| Chad Harrington                           |                               |
| Michael Harrison                          |                               |
| Brandon Harvey                            |                               |
| Benjamin Haskell                          | benizi                        |
| Colin Hastie                              | Chastie                       |
| Tobias Hauth                              | toloh                         |
| Lukas Havemann                            | LukasHavemann                 |
| Heather Haylett                           | HeatherHaylett                |
| Justin Haynes                             | jhaynes                       |
| Ryan Haywood                              | lsdafjklsd                    |
| Joshua Headapohl                          | joshhead                      |
| JR Heard                                  | jrheard                       |
| Thomas Heller                             | THHeller                      |
| Immo Heikkinen                            | immoh                         |
| Jeremy Heiler                             | jeremyheiler                  |
| Ryan Heimbuch                             | rheimbuch                     |
| Eero Helenius                             | eerohele                      |
| James Henderson                           | james-henderson               |
| Sebastian Hennebrueder                    | laliluna                      |
| Brandon Henry                             | bhenry                        |
| Jonathon Henry                            | oahner                        |
| Gerrit Hentschel                          | gerrit-hntschl                |
| Jean-Francois Heon                        | JeffHeon                      |
| Mark Hepburn                              | markhepburn                   |
| Robin Hermansson                          | krherm                        |
| Brendan Hickey                            |                               |
| Tom Hickey                                |                               |
| Carl Hicks                                | hicksca                       |
| Tom Hicks                                 |                               |
| Antonin Hildebrand                        | darwin                        |
| Adam Hill                                 | adamhill                      |
| Colin P. Hill                             | malnormalulo                  |
| Bridget Hillyer                           |                               |
| Mike Hinchey                              | hincheymg                     |
| Matthew Hinman                            |                               |
| Konrad Hinsen                             |                               |
| Stuart Hinson                             | stuarth                       |
| Markus Hjort                              | mhjort                        |
| Tyler Hobbs                               | thobbs                        |
| Herwig Hochleitner                        | bendlas                       |
| Matt Hoffman                              | matthoffman                   |
| Travis Hoffman                            |                               |
| Barry Hoggard                             | bhoggard                      |
| Joel Holdbrooks                           | noprompt                      |
| Simon Holgate                             |                               |
| Justin Holguin                            | holguinj                      |
| Jakub Holy                                | holyjak                       |
| Shawn Hoover                              | shoovertime                   |
| Stephen Hopper                            | enragedginger                 |
| Rahul Hore                                | O-I                           |
| Tassilo Horn                              | tsdh                          |
| Gabriel Horner                            | cldwalker                     |
| Markus Hjort                              | mhjort                        |
| Joshua Horwitz                            | jdhorwitz                     |
| Jürgen Hötzel                             |                               |
| Chris Houser                              | chouser                       |
| Matt Hoyt                                 | mrb0057                       |
| Takahiro Hozumi                           |                               |
| ZhiFeng Hu                                | netroby                       |
| Ziyang Hu                                 | zh217                         |
| Raymond Huang                             | rymndhng                      |
| Peter Hudec                               | peterhudec                    |
| Matthew Huebert                           | mhuebert                      |
| Jeremy Hughes                             | jedahu                        |
| Richard Hull                              | rm-hull                       |
| Hunter Hutchinson                         |                               |
| Robert Hutchison                          | hutch                         |
| Peter Hultgren                            |                               |
| John D. Hume                              | duelin.markers                |
| Chad Humphries                            | spicycode                     |
| Jasper Humphrey                           |                               |
| Pauli Jaakkola                            | nilern                        |
| David James Humphreys                     | davidjameshumphreys           |
| Brian Hurt                                |                               |
| Taha Husain                               | taha-husain                   |
| Robert Hutchison                          | hutch                         |
| Yiu Ming Huynh                            | ymh-engineering               |
| Ales Huzik                                | alesguzik                     |
| Vladimir Iakovlev                         | nvbn                          |
| Bahadur Ibrahimov                         | bibrahimov                    |
| Regina Imhoff                             | StabbyMcDuck                  |
| Mark Ingram                               | markdingram                   |
| Omer Iqbal                                | olenhad                       |
| Shainnif Ismail                           | shainnif                      |
| Michael Israel                            | Mike3620                      |
| Ognen Ivanovski                           | ognen                         |
| Todd Iverson                              | yardsale8                     |
| Michael Ivey                              |                               |
| Hubert Iwaniuk                            | neotyk                        |
| Nicholas Jacek                            | nickjacek                     |
| Donald Clark Jackson                      | dcj/likestream                |
| Thomas Jack                               | tomoj                         |
| Edmund Jackson                            | ejackson                      |
| Jason Jackson                             | jasonjckn                     |
| Michael Joseph Jackson                    | occamin                       |
| David Jacobs                              | davejacobs                    |
| John Jacobsen                             | eigenhombre                   |
| David Jacot                               | dajac                         |
| George Jahad                              |                               |
| Mayank Jain                               | firesofmay                    |
| Ravindra R. Jaju                          | jaju                          |
| Blake Jakopovic                           | blakejakopovic                |
| Tom Jakubowski                            | tomjakubowski                 |
| Asim Jalis                                |                               |
| David James                               |                               |
| Anders Janmyr                             | andersjanmyr                  |
| Daniel Janus                              | nathell                       |
| Andrew Jarosinski                         | mustangJaro                   |
| Piotr Jarzemski                           | kazuhiro                      |
| W. David Jarvis                           | venantius                     |
| Hitesh Jasani                             | hiteshjasani                  |
| Bodaniel Jeanes                           | bjeanes                       |
| Khalid Jebbari                            | DjebbZ                        |
| Adam P. Jenkins                           | ajenkinski                    |
| Brian Jenkins                             | bonkydog                      |
| Borge Andre Jensen                        | imborge                       |
| Sean Jensen-Grey                          | seanjensengrey                |
| Hyeongmin Jeon                            | hmnjeon                       |
| Chris Jeris                               | BCcjeris                      |
| Chris K. Jester-Young                     |                               |
| Jason Jobe                                |                               |
| Dainius Jocas                             | dainiusjocas                  |
| Christian Johansen                        | cjohansen                     |
| Allen Johnson                             |                               |
| Justin Chalres Johnson                    | justinjohnsonio               |
| Ryan Johnson                              | bakeemawaytoys                |
| Robert Johnson                            | RobertLJ                      |
| Isaac Johnston                            | superstructor                 |
| Jonathan Johnston                         | jdjohnston                    |
| Wilkes Joiner                             | wilkes                        |
| Colin Jones                               |                               |
| Gareth Jones                              |                               |
| Josh Jones                                | joshjones                     |
| Kevin Jones                               | kevin24by7                    |
| Kevin Ilchmann Jorgensen                  | kij                           |
| Dejan Josifovic                           | 28                            |
| Tamas Jung                                | tamasjung                     |
| PENG Jun-hao                              | flaing                        |
| Eric Jutrzenka                            | burn-shave                    |
| Sivasubramanian K                         | mksiva                        |
| Colin Kahn                                | colinkahn                     |
| Arttu Kaipiainen                          | arttuka                       |
| Oliver Kaiser                             | undernorthernsky              |
| Alain Kalker                              | ackalker                      |
| Steven Kallstrom                          | kallstrom                     |
| Clark Kampfe                              | ckampfe                       |
| Stefan Kamphausen                         | ska2342                       |
| John Kane                                 |                               |
| Sahil Kang                                | SahilKang                     |
| Xuyang Kang                               | xuyangkang                    |
| Ikuru Leif Kanuma                         | iku000888                     |
| Maksim Karandashov                        | Norgat                        |
| Antti Karanta                             | akaranta                      |
| Yrjö Kari-Koskinen                        | ykarikos                      |
| Kiran Karkera                             | shark8me                      |
| Pratik Karki                              | prertik                       |
| Stefan Karlsson                           | zclj                          |
| Laurence Karnowski                        |                               |
| s. Karthikeyan                            | tirkarthi                     |
| Bart Kastermans                           | kasterma                      |
| Axel Katerbau                             | KaterMikesch                  |
| Simon Katz                                |                               |
| Martin Kavalar                            | mk                            |
| Rahul Kavale                              | rahulkavale                   |
| Christian Kebekus                         |                               |
| James A Keene                             | jamak                         |
| Peter Kehl                                | peter-kehl                    |
| Matt Keller                               |                               |
| Alexander Kellett                         | lypanov                       |
| Kevin L. Kelley                           | KevinKelley                   |
| Hunter Kelly                              | retnuh                        |
| Matthew Kennedy                           | lispnik                       |
| Robert J. Kennedy                         | arkdrag                       |
| Rett Kent                                 | rettkent                      |
| Daniel Kersten                            | danielytics                   |
| Marat Khafizov                            | xafizoff                      |
| Oleksii Khomchenko                        | akhomchenko                   |
| Thomas Kidd                               | tomjkidd                      |
| George Kierstein                          | MissInterpret                 |
| Alexander Kiel                            | alexanderkiel                 |
| Patrick Killean                           | pkpkpk                        |
| Brian Kim                                 | brainkim                      |
| Daniel Kim                                | danielrk                      |
| Eunmin Kim                                | eunmin                        |
| Jinseop Kim                               | vmfhrmfoaj                    |
| Zachary Kim                               |                               |
| Daniel Kimbel                             | Techowl                       |
| Adam King                                 | aking                         |
| Alexander James King                      | alexanderjamesking            |
| Tim King                                  | kingtim                       |
| Tristan King                              |                               |
| Kyle Kingsbury                            | aphyr                         |
| Masanori Kinoshita                        | makinoshi                     |
| David Kinzer                              | dkinzer                       |
| Creighton Kirkendall                      | ckirkendall                   |
| Neil Kirsopp                              | cursork                       |
| Andy Kish                                 |                               |
| Dom Kiva-Meyer                            |                               |
| Alan Bustos Kleiman                       | akleiman                      |
| Marius Kjeldahl                           | mariusk                       |
| Martin Klepsch                            | martinklepsch                 |
| Андрей Клещинский / Andrei Kleschinski    | metametaclass                 |
| Michael Klishin                           | micharlklishin                |
| Aravind K.n                               | arav93                        |
| Simon Knudsen                             | simonknudsen                  |
| Eduard Knyshov                            | edvorg                        |
| Georges KO                                | gko, geko                     |
| Kenichi Kobayashi                         | kencoba                       |
| Eric Kobrin                               | erluko, ekobrin               |
| Stefan Kohler                             | brixtonasias                  |
| Christopher Kolodin                       | seako                         |
| Espen Amble Kolstad                       |                               |
| Yoshito Komatsu                           | ykomatsu                      |
| Dieter Komendera                          | kommen                        |
| Eugene Koontz                             | ekoontz                       |
| Chaitanya Sunil Koparkar                  | cskksc                        |
| Tobias Kortkamp                           | t6                            |
| Kimmo Koskinen                            | viesti                        |
| Miikka Koskinen                           | miikka                        |
| Cezary Kosko                              | cezarykosko                   |
| Eugene Kostenko                           | dek5                          |
| Imre Kószó                                | imrekoszo                     |
| Ben Kovitz                                | bkovitz                       |
| Jeffrey Kowalczyk                         |                               |
| Ivan Kozik                                |                               |
| Misha Kozik                               | mishadoff                     |
| Nandor Kracser                            | bonifaido                     |
| Robert Krahn                              | rksm                          |
| Justin Kramer                             |                               |
| Hugo Krawczyk                             | petitchatnoir                 |
| Max Kreminski                             | mkremins                      |
| Stas Krichevsky                           | stask                         |
| Krishna Krishnamaneni                     |                               |
| Thomas G. Kristensen                      | tgk                           |
| Paul Kristoff                             |                               |
| Karl Krukow                               | krucow                        |
| Christopher Kruse                         | ballpointcarrot               |
| Ivan Kryvoruchko                          | gsnewmark                     |
| Mikhail Ksenzov                           | mksenzov                      |
| Kučera                                    | kucerm2                       |
| Mitchel Kuijpers                          | mitchelkuijpers               |
| Seçkin Kükrer                             | leavenha                      |
| Tomas Kulich                              | tomaskulich                   |
| Kiran Kulkarni                            | kiran                         |
| Ryohei Kumakiri                           | ark6                          |
| Shantanu Kumar                            |                               |
| Raghuveer Kumarakrishnan                  | raghuftw                      |
| Zhang Kun                                 | azurezk                       |
| Ingo Kuper                                | RAMart                        |
| Antony Kuzmicicu                          |                               |
| Youndo Kwak                               | kwakbab                       |
| Alyssa Kwan                               |                               |
| Daniel Kwiecinski                         | lambder                       |
| Carmen La                                 | lacarmen                      |
| Wayne LaBelle                             |                               |
| Robert Lachlan                            | Heffalump                     |
| Pieter Laeremans                          | plaeremans                    |
| Aaron James Lahey                         | aaronlahey                    |
| Gavin Lam                                 | gavinkflam                    |
| Paul Lam                                  | Quantisan                     |
| Anthony LaMantia                          | w4ffles                       |
| Joseph Lane                               | magemasher                    |
| Michael Langford                          | landford                      |
| Jared Langson                             | jlangson                      |
| William Langstroth                        |                               |
| Dan Larkin                                |                               |
| Robin Larsson                             | R-Larsson                     |
| Olov Lassus                               |                               |
| Danijel Latin                             | dlatin                        |
| Von Latinski                              | von-latinski                  |
| Neil Laurance                             | toolkit                       |
| Karlis Lauva                              | skazhy                        |
| Oliver Lauzon                             | olauzon                       |
| James Laver                               | jjl                           |
| Eric Lavigne                              |                               |
| Elton Law                                 | eltonlaw                      |
| Thom Lawrence                             | delver                        |
| Corin Lawson                              | au-phiware                    |
| Konstantin Lazarev                        | Le6ow5k1                      |
| David Leatherman                          | leathered                     |
| Sergei Lebedev                            | superbobry                    |
| Adam D. Lee                               | adamdavislee                  |
| Chee Sing Lee                             | cheesinglee                   |
| Justin Lee                                | jmlsf                         |
| Matthew Lee                               | thatismatt                    |
| Minsun Lee                                | dalzony                       |
| Thomas Lee                                | thomaslee                     |
| Young Lee                                 | youngLeeNENU                  |
| Antoine Lefevre                           | antoineLefevre                |
| Paul Legato                               |                               |
| Eric Le Goff                              | elegoff                       |
| Matt Lehman                               | mlehman                       |
| Malia Lehrer                              | mllehrer                      |
| Shuland Lei                               | gzmask                        |
| Josh Lemer                                | joshlemer                     |
| Milan Lempera                             | milanlempera                  |
| Rok Lenarcic                              | RokLenarcic                   |
| Jonathan Leonard                          | johanatan                     |
| Scott Leonard                             | scottwleonard                 |
| Greg Leppert                              | leppert                       |
| Carl Lerche                               | carllerche                    |
| Stephen Lester                            | slester                       |
| Robert P. Levy                            | rplevy                        |
| Alex Lew                                  | alex-lew                      |
| Jason Lewis                               | canweriotnow                  |
| Howard Lewis Ship                         | hlship                        |
| John Li                                   | jli                           |
| Kanwei Li                                 | kanwei                        |
| Gang Liang                                | randomizedthinking            |
| Minzhi Liao                               | liao02x                       |
| David Liebke                              |                               |
| David Liepmann                            | daveliepmann                  |
| Andreas Liljeqvist                        | bonega                        |
| August Lilleaas                           |                               |
| Mathieu Lirzin                            | mthl                          |
| Joe Littlejohn                            | joelittlejohn                 |
| Marc Limotte                              | mlimotte                      |
| Henrik Lindberg                           | hlindberg                     |
| Eli Lindsey                               | elindsey                      |
| Logan Linn                                | loganlinn                     |
| Ernestas Lisauskas                        | ernestas                      |
| Joe Littlejohn                            | joelittlejohn                 |
| Jiacai Liu                                | jiacai2050                    |
| Roman Liutikov                            | roman01a                      |
| Nathan Lloyd                              | mangosmoothie                 |
| Pawel Loba                                | paszek                        |
| Joakin Lofgren                            | JoakinLofgren                 |
| Chris Lohfink                             | clohfink                      |
| Gregory Look                              | greglook                      |
| Marcio Lopes de Faria                     | marciol                       |
| Ignacio Blasco Lopez                      | elnopintan                    |
| Leandro López                             | inkel                         |
| Jean Niklas L'orange                      | hyPiRion                      |
| Yanxiang Lou                              | louyx                         |
| Benjamin James Lovell                     | socksy                        |
| J. David Lowe                             | dlowe                         |
| Scott Lowe                                | scottlowe                     |
| Peter Lubell- Doughtie                    | pld                           |
| Rovanion Luckey                           | Rovanion                      |
| Craig Brent Ludington                     |                               |
| Simon Lutzelschwab                        | simonpure                     |
| Richard Lyman                             | richard-lyman                 |
| Kevin Lynagh                              | lynaghk                       |
| Daniel Lyons                              |                               |
| Tom Lyons                                 | tbl3rd                        |
| Bryan Maass                               | escherize                     |
| Ben Mabey                                 | bmabey                        |
| Elena Machkasova                          | elenam                        |
| Daemian John Farling Mack                 | daemianmack                   |
| Brian Maddy                               | bmaddy                        |
| Shaun Mahood                              | smahood                       |
| Christopher Maier                         |                               |
| Glen Mailer                               | glenjamin                     |
| Roman Makhlin                             | yokalona                      |
| Cristian Malinescu                        | Cristian-Malinescu            |
| Alan Malloy                               |                               |
| Henrish Maluleka                          | henroid                       |
| Itay Maman                                |                               |
| Chester Mancini                           | chetmancini                   |
| Vedang Manerikar                          |                               |
| Max Jiayin Mao                            | jmao                          |
| Matthew Maravillas                        |                               |
| Tom Marble                                |                               |
| Michal Marczyk                            |                               |
| Jeff Marder                               |                               |
| Matthias C. Margush                       | matthias-margush              |
| Mauricio Aldazosa Mariaca                 | mauricio aldazosa             |
| Anthony Marcar                            | moocar                        |
| Zach Maril                                | zmaril                        |
| Daniel Marjenburgh                        | dmarjenburgh                  |
| Orestis Markou                            | orestis                       |
| Oliver Marshall                           | Akeboshiwind                  |
| Nuno Marques                              | nfma                          |
| Ken Marshall                              | kmarshall008                  |
| Jiri Marsik                               | jirkamarsik                   |
| Sebastien Martel                          | sebmartel                     |
| Raphael Martelles                         |                               |
| Olle Martensson                           | ollez                         |
| Jess Martin                               | jessmartin                    |
| Joel Martin                               | kanaka                        |
| Micah Martin                              | slagyr, micahmartin           |
| Sahyden Martin                            | shadizzle                     |
| Juan Carlos Martinez-Ovando               | jcmartinezovando              |
| Juraj Martinka                            | jumarko                       |
| Pedro Iago Carvalho Martins               | pjago                         |
| Nathan Marz                               | nathanmarz                    |
| Ogino Masanori                            | omasanori                     |
| Harrison Maseko                           | MasekoH                       |
| John Mastro                               | johnmastro                    |
| Nathan Matthews                           | N8DAWGRR                      |
| Kashchenko Maxim                          | mkaschenko                    |
| J. McConnell                              | j-dot                         |
| John E. McConnell                         | johnmcconnell                 |
| Chris McCormick                           | chr15m                        |
| Tim McCormack                             |                               |
| Jake McCrary                              | jakemcc                       |
| Ryan McCuaig                              | rgm                           |
| Ethan McCue                               | bowbahdoe                     |
| Jeffrey J. McCune                         | jeffmccune                    |
| Craig McDaniel                            | craigmcd                      |
| Craig McDaniel                            | cpmcdaniel                    |
| Ray McDermott                             | raymcdermott                  |
| Christopher McDevitt                      | minimal                       |
| John Alan McDonald                        | palisades-lakes               |
| Ross McDonald                             | rossputin                     |
| Brighid McDonnell                         | brighid                       |
| Donovan McGillen                          | dmcgillen                     |
| Mark McGranaghan                          | mmcgrana                      |
| Rob McGuire-Dale                          | robatron                      |
| Robert McIntyre                           | rlm, bortreb                  |
| Reid McKenzie                             | arrdem                        |
| Jonathon McKitrick                        | j-mckitrick                   |
| Kira McClean                              | kiramclean                    |
| Murphy McMahon                            | pandeiro                      |
| David McNeil                              |                               |
| Tony John McNeil                          | tony-john-mcneil              |
| Andrew McVeigh                            | andrewmcveigh                 |
| Adrian Medina                             | aamedina                      |
| Christopher Meiklejohn                    | cmeiklejohn                   |
| Carin Meier                               |                               |
| Philipp Meier                             | ordnungswidrig                |
| Johan Mena                                | jhn                           |
| Neil Menne                                | NeilMenne                     |
| Andrew s. Meredith                        | kendru                        |
| Benjamin C Meyer                          |                               |
| Evan Mezeske                              | emezeske                      |
| Gregor Middell                            | gremid                        |
| Kurt Miebach                              | kwmiebach                     |
| Karl Andrew Mikkelsen                     | karlmikko                     |
| Timo Mihaljov                             | noidi                         |
| Ivan Mikushin                             | imikushin                     |
| Brent Millare                             | bmillare                      |
| Adam Kenneth Miller                       | akmiller78                    |
| Alex Miller                               | puredanger                    |
| Blake Miller                              | blak3mill3r                   |
| David Miller                              |                               |
| Ethan Miller                              | ezmiller                      |
| Jimmy Miller                              | jimmyhmiller                  |
| Joshua Miller                             | joshuamiller                  |
| Mike T. Miller                            | mtm                           |
| Samuel Miller                             | kamn                          |
| Stephen Miner                             | miner                         |
| Sergey Miryanov                           |                               |
| Andrii Mishkovskyi                        | mishok13                      |
| Nachiketa Mishra                          | nmishra                       |
| Stuart Mitchell                           | stumitchell                   |
| Richard Mohn                              | moehn                         |
| Matthew James Molloy                      | whamtet                       |
| Nicola Mometto                            | bronsa                        |
| Michael Monette                           | mmonette                      |
| Dominic Monroe                            | SevereOverfl0w                |
| Dan Montague                              | atstp                         |
| Antonio Nuno Monteiro                     | anmonteiro                    |
| Bhaskar Mookerji                          | mookerji                      |
| Deon Moolman                              | cmdrdats                      |
| Alan Moore                                | kahunamoore                   |
| Matt Moore                                | mattmoore                     |
| Paul Mooser                               |                               |
| Oscar Morante                             | spacepluk                     |
| Michael Morearty                          | mmorearty                     |
| Shawn Morel                               | strangemonad                  |
| Adam J. Morgan                            | ajmorgan                      |
| Wesley Morgan                             | cap10morgan                   |
| Will Morgan                               | wwmorgan                      |
| Paudi Moriarty                            |                               |
| Rich Morin                                | RichMorin                     |
| Ralph Moritz                              |                               |
| Dmytro Morozov                            | erasmas                       |
| Nelson Morris                             |                               |
| Jacob Mortansen                           | jacobm                        |
| Simone Mosciatti                          | Siscia                        |
| Aedipa Moss                               | aedipamoss                    |
| Ben Moss                                  | benmoss                       |
| Davie Moston                              | davie                         |
| Christopher Mowforth                      | m0wfo                         |
| Rick Moynihan                             | RickMoynihan                  |
| Konrad Mrozek                             | mrroman                       |
| Priyatam Mudivarti                        | priyatam                      |
| Don Mullen                                |                               |
| Dominic Muller                            | domgetter                     |
| Thomas Patrick Mulvaney                   | thomasmulvaney                |
| Marco Munizaga                            | MarcoPolo                     |
| Elliot Murphy                             | statik                        |
| Jason Murphy                              | jsonmurphy                    |
| Brendon John Muschamp                     | brendonjohn                   |
| Ramakrishnan Muthukrishnan                |                               |
| Tim Myrtle                                |                               |
| Thurston Nabe                             | nomagic                       |
| Rafik Naccache                            | turbopape                     |
| Eli Naeher                                | enaeher                       |
| Ryotaro Nakamura                          | KazumaSATO                    |
| Hyunwoo Nam                               | namenu                        |
| Stanislas Nanchen                         |                               |
| Niklas Narhinen                           | nnarhinen                     |
| George Narroway                           | gnarrow1                      |
| Nikhil Narula                             | nn2242                        |
| Ramsey Nasser                             | nasser                        |
| Dmitri Naumov                             | dnaumov                       |
| Muthukumaran Navaneethakrishnan           | muthuishere                   |
| Jon Neale                                 | jonneale                      |
| Kevin Neaton                              | neatonk                       |
| Ganesh Neelekani                          | ganeshneelekani               |
| Or Neeman                                 | oneeman                       |
| Matthias Nehlsen                          | matthiasn                     |
| Maria Neise                               | MNeise                        |
| Joubert Nel                               |                               |
| Alex Nelson                               |                               |
| Sam Neubardt                              | Samn                          |
| Ryan Neufeld                              | rkneufeld                     |
| Leah Neukirchen                           | LeahNeukirchen                |
| John Michael Newman III                   | johnmn3                       |
| Richard Newman                            |                               |
| Jim Newton                                | jimka2001                     |
| Matthew Newton                            | mnewt                         |
| An Nguyen                                 | annguy3n                      |
| Michael Nguyen                            | lexwraith                     |
| Thomson Nguyen                            | itsthomson                    |
| Nick Nichols                              | nnichols                      |
| Claudius Nicolae                          | clyfe                         |
| Robert Nikander                           | rnikander                     |
| Marin Atanasov Nikolov                    | dnaeon                        |
| Harmon S. Nine                            | hnine999                      |
| Ayato Nishimura                           | ayato0211                     |
| Micha Niskin                              | micha                         |
| Clinton Nixon                             | crnixon                       |
| Leo Noel                                  | leonoel                       |
| David Nolen                               |                               |
| Marcelo Yuji Nomoto                       | mynomoto                      |
| Gavin-John Noonan                         | adulteratedjedi               |
| Aron Nopanen                              | aroneous                      |
| Eric Normand                              | ericnormand                   |
| William Narmontas                         | ScalaWilliam                  |
| Jakub Nowak                               | mecolin                       |
| Christopher Nuernberger                   | cnuernber                     |
| Duarte Nunes                              | duartem                       |
| Tomasz Nurkiewicz                         | nurkiewicz                    |
| Kyle Nusbaum                              | knusbaum                      |
| Michael Nussbaum                          | mnussbaum                     |
| Nuttanart                                 | visibletrap                   |
| Mark Nutter                               | manutter51                    |
| Bryce Nyeggen                             | fiatmoney                     |
| Michael Nygard                            |                               |
| Zachary S. Oakes                          | oakes                         |
| Chris Oakman                              | oakmac                        |
| Andrew Oberstar                           | ajoberstar                    |
| Jan Oberhagemann                          |                               |
| Robert O'Connor                           | robbyoconnor                  |
| Stefan Oestreicher                        |                               |
| Trent Ogren                               | misfo                         |
| Kent Ohashi                               | lagenorhynque                 |
| Lauri Oherd                               | laurio                        |
| Shogo Ohta                                | athos                         |
| Rory O'Kane                               | roryokane                     |
| Michael O'Keefe                           | michael-okeefe                |
| David O'Meara                             | davidomeara                   |
| Marc O'Morain                             | marcomorain                   |
| Erich K Oliphant                          | eoliphan                      |
| Russ Olsen                                |                               |
| Joshua Olsen                              | MrMormon                      |
| Jim Oly                                   |                               |
| Akito Ono                                 | ak1t0                         |
| OPGeorge                                  | olivergeorge                  |
| Chris Opperwall                           | copperwall                    |
| Matt Oquist                               | moquist                       |
| Jarkko Oranen                             | Chousuke                      |
| James Orchard-Hays                        |                               |
| Alex Osborne                              | ato                           |
| Alex Ott                                  | alexott                       |
| Erik Ouchterlony                          | ejlo                          |
| Nicolas Oury                              |                               |
| Florian Over                              | FlorianO                      |
| Ustun Ozgur                               | ustunozgur                    |
| Sung Pae                                  | guns                          |
| PaGrom                                    | PaGrom                        |
| Lucas Vitalino Severo Pais                | lsevero                       |
| Jeff Palmucci                             | jpalmucci                     |
| Jinyu Pan                                 | swimablefish                  |
| Bruno Panasiewicz                         | ciuak                         |
| Thai Pangsakulyanont                      | dtinth                        |
| Pankaj                                    | metacritical                  |
| Niranjan Paranjape                        | achamian                      |
| Thonghee Park                             |                               |
| Shaun Parker                              | shaunparker                   |
| Paavo Parkkinen                           | pparkkin                      |
| Andy S. Parsons                           | andyparsons                   |
| Achim Passen                              |                               |
| Bolaram Paul                              | bolaram                       |
| Chris Paul                                | cmpaul                        |
| Jestine Paul                              | jestinepaul                   |
| Anna Pawlicka                             | apawlicka                     |
| Sherman Pay                               | shermpay                      |
| Wesley N. Payne                           | wnpayne                       |
| Marc Peabody                              | marcpeabody                   |
| Wouter Peers                              | wopeers                       |
| Joris Peeters                             | jmgpeeters                    |
| Mike Pence                                | mikepence                     |
| Martin Penckert                           | penckert                      |
| Mike Penckert                             | felbit                        |
| Michael D. Pendergrass                    | mdpendergrass                 |
| Maximilien Penet                          | mpenet                        |
| Ted Pennings                              | ted pennings / thesleepyvegan |
| Jason Pepas                               | cellularmitosis               |
| Vitaly Peressada                          | vitalyper                     |
| Eduardo Emilio Julian Pereyra             |                               |
| Nikola Peric                              | nikolap                       |
| Chris Perkins                             |                               |
| Anurag Peshne                             | anuragpeshne                  |
| Lauri Pesonen                             | liwp                          |
| J. Matt Peterson                          | jmatt                         |
| Michael Peterson                          |                               |
| Laurent Petit                             |                               |
| Christopher Petrilli                      |                               |
| Robert Pfeiffer                           | tarquinius                    |
| Daniel Phelps                             |                               |
| Douglas Philips                           |                               |
| Ian Phillips                              | ianp                          |
| Jonathan Phillips                         |                               |
| Matthew Phillips                          | scramjet                      |
| Nguyen Duc Phong                          | goodwind89                    |
| Phong                                     | edwastone                     |
| Phongphan Phuttha                         | phongphan                     |
| Brian Picciano                            | mediocregopher                |
| Olli Piepponen                            | Luxbock                       |
| Ivan Pierre                               | ivanpierre                    |
| Chris Pickard                             | ChrisPickard                  |
| Dimitrios Piliouras                       | jimpil                        |
| Azarie Piskunov                           | Gorssa                        |
| Robert Pitts                              | rbxbx                         |
| Hendrik Poernama                          | poernahi                      |
| Jannis Pohlmann                           | jannis                        |
| David Pollack                             | dpp                           |
| Camilo Polymeris                          | polymeris                     |
| Tim Pope                                  | tpope                         |
| John Poplett                              | John-Poplett                  |
| Cesar Bolanos Portilla                    | cesarbp                       |
| Gerbrand "Gary" Poster IV                 | gary-poster                   |
| Timothy Pote                              | otetm                         |
| Philip Potter                             | ppotter                       |
| David Powell                              |                               |
| Oliver Powell                             | greywolve                     |
| James M Powers                            |                               |
| Nikhil Prabhakar                          |                               |
| Prakash                                   | prakash23                     |
| Timothy Pratley                           |                               |
| Luc Prefontaine                           | lprefontaine                  |
| Chris Price                               | cprice404                     |
| Romain Primet                             | rprimet                       |
| Nivedita Priyadarshini                    | nid90                         |
| Nikita Prokopov                           | tonsky                        |
| Dennis Proksch                            | MemoWalk                      |
| Neil Prosser                              | neilprosser                   |
| Rhodri Pugh                               | rodnaph                       |
| Joonas Pulakka                            |                               |
| Cameron Pulsford                          |                               |
| Stephen Purcell                           |                               |
| Geoffrey Purdy                            | GeoffPurdy                    |
| Tienson Qin                               | tiensonqin                    |
| Fu Yong Quah                              | fyquah95                      |
| Quach Ngoc Quang                          | quangquach                    |
| Zubair Quraishi                           | zubairq                       |
| Martin Račák                              | rakyi                         |
| Sameer Rahmani                            | lxsameer                      |
| Drew Raines                               | drewr, mtndrew0               |
| R U Naresh Raju                           | meumanaresh                   |
| Benjamin Ran                              | benjaminran                   |
| Roger E. Randall II                       | randre03                      |
| Mikko Lukas Räsänen                       | mikkolukas                    |
| Shawn Rasheed                             | unshorn                       |
| Neha Rastogi                              | neharastogi093                |
| Amit Rathore                              |                               |
| Andre Rauh                                | rauhs                         |
| Kamwa Fosso Arcel Raulain                 | kraulain                      |
| David Ray                                 | daveray                       |
| Atharva Raykar                            | tfidfwastaken                 |
| Lee Read                                  | lread                         |
| Reno Reckling                             | exi                           |
| Abhishek Reddy                            | arbscht                       |
| Milton J Reder                            | milt                          |
| Christopher Redinger                      |                               |
| Alex Redington                            |                               |
| James Reeves                              | weavejester                   |
| Mihir Rege                                | geremih                       |
| Aviad Reich                               | aviad                         |
| Herald Reierskog                          | uosl                          |
| Nicholas Reilingh                         | NReilingh                     |
| Tommi Reiman                              | ikitommi                      |
| Daniel Renfer                             | duck1123                      |
| Matt Revelle                              | mattrepl                      |
| Brendan Ribera                            | abscondment                   |
| Alen Ribic                                | billdozr                      |
| Stephen Ribich                            | nulliel                       |
| Norman Richards                           | normanrichards                |
| Tim Richardt                              | timrichardt                   |
| Andrea Richiardi                          | arichiardi                    |
| Daniel Richman                            | ddrichman                     |
| Eric Richmond                             | erichmond                     |
| Tim Riddell                               |                               |
| Christopher Riddoch                       |                               |
| Owen Riddy                                | owenRiddy                     |
| Seth Rider                                | thumbquat                     |
| Rafael Rinaldi                            | rafaelrinaldi                 |
| Brandon Ringe                             | bpringe                       |
| Jim Riordan                               | j1mr10rd4n                    |
| Samuel Ritchie                            |                               |
| Ralph Ritoch                              | rritoch                       |
| Pierre-Yves Ritschard                     |                               |
| William Robertson                         | billrobertson42               |
| Cliff Rodgers                             | kliph                         |
| Thomas Rodgers                            |                               |
| Bruno R M Rodrigues                       | brmrodrigues                  |
| Richard Roe                               | rroe                          |
| William Roe                               | wjlroe                        |
| Sam Roelants                              | sroelants                     |
| Roeland                                   | roelandoosterloo              |
| Collin Rogowski                           | qollin                        |
| Allen Rohner                              | arohner                       |
| Marco Rolappe                             | mrolappe                      |
| Christian Romney                          | christianromney               |
| Andrew Rosa                               | andrewhr                      |
| Jeff Rose                                 | rosejn                        |
| Sean Ross                                 |                               |
| Ales Roubicek                             | rarous                        |
| Tchavdar Roussanov                        |                               |
| Darren Ruane                              | DarrenRuane                   |
| Yoav Rubin                                | yoavrubin                     |
| Brian J. Rubinton                         | brianru                       |
| Tavis Rudd                                | tavisrudd                     |
| Jason Rudolph                             | jasonrudolph                  |
| Edward Ruggeri                            | ruggeri                       |
| Jose Antonio Ortega Ruiz                  | jao                           |
| David Rupp                                |                               |
| Chance Russell                            | chancerussell                 |
| Patrick Ryan                              | phiat                         |
| Peter Ryan                                |                               |
| Jan Rychter                               |                               |
| Jeff Sack                                 |                               |
| Daniel Sada                               | danielsada                    |
| Roland Sadowski                           | fyuryu                        |
| Alexander Salamatnikov                    | fmnoise                       |
| Alan Salewski                             | salewski                      |
| Michel Salim                              |                               |
| Steve Salkin                              | sls                           |
| Adrian Sampaleanu                         | asampal                       |
| Jason Samsa                               |                               |
| Lee Pau San                               | leepausan                     |
| Timo Joachim Sand                         | deiga                         |
| Taylor Sando                              | taylorSando                   |
| Park Sang-Kyu                             | guruma                        |
| Jason Sankey                              |                               |
| Dave Sann                                 | davesann                      |
| David Santiago                            |                               |
| Joseph Santos                             | joridos                       |
| Fabio Santschi                            | hokkaido                      |
| Jeff Sapp                                 |                               |
| David Sargeant                            | dubiousdavid                  |
| Nathan Sashihara                          | [[mailto:nsashihara@princeton.com][nsashihara@princeton.com]]      |
| Michael Sassak                            | msassak                       |
| Cam Saul                                  | camsaul                       |
| Christoffer Sawicki                       | gerub                         |
| Jacek Schae                               | jacekschae                    |
| Mat Schaffer                              | matschaffer                   |
| Michael Scheinholtz                       |                               |
| Kurt Schelfthout                          |                               |
| Roman Scherer                             | roman jira                    |
| Samuel Jacob Schetterer                   | schets                        |
| Daniel R Schlegel                         | digitalneoplasm               |
| Gregory Schlomoff                         | gregschlom                    |
| Adam Schmideg                             | adamschmideg                  |
| Albrecht Schmidt                          | iamdrowsy                     |
| Karsten Schmidt                           | toxi                          |
| John Schmidt                              | schmee                        |
| Ralf Schmitt                              | schmir                        |
| Eric Schoonover                           | spoon16                       |
| Thomas Schranz                            | tosh                          |
| Silvia Schreier                           | saivlis                       |
| Dennis Schridde                           | devurandom                    |
| Seth Schroeder                            |                               |
| Robin Schroer                             | sulami                        |
| Marian Schubert                           | maio                          |
| Peter Schuck                              | spinningtopsofdoom            |
| Peter Schuller                            |                               |
| Bobby Schultz                             | puppybits                     |
| K E Schulze                               | keithschulze                  |
| Maik Schünemann                           | mschuene                      |
| Rainer Schuster                           | schuster-rainer               |
| Peter J. Schwarz                          | peterschwarz                  |
| Joung Mun Sic                             | ruseel                        |
| David Siefert                             | davidsiefert                  |
| Aleksander Simić                          | dotemacs                      |
| Søren Sjørup                              | zoren                         |
| Carlo Sciolla                             | skuro                         |
| Aaron Scott                               |                               |
| Dylan Scott                               | dylanscott                    |
| Gregory S. Seaton                         | gseaton                       |
| Jeremy R. Sellars                         | jeremyrsellars                |
| Mourjo Sen                                | mourjo                        |
| Karim Senhaji                             | kimsnj                        |
| Ryan Senior                               |                               |
| Rodrigo Dias Arruda Senra                 | rodsenra                      |
| Kwang Yul Seo                             | kseo                          |
| Mishin Sergey                             | ralder                        |
| Reut Sharabani                            | reutsharabani                 |
| John Shaffer                              | john-shaffer                  |
| Smit Shah                                 | Who828                        |
| Zhanlin Shang                             | Z-Shang                       |
| Rupa Shankar                              | RUPSS                         |
| Geoff Shannon                             | RadicalZephyr                 |
| Daniel Shapero                            | danshapero                    |
| Yehonathan Sharvit                        | viebel                        |
| Vadym Shavalda                            | m3sv                          |
| Drew Shaw                                 | ds923y                        |
| Ghadi Shayban                             |                               |
| Christopher Shea                          |                               |
| Zane Shelby                               | zane                          |
| Andy Sheldon                              | asheldo                       |
| Christopher Shelley                       | basiclaser                    |
| Jeremy Sherman                            | jeremy-w                      |
| Joe Shidel                                | shidel-dev                    |
| Patrick Shields                           |                               |
| Jose Pablo Fernandez Silva                | pupeno                        |
| Filipe Silva                              | filipesilva                   |
| Jeremy Shoemaker                          | codingkoi                     |
| Sean Shubin                               |                               |
| Oleksandr Shyshko                         | oshyshko                      |
| Joseph Siddall                            | jbsiddall                     |
| Inderbir Sidhu                            | bcisidhu                      |
| Frank Siebenlist                          |                               |
| Stuart Sierra                             |                               |
| Peter Siewert                             | cninja                        |
| Hloover Sigurosson                        | hlolli                        |
| Ben Sima                                  | bsima                         |
| David Simons                              | SwamWithTurtles               |
| Anthony L. Simpson                        |                               |
| Mark Simpson                              | verdammelt                    |
| Chris Sims                                | jcsims                        |
| Narayan Singhal                           |                               |
| David Sison                               | thoughtmanifest               |
| Daniel Škarda                             | danskarda                     |
| Brandon Skinner                           | brandon-m-skinner             |
| Isak Sky                                  | isaksky                       |
| Ben Sless                                 | bsless                        |
| Christopher T. Small                      | metasoarous                   |
| Griffin Smith                             | glittershark                  |
| Jennifer Smith                            | jennifersmith                 |
| Joseph Smith                              | solussd                       |
| Jonathan Smith                            |                               |
| Justin Glenn Smith                        | noisesmith                    |
| Matthew O. Smith                          | m0smith                       |
| Nathaniel Smith                           | nwjsmith                      |
| Radford Smith                             | rads                          |
| Ben Smith-Mannschott                      |                               |
| Joseph J Snickeris                        | jsnickeris                    |
| Jerry Snitselaar                          | snits                         |
| Paul L. Snyder                            | pataprogramming               |
| Renata Soares dos Santos                  | renatasoares                  |
| Frantisek Sodomka                         | fsodomka                      |
| Erik Soehnel                              | hoeck                         |
| Daniel Solano Gómez                       | sattvik                       |
| Artem Solomatin                           | solar05                       |
| James Tyler Solomon                       | uwo                           |
| Kevin Solorio                             | ksolo                         |
| Alexander Solovyov                        | piranha                       |
| Maksim Soltan                             | Gonzih                        |
| William Sommers                           | will-sommers                  |
| Dmitri Sotnikov                           | yogthos                       |
| Kevin Sookocheff                          | soofaloofa                    |
| Amar Sood                                 | tekacs                        |
| Josh Soref                                | jsoref                        |
| Nathan Sorenson                           |                               |
| Aleksandr Sorokoumov                      | Gerrrr                        |
| Dmitri Sotnikov                           | yogthos                       |
| Rafal Spacjer                             | rspacjer                      |
| Stephen Spalding                          | fotoetienne                   |
| Malcolm Sparks                            | malcolmsparks                 |
| Rangel Spasov                             | raspasov                      |
| Justin Spedding                           | justinspedding                |
| Cort Spellman                             | spellman                      |
| Thomas Spellman                           | thosmos                       |
| Christopher Spencer                       | cspencer                      |
| Michael Sperber                           | active-group                  |
| Marcus Spiegel                            | malesch                       |
| Spinu                                     | vspinu                        |
| Marek Srank                               | Mnicky                        |
| Ramko Sredojevic                          | radoye                        |
| Akhilesh Srikanth                         | akhileshs                     |
| Srihari Sriraman                          | ssrihari                      |
| Scott Stackelhouse                        | scottstackelhouse             |
| Paul Stadig                               |                               |
| Alex Stangl                               | astangl                       |
| Damien Stanton                            | damienstanton                 |
| Aleksander Madland Stapnes                | madstap                       |
| Yulia Startsev                            | ioctaptceb                    |
| Larry Staton Jr.                          | statonjr                      |
| Randall W Stauner                         | rwstauner                     |
| Mitchell Steed                            | MitchSteed                    |
| Jacob Stein                               | jakestein                     |
| Cosmin Stejerean                          |                               |
| Peter Stephens                            | pstephens                     |
| Immanuel Sterzik                          | immist                        |
| John Stevenson                            | jr0cket                       |
| Eric Stewart                              | ericstewart                   |
| Daniel Stockton                           | danielstockton                |
| Bodil Stokke                              | bodil                         |
| John Stoneham                             |                               |
| Vincent Storme                            | vincentstorme                 |
| Chad Stovern                              | chadhs                        |
| Nola Stowe                                | rubygeek                      |
| Alf Kristian Støyle                       | stoyle                        |
| Tristan Strange                           | triss                         |
| Jefrey Straszheim                         |                               |
| Stephen Striplin                          | arsenerei                     |
| Peter Strömberg                           | PEZ                           |
| Robert Stuttaford                         |                               |
| Gijs Stuurman                             | thegeez                       |
| Carl X. Su                                | bcbcarl                       |
| Steven Suehs                              | skelter                       |
| Manuel Sugawara                           | manuel-sugawara               |
| John Sullivan                             | JackSullivan                  |
| John Sullivan                             | jjsullivan5196                |
| Geoffry Sumter                            | geoffrys                      |
| Ning Sun                                  | sunng87                       |
| Daniel Sunnerek                           | kardan                        |
| Daniel Sutton                             | dpsutton                      |
| Magnar Sveen                              | magnars                       |
| Rasmus Svensson                           | raek                          |
| Ivan Sviatenko                            | pobivan                       |
| Christopher Swanson                       | Muduta                        |
| Neale Swinnerton                          | sw1nn                         |
| Julian Sy                                 | syjulian                      |
| Ghufran Syed                              | ghufransyed                   |
| Gordon Syme                               | gordonsyme                    |
| Egg (Davis) Syntax                        | eggsyntax                     |
| Juha Syrjälä                              | jsyrjala                      |
| Marten Sytema                             | Kah0ona                       |
| Tamas Szabo                               | sztamas                       |
| John Szakmeister                          |                               |
| Raf Szalanski                             | szalansky                     |
| Daniel Szmulewicz                         | danielsz                      |
| Ketan Tada                                | kvtada                        |
| Alex Taggart                              |                               |
| Tyler Tallman                             |                               |
| Levi R. I. Tan Ong                        | levitanong                    |
| Wei Tang                                  | sorpaas                       |
| Peter Taoussanis                          | PTaoussanis                   |
| Davide Taviani                            | Heliosmaster                  |
| Brian Taylor                              | netguy204                     |
| Chad Taylor                               | tessellator                   |
| Colin Taylor                              | coltnz                        |
| Miki Tebeka                               |                               |
| Ian Tegebo                                | itegebo                       |
| Zachary Tellman                           |                               |
| Sven Tennie                               | supersven                     |
| Zachary Teo                               | zackteo                       |
| Juho Teperi                               | Deraen                        |
| Jeff Terrell                              | kyptin                        |
| Alex ter Weele                            | aterweele                     |
| Benjamin Teuber                           |                               |
| Dale Thatcher                             | dalethatcher                  |
| Srinivas Reddy Thatiparthy                | srinivasreddy                 |
| Andreas Tholke                            | andreasthoelke                |
| Scott Thoman                              | thorstt                       |
| Justin Thomas                             | base698                       |
| Randall Thomas                            | evilmartini                   |
| Alan Thompson                             | catalan42 and cloojure        |
| Oskar Thorén                              | Oskarth                       |
| Thormelk                                  | thormelk                      |
| Eric Thorsen                              | EricThorsen                   |
| Travis Thieman                            | tthieman                      |
| Shi Tianshu                               | DogLooksGood                  |
| Joshua Tilles                             | mereleyapseudonym             |
| Yegor Timoshenko                          | yegortimoshenko               |
| Justin Tirrell                            | jjttjj                        |
| Ackerly Tng                               | ackerleytng                   |
| Eugene Tolbakov                           | etolbakov                     |
| Robert W. Tolbert                         |                               |
| David Tolpin                              | dtolpin                       |
| Steven Tomcavage                          | stomcavage                    |
| Lubos Tomsa                               | func-info                     |
| David Tonhofer                            | dtonhofer                     |
| Marko Topolnik                            | mtopolnik                     |
| Laszlo Török                              | LACZOKA                       |
| Devin Alexander Torres                    | devinus                       |
| Grigory "Gary" Trakhman                   | gtrak                         |
| Jonathan Tran                             |                               |
| Marc-Andre Tremblay                       | marcterm                      |
| Jose V. Trigueros                         | jvtrigueros                   |
| Perry Trolard                             | trolard                       |
| Chris Truter                              | crisptrutski                  |
| Benny Tsai                                | bitsai                        |
| Vladimir Tsanev                           | tsachev                       |
| Edward Tsech                              | edtsech                       |
| Giorgos Tsiftsis                          | chief                         |
| Tatsuya Tsuda                             | otabat                        |
| Fabio Tudone                              | circlespainter                |
| J. Chris Turner                           | BestFriendChris               |
| Emrehan Tuzun                             | emrehan                       |
| Arthur Ulfeldt                            |                               |
| Moritz Ulrich                             | the-kenny                     |
| Sam Umbach                                |                               |
| Leonardo Urbina                           | leourbina                     |
| Anthony Urena                             | anthgur                       |
| Travis Vachon                             |                               |
| Keyhan Vakil                              | kvakil                        |
| Matthew Valdez                            | mjvaldez                      |
| John Valente                              | johnv02139                    |
| Victor M. Valenzuela                      | vemv                          |
| Jeff Valk                                 | jeffvalk                      |
| Luke VanderHart                           |                               |
| Walter Van Der Laan                       |                               |
| Tom van der Sommen                        | tomvdsom                      |
| Jeroen van Dijk                           | jeroenvandijk                 |
| Toni Vanhala                              | tonivanhala                   |
| Cees Van Kemenade                         | cvkem                         |
| Geert Van Laethem                         | geertvl                       |
| Pieter van Prooijen                       | pieter-van-prooijen           |
| Klaus van Schelven                        | vanschelven                   |
| Tim Van Steenburgh                        | tvansteenburgh                |
| D van Tonder                              | daneelvt                      |
| Remco van't Veer                          | rwvtveer                      |
| Gerrit Jansen Van Vuuren                  | gerritjvv                     |
| Bill Vanyo                                | billvanyo                     |
| Alex Vear                                 | axvr                          |
| veera                                     | veera83372                    |
| David Velez                               | velez                         |
| Gary Verhaegen                            | gaverhae                      |
| Prayag Verma                              | pra85                         |
| Christopher K. Vermilion                  | cvermilion                    |
| Ryan Verner                               | ryanzverner                   |
| Seth Verrinder                            | sethev                        |
| Constantine Vetoshev                      | gcv                           |
| Max Veytsman                              | mveytsman                     |
| Magyari Viktor                            | moxaj                         |
| Villard                                   | teawaterwire                  |
| Pavlos Vinieratos                         | pvinis                        |
| Francisco Viramontes                      | Kidpollo                      |
| Tim Visher                                | timvisher                     |
| Léo Meira Vital                           | Leulz                         |
| Finn Völkel                               | fiv0                          |
| Simon Vocella                             | voxsim                        |
| Nick Vrvilo                               | DaoWen                        |
| Harley Waagmeester                        | HarleyWaagmeester             |
| Anil Wadghule                             | anildigital                   |
| Valentin Waeselynck                       | vvvvalvalval                  |
| andre Wagner                              | aw7                           |
| Jozef Wagner                              | wagjo                         |
| Adnan Wahab                               | King-of-Spain                 |
| Akhil Wali                                | darth10                       |
| John Walker                               | johnwalker                    |
| Joshua Walker                             | joshwalker9115                |
| Jason Walsh                               | jwalsh                        |
| Devin Walters                             | defn                          |
| Matthew Wampler-Doty                      | xcthulhu                      |
| Frank Wang                                | ProjectFrank                  |
| Lei Wang                                  |                               |
| Greg Warner                               | gdw2                          |
| Timothy J. Washington                     | twashing                      |
| Rainer Wasserfuhr                         | wasserfuhr                    |
| Edwin H. Watkeys III                      | edw                           |
| Mark Watson                               | mkwatson                      |
| Ben Weaver                                | weaver                        |
| Brian Weber                               |                               |
| Kevin Webster                             | rabidpraxis                   |
| Julian Wegkamp                            | julianwegkamp                 |
| Philip John Weir                          | weirp                         |
| Jeffrey Weiss                             | jweiss                        |
| Tim Welch                                 | tijwelch                      |
| Crispin Wellington                        | retrogradeorbit               |
| Yang Wenjie                               | mrmiywj                       |
| Trevor Wennblom                           | trevor                        |
| Jesse Wertheim                            | jaawerth                      |
| Blake West                                | bwest87                       |
| Matthew West                              | MatthewWest                   |
| Peter West                                | numinasthmatic                |
| Joel Westerberg                           | sunkencity                    |
| Christian Westrom                         | wildwestrom                   |
| Kaylen Wheeler                            | JvJ                           |
| Mark Whelan                               | mrwhelan                      |
| Russell Whitaker                          | russellwhitaker               |
| Ryan White                                | riaandewit                    |
| Jason Whitlark                            | jwhitlark                     |
| David Whittington                         |                               |
| Ivan Wick                                 | ivanwick                      |
| Oskar Wickstom                            | owickstrom                    |
| Henry Widd                                | henryw374                     |
| Darrick Wiebe                             | pangloss                      |
| Lucas Wiener                              | wnr                           |
| Nate Wildermuth                           | wildermuthin                  |
| Joseph Wilk                               | josephwilk                    |
| Ivan Willig                               | iwillig                       |
| Colin Williams                            | lackita                       |
| John Williams                             |                               |
| Shaun Williams                            | shaunlebron                   |
| Chris Wilson                              |                               |
| Ryan Wilson                               | rwilson                       |
| Joel Wilsson                              | wjoel                         |
| Guillermo Winkler                         | Guilespi                      |
| Jenan Wise                                | jenanwise                     |
| John Wiseman                              | wiseman                       |
| Toralf Wittner                            |                               |
| wmseddon                                  | mseddon                       |
| Karol Wójcik                              | FieryCod                      |
| Daniel Woelfel                            | dwwoelfel                     |
| Przemysław Wojnowski                      | pwojnowski                    |
| Jason Wolfe                               |                               |
| Francis Wolke                             |                               |
| Juvenn Woo                                | juvenn                        |
| Taylor Wood                               | taylorwood                    |
| Kevin Woram                               | kworam                        |
| Michael A. Wright                         | wrightmikea                   |
| Andreas Wurzer                            | andeee                        |
| Zhuang XiaoDan                            | killme2008                    |
| Di Xu                                     | xudifsd                       |
| James Xu                                  | xumingming                    |
| Alexander Yakushev                        | alexander-yakushev            |
| Minori Yamashita                          | ympbyc                        |
| Hongseok Yang                             | hongseok-yang                 |
| Huahai Yang                               | huahaiy                       |
| Tsutomu Yano                              | tyano                         |
| Jingguo Yao                               | jingguo                       |
| David J. Yarwood                          | daveyarwood                   |
| Benjamin Yelsey                           | byels                         |
| Lee Yen-Chin                              | coldnew                       |
| Jason Yeo                                 | jsyeo                         |
| Steven Yi                                 | kunstmusik                    |
| Nathaniel Young                           |                               |
| Brennon York                              | brennonyork                   |
| Yifeng Yu                                 | tylaar                        |
| Seth Yuan                                 | sethyuan                      |
| Miles Yucht                               | mgyucht                       |
| Yunkai                                    | clojurix                      |
| Stanislav Yurin                           | juskrey                       |
| Hu Yuxuan                                 | piotr-yuxuan                  |
| Daniel Zacarias                           | dzacarias                     |
| Nathan Zadoks                             | nathan7                       |
| Nicholas Zaleski                          | nzaleski                      |
| Carlo Zancanaro                           | czan                          |
| Michael Zavarella                         | admay                         |
| Andrey Zaytsev                            | zajac                         |
| Nick Zbinden                              | nickik                        |
| Guangyu Zhang                             | zguangyu0000                  |
| Dosbol Zhantolin                          | dosbol                        |
| Sergey Zharinov                           | zharinov                      |
| Jihui Zheng                               | zjhmale                       |
| Xiamgyu Zheng                             | zxygentoo                     |
| zhihong zhang                             | jiyouyou125                   |
| Michael Zhou                              | Dominator008                  |
| zuohong zhou                              | SuperStevenZ                  |
| Rob Zumwalt                               | rzoom                         |
| Greg Zuro                                 | gregzuro                      |
| Piotr Zygielo                             | pzygielo                      |

** Creating Tickets
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/creating_tickets.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/creating_tickets
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-12-05
:CUSTOM_ID: content/dev/creating_tickets
:END:

If you do not have a JIRA account, please follow the [[#content/community/contributing#reporting-problems-and-requesting-enhancements][preferred process]]
for filing an issue at [[https://ask.clojure.org][ask.clojure.org]]. If you're interested in
supplying patches or contributing to Clojure, please see the
[[#content/dev/dev][development overview]].

*** Creating Tickets

To create a ticket, you must already have a Clojure JIRA
account. Issues for Clojure itself can be created in the [[https://clojure.atlassian.net/projects/CLJ][CLJ]]
project. Contrib projects will have a link to their JIRA project in
the README.

*** Qualities of a Great Ticket

All tickets should have:

- Type: Correct categorization as Defect, Enhancement (extension of
  existing feature), or Feature (new)
- Summary: concise summary of the problem
- Description:
  - Exactly one problem (if multiple, split across tickets and link)
  - (If Defect) Reproducible demonstration of problem (commands that
    can be duplicated in a repl are preferred, particularly a plain
    Clojure repl, not a Leiningen repl), and a description of what you
    think should happen instead
  - (If Enhancement) Statement of how this is encountered and why it
    is a problem worth solving.
  - Links to relevant prior discussion if relevant
- Priority: categorize based on impact and whether this is a
  theoretical issue or one actually encountered in real code. This may
  be adjusted by the core team during triage.
- Labels: (see section below)

Tickets ready for screening should also have:

- Description:
  - The cause of the problem
  - List of alternatives to solving the problem
  - Which approach is being pursued
  - Name of current patch to consider
  - A description of the changes in the patch - anything you can do to
    illuminate what the changes are and why you made them will help
    ticket screeners as they re-walk your steps.
  - Benchmark data (if performance related)
- Patch attachment:
  - Implementation that follows the approach specified in the
    description
  - Tests as appropriate

Example:

This is an example of how the description might look once a ticket has
gone through screening - it starts with a succinct description of the
problem and a demonstration that can be tried at the REPL. That may be
all that exists when the ticket comes into the system. By the time it
gets through screening, we should expect to see the dev's analysis of
the cause of the problem, the solution that is being offered (and
possibly alternatives that were considered), and the patch currently
implementing the solution and test.

#+BEGIN_EXAMPLE
Adding odd numbers doesn't work.

----
user> (+ 2 2)
4
user> (+ 1 3)
ClassCastException
----

Cause:  Never implemented odd number adding in the Compiler!
See the missing branch in FooExpr.

Solution:  Fully implemented the branch for odd numbers to
be just like even numbers. Considered just getting rid of
addition altogether but I guess people use it.

Patch: add-odd-3.patch
#+END_EXAMPLE

*** Tend Your Ticket

As work progresses on a ticket, it is common for it to accumulate
discussion between submitter, screeners, and patch developers. As this
occurs, it is essential to edit the ticket description to stay up to
date as a summary of the essential problem, solution approach, and
patch. It should not be necessary to read the the full ticket history to
evaluate the patch.

Patches may, over time, no longer apply to master. Screeners often
update patches so they stay relevant (retaining attribution to the
author), but you can do this work as well if you like.

*** Labels

The following labels should be used to tag specific categories
(sometimes these are useful for searching):

- aot - ahead-of-time compilation bugs
- compiler - Clojure compiler
- checkargs - additional argument checking for functions
- deftype - types
- defrecord - records
- docstring - function docstrings
- documentation - clojure.org docs or other doc-related issues
- edn - EDN
- errormsgs - improving (or sometimes adding) an error message returned
  by Clojure
- interop - Java interop
- io - clojure.java/io
- math - arithmetic issues - overflow, underflow, etc
- memory - memory issues (GC, head holding, locals clearing, etc)
- performance - make it faster!
- print - print and pprint
- protocols - defprotocol
- reader - reader (either clojure or edn)
- reducers
- repl - usability on the repl (doc, source, apropos, etc)
- string - clojure.string, subs, etc
- typehints - their definition or application
- walk - clojure.walk
- zip - clojure.zip

DO NOT use these tags:

- bug - this is already covered by the issue type
- enhancement - this is already covered by the issue type
- patch - already covered by the patch field
- test - already covered by the patch field

** Developing Patches
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/developing_patches.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/developing_patches
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-12-05
:CUSTOM_ID: content/dev/developing_patches
:END:

If you're interested in supplying patches or contributing to Clojure,
please see the [[#content/dev/dev][development overview]].

*** Before You Code

If you consider the following items before you begin coding, you will
produce a patch that is easier to assess and more likely to be accepted:

- What problem are you trying to solve? Prior to any patch you should
  have a problem statement, and it should be included in the
  description of the patch.
- What is your solution approach? Please make this clear in the
  description, so that it does not have to be inferred from the code.
- Have you vetted your idea with the community? Please discuss in Slack
  or mailing list with members of the core team if you can. (Not
  necessary for everything, like typos.)
- Make a table of considered alternatives, and their tradeoffs.
  Describe why the chosen solution is the best choice.
- How will you prove to others your patch works? Plan to include tests.
  Example-based tests are ok, but generative tests are preferred.
- Document the changes in the patch in the ticket. Anything that can
  help a screener understand what changes you made and why will make
  their job easier.
- Don't do too much! Submit small patches that address specific
  problems, don't add anything extra, even (especially!) "cleanup" of
  nearby code. This only serves to confuse the intent of the patch.

*** While Your Patch is Being Considered

- Keep the description up-to-date as comments come in. It is very
  time-consuming to reconstruct the current state of a ticket by
  reading the comment thread.
- Rally support. Votes are good, and comments from other users
  reviewing the ticket are even better.
- As tickets grow, make sure you document clearly which patch(es) are
  active. Don't do this by deleting old patches, just refer to patches
  by name in the comments.

*** Coding

Once you're ready to craft your code, the first thing you'll need is a
clone of the Clojure or appropriate repository. The examples below are
for the Clojure project --- for submissions to Clojure itself:

#+BEGIN_EXAMPLE
$ git clone git://github.com/clojure/clojure.git
$ cd clojure
#+END_EXAMPLE

Next, create a new branch for yourself:

#+BEGIN_EXAMPLE
$ git checkout -b fixbug42
Switched to a new branch "fixbug42"
#+END_EXAMPLE

Now you're ready to get hacking. Before you start working, make sure all
existing regression tests still pass e.g. For Clojure, use Maven:

#+BEGIN_EXAMPLE
$ mvn clean test
...lots of output...
test:
[INFO] Executed tasks
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 01:26 min
[INFO] Finished at: 2018-12-05T14:36:54-06:00
[INFO] ------------------------------------------------------------------------
#+END_EXAMPLE

Once you've finished making your changes you need to commit them. Please
use a commit message that begins with the JIRA number (CLJ-xyz) and
includes a statement about the problem or enhancement the changes are in
service to!

#+BEGIN_EXAMPLE
$ git commit -a -m "CLJ-932 fixed annoying bug"
Created commit 8f7c712: fixed annoying bug
1 files changed, 0 insertions(+), 1 deletions(-)
#+END_EXAMPLE

Now that you've made your changes it's time to get them into a patch.
You need to update the repo and fix any conflicts you had.

#+BEGIN_EXAMPLE
$ git checkout master
Switched to branch "master"
$ git pull
...
$ git checkout fixbug42
Switched to branch "fixbug42"
$ git rebase master
#+END_EXAMPLE

Once you've fixed any conflicts, you're ready to create a patch:

#+BEGIN_EXAMPLE
$ git format-patch master --stdout -U8 > clj-932-1.patch
#+END_EXAMPLE

*** Adding patches

Now you can attach that patch file to the JIRA ticket. In the More
Actions menu near the top of the page, select Attach Files. Please read
and follow the recommendations below when writing comments about your
attached patch. Screeners have limited time available for screening. You
are more likely to get your patch approved if you can be as clear as you
can, and as efficient with their time as possible.

- Please use .patch or .diff (not .txt) as a suffix for patch files.
- Read your patch file before attaching it. If you see things like
  white space changes unrelated to the portion of code you are
  modifying, please edit and remove those changes and regenerate the
  patch. Also, while it is nice when developing to do multiple commits
  in a sequence, with explanations of each commit, patch reviewers
  usually prefer to have all changes squashed to a single commit for
  review.
- Using 'git add --patch' to stage your changes will make it easier to
  avoid committing extraneous changes.
- Please use a name different from all existing attachments on the
  ticket. JIRA allows you to add multiple attachments with the same
  name, but later ones do not replace earlier ones. This can lead to
  confusion when referring to patches by name.
- Include the file name and date of the patch in any comments referring
  to it. It is possible to match up comments with patches based on the
  date and time, but it is tedious and error prone.
- To get email whenever the ticket is updated, click on the word
  "Watch" in the top right area of the page. This can help you know
  when someone else comments on your patch or creates a new one, etc.
  Click "Watching" if you want to stop the update emails for a ticket.
  You may want to verify that the automated emails get through your
  spam filter. Emails will be sent to the address associated with your
  JIRA account, and will come from the address [[mailto:jira@dev.clojure.org][jira@dev.clojure.org]].
- If you create a new patch that incorporates one or more earlier ones,
  please combine them all into one patch file, and indicate in your
  comments that you have done this (with file names and dates of the
  patches you are superseding). One exception to this is when there
  are significant largely independent contributions from multiple
  people (for example, one made a code change and the other wrote the
  tests) and both want credit. In that case, a single patch file with
  multiple commits is fine. However, we'd like to avoid multiple
  patches that repeatedly modify the same code.

Mark the ticket as having a patch ready for screening by editing the
Patch field. Click the Edit button near the top left of the page for the
ticket. In the next page find the heading "Patch" with a popup menu next
to it. Select "Code" or "Code and Test" from that menu, then click the
Update button at the bottom of the page. If you do not see an Edit
button on the page for the ticket, and you have signed a CA, ask on the
developer's email list or on #clojure-dev in Clojurians Slack to be
given permission to edit Jira tickets.

*** Removing patches

To remove a patch (e.g. because it is no longer relevant), go to the
page for the ticket and look for the "Attachments" heading beneath the
Description text. Far to the right is a plus sign and a triangle. Click
on the triangle and select "Manage Attachments" from the menu. Think
carefully on which one you want to delete, and click the trash can icon
next to it. Note: most people have permission to remove their own
attachments, but not those added by someone else.

In general, you don't need to remove old patches. Just let them
accumulate and track the most relevant in the ticket description.

*** Updating stale patches

A stale patch means one that used to apply cleanly to the latest Clojure
master version, but due to commits made since the patch was created, it
no longer does. In particular, the output of this command:

#+BEGIN_EXAMPLE
$ git am --keep-cr -s --ignore-whitespace < patch_file.patch
#+END_EXAMPLE

includes 'Patch failed' and 'To restore the original branch and stop
patching, run "git am --abort"'. You should do the "git am --abort" to
get rid of state of the failed patch attempt left behind by the command
above.

"git am" is very "fragile", meaning that if the ~patch_file~ was created
with one version of the source code, all it takes for the command to
fail is a change in any of the lines of context present in the patch
file, even if it is not one of the lines being changed by the patch.
This is especially common for files containing unit tests, because
people usually add new tests at the end of such a file, and so the lines
of context before the new test change if two different patches add a new
test to the end of the same file.

To apply such a patch, use the --reject flag:

#+BEGIN_EXAMPLE
$ git apply --reject patch_file.patch
#+END_EXAMPLE

The output will give you some hints of whether each "hunk" of the patch
file succeeded or failed. If they all succeed, then likely the only
thing wrong with the patch file is that a few context lines were
changed. If any hunks fail, patch creates files ending with ".rej"
containing rejected hunks that it did not apply, and you can focus on
those as places where the source code likely changed more significantly.
A command like this will find them all:

#+BEGIN_EXAMPLE
$ find . -name '*.rej'
#+END_EXAMPLE

You will need to look at those rejected hunks, perhaps think about them
for a bit to see if and how they still apply, and apply them by
hand-editing the source code yourself.

When creating a new git patch with:

#+BEGIN_EXAMPLE
$ git format-patch master --stdout -U8 > patch_file.patch
#+END_EXAMPLE

it puts your name and the current date near the top of the file. If the
only changes that you have made are in the context lines, please keep
the original author's credit intact by copying the name and date from
the original patch that you started from, then upload that.

If you write unit tests where there were none in the original patch, but
didn't otherwise modify the original patch, and you would like your name
in the commit log for your work, create a separate patch of test
additions with your name on it, leaving the original author's name on
the updated patch.

*** Screening a patch

If you are a screener testing a patch, you can create a new branch and
apply the patch to start working with it:

#+BEGIN_EXAMPLE
$ git checkout -b testxyz
$ git am --keep-cr -s --ignore-whitespace < patch_file.patch
#+END_EXAMPLE

And you can throw that branch away when you're done with:

#+BEGIN_EXAMPLE
$ git checkout master
$ git branch -D testxyz
#+END_EXAMPLE

*** How To Run All Clojure Tests

#+BEGIN_EXAMPLE
$ mvn clean test
#+END_EXAMPLE

To reduce the duration of the pseudo-randomly generated generative tests
from 60 sec down to 1 sec (for example), edit the file
~src/script/run_test_generative.clj~ and change the 60000 number. Just
be careful not to include such changes in any patches you submit. (The
file was called ~src/scripts/run_tests.clj~ in Clojure 1.6.0 and earlier)

*** Run An Individual Test

First, build the latest Clojure without running any tests:

#+BEGIN_EXAMPLE
$ mvn -Dmaven.test.skip=true clean package
# If no compilation errors, mvn command above creates target/clojure-VERSION-master-SNAPSHOT.jar
#+END_EXAMPLE

The commands above build a Clojure jar file, but neither compile nor run
the tests.

Create a deps.edn file describing dependencies you might need:

#+BEGIN_SRC clojure
{:paths ["test"]
 :deps
 {org.clojure/clojure {:mvn/version "RELEASE"}
  org.clojure/test.check {:mvn/version "0.9.0"}
  org.clojure/test.generative {:mvn/version "0.5.2"}}
 :aliases
 {:dbg {:classpath-overrides {org.clojure/clojure "target/classes"}
        :extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}}}
#+END_SRC

Start a repl using clj and run individual tests from it:

#+BEGIN_EXAMPLE
$ clj -A:dbg
Clojure ...
;; We're testing with clojure.test
=> (require 'clojure.test)
nil
;; Load a test file
user=> (require 'clojure.test-clojure.data)
nil
;; Run it
user=> (clojure.test/run-tests 'clojure.test-clojure.data)

Testing clojure.test-clojure.data
Ran 1 tests containing 17 assertions.
0 failures, 0 errors.
{:type :summary, :pass 17, :test 1, :error 0, :fail 0}
#+END_EXAMPLE

Start a repl and run a generative test from it:

Generative tests use additional testing jars (installed when you run
./antsetup.sh). Thus, you'll need to have some additional classpath
which antsetup.sh will leave in the maven-classpath file. If you are on
*nix, the easiest way to leverage this file is:

#+BEGIN_EXAMPLE
$ clj -A:dbg
Clojure ...
;; Install some clojure.test extensions
user=> (require 'clojure.test-helper)
nil
;; Load a test file that uses test.generative
user=> (require 'clojure.test-clojure.reader)
nil
;; Load the test.generative runner ns
user=> (use 'clojure.test.generative.runner)
nil
;; Test a specification on 1 thread for 200 ms
user=> (run 1 200 #'clojure.test-clojure.reader/types-that-should-roundtrip)
{:iter 60, :seed 1255541066, :test clojure.test-clojure.reader/types-that-should-roundtrip}
nil
#+END_EXAMPLE

*** Other options for building Clojure
**** Building Clojure without direct linking

By default, Clojure is built with direct linking enabled. While this
improves performance, it means that if a function A calls a function B,
both within Clojure, then using spec to instrument B will leave A still
calling the original function B, not the instrumented version. If you
wish to instrument B and have other functions in Clojure call the
instrumented version, one way is to build Clojure with direct linking
disabled.

Edit the file build.xml to replace "true" with "false" in the following
line, which is inside of the section beginning with 'target
name="compile-clojure"':

#+BEGIN_EXAMPLE
<sysproperty key="clojure.compiler.direct-linking" value="true"/>
#+END_EXAMPLE

Then use your preferred method of building Clojure from source, e.g.:

#+BEGIN_EXAMPLE
$ mvn -Dmaven.test.skip=true clean install
#+END_EXAMPLE

** Development
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/dev.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/dev
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-06-03
:CUSTOM_ID: content/dev/dev
:END:

Clojure was created by Rich Hickey and is developed by a core team of
developers at [[https://cognitect.com][Cognitect]], which supports this work. The Clojure
development team values a measured and thoughtful approach to language
evolution with a strong emphasis on maintaining backward
compatibility.

*** Becoming a Contributor

First, please consider the [[#content/community/contributing][many ways to contribute]] as a Clojure
user. If you wish to discuss a problem or enhancement, [[#content/community/ask][you can do so
on the forum]] without becoming a contributor.

The Clojure core team values those that engage with the current stream
of ongoing work, doing the hard work of triage, [[#content/dev/developing_patches][patch development]],
[[#content/dev/screening_tickets][screening]], etc. The [[#content/dev/workflow][workflow]] page highlights places to tap into those
queues of work as jira reports. The core team tends to focus on
tickets primarily in the late alpha / early beta period for a release
cycle.  During other parts of the release cycle, activity may seem
dormant, but that is the perfect time to improve tickets so they are
ready to evaluate. Tickets that are well-written with good patches can
move quickly through the cycle at the appropriate time.

If you are interested in becoming involved as an active contributor:

1. Sign the [[#content/dev/contributor_agreement][Clojure Contributor Agreement]].
2. File a [[https://clojure.atlassian.net/servicedesk/customer/portal/1][contributor support request]] to get a contributor account -
   please include the email address you wish to use with your
   account.

*** Participating as a Contributor
**** Issues

Contributors can file tickets directly in the issue tracker. You might
want to check what you are seeing with others on a Clojure discussion
forum before filing. Please review the [[#content/dev/creating_tickets][guide to creating useful
tickets]].

Clojure accepts contributions as patches on issues. Please review
[[#content/dev/developing_patches][these guidelines]] on developing patches.  Tickets may be assessed over
a long period of time, following the [[#content/dev/workflow][workflow]].

**** Enhancements and Features

Clojure's direction is determined by Rich Hickey and the core team. This
process is open to input and visible in issues and commits, but not
explicitly driven by the community. The core team pays attention to the
needs of the community by monitoring and participating in many Clojure
discussion forums, and by reviewing issues and votes in the issue
tracker. We are currently evaluating better systems for collecting and
prioritizing enhancement requests.

If you have an idea for an enhancement or new feature for Clojure, it
may be helpful to search the issue tracker for prior issues and/or raise
this idea for discussion in one of the Clojure forums. In particular,
the mailing lists or #clojure-dev room on Clojurian slack are good
places to discuss.

Please follow the guidelines in [[#content/dev/creating_tickets][Creating Tickets]] and [[#content/dev/developing_patches][Developing
Patches]] - enhancement/feature tickets should start with a compelling
problem to solve and compare alternatives and their tradeoffs, rather
than leap straight to a solution and a patch. Clojure is a small
language and endeavors to remain so. In many cases, proposed features
can instead be provided in functions or libraries outside the core.

*** Roadmap

Clojure is an open-ended project with no fixed release schedule. Major
releases typically occur about once per year. While there are usually
a few focused areas of work in a major release, it is common for those
to change during the development of the release in response to either
feedback or changing external needs. Because of this, a roadmap is
typically not declared at the beginning of a release. Ongoing
development is visible during alpha releases, often phased over
multiple dev releases. The [[#content/releases/devchangelog][Dev Changelog]] chronicles these changes
during the release cycle.

Additionally, the core team may be doing work in dependent projects or
tools, rather than the language itself, such as spec, core.specs,
tools.deps, clj, etc. This is still considered part of the broader
"release" train.

** Screening Tickets
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/screening_tickets.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/screening_tickets
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-04-24
:CUSTOM_ID: content/dev/screening_tickets
:END:

If you're interested in supplying patches or contributing to Clojure,
please see the [[#content/dev/dev][development overview]].

The job of screening is to create a funnel, so that the highest
importance, highest urgency items are brought to the BDFL's attention
first, already vetted and tested.

*** Choosing Tickets to Screen

- Bugs first, then features. Most users do not edit the issue type or
  severity fields, so most tickets start marked as bugs, and job 1 is
  to recategorize them.
- Focus on tickets with code. If there isn't code yet, you will have to
  write it, and have someone else screen it.
- No new features during Beta. The most a feature request can hope for
  during Beta is to be assigned the "Approved Backlog" release
- Do the important bugs first. There is no AI query to find these. One
  obvious criterion for importance is difficulty of workaround. Another
  is regression. Another is upvoted issues.
- Vote up issues you think important.

*** Fail Fast

Reasons to decline a ticket:

- Change does more than one thing. Break it up, submit individual
  problems and patches.
- Enhancement belongs in a library instead. Be encouraging and redirect
  the person to an appropriate Contrib (or propose a new Contrib).
- Does not comprehensively consider the root problem.

The following are required in the ticket. Mark the ticket incomplete if
any are missing (or fix the gap if you can):

- Clear description of the problem.
- For defects, a reproducing case in a basic repl (no gists, no
  external github projects, no jars, etc unless absolutely necessary
  due to AOT etc).
- For defects, a description of the cause of the problem.
- The approach to fixing the problem (or implementing the enhancement).
  This should explain (as a narrative) the change in the patch.
- For changes that have a performance impact, a performance analysis.
  Results should be in a table showing before and after timings.
  Example code to reproduce the timings should be either linked or
  included. Specify the Clojure and Java version used to take the
  timings.
- The name of the patch to consider (unless there is only one patch,
  and even then, it wouldn't hurt).
- Links to background discussions or other relevant material a screener
  should read.

The following are required in the patch. Mark the ticket incomplete if
any are missing:

- Patch file should end in .patch or .diff.
- Commit message should start with the ticket id and have a brief 1
  line description of the change. Optionally, it may have a longer
  description after that.
- Patch should be in proper format and include tests.

*** Want to Become a Screener?

Screeners are a subset of contributors who are responsible for moving
tickets through a review process, and then funneling tickets to the
BDFL.

It would be great to have more screeners. If you are interested, just do
all the steps described in this document, without actually changing any
ticket attributes. Instead, add a comment to the ticket explaining what
you would have done to screen it. (Screeners: keep an eye out for such
comments, and where sensible provide feedback so that we are grooming
more screeners.)

*** Process in Detail

Periodically, screeners will review tickets whose approval is marked
'Test'.

- Take ownership of the ticket so that others know you are working on
  it.
- Make sure to work on defects first. Enhancements are much lower
  priority, and should typically begin with a design conversation in a
  mailing list or elsewhere
- Read the entire ticket, including linked docs and comments.

To apply someone's changes you need to first create a branch:

#+BEGIN_EXAMPLE
$ git checkout -b freds_fixbug42
$ git am --keep-cr -s --ignore-whitespace < their-patch-file.diff
#+END_EXAMPLE

- make sure you have a clean local checkout
- no need to check on multiple OSes (unless the ticket is specific to
  this)
- If you are committing i.e. you own the lib, please note the
  importance of -s above, as it indicates that you are the one
  accepting this patch.
- The --keep-cr helps when files being patched contain DOS CR/LF line
  endings. It seems to be harmless when it isn't needed, but leave it
  off or use --no-keep-cr if you suspect it is causing issues.
- The --ignore-whitespace helps when the only changes made to master
  since the patch was created are to whitespace in the context lines.
  Without this option, some patches will fail to apply. With that
  option, screeners can help avoid making contributors update patches
  merely because some whitespace changed in master.

Once you have a working copy, you should take note of the following
kinds of things:

- Review the code in a diff tool to make sure that nothing extraneous
  snuck in
- Ensure that the commit message includes a statement about the problem
  or enhancement that the patch is in service to.
- Make sure compile and tests pass
- Test the functionality from the REPL
- Does the patch accomplish the goals stated in the ticket
- Is the code in proper style? But remember that [[#content/dev/contrib_howto#coding-guidelines][Coding Guidelines]] are
  guidelines, not fixed laws of the universe.
- If questions were raised in the discussion, are they answered in the
  ticket?
- Are you happy with the tests, can you follow what they're testing, is
  there anything missing?
- Are the tests excessive (introducing dependency on implementation
  detail)?
- Does the documentation still seem right to you?
- Is the implementation idiomatic (if not, explain why, link to
  examples...​)
- Is the patch performance-sensitive? If so, is the approach
  appropriate?

After review, if you are happy, you should

- Set the approval of the ticket to Screened
- If you own the lib in question, you can set approval to Accepted, and
  deploy the change

If you are not happy, but the ticket is fixable:

- Add a comment to the ticket, explaining what the issues are
- Set the approval of the ticket to 'Incomplete'
- Set the waiting-on of the ticket to the person who created the patch

If you are not happy, and the ticket does not seem fixable

- add a comment, explaining the issues
- Decline the ticket

If you aren't sure

- Get a second opinion, and note this in the comments
- Set the waiting-on to Rich or Stu, if appropriate

** Workflow
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/dev/workflow.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/dev/workflow
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-12-06
:CUSTOM_ID: content/dev/workflow
:END:
*** How a Ticket Becomes a Commit

This page describes the overall workflow for how tickets (bugs and
enhancement requests) make their way through the JIRA ticketing system
and ultimately become part of Clojure, ClojureScript, and ClojureCLR.

The overall process described here has several goals:

- Maintain Clojure quality
- Fix problems that are important to users
- Engage the community in working toward the best possible Clojure

*** Groups

There are several groups involved in this process with increasing levels
of responsibility:

- Anyone - anyone can submit a bug or enhancement request to Clojure
  once you have created a Clojure JIRA account
- Contributors - anyone that has [[#content/dev/contributor_agreement][signed the contributor agreement]] can
  supply patches or work on improving tickets
- Screeners - a smaller group of trusted individuals have been granted
  the ability to move tickets through (some of) the stages of the
  process, in particular the Triage and Screening activities
- BDFL - Rich Hickey is the creator and Benevolent Dictator for Life of
  what goes into Clojure. Stuart Halloway also has a special level of
  access and typically commits patches to Clojure.

*** Ticket fields

There are several important fields on a ticket that jointly determine
it's "state" in the workflow below. Some key fields to know about:

- JIRA status- these govern the default JIRA workflow and consist of
  Open, In progress, Reopened, Resolved, Closed
  - The Clojure workflow does not really distinguish between these
    much other than general open/closed differentiation
- Approval- a custom field that is (mostly) how Screeners change the
  state of a ticket
  - None - new ticket
  - Triaged - screener has approved the ticket as worth working on
  - Prescreened - screener has approved the ticket and screened the
    patch for review
  - Vetted - screener and Rich have approved the ticket as worth
    working on
  - Screened - screener has approved a ticket's patch for review by
    Rich
  - Incomplete - screener has requested improvements to a ticket or
    patch
  - Ok - Rich has approved the ticket for inclusion
- Patch- qualifies the kind of patch attached
  - None - no patch
  - Code - code only, no test
  - Code and Test - code and test
- Fix version
  - Release X.X - specific targeted release
  - Backlog - will consider in future release
- Resolution- when a ticket is closed, it will have a resolution
  - Declined - did not accept a ticket for work
  - Duplicate
  - Completed
  - Unresolved

*** Workflow

The diagram below documents the process used for how tickets make their
way through the system. The rounded boxes represent states in the
workflow. They have well defined criteria (which sometimes cover
multiple fields) such that each of these states can have a report. In
general, a single line state indicates the Approval state. If additional
fields are in play, they are listed after the state.

The colored blocks represent activities performed by different groups -
the colors correspond to the group (Orange = contributors, Blue =
screeners, Green = BDFL). Diamonds represent decisions to be made during
an activity. Activities are described in more detail below the diagram.

[[./assets/images/content/community/process.png]]

*** Activities

*Triage*

- Who: Screeners
- Report: [[https://clojure.atlassian.net/issues/?filter=10001][Open tickets]]
- Goal: decide whether the bug or enhancement described in the ticket
  is actually a real bug or enhancement.
- Process (see: [[#content/dev/creating_tickets][Creating Tickets]]):
  1. Is the ticket about 1 thing? If not, then either split the ticket
     yourself or ask the submitter to do so.
  2. Does the ticket clearly state the problem? If not, then either
     update yourself or ask the submitter to do so.
  3. For larger enhancements / features, it is probably better to
     suggest the submitter post to clojure-dev and then create a page
     on the design wiki instead.
  4. For bugs, there should be some demonstration that the problem
     actually exists (output from a repl, test, etc). Verify the
     problem exists in the current release of Clojure.
  5. Does the ticket include a link to other relevant discussion (such
     as a clojure-dev thread, IRC conversation, etc)?
  6. At this stage, it is not necessary for there to be a patch or to
     validate it fixes the problem.
- Actions, pick one of:
  - Comment on ticket to ask for more information, better description,
     better demonstration of problem, etc
  - Close with Resolution=Decline, reasons:
    - Not a bug: submitter misunderstood or misused a feature or
      ticket doesn't make sense
    - Scope too big: feature may be better served by creating a page
      in the design wiki than in a ticket
    - Enhancement not wanted: enhancement is not something we want to
      do
    - Duplicate: of existing ticket
    - Too many things: break this ticket apart into smaller pieces
  - Set Approval=Triaged - problem is ok
    - If needed, adjust ticket to standards in
      [[#content/dev/creating_tickets][Creating Tickets]]

*Prescreening*

- Who: Screeners
- Report: [[https://clojure.atlassian.net/issues/?filter=10002][Triaged tickets]]
- Goal: improve the ticket and screen the patch before Rich does
  vetting, allows faster path through the remainder of the process
- Actions:
  - Set Approval=Prescreened - patch is ok
  - Comment on ticket regarding issues with patch (leaves in Triaged)

*Vetting*

- Who: Rich
- Report: [[https://clojure.atlassian.net/issues/?filter=10002][Triaged]] and [[https://clojure.atlassian.net/issues/?filter=10003][Prescreened]] tickets
- Goal: second check on whether the bug/enhancement is worth working on
  and decision of whether it's suitable for the next release.
- Actions:
  - Close w Resolution=Declined - as above, ticket may not be
    something we want to address
  - Set Approval=Vetted - problem is good

*Release scheduling*

- Who: Rich
- Report: [[https://clojure.atlassian.net/issues/?filter=10004][Vetted tickets]]
- Goal: determine whether a ticket is in scope for next release or
  should be in backlog
- Actions:
  - Set Fix Version to "Backlog" - don't want to fix it in the next
    release
  - Set Fix Version to current release
    - If does not have patch, will show up in [[https://clojure.atlassian.net/issues/?filter=10007][Needs Patch]] report
    - If does have patch, will show up in [[https://clojure.atlassian.net/issues/?filter=10008][Screenable]] report

*Dev patch*

- Who: contributors (anyone with signed CA)
- Report:
  - [[https://clojure.atlassian.net/issues/?filter=10007][Needs
    Patch]] - for tickets that need a patch
  - [[https://clojure.atlassian.net/issues/?filter=10009][Incomplete]] tickets - for tickets that have patches that need work
- Goal: create a high quality ticket and patch for consideration (see
  sections below)
- Actions:
  - Edit ticket or update patch to address problems or gaps based on
    comments.
  - Adding a new patch and changing "Patch" attribute to "Code" or
    "Code and Test" automatically causes a patch to move from the
    "Needs Patch" to the "Screenable" list of tickets. However, adding
    a patch to an incomplete ticket does not. Alex Miller periodically
    scans Incomplete tickets to see if they appear ready to go back to
    Screenable, and makes those state changes manually.

*Screening*

- Who: Screeners
- Reports:
  - [[https://clojure.atlassian.net/issues/?filter=10008][Screenable]] tickets (for new vetted tickets with patches)
  - [[https://clojure.atlassian.net/issues/?filter=10009][Incomplete]] tickets that have changed recently - need to re-review
    if submitter has updated ticket since marked Incomplete.
- Goal: verify that ticket and patch are ready for Rich to review. The
  quality bar is HIGH - the ticket and patch should be perfect.
- Checks (see [[#content/dev/creating_tickets][Creating Tickets]] and [[#content/dev/developing_patches][Developing Patches]] and [[#content/dev/screening_tickets][Screening
  Tickets]]):

  1. Is there a patch?
  2. Is there a test?
  3. Has author [[#content/dev/contributor_agreement][signed the CA]]?
  4. Can you apply the patch to current source tree?
  5. Do all tests pass?
  6. Is patch clean (no extraneous whitespace or changes outside the
     scope of the problem)?
  7. Are docstrings still accurate?
  8. Are there potential performance impacts? If so, what benchmarks
     have been performed?
  9. Does the solution follow code guidelines and look like the
     surrounding code in style?
  10. Does the solution imply possible similar changes elsewhere?
  11. Does the solution introduce new failure conditions that might
      need to be considered or documented?
  12. Does the solution change external or internal APIs that might
      affect users?
- Actions:
  - Set Approval=Incomplete and add comment describing needed
    improvements
  - Set Approval=Screened - ticket and patch are perfect and Rich
    should review

*Final screening*

- Who: Rich
- Report: [[https://clojure.atlassian.net/issues/?filter=10010][Screened tickets]]
- Goal: Rich blessing the change
- Actions:
  - Set Approval=Incomplete - ticket or patch needs improvement
  - Set Approval=OK - everything is good, ready to commit

*Commit*

- Who: Stu H (usually)
- Report: [[https://clojure.atlassian.net/issues/?filter=10011][OK tickets]]
- Goal: Final review of change and commit to Clojure source
- Actions:
  - Make sure you have the right patch
  - Make sure the author has signed the CA
  - Double-check that the patch applies cleanly and builds locally
  - Commit and push the patch
    - I find it safest to do committing from a separate local
      repository. I have a "clojure" git clone that does not have push permissions for dev and screening, and a separate "clojure-for-commit" checkout for committing. This reduces the chance that my muscle memory will produce a "git push" at the wrong time.
  - Set Approval=Accepted and close ticket

*Backlog Review*

- Who: Rich (primarily)
- Report: [[https://clojure.atlassian.net/issues/?filter=10006][Backlog tickets]]
- Goal: See if backlogged tickets should be pulled into next release
- Actions:
  - Set Fix Version from Backlog to current release
  - (or don't to leave in Backlog)

*** Ticket report summary

- Clojure
  - Release-independent reports - [[https://clojure.atlassian.net/issues/?filter=10001][Open]] | [[https://clojure.atlassian.net/issues/?filter=10002][Triaged]] | [[https://clojure.atlassian.net/issues/?filter=10003][Prescreened]] |
    [[https://clojure.atlassian.net/issues/?filter=10004][Vetted]] | [[https://clojure.atlassian.net/issues/?filter=10005][Declined]] | [[https://clojure.atlassian.net/issues/?filter=10006][Backlog]]
  - Next release work queues - [[https://clojure.atlassian.net/issues/?filter=10007][Needs Patch]] | [[https://clojure.atlassian.net/issues/?filter=10008][Screenable]] | [[https://clojure.atlassian.net/issues/?filter=10009][Incomplete]] |
    [[https://clojure.atlassian.net/issues/?filter=10010][Screened]] | [[https://clojure.atlassian.net/issues/?filter=10011][Ok]] | [[https://clojure.atlassian.net/issues/?filter=10012][Accepted]] | [[https://clojure.atlassian.net/issues/?filter=10013][Closed]]
- ClojureScript - [[https://clojure.atlassian.net/issues/?filter=10028][Newbie]] | [[https://clojure.atlassian.net/issues/?filter=10017][Screenable]]
- core.async - [[https://clojure.atlassian.net/issues/?filter=10023][Open, no patch]] | [[https://clojure.atlassian.net/issues/?filter=10024][Open, with patch]] | [[https://clojure.atlassian.net/issues/?filter=10025][Open, CLJS-only]]

* Events
** 2015
*** Clojure eXchange
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2015/clojurex.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2015/clojurex
:CLOJURE_SITE_AUTHOR: Skills Matter
:CLOJURE_SITE_DATE: 2015-12-03
:CUSTOM_ID: content/events/2015/clojurex
:END:

Do you want to explore the latest innovations in Clojure and meet with
your peers attempting to solve complex software problems using this
Functional language?

Clojure's rise to prominence and it's increasing popularity as 'weapon
of choice' for tackling complex software problems got us thinking;
wouldn't it be great to get the world's greatest Clojure experts in
London with hundreds of fellow Clojurians? Well, we thought so too.

** 2016
*** ClojureBridge Austin
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_austin.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_austin
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-11-06
:CUSTOM_ID: content/events/2016/clojurebridge_austin
:END:

[[http://www.clojurebridge.org/][ClojureBridge Workshops]] are intended for Women Developers and those
that identify as Women.

Learn Clojure, a functional language built on top of java. We will use
Clojure to build a simple web app, learning as we go.

Experience Needed: You should be familiar with basic coding and have a
laptop able to run Java 1.8.

*** ClojureBridge Berlin Germany
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_berlin_2.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_berlin_2
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-11-25
:CUSTOM_ID: content/events/2016/clojurebridge_berlin_2
:END:

We are offing this workshop to help make the Clojure community more
accessible to a diverse range of participants. As such, registration is
open to people who identify as a woman or have a nonbinary gender
identity. Note that our coaches and organizers who will also be present
at the event are members of the local Clojure community of various
genders.

We'll meet up Friday late afternoon to install all of the software you
need, and then spend Saturday learning and writing code. You will learn
and practice in small groups of 2 to 4 attendees each.

*** ClojureBridge Berlin
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_berlin.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_berlin
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-01-22
:CUSTOM_ID: content/events/2016/clojurebridge_berlin
:END:

This 2-day-workshop will be held in Berlin, Germany, on January 22 & 23,
2015. We will use Clojure, a modern programming language, to introduce
you to fundamental programming concepts and build a sample app using
Clojure.

Total programming novices, system administrators, developers in other
languages, and folks who attended our previous workshops are all
welcome. We'll have different classes separated by experience level.

*** ClojureBridge Boston
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_boston.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_boston
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-10-14
:CUSTOM_ID: content/events/2016/clojurebridge_boston
:END:

ClojureBridge Workshop is aimed at increasing women's participation in
the Clojure community. A free 1-day workshop will be held in Cambridge,
MA on Saturday October 15 2016 with an optional install fest on Friday
late afternoon October 14 2016. The workshop is intended both for those
new to programming, as well as those with some programming experience,
who would like to explore programming using Clojure, a modern functional
programming language.

The workshop will introduce you to fundamental programming concepts and
approaches. Participants can choose between two tracks, based on their
programming experience. Participants can install the required software
for the workshop by themselves. For those who would like help or prefer
to to install software as a group, we will meet Friday late afternoon to
install all of the software. Saturday will be spent learning and
practicing Clojure programming. You will be working in small groups of 2
to 4 attendees each. Each participant needs to bring a laptop computer
with a fairly recent operating system (Mac, Linux or Windows). If you
have questions about your hardware or you don't have a laptop, don't
hesitate to send an email to the organizers before the event.

**** Who can attend?

The workshop is open to all women, trans*, and gender nonconforming
people. Men are welcome if they are an invited guest of a student who
qualifies by the above definition. Attendees inviting a guest should
select quantity 2 when signing up for tickets, and fill out their
guest's information in the 2nd ticket.

*** ClojureBridge Kraków, Poland
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_krakow.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_krakow
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-12-02
:CUSTOM_ID: content/events/2016/clojurebridge_krakow
:END:

We're aiming the event at women who are new to programming. The mentors
are experienced developers, but perhaps not Clojure experts -- we'll all
be learning.

We'll meet on Friday evening to install Clojure and all of the software
we need. On Saturday, we will learn to code Clojure.

*** ClojureBridge London - Fall
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_london_2.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_london_2
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-09-30
:CUSTOM_ID: content/events/2016/clojurebridge_london_2
:END:

ClojureBridge London aims to further increase diversity within the
Clojure community by offering free, beginner-friendly Clojure
programming workshops for underrepresented groups in tech. Priority is
given to those who identify as women, trans-gener or non-binary gender.
Males may register as a guest of one of these participants.

The workshop material supports those with little or no programming
experience and introduces them to programming concepts. We organise
attendees into small groups with at least one teacher and one assistant.

*** ClojureBridge London - November
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_london_3.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_london_3
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-11-15
:CUSTOM_ID: content/events/2016/clojurebridge_london_3
:END:

ClojureBridge London aims to further increase diversity within the
Clojure community by offering free, beginner-friendly Clojure
programming workshops for under-represented groups in technology.
Priority is given to those who identify as women, trans-gener or
non-binary gender. Males may register as a guest of one of these
participants.

Its essential to attend the evening session on the 25th November if you
wish to attend the workshop the next day. This avoids delays to getting
started with the workshop.

Food and drinks will be provided throughout the event, so please let us
know if you have any special requirements when you register.

*** ClojureBridge London
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_london.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_london
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-02-19
:CUSTOM_ID: content/events/2016/clojurebridge_london
:END:

We're offering this workshop to help make the Clojure community more
accessible to a diverse range of participants. As such, this event is
only welcoming participants who identify as female or nonbinary. Males
may register as a guest of one of these participants.

This workshop is intended for those with none/some programming
experience.

*** ClojureBridge Minnesota
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_minneapolis.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_minneapolis
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-11-04
:CUSTOM_ID: content/events/2016/clojurebridge_minneapolis
:END:

ClojureBridge aims to increase diversity within the Clojure community by
offering free, beginner-friendly Clojure programming workshops for
underrepresented groups in tech.

We'll meet up Friday night to install all of the software you need on
your laptop, and then spend Saturday learning and writing code:

- Track1: simple application
- Track2: basic syntax, data structure and more

*** ClojureBridge NYC
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_nyc.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_nyc
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-07-22
:CUSTOM_ID: content/events/2016/clojurebridge_nyc
:END:

[[http://www.clojurebridge.org/][ClojureBridge]] aims to increase diversity within the Clojure community
by offering free, beginner-friendly Clojure programming workshops for
women.

In this workshop, we'll introduce you to the fundamentals of the Clojure
programming language. We'll meet up Friday night to install all of the
software you need, and then spend Saturday learning and writing code.

*** ClojureBridge Pittsburgh
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_pittsburgh.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_pittsburgh
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-09-09
:CUSTOM_ID: content/events/2016/clojurebridge_pittsburgh
:END:

[[http://www.clojurebridge.org/][ClojureBridge]] aims to increase diversity within the Clojure community
by offering free, beginner-friendly Clojure programming workshops for
women.

In this workshop, we'll introduce you to the fundamentals of the Clojure
programming language. We'll meet up Friday night to install all of the
software you need, and then spend Saturday learning and writing code.

*** ClojureBridge San Francisco
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_sanfrancisco.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_sanfrancisco
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-10-21
:CUSTOM_ID: content/events/2016/clojurebridge_sanfrancisco
:END:

ClojureBridge, a free 1-day workshop aimed at increasing the
participation of women in the Clojure community, will be held in San
Francisco on Saturday October 22 2016 with an optional install fest on
Friday October 21 2016 in the late afternoon. The workshop is intended
both for those new to programming, as well as those with some
programming experience, who would like to explore programming using
Clojure, a modern functional programming language.

The workshop will introduce you to fundamental programming concepts and
approaches. Participants can choose between two tracks, based on their
programming experience.

*** ClojureBridge Seattle
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurebridge_seattle.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurebridge_seattle
:CLOJURE_SITE_AUTHOR: ClojureBridge
:CLOJURE_SITE_DATE: 2016-04-08
:CUSTOM_ID: content/events/2016/clojurebridge_seattle
:END:

In this workshop, we'll introduce you to the fundamentals of the Clojure
programming language. We'll meet up Friday night to install all of the
software you need, and then spend Saturday learning and writing code.

This event is intentionally timed to be the weekend before the big west
coast Clojure conference (Clojure/West), which is also being held here
in Seattle.

*** Clojure/conj
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojureconj.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojureconj
:CLOJURE_SITE_AUTHOR: Cognitect
:CLOJURE_SITE_DATE: 2016-12-01
:CUSTOM_ID: content/events/2016/clojureconj
:END:

Clojure/conj is the original conference for Clojure and its community.
Founded in 2010, the conference is the premier place for developers from
all around the world to gather and learn about what is happening with
the language, in the community, and within organizations using Clojure.

Clojure/conj couples a session track with in-depth workshops and
learning opportunities, and offers a unique opportunity to mingle with
other developers, contributors, and professionals during a dense
three-day event.

This year's event will be held in Austin, TX from December 1-3. The Conj
offers a great mix of experienced Clojurists and new adopters and
everyone can find something to suit their need.

*** ec:clojureD
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojured.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojured
:CLOJURE_SITE_AUTHOR: clojureD
:CLOJURE_SITE_DATE: 2016-02-20
:CUSTOM_ID: content/events/2016/clojured
:END:

:clojureD is an independent non-profit conference from the Clojure
community for the Clojure community. Focus points will be interesting
developments and ideas in the global Clojure community as well as
introductory-level talks highlighting the fun aspects of learning and
messing with Clojure. Besides a day of interesting talks :clojureD will
be an opportunity to meet the German & European Clojure community and
share a good time together.

The conference will be held in English.

*** Clojure eXchange
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojureexchange.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojureexchange
:CLOJURE_SITE_AUTHOR: Skills Matter
:CLOJURE_SITE_DATE: 2016-12-01
:CUSTOM_ID: content/events/2016/clojureexchange
:END:

If you're looking for the best place to learn about Clojure, Functional
Programming and network with like-minded people, then the Clojure
eXchange 2016 is the conference you simply can't miss! Meet with the
world's leading experts, learn how to use Clojure in your team and
discuss war stories with your peers.

*** Clojure Remote
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojureremote.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojureremote
:CLOJURE_SITE_AUTHOR: Homegrown Labs
:CLOJURE_SITE_DATE: 2016-02-11
:CUSTOM_ID: content/events/2016/clojureremote
:END:

This February, Homegrown Labs presents Clojure Remote---Clojure's first
exclusively Remote conference. Join us anywhere; from your home, your
office, or the coffee shop.

Over two days, you'll join hundreds of other Clojurists online via
crowdcast.io to enjoy up to two tracks of beginner to intermediate
Clojure talks.

*** Clojure/west
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojurewest.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojurewest
:CLOJURE_SITE_AUTHOR: Cognitect
:CLOJURE_SITE_DATE: 2016-04-15
:CUSTOM_ID: content/events/2016/clojurewest
:END:

Clojure/west is the biggest Clojure conference in the western United
States. Founded in 2012, the conference is a great place to meet Clojure
developers and learn about what is happening in the language, in the
community, and in companies using Clojure. Clojure/west features two
tracks of sessions.

*** clojuTRE
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/clojutre.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/clojutre
:CLOJURE_SITE_AUTHOR: clojuTRE
:CLOJURE_SITE_DATE: 2016-09-10
:CUSTOM_ID: content/events/2016/clojutre
:END:

clojuTRE is a free Clojure conference organized by [[http://www.metosin.fi/][Metosin]]. The event
has single track, late start, short talks (20 minutes and 5 minutes
Q&A) and a funky after party for networking, discussions and draft
beer. We welcome both newbies and seasoned Clojurists.

*** Dutch Clojure Days
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/dutch_clojure_days.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/dutch_clojure_days
:CLOJURE_SITE_AUTHOR: Dutch Clojure Days
:CLOJURE_SITE_DATE: 2016-03-19
:CUSTOM_ID: content/events/2016/dutch_clojure_days
:END:

The Annual Gathering of Clojure Enthusiasts and Practitioners in the
Netherlands!

*** EuroClojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/euroclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/euroclojure
:CLOJURE_SITE_AUTHOR: EuroClojure
:CLOJURE_SITE_DATE: 2016-10-25
:CUSTOM_ID: content/events/2016/euroclojure
:END:

EuroClojure is the largest Clojure conference in Europe and draws
developers from all over the continent to gather and learn what is
happening with the language, in the community, and within organizations
using Clojure. This year's event will be held in Bratislava, Slovakia
from October 25-26. EuroClojure offers a great mix of experienced
Clojurists and new adopters and everyone can find something to suit
their needs.

EuroClojure is a Cognitect event.

*** InClojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/inclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/inclojure
:CLOJURE_SITE_AUTHOR: InClojure
:CLOJURE_SITE_DATE: 2016-11-26
:CUSTOM_ID: content/events/2016/inclojure
:END:

InClojure is India's first conference focused on the many joys of
Clojure. The inaugural edition will be held in Pune, India on November
26th, 2016. InClojure 2016 will be a 1-day, single track conference with
5 or 6 high quality talks and plenty of time for interaction and Q&A.
Our goal with this conference is to nurture the small but growing
community of Clojure programmers in India. We expect to have between 100
to 150 attendees from India and abroad, with a mix of experienced
Clojure programmers and enthusiasts.

*** Clojure and thi.ng for 3D Printing
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2016/thing-sept.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2016/thing-sept
:CLOJURE_SITE_AUTHOR: Clojure and thi.ng for 3D Printing
:CLOJURE_SITE_DATE: 2016-09-10
:CUSTOM_ID: content/events/2016/thing-sept
:END:

3D printing technology is becoming ever more affordable and there's no
shortage of design tools. However, this workshop is for anyone
interested in using an algorithmic approach to fabricate physical
objects and do so using a language & toolset, which makes playing with
data and geometry truly joyful. Over the two days of this workshop,
you'll will learn hands-on some of the endless potential, which
procedural generation can bring to the field of digital fabrication.
And, you'll not only be able to take home your own 3D printed object,
but too learn about important skills and pitfalls to watch out for in
your future practice with these technologies.

** 2017
*** ClojureBridge Buenos Aires
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojurebridge-ba.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojurebridge-ba
:CLOJURE_SITE_AUTHOR: ClojureBridge Buenos Aires
:CLOJURE_SITE_DATE: 2017-03-10
:CUSTOM_ID: content/events/2017/clojurebridge-ba
:END:

The first workshop of ClojureBridge Buenos Aires (and first in South
America)!

*** ClojureBridge Boston
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojurebridge-boston.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojurebridge-boston
:CLOJURE_SITE_AUTHOR: ClojureBridge Boston
:CLOJURE_SITE_DATE: 2017-03-17
:CUSTOM_ID: content/events/2017/clojurebridge-boston
:END:

ClojureBridge Workshop is aimed at increasing women's participation in
the Clojure community. A free 1-day workshop will be held in Cambridge,
MA on Saturday March 18, 2017 with an optional install fest on Friday
late afternoon March 17, 2017. The workshop helps explore programming
using Clojure, a modern functional programming language, and is intended
both for those new to programming and those with some programming
experience.

*** ClojureBridge San Francisco
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojurebridge-sanfrancisco.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojurebridge-sanfrancisco
:CLOJURE_SITE_AUTHOR: ClojureBridge San Francisco
:CLOJURE_SITE_DATE: 2017-09-15
:CUSTOM_ID: content/events/2017/clojurebridge-sanfrancisco
:END:

ClojureBridge is a free 1-day workshop aimed at increasing the
participation of women, trans* and non-binary gender individuals in the
Clojure community. The workshop is intended for those new to programming
as well as individuals with some programming experience who would like
to explore programming using Clojure, a modern functional programming
language.

The workshop will introduce participants to fundamental programming
concepts and approaches.

*** ClojureBridge Seoul
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojurebridge-seoul.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojurebridge-seoul
:CLOJURE_SITE_AUTHOR: ClojureBridge Seoul
:CLOJURE_SITE_DATE: 2017-03-18
:CUSTOM_ID: content/events/2017/clojurebridge-seoul
:END:

ClojureBridge is a free 1-day workshop aimed at increasing the
participation of women in the Clojure community. It will be held in
Seoul, on Saturday March 18th, 2017 with an optional install fest on
Friday March 17th, 2017 in the evening. The workshop is intended both
for those new to programming, as well as those with some programming
experience who would like to explore programming using Clojure, a modern
functional programming language.

*** ClojureBridge Tampere
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojurebridge-tampere.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojurebridge-tampere
:CLOJURE_SITE_AUTHOR: ClojureBridge Tampere
:CLOJURE_SITE_DATE: 2017-05-06
:CUSTOM_ID: content/events/2017/clojurebridge-tampere
:END:

Note: this event will be held in Finnish. + Huom: tämä tapahtuma on
suomenkielinen.

Tapahtuma järjestetään lauantaina 6.5.2017 klo 10-18 Tampereella
Futuricen toimistolla, Kelloportinkatu 1D, 33100 Tampere.

ClojureBridgen tarkoituksena on lisätä monimuotoisuutta
Clojure-yhteisössä tarjoamalla ilmaisia, aloittelijaystävällisiä
koodaustyöpajoja naisille.

ClojureBridge on ilmainen ja tarkoitettu kaikille, jotka identifioituvat
naiseksi.

Vaatimuksena on, että osallistujalla on oma kannettava tietokone, jossa
wifi sekä johon on oikeus asentaa ohjelmia (eli ns. adminoikeudet).
Mikäli käytät windows-konetta, on käyttöjärjestelmän oltava vähintään
windows 7.

*** ClojureBridge Toronto
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojurebridge-toronto.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojurebridge-toronto
:CLOJURE_SITE_AUTHOR: ClojureBridge Toronto
:CLOJURE_SITE_DATE: 2017-02-24
:CUSTOM_ID: content/events/2017/clojurebridge-toronto
:END:

ClojureBridge is a free 1-day workshop aimed at increasing the
participation of women in the Clojure community. It will be held in
Toronto, on Saturday February 25th, 2017 with an optional install fest
on Friday February 24th, 2017 in the evening. The workshop is intended
both for those new to programming, as well as those with some
programming experience who would like to explore programming using
Clojure, a modern functional programming language.

*** Clojure/conj
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojureconj.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojureconj
:CLOJURE_SITE_AUTHOR: Cognitect
:CLOJURE_SITE_DATE: 2017-10-12
:CUSTOM_ID: content/events/2017/clojureconj
:END:

Clojure/conj is the original conference for Clojure and its community.
Founded in 2010, the conference is the premier place for developers from
all around the world to gather and learn about what is happening with
the language, in the community, and within organizations using Clojure.

Clojure/conj couples a session track with in-depth workshops and
learning opportunities, and offers a unique opportunity to mingle with
other developers, contributors, and professionals during a dense
three-day event.

This year's event will be held in Baltimore, MD from October 12-14. The
Conj offers a great mix of experienced Clojurists and new adopters and
everyone can find something to suit their need. This will be a special
year for the Conj as Clojure will celebrate it's 10th birthday!

*** ec:clojureD
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojured.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojured
:CLOJURE_SITE_AUTHOR: clojureD
:CLOJURE_SITE_DATE: 2017-02-25
:CUSTOM_ID: content/events/2017/clojured
:END:

:clojureD is an independent non-profit conference from the Clojure
community for the Clojure community. Focus points will be interesting
developments and ideas in the global Clojure community as well as
introductory-level talks highlighting the fun aspects of learning and
messing with Clojure. Besides a day of interesting talks :clojureD will
be an opportunity to meet the German & European Clojure community and
share a good time together.

The conference will be held in English.

*** Clojure Remote
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojureremote.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojureremote
:CLOJURE_SITE_AUTHOR: Ryan Neufeld & Homegrown Labs
:CLOJURE_SITE_DATE: 2017-02-09
:CUSTOM_ID: content/events/2017/clojureremote
:END:

The second edition of Clojure Remote takes place this February 9th &
10th, 2017.

Clojure Remote is an online Clojure conference targeted at *practicing*
Clojure developers. During the two-day event, you'll experience not only
talks, but interactive tutorials and workshops. All these sessions will
culminate in a team breakout session where you can explore the new ideas
teeming in your head with speaker assistance and the help of your team.

As with [[https://2016.clojureremote.com][Clojure Remote 2016]], videos
and source from the conference will be made freely available after the
conference as a gift to the community.

Clojure Remote's schedule is being developed iteratively this year.
Visit the [[https://clojureremote.com/schedule][current schedule here]], or [[https://clojureremote.com][the homepage]] for event information
and tickets.

We hope to see you and your team at the conference this year!

Cheers,

Ryan Neufeld at Clojure Remote

[[https://twitter.com/clojureremote]]

[[https://raw.githubusercontent.com/clojureremote/cr17/master/logos/Expanded-1000px.png]]

*** Clojure/west
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojurewest.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojurewest
:CLOJURE_SITE_AUTHOR: Cognitect
:CLOJURE_SITE_DATE: 2017-03-30
:CUSTOM_ID: content/events/2017/clojurewest
:END:

Clojure/west is the biggest Clojure conference in the western United
States. Founded in 2012, the conference is a great place to meet Clojure
developers and learn about what is happening in the language, in the
community, and in companies using Clojure. Clojure/west features two
tracks of sessions.

*** ClojureX
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojurex.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojurex
:CLOJURE_SITE_AUTHOR: London Clojurians
:CLOJURE_SITE_DATE: 2017-12-04
:CUSTOM_ID: content/events/2017/clojurex
:END:

The seventh edition of Clojure eXchange (ClojureX) annual conference
takes place in London, UK on the 4th & 5th December 2017.

Its a two-day fun-packed conference that attracts speakers from around
the world and local developers in the community sharing their
experiences.

Have your say in how we put the conference together via our [[https://skillsmatter.com/conferences/8783-clojure-exchange-2017#get_involved][Call For
Thoughts]] and take a look at the video's from previous conferences.

We hope you will [[https://skillsmatter.com/conferences/8783-clojure-exchange-2017][join us]] and meet hundreds of people from the London
Clojurians community and many other like-minded people from around the
world.

Thank you

London Clojurians

[[https://twitter.com/ldnclj]]

[[https://raw.githubusercontent.com/jr0cket/london-clojurians-logo/master/london-clojurians-text-highlight-lambda-jr0cket.png]]

*** clojuTRE
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/clojutre.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/clojutre
:CLOJURE_SITE_AUTHOR: clojuTRE
:CLOJURE_SITE_DATE: 2017-09-02
:CUSTOM_ID: content/events/2017/clojutre
:END:

clojuTRE is a Clojure conference organized by [[http://www.metosin.fi/][Metosin]]. The event has
single track, late start, short talks (20 minutes and 5 minutes Q&A)
and a funky after party for networking, discussions and draft beer. We
welcome both newbies and seasoned Clojurists.

*** Dutch Clojure Day
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/dutchclojureday.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/dutchclojureday
:CLOJURE_SITE_AUTHOR: Dutch Clojure Day
:CLOJURE_SITE_DATE: 2017-03-25
:CUSTOM_ID: content/events/2017/dutchclojureday
:END:

The Annual Gathering of Clojure Enthusiasts and Practitioners in the
Netherlands!

*** EuroClojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2017/euroclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2017/euroclojure
:CLOJURE_SITE_AUTHOR: EuroClojure
:CLOJURE_SITE_DATE: 2017-07-20
:CUSTOM_ID: content/events/2017/euroclojure
:END:

EuroClojure is the largest Clojure conference in Europe and draws
developers from all over the continent to gather and learn what is
happening with the language, in the community, and within organizations
using Clojure. This year's event will be held in Berlin, Germany from
July 20-21. EuroClojure offers a great mix of experienced Clojurists and
new adopters and everyone can find something to suit their needs.

EuroClojure is a Cognitect event.

** 2018
*** Clojure/conj
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2018/clojureconj.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2018/clojureconj
:CLOJURE_SITE_AUTHOR: Cognitect
:CLOJURE_SITE_DATE: 2018-11-29
:CUSTOM_ID: content/events/2018/clojureconj
:END:

Clojure/conj is the original conference for Clojure and its community.
Founded in 2010, the conference is the premier place for developers from
all around the world to gather and learn about what is happening with
the language, in the community, and within organizations using Clojure.

Clojure/conj couples a session track with in-depth workshops and
learning opportunities, and offers a unique opportunity to mingle with
other developers, contributors, and professionals during a dense
three-day event.

This year's event will be held in Durham, NC from Nov 29-Dec 1st. The
Conj offers a great mix of experienced Clojurists and new adopters and
everyone can find something to suit their need.

*** ec:clojureD
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2018/clojured.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2018/clojured
:CLOJURE_SITE_AUTHOR: clojureD
:CLOJURE_SITE_DATE: 2018-02-24
:CUSTOM_ID: content/events/2018/clojured
:END:

The developer conference :clojureD premiered in 2015 and quickly evolved
to the biggest annual Clojure conference in Germany. Software developers
from all over the world meet in Berlin to share new, amazing and
mind-blowing ideas and techniques. Besides a day of interesting talks
:clojureD will be an opportunity to meet the German & European Clojure
community and share a good time together.

The Call for Proposals is on from 01. September to 31. October, Ticket
Sale started 1. October.

We hope to see you in Berlin for another great an inspiring :clojureD
conference!

*** Clojure SYNC
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2018/clojure-sync.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2018/clojure-sync
:CLOJURE_SITE_AUTHOR: clojureSYNC
:CLOJURE_SITE_DATE: 2018-02-15
:CUSTOM_ID: content/events/2018/clojure-sync
:END:

It's a synchronous event, in a syncretist city with syncopated music,
about an async language. On February 15th and 16th, 2018, two hundred
Clojurists from around the world, like yourselves, will come to the
heart of New Orleans to enjoy talks about humanity, business, and code
through the lens of Clojure and Functional Programming.

The topics are different from what we're used to at other conferences.
If Strange Loop is about the confluence of industry and academia,
Clojure SYNC is about the connections between our skills, our work, and
the history of technology. If you like the PurelyFunctional.tv
Newsletter, you'll love the talks at Clojure SYNC. An explicit goal of
the conference is to broaden our perspectives on the history of
computing and how it fits into the history of humanity.

*** ClojureX
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2018/clojurex.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2018/clojurex
:CLOJURE_SITE_AUTHOR: London Clojurians
:CLOJURE_SITE_DATE: 2018-12-03
:CUSTOM_ID: content/events/2018/clojurex
:END:

The eighth edition of Clojure eXchange (ClojureX) annual conference
takes place in London, UK on the 3rd & 4th December 2018.

Its a two-day fun-packed conference that attracts speakers from around
the world along with local developers in the community sharing their
experiences.

Help make our conference amazing and diverse by [[https://skillsmatter.com/conferences/10459-clojure-exchange-2018#get_involved][submitting to our Call
For Papers]] and take a look at the video's from previous conferences.

We hope you will [[https://skillsmatter.com/conferences/10459-clojure-exchange-2018][join us]] and meet hundreds of people from the London
Clojurians community and many other like-minded people from around the
world.

Thank you

London Clojurians

[[https://twitter.com/ldnclj]]

[[https://raw.githubusercontent.com/jr0cket/london-clojurians-logo/master/london-clojurians-logo.png]]

*** ClojuTRE
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2018/clojutre.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2018/clojutre
:CLOJURE_SITE_AUTHOR: clojuTRE
:CLOJURE_SITE_DATE: 2018-09-14
:CUSTOM_ID: content/events/2018/clojutre
:END:

ClojuTRE is a Clojure conference organized by [[http://www.metosin.fi/][Metosin]]. The event has
single track, late start, short talks (20 minutes and 5 minutes Q&A)
and a funky after party for networking, discussions and craft beer. We
welcome both newbies and seasoned Clojurists.

*** Dutch Clojure Day
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2018/dutchclojureday.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2018/dutchclojureday
:CLOJURE_SITE_AUTHOR: Dutch Clojure Day
:CLOJURE_SITE_DATE: 2018-04-21
:CUSTOM_ID: content/events/2018/dutchclojureday
:END:

The Annual Gathering of Clojure Enthusiasts and Practitioners in the
Netherlands!

- CFP: [[https://www.papercall.io/dcd18]]
- Register: [[https://www.eventbrite.com/e/dutch-clojure-day-2018-tickets-41749338395]]

*** IN/Clojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2018/inclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2018/inclojure
:CLOJURE_SITE_AUTHOR: IN/Clojure
:CLOJURE_SITE_DATE: 2018-01-12
:CUSTOM_ID: content/events/2018/inclojure
:END:

IN/Clojure 2018 is the second edition of Asia's first Clojure
conference. Our goal with this conference is to nurture the growing
community of Clojure programmers in India. We expect to have a mix of
experienced Clojure programmers and enthusiasts.

** 2019
*** ClojureBridge London
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojurebridge-london-may-2019.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojurebridge-london-may-2019
:CLOJURE_SITE_AUTHOR: London Clojurians
:CLOJURE_SITE_DATE: 2019-05-11
:CUSTOM_ID: content/events/2019/clojurebridge-london-may-2019
:END:

[[https://clojurebridgelondon.github.io/][ClojureBridge London]] is a fun, free and friendly workshop to support
women(trans/cis) and non-binary people into software development. The
workshop is suitable for people just starting to code, or people on
their first language who are Clojure curious.

**** Event overview

Friday evening we have members of the community sharing their
development experiences and demonstrating what you can do with Clojure.
We also help you install Clojure development tools (optional).

Saturday we coach you through a day of small practical exercises,
building responsive websites or creating simple games. We aim for 1-2-1
coaching so we can support you each step of the way.

**** Requirements

Each participant requires their own laptop with either MacOSX, Linux or
Windows operating system. We help you set up your laptop for Clojure
during the Friday evening (optional if you are just starting to code).

**** Why learn Clojure?

Clojure is a small language with a simple design that can be used to
build apps for the web, mobile apps, and even desktop apps. Clojure is a
great choice for those new to programming, or existing developers who
want to learn about functional programming and use it in the software
industry.

Clojure has a huge amount of libraries available to help you build a
wide range of apps really quickly. You can use all the libraries from
its host platforms, JavaScript/Node.js, Java or Microsoft .Net, too.

For more information, please take a look at the [[https://clojurebridgelondon.github.io/][ClojureBridge London
website]].

**** Our Sponsor

Thank you to our sponsor [[https://functional.works-hub.com/][Functional Works]] for providing the venue and
all the food and refreshments for the event. We will aim to have 50%
vegetarian food and around 10% of that will be vegan. We can always
increase this based on you feedback.

Functional Works are breaking down the barriers of hiring the right
software engineers and providing a platform for managing the whole
process (written in ClojureScript).

[[https://www.works-hub.com/images/homepage/walkthrough02.svg]]

**** Who is involved

The event is free of charge and run by unpaid volunteers from the
Clojure community. While the workshop is primarily for trans/cis women &
non-binary attendees, our coaches and organisers are members of the
local Clojure community of any gender or none. Everyone agrees to abide
by the Bridge Foundry Code of Conduct. If anyone is interested in
volunteering as a coach, take a look at the workshop content and if you
understand the basic Clojure we cover then you can coach. Coach training
is provided around a week before the event

***** Volunteer Details

Be sure to work through the exercises in the ClojureBridge London
workshop before the coach training event.

[[https://clojurebridgelondon.github.io/workshop/]]

If you are interested in coaching students with some coding experience,
also take a look at the projects in the workshop and have one of the
recommended editors/IDE's installed.

***** Student Details

All students need to bring their own laptop and power adaptor

If you want to build websites or games, then you will need to install
development tools for Clojure. We can help with this on the Friday
evening (or Saturday if required). Instructions are on our website
[[https://clojurebridgelondon.github.io/workshop/development-tools/]]

Thank you

London Clojurians

[[https://twitter.com/ldnclj]]

[[https://raw.githubusercontent.com/jr0cket/london-clojurians-logo/master/london-clojurians-logo.png]]

*** Clojure/conj
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojureconj.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojureconj
:CLOJURE_SITE_AUTHOR: Cognitect
:CLOJURE_SITE_DATE: 2019-11-21
:CUSTOM_ID: content/events/2019/clojureconj
:END:

Clojure/conj is the original conference for Clojure and its community.
Founded in 2010, the conference is the premier place for developers from
all around the world to gather and learn about what is happening with
the language, in the community, and within organizations using Clojure.

Clojure/conj couples a session track with in-depth workshops and
learning opportunities, and offers a unique opportunity to mingle with
other developers, contributors, and professionals during a dense
three-day event.

This year's event will be held in Durham, NC from Nov 21-Nov 23. The
Conj offers a great mix of experienced Clojurists and new adopters and
everyone can find something to suit their need.

*** ec:clojureD
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojured.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojured
:CLOJURE_SITE_AUTHOR: clojureD
:CLOJURE_SITE_DATE: 2019-02-23
:CUSTOM_ID: content/events/2019/clojured
:END:

The developer conference :clojureD premiered in 2015 and quickly evolved
to the biggest annual Clojure conference in Germany. Software developers
from all over the world meet in Berlin to share new, amazing and
mind-blowing ideas and techniques. Besides a day of interesting talks
:clojureD will be an opportunity to meet the German & European Clojure
community and share a good time together.

We hope to see you in Berlin for another great an inspiring :clojureD
conference!

*** Clojure Day Ukraine
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojureeua.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojureeua
:CLOJURE_SITE_AUTHOR: Clojure Day Ukraine
:CLOJURE_SITE_DATE: 2019-12-07
:CUSTOM_ID: content/events/2019/clojureeua
:END:

Two-day community driven event for everyone interested in Clojure and
functional programming.

*** Clojure/north
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojurenorth.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojurenorth
:CLOJURE_SITE_AUTHOR: Clojure/north
:CLOJURE_SITE_DATE: 2019-04-19
:CUSTOM_ID: content/events/2019/clojurenorth
:END:

Clojure/north is Canada's first Clojure conference. It is a non-profit
event from the Clojure community for the community with three main
objectives.

1. Share knowledge within the Clojure community
2. Grow the Clojure community by offering accessible talks to newcomers
3. Demonstrate with the broader community how Clojure is being used to
   solve problems

We hope to see you there!

- CFP: [[https://clojurenorth.typeform.com/to/YuveUZ]]
- Tickets: [[https://ti.to/clojure-north/clojure-north-2019]]

*** Clojure/South
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojuresouth.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojuresouth
:CLOJURE_SITE_AUTHOR: Nubank
:CLOJURE_SITE_DATE: 2019-09-01
:CUSTOM_ID: content/events/2019/clojuresouth
:END:

Clojure/South will be held Aug 31-Sep 1 in São Paulo, Brazil.
Clojure/South is the first Clojure conference in South America and is
expected to have at least 500 attendees, making it one of the largest
Clojure conferences in the world.

Stuart Halloway and David Chelimsky will be the keynote speakers for the
event. A Call for Presentations is open from June 15-July 21 - see
[[https://www.papercall.io/clojure-south][CFP]]. Talks will be 40
minutes and there will be two session rooms.

*** ClojureX is cancelled
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojurex.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojurex
:CLOJURE_SITE_AUTHOR: London Clojurians
:CLOJURE_SITE_DATE: 2019-12-02
:CUSTOM_ID: content/events/2019/clojurex
:END:

Unfortunately the ClojureX conference scheduled for 2nd/3rd December
2019 has been cancelled.

SkillsMatter, the company that owns, finances and runs the event has
gone into financial administration and are effectively no longer a
business. SkillsMatter have previously run 10 successful Clojure
conferences in London and the future of this conference is unknown.

London Clojurians appologies to all speakers who make travel plans or
attendees who purchased tickets/travel. We do not know if any of this is
recoverable.

London Clojurians will share any further developments on this matter
that are relevant to the Clojurian community as soon as we can.

Please use the #clojurex channel on the Clojurians Slack channel if you
have questions and we will try our best to advise.

Again, our deepest appologies to all involved in this event.

Thank you

London Clojurians

[[https://twitter.com/ldnclj]]

[[https://raw.githubusercontent.com/jr0cket/london-clojurians-logo/master/london-clojurians-logo.png]]

*** Cloju.ru
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojuru.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojuru
:CLOJURE_SITE_AUTHOR: Cloju.ru
:CLOJURE_SITE_DATE: 2019-10-26
:CUSTOM_ID: content/events/2019/clojuru
:END:

Cloju.ru is the first Russian Clojure conference, to be held in Moscow
on October 26th. More than 70 attendees are expected, talks in English
are welcome.

Call for presentations is open at [[mailto:orgs@cloju.ru][orgs@cloju.ru]].

*** ClojuTRE
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/clojutre.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/clojutre
:CLOJURE_SITE_AUTHOR: ClojuTRE
:CLOJURE_SITE_DATE: 2019-09-26
:CUSTOM_ID: content/events/2019/clojutre
:END:

ClojuTRE is a two day Clojure and functional programming conference
organized by [[http://www.metosin.fi/][Metosin]]. The event has single track, late start, short
talks and a funky after party for networking.  We welcome both newbies
and seasoned Clojurists and other FP enthusiasts. Next edition of the
event will be held in Helsinki Thursday 26th - Friday 27th
September 2019.

- Tickets: [[https://www.eventbrite.com/e/clojutre2019-tickets-53048236704]]

*** Dutch Clojure Day
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/dutchclojureday.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/dutchclojureday
:CLOJURE_SITE_AUTHOR: Dutch Clojure Day
:CLOJURE_SITE_DATE: 2019-04-06
:CUSTOM_ID: content/events/2019/dutchclojureday
:END:

The Annual Gathering of Clojure Enthusiasts and Practitioners in the
Netherlands!

- CFP: [[https://www.papercall.io/dcd19]]

*** Heart of Clojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/heartofclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/heartofclojure
:CLOJURE_SITE_AUTHOR: Heart of Clojure
:CLOJURE_SITE_DATE: 2019-08-02
:CUSTOM_ID: content/events/2019/heartofclojure
:END:

A brand new Clojure conference in the heart of Europe. On August 2nd the
European community comes together for two days of talks, activities, and
summer fun.

*** IN/Clojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/inclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/inclojure
:CLOJURE_SITE_AUTHOR: IN/Clojure
:CLOJURE_SITE_DATE: 2019-01-11
:CUSTOM_ID: content/events/2019/inclojure
:END:

IN/Clojure 2019 is the third edition of Asia's first Clojure conference.
Our goal with this conference is to nurture the growing community of
Clojure programmers in India. We expect to have a mix of experienced
Clojure programmers and enthusiasts.

*** re:Clojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2019/reclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2019/reclojure
:CLOJURE_SITE_AUTHOR: London Clojurians
:CLOJURE_SITE_DATE: 2019-12-02
:CUSTOM_ID: content/events/2019/reclojure
:END:

We have the pleasure to invite you to [[https://reclojure.org][re:Clojure]] - a brand new and
free community driven conference, taking place in London on Dec 2nd,
2019 in an incredible venue. Many of the original ClojureX speakers
will be there.  Special thanks to the Clojure community and the
sponsors for managing to put this together at such short notice. We
look forward to seeing you there!

Please reserve your seat at [[https://reclojure.org]] and join
#reclojure on Clojurians for more info.

** 2020
*** ClojureBridge London
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2020/clojurebridge.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2020/clojurebridge
:CLOJURE_SITE_AUTHOR: London Clojurians
:CLOJURE_SITE_DATE: 2020-02-21
:CUSTOM_ID: content/events/2020/clojurebridge
:END:

ClojureBridge is a fun, free and friendly workshop for trans/cis women
and non-binary people. The workshop is suitable for people just starting
to code, or people on their first language who are also Clojure curious.

On the Friday evening we have members of the community sharing their
development experiences and show what you can do with Clojure. We also
help you install Clojure development tools (optional).

On Saturday we coach you through a day of small practical exercises,
building responsive websites or creating simple games. We aim for 1-2-1
coaching so we can support you each step of the way.

The event is free of charge and run by unpaid volunteers from the
Clojure community. While the workshop is primarily for trans/cis women &
non-binary attendees, our coaches and organisers are members of the
local Clojure community of any gender or none. Everyone agrees to abide
by the ClojureBridge Code of Conduct.

If you are interested in attending, please register at [[https://www.bridgetroll.org/events/500][BridgeTroll]].

Thank you

London Clojurians

[[https://twitter.com/ldnclj][Twitter]]

[[https://raw.githubusercontent.com/ClojureBridgeLondon/clojurebridge-logo-modern/master/clojurebridge-logo-modern-london.png]]

*** ec:clojureD
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2020/clojured.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2020/clojured
:CLOJURE_SITE_AUTHOR: clojureD
:CLOJURE_SITE_DATE: 2020-02-29
:CUSTOM_ID: content/events/2020/clojured
:END:

The developer conference :clojureD premiered in 2015 and quickly evolved
to the biggest annual Clojure conference in Germany. Software developers
from all over the world meet in Berlin to share new, amazing and
mind-blowing ideas and techniques. Besides a day of interesting talks
:clojureD will be an opportunity to meet the German & European Clojure
community and share a good time together.

We hope to see you in Berlin for another great an inspiring :clojureD
conference!

*** Clojure/north
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2020/clojurenorth.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2020/clojurenorth
:CLOJURE_SITE_AUTHOR: Clojure/north
:CLOJURE_SITE_DATE: 2020-06-25
:CUSTOM_ID: content/events/2020/clojurenorth
:END:

Clojure/north is the 2nd edition of Canada's annual Clojure conference.
It is a non-profit event from the Clojure community for the community
with three main objectives.

1. Share knowledge within the Clojure community
2. Grow the Clojure community by offering accessible talks to newcomers
3. Demonstrate with the broader community how Clojure is being used to
   solve problems

We hope to see you there!

- Call for Proposals and ticket sales coming soon
- Follow us for updates! [[https://twitter.com/clojurenorth]]

*** ClojuTRE
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2020/clojutre.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2020/clojutre
:CLOJURE_SITE_AUTHOR: ClojuTRE
:CLOJURE_SITE_DATE: 2020-10-08
:CUSTOM_ID: content/events/2020/clojutre
:END:

ClojuTRE is a two day Clojure and functional programming conference
organized by [[http://www.metosin.fi/][Metosin]]. The event has single
track, late start, short talks and a funky after party for networking.
We welcome both newbies and seasoned Clojurists and other FP
enthusiasts. Next edition of the event will be held in Tampere Thursday
8th - Friday 9th October 2020.

- Tickets: [[https://www.eventbrite.fi/e/84875662391]]

*** Dutch Clojure Day
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2020/dutchclojureday.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2020/dutchclojureday
:CLOJURE_SITE_AUTHOR: Dutch Clojure Day
:CLOJURE_SITE_DATE: 2020-05-16
:CUSTOM_ID: content/events/2020/dutchclojureday
:END:

The Annual Gathering of Clojure Enthusiasts and Practitioners in the
Netherlands!

- CFP: [[https://www.papercall.io/dcd20]]

*** IN/Clojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2020/inclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2020/inclojure
:CLOJURE_SITE_AUTHOR: IN/Clojure
:CLOJURE_SITE_DATE: 2020-02-14
:CUSTOM_ID: content/events/2020/inclojure
:END:

IN/Clojure 2020 is the 4th edition of India's annual Clojure and
Clojurescript conference, and Asia's first. We were also Asia's only
such conference, but no more; yay ClojuRU!

IN/Clojure strives to facilitate the free exchange of ideas between new
and experienced Clojure programmers alike. Learning and networking
opportunities abound across:

- A single-track day of conference talks with 150-odd attendees and our
  awesome sponsors.
- A day of hands-on workshops having 80-100 participants across a track
  for newcomers and another for more experienced Clojurists.
- Oh, and the after-party(ies) and impromptu get-togethers that
  invariably happen.

Over the years, IN/Clojure has helped kick-start a series of Clojure
workshops and meet-ups across the country. It has helped companies
hiring Clojurists reach out to a wonderful community. And it has helped
attendees make a strong case for Clojure/Clojurescript adoption in their
companies.

We hope to make IN/Clojure 2020 bigger this year and continue our
efforts to help foster the growing Clojure community in Asia/India.

And we hope to see you there!

- Propose a talk:
  [[https://hasgeek.com/inclojure/2020/proposals#call-for-proposal]]
- Follow us for the latest-greatest: [[https://twitter.com/in_clojure]]

*** re:Clojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/events/2021/reclojure.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/events/2021/reclojure
:CLOJURE_SITE_AUTHOR: London Clojurians
:CLOJURE_SITE_DATE: 2021-12-03
:CUSTOM_ID: content/events/2021/reclojure
:END:

re:Clojure is a community-driven effort to bring together knowledgeable
speakers to present new and exciting topics on all things Clojure and
ClojureScript.

This year, like last year (during these COVID times), the conference
will be held online, on the 3rd and 4th of December 2021. You are
cordially invited to come along, listen, participate and perhaps learn
one or two new things along the way.

For further details, including the speakers/schedule/instructions and
how to attend, please visit [[https://reclojure.org][re:Clojure]]. You can also pop along to our
[[https://discord.com/invite/m4DaGW6N][Discord server]] to speak to any of the organisers and fellow
Clojurians.

We look forward to seeing you there!

* Guides
** Comparators Guide
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/comparators.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/comparators
:CLOJURE_SITE_AUTHOR: Andy Fingerhut
:CLOJURE_SITE_DATE: 2016-02-22
:CUSTOM_ID: content/guides/comparators
:END:

/Note: This document describes Clojure 1.10 and Java 8, but applies to
most other versions as well./

*** Summary

A comparator is a function that takes two arguments ~x~ and ~y~ and
returns a value indicating the relative order in which ~x~ and ~y~
should be sorted. It can be a 3-way comparator returning an integer, or
a 2-way comparator returning a boolean. See the DOs below for what the
return values should be, depending upon the order of ~x~ and ~y~.

In Clojure you need comparators for sorting a collection of values, or
for maintaining a collection of values in a desired sorted order, e.g
a [[clojure:core.clj::(defn sorted-map][sorted-map]], [[clojure:core.clj::(defn sorted-set][sorted-set]], or [[https://clojure.github.io/data.priority-map/#clojure.data.priority-map/priority-map][priority-map]] (also known as a priority
queue).

The default comparator [[clojure:core.clj::(defn compare][compare]] works well for sorting numbers in
increasing order, or strings, keywords, or symbols, in [[https://en.wikipedia.org/wiki/Lexicographical_order][lexicographic]]
(i.e dictionary) order, and a few other cases. See below for examples
and more details.

If ~compare~ does not do what you want, you must provide your own
comparator that does. Each of the recommendations below is explained in
more detail later in this document.

DOs:

- Ensure that your comparators are based on a [[https://en.wikipedia.org/wiki/Total_order][total order]] over the
  values you want to compare. It should be able to compare any pair of
  values that can appear in your data set, and determine which value
  should come first (or that they are equal).
- Write either a 3-way comparator or a boolean comparator:
  - A 3-way comparator takes 2 values, ~x~ and ~y~, and returns a Java
    32-bit /int/ that is negative if ~x~ comes before ~y~, positive if x
    comes after ~y~, or 0 if they are equal. Use values -1, 0, and 1 if
    you have no reason to prefer other return values.
  - A boolean comparator takes 2 values, ~x~ and ~y~, and returns true if
    ~x~ comes before ~y~, or false otherwise (including if ~x~ and ~y~ are
    equal). ~<~ and ~>~ are good examples. ~<=~ and ~>=~ are not. Performance
    note: your boolean comparator may be called twice to distinguish
    between the "comes after" or "equals" cases.
- Reverse the sort by reversing the order that you give the arguments
  to an existing comparator.
- Compare equal-length Clojure vectors containing "sort keys" in order
  to do a multi-field comparison between values.
- Remove or replace occurrences of "Not a Number" (~##NaN~) from your
  data before sorting a collection, and avoid using them as parts of
  keys in a sorted collection.

DO NOTs:

- Do not write a boolean comparator that returns true if the values are
  equal. Such a comparator is inconsistent. It will cause sorted
  collections to behave incorrectly, and sorting to give unpredictable
  orders.
- Do not use comparators for sorted sets and maps that treat two values
  as equal, unless you want at most one of those two values to appear
  in the sorted collection.
- Do not use subtraction when writing a 3-way comparator, unless you
  really know what you are doing.

See also: [[clojure:core.clj::(defn compare][compare]], [[clojure:core.clj::3090][sort]], [[clojure:core.clj::(defn sort-by][sort-by]], [[clojure:core.clj::(defn sorted-set][sorted-set]], [[clojure:core.clj::(defn sorted-set-by][sorted-set-by]],
[[clojure:core.clj::(defn
sorted-map][sorted-map]], [[clojure:core.clj::(defn sorted-map-by][sorted-map-by]], [[clojure:core.clj::(defn subseq][subseq]], [[clojure:core.clj::(defn rsubseq][rsubseq]]

*** Introduction

Here we describe the default sorting order provided by the function
~compare~. After that we give examples of other comparators, with some
guidelines to follow and mistakes to avoid when writing your own.

*** Clojure's default comparator

If you do not specify your own comparator, sorting is done by a built-in
function ~compare~. ~compare~ works for many types of values, ordering
them in one particular way:

- numbers are sorted in increasing numeric order, returning 0 if two
  numbers are numerically equal by ~==~, even if ~=~ returns false.
  Exception: Even though ~( ##NaN x)~ is false for all numbers ~x~,
  even ~##NaN~, ~(compare ##NaN x)~ is 0 for all numbers ~x~, including
  ~##NaN~.
- strings are sorted in [[http://en.wikipedia.org/wiki/Lexicographical_order][lexicographic order]] (aka dictionary order) by
  their representation as sequences of UTF-16 code units. This is
  alphabetical order (case-sensitive) for strings restricted to the
  ASCII subset.
- symbols are sorted first by their namespace, if they have one, and
  if they have the same namespace, then by their name. Both the
  namespace and names are compared as their string representations
  would be, lexicographically. All symbols that do not have a
  namespace are sorted before any symbol with a namespace.
- keywords are sorted the same way as symbols, but an exception is
  thrown if you attempt to compare a keyword to a symbol.
- vectors are sorted from fewest elements to most elements, with
  [[http://en.wikipedia.org/wiki/Lexicographical_order][lexicographic ordering]] among equal length vectors.
- Clojure refs are sorted in the order that they were created.
- All Java types implementing the [[https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html][Comparable]] interface such as
  characters, booleans, File, URI, and UUID are compared via their
  ~compareTo~ methods.
- ~nil~: can be compared to all values above, and is considered less
  than anything else.

~compare~ throws an exception if given two values whose types are "too
different", e.g. it can compare integers, longs, and doubles to each
other, but not strings to keywords or keywords to symbols. It cannot
compare lists, sequences, sets, or maps.

The examples below with ~sort~, ~sorted-set~, and ~sorted-map~ all use
the default comparator.

#+BEGIN_SRC clojure
user> (sort [22/7 2.71828 ##-Inf 1 55 3N])
(##-Inf 1 2.71828 3N 22/7 55)

user> (sorted-set "aardvark" "boo" "a" "Antelope" "bar")
#{"Antelope" "a" "aardvark" "bar" "boo"}

user> (sorted-set 'user/foo 'clojure.core/pprint 'bar 'clojure.core/apply 'user/zz)
#{bar clojure.core/apply clojure.core/pprint user/foo user/zz}

user> (sorted-map :map-key 10, :amp [3 2 1], :blammo "kaboom")
{:amp [3 2 1], :blammo "kaboom", :map-key 10}

user> (sort [[-8 2 5] [-5 -1 20] [1 2] [1 -5] [10000]])
([10000] [1 -5] [1 2] [-8 2 5] [-5 -1 20])

user> (import '(java.util UUID))
java.util.UUID

user> (sort [(UUID. 0xa 0) (UUID. 5 0x11) (UUID. 5 0xb)])
(#uuid "00000000-0000-0005-0000-00000000000b"
 #uuid "00000000-0000-0005-0000-000000000011"
 #uuid "00000000-0000-000a-0000-000000000000")

user> (sort [:ns2/kw1 :ns2/kw2 :ns1/kw2 :kw2 nil])
(nil :kw2 :ns1/kw2 :ns2/kw1 :ns2/kw2)
#+END_SRC

An exception will be thrown if you call ~compare~ with different types.
Any numeric types above can be compared to each other, but not to a
non-numeric type. An exception will also be thrown if you use ~compare~
on a list, set, map, or any other type not mentioned above. You must
implement your own comparator if you wish to sort such values.

*** Off-the-shelf comparators

First consider using well-tested comparators developed by others,
especially if they are complex.

A perfect example of this would be sorting Unicode strings in
different languages in orders specific to different locales. The Java
[[https://docs.oracle.com/javase/8/docs/api/java/text/Collator.html][Collator]] class and [[http://site.icu-project.org/home#TOC-What-is-ICU-][ICU]] (International Components for Unicode) provide
libraries for this.

*** Writing your own comparators
**** Reverse order

To sort numbers in decreasing order, simply write a comparator that
calls ~compare~ with the arguments in the opposite order:

#+BEGIN_SRC clojure
user> (sort [4 2 3 1])
(1 2 3 4)

user> (defn reverse-cmp [a b]
        (compare b a))
#'user/reverse-cmp

user> (sort reverse-cmp [4 3 2 1])
(4 3 2 1)
#+END_SRC

Such short functions are often written using Clojure's #() notation,
where the two arguments are %1 and %2, in that order.

#+BEGIN_SRC clojure
user> (sort #(compare %2 %1) [4 3 2 1])
#+END_SRC

~reverse-cmp~ will also work for all other types ~compare~ works for.

**** Multi-field comparators

Because equal-length Clojure vectors are compared lexicographically,
they can be used to do multi-field sorting on values like maps or
records. This only works if the fields are already sorted by ~compare~
in the order you wish (or the reverse of that).

First we will show a way to do it that does not compare vectors.

#+BEGIN_SRC clojure
(def john1 {:name "John", :salary 35000.00, :company "Acme"})
(def mary  {:name "Mary", :salary 35000.00, :company "Mars Inc"})
(def john2 {:name "John", :salary 40000.00, :company "Venus Co"})
(def john3 {:name "John", :salary 30000.00, :company "Asteroids-R-Us"})
(def people [john1 mary john2 john3])

(defn by-salary-name-co [x y]
  ;; :salary values sorted in decreasing order because x and y
  ;; swapped in this compare.
  (let [c (compare (:salary y) (:salary x))]
    (if (not= c 0)
      c
      ;; :name and :company are sorted in increasing order
      (let [c (compare (:name x) (:name y))]
        (if (not= c 0)
          c
          (let [c (compare (:company x) (:company y))]
            c))))))

user> (pprint (sort by-salary-name-co people))
({:name "John", :salary 40000.0, :company "Venus Co"}
 {:name "John", :salary 35000.0, :company "Acme"}
 {:name "Mary", :salary 35000.0, :company "Mars Inc"}
 {:name "John", :salary 30000.0, :company "Asteroids-R-Us"})
#+END_SRC

Below is the shorter way, by comparing Clojure vectors. It behaves
exactly the same as above. Note that as above, the field :salary is
sorted in descending order because ~x~ and ~y~ are swapped.

#+BEGIN_SRC clojure
(defn by-salary-name-co2 [x y]
    (compare [(:salary y) (:name x) (:company x)]
             [(:salary x) (:name y) (:company y)]))

user> (pprint (sort by-salary-name-co2 people))
({:name "John", :salary 40000.0, :company "Venus Co"}
 {:name "John", :salary 35000.0, :company "Acme"}
 {:name "Mary", :salary 35000.0, :company "Mars Inc"}
 {:name "John", :salary 30000.0, :company "Asteroids-R-Us"})
#+END_SRC

The above is fine for key values that are inexpensive to compute from
the values being sorted. If the key values are expensive to compute, it
is better to calculate them once for each value. See the
"decorate-sort-undecorate" technique described in the documentation for
[[https://github.com/jafingerhut/thalia/blob/master/doc/project-docs/clojure.core-1.5.1/clojure.core/sort-by.md][sort-by]].

**** Boolean comparators

Java comparators are all 3-way, meaning they return a negative, 0, or
positive integer depending upon whether the first argument should be
considered less than, equal to, or greater than the second argument.

In Clojure, you may also use boolean comparators that return ~true~ if
the first argument should come before the second argument, or ~false~
otherwise (i.e. should come after, or it is equal). The function ~<~ is
a perfect example, as long as you only need to compare numbers. ~>~
works for sorting numbers in decreasing order. Behind the scenes, when
such a Clojure function ~bool-cmp-fn~ is "called as a comparator",
Clojure runs code that works like this to return an /int/ instead:

#+BEGIN_SRC clojure
(if (bool-cmp-fn x y)
  -1     ; x < y
  (if (bool-cmp-fn y x)  ; note the reversed argument order
    1    ; x > y
    0))  ; x = y
#+END_SRC

You can see this by calling the compare method of any Clojure function.
Below is an example with a custom version ~my-<~ of ~<~ that prints its
arguments when it is called, so you can see the cases where it is called
more than once:

#+BEGIN_SRC clojure
user> (defn my-< [a b]
        (println "(my-<" a b ") returns " (< a b))
        (< a b))
#'user/my-<

;; (. o (compare a b)) calls the method named compare for object
;; o, with arguments a and b.  In this case the object is the
;; Clojure function my-<
user> (. my-< (compare 1 2))
(my-< 1 2 ) returns  true
-1
user> (. my-< (compare 2 1))
(my-< 2 1 ) returns  false
(my-< 1 2 ) returns  true
1
user> (. my-< (compare 1 1))
(my-< 1 1 ) returns  false
(my-< 1 1 ) returns  false
0

;; Calling a Clojure function in the normal way uses its invoke
;; method, not compare.
user> (. my-< (invoke 2 1))
(my-< 2 1 ) returns  false
false
#+END_SRC

See Clojure source file [[https://github.com/clojure/clojure/blob/clojure-1.10.0/src/jvm/clojure/lang/AFunction.java#L50][src/jvm/clojure/lang/AFunction.java]] method
~compare~ if you want all the details.

**** General rules for comparators

Any comparator, whether 3-way or boolean, should return answers
consistent with a [[https://en.wikipedia.org/wiki/Total_order][total order]] on the values you want to compare.

A total order is simply an ordering of all values from smallest to
largest, where some groups of values can all be equal to each other.
Every pair of values must be comparable to each other (i.e. no "I do not
know how to compare them" answers from the comparator).

For example, you can order all fractions written in the form ~m/n~ for
integers m and n from smallest to largest, in the usual way this is done
in mathematics. Many of the fractions would be equal to each other, e.g.
~1/2 = 2/4 = 3/6~. A comparator implementing that total order should
behave as if they are all the same.

A 3-way comparator ~(cmp a b)~ should return a negative, positive, or 0
/int/ if ~a~ is before, after, or is considered equal to b in the total
order, respectively.

A boolean comparator ~(cmp a b)~ should return true if ~a~ is before ~b~
in the total order, or false if ~a~ is after or considered equal to ~b~.
That is, it should work like ~<~ does for numbers. As explained later,
it should not behave like ~<=~ for numbers (see section "Comparators for
sorted sets and maps are easy to get wrong").

*** Mistakes to avoid
**** Be wary of "Not a Number" values as compared values in sorted
collections

Clojure's default comparator ~compare~ treats "Not a Number" (~##NaN~)
values as equal to all other numbers. If you call [[clojure:core.clj::3090][sort]] on sequences of
numbers that contain occurrences of ~##NaN~, it might throw an
exception.

#+BEGIN_SRC clojure
user> (sort [##NaN 5 13 ##NaN 3 7 12 ##NaN 8 4 2 20 6 9 ##NaN 50 83 19 -7 0 18 26 30 42 ##NaN 57 90 -8 -12 43 87 38])
Execution error (IllegalArgumentException) at java.util.TimSort/mergeHi (TimSort.java:899).
Comparison method violates its general contract!
#+END_SRC

Even if it does not throw an exception, it is likely that the returned
sequence will not be sorted. This is because ~compare~ does not put
~##NaN~ into a total order with other numbers as a comparator should, in
order for ~sort~ to work correctly:

#+BEGIN_SRC clojure
user> (sort [##NaN 10 5 13 ##NaN 3 7 12 ##NaN 8 4 2 20 6 9 ##NaN 50 83 19 -7])
(##NaN -7 2 3 4 5 6 7 8 10 12 13 ##NaN ##NaN 9 19 20 ##NaN 50 83)
#+END_SRC

Because ~##NaN~ is not equal to any other value, you cannot use code
like this to remove values from a sequence of numbers:

#+BEGIN_SRC clojure
user> (remove #(= % ##NaN) [9 3 ##NaN 4])
(9 3 ##NaN 4)
#+END_SRC

You may use the Java method ~Double/isNaN~ to indicate whether a value
is ~##NaN~:

#+BEGIN_SRC clojure
user> (remove #(Double/isNaN %) [9 3 ##NaN 4])
(9 3 4)
#+END_SRC

**** Comparators for sorted sets and maps are easy to get wrong

This is just as accurately stated as "comparators are easy to get
wrong", but it is often more noticeable when you use a bad comparator
for sorted sets and maps. If you write the kinds of bad comparators in
this section and use them to call ~sort~, usually little or nothing will
go wrong (although inconsistent comparators are not good for sorting,
either). With sorted sets and maps, these bad comparators can cause
values not to be added to your sorted collections, or to be added but
not be found when you search for them.

Suppose you want a sorted set containing vectors of two elements, where
each is a string followed by a number, e.g. ~["a" 5]~. You want the set
sorted by the number, and to allow multiple vectors with the same number
but different strings. Your first try might be to write something like
~by-2nd~:

#+BEGIN_SRC clojure
(defn by-2nd [a b]
  (compare (second a) (second b)))
#+END_SRC

But look what happens when you try to add multiple vectors with the same
number.

#+BEGIN_SRC clojure
user> (sorted-set-by by-2nd ["a" 1] ["b" 1] ["c" 1])
#{["a" 1]}
#+END_SRC

Only one element is in the set, because ~by-2nd~ treats all three of the
vectors as equal. Sets should not contain duplicate elements, so the
other elements are not added.

A common thought in such a case is to use a boolean comparator function
based on ~<=~ instead of ~<~:

#+BEGIN_SRC clojure
(defn by-2nd-<= [a b]
  (<= (second a) (second b)))
#+END_SRC

The boolean comparator ~by-2nd-<=~ seems to work correctly on the first
step of creating the set, but fails when testing whether elements are in
the set.

#+BEGIN_SRC clojure
user> (def sset (sorted-set-by by-2nd-<= ["a" 1] ["b" 1] ["c" 1]))
#'user/sset
user> sset
#{["c" 1] ["b" 1] ["a" 1]}
user> (sset ["c" 1])
nil
user> (sset ["b" 1])
nil
user> (sset ["a" 1])
nil
#+END_SRC

The problem here is that ~by-2nd-<=~ gives inconsistent answers. If you
ask it whether ~["c" 1]~ comes before ~["b" 1]~, it returns true (which
Clojure's boolean-to-int comparator conversion turns into -1). If you
ask it whether ~["b" 1]~ comes before ~["c" 1]~, again it returns true
(again converted into -1 by Clojure). One cannot reasonably expect an
implementation of a sorted data structure to provide any kind of
guarantees on its behavior if you give it an inconsistent comparator.

The techniques described in "Multi-field comparators" above provide
correct comparators for this example. In general, be wary of comparing
only parts of values to each other. Consider having some kind of
tie-breaking condition after all of the fields of interest to you have
been compared.

Aside: If you do not want multiple vectors in your set with the same
number, ~by-2nd~ is the comparator you should use. It gives exactly the
behavior you want. (TBD: Are there any caveats here? Will ~sorted-set~
ever use ~=~ to compare elements for any reason, or only the supplied
comparator function?)

**** Beware using subtraction in a comparator

Java comparators return a negative int value if the first argument is to
be treated as less than the second, a positive int value if the first
argument is to be treated as greater than the second, and 0 if they are
equal.

#+BEGIN_SRC clojure
user> (compare 10 20)
-1
user> (compare 20 10)
1
user> (compare 20 20)
0
#+END_SRC

Because of this, you might be tempted to write a comparator by
subtracting one numeric value from another, like so.

#+BEGIN_SRC clojure
user> (sort #(- %1 %2) [4 2 3 1])
(1 2 3 4)
#+END_SRC

While this works in many cases, think twice (or three times) before
using this technique. It is less error-prone to use explicit conditional
checks and return -1, 0, or 1, or to use boolean comparators.

Why? Java comparators must return a 32-bit /int/ type, so when a Clojure
function is used as a comparator and it returns any type of number,
that number is converted to an /int/ behind the scenes using the Java
method [[https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html#intValue--][intValue]].  See Clojure source file
[[https://github.com/clojure/clojure/blob/clojure-1.10.0/src/jvm/clojure/lang/AFunction.java#L50][src/jvm/clojure/lang/AFunction.java]] method ~compare~ if you want the
details.

For comparing floating point numbers and ratios, this causes numbers
differing by less than 1 to be treated as equal, because a return value
between -1 and 1 is truncated to the /int/ 0:

#+BEGIN_SRC clojure
;; This gives the correct answer
user> (sort #(- %1 %2) [10.0 9.0 8.0 7.0])
(7.0 8.0 9.0 10.0)

;; but this does not, because all values are treated as equal by
;; the bad comparator.
user> (sort #(- %1 %2) [1.0 0.9 0.8 0.7])
(1.0 0.9 0.8 0.7)

;; .intValue converts all values between -1.0 and 1.0 to 0
user> (map #(.intValue %) [-1.0 -0.99 -0.1 0.1 0.99 1.0])
(-1 0 0 0 0 1)
#+END_SRC

This also leads to bugs when comparing integer values that differ by
amounts that change sign when you truncate it to a 32-bit /int/ (by
discarding all but its least significant 32 bits). About half of all
pairs of long values are compared incorrectly by using subtraction as a
comparator.

#+BEGIN_SRC clojure
;; This looks good
user> (sort #(- %1 %2) [4 2 3 1])
(1 2 3 4)

;; What the heck?
user> (sort #(- %1 %2) [2147483650 2147483651 2147483652 4 2 3 1])
(3 4 2147483650 2147483651 2147483652 1 2)

user> [Integer/MIN_VALUE Integer/MAX_VALUE]
[-2147483648 2147483647]

;; How .intValue truncates a few selected values.  Note especially
;; the first and last ones.
user> (map #(.intValue %) [-2147483649 -2147483648 -1 0 1
                            2147483647  2147483648])
(2147483647 -2147483648 -1 0 1 2147483647 -2147483648)
#+END_SRC

Java itself uses a subtraction comparator for strings and characters,
among others. This does not cause any problems, because the result of
subtracting an arbitrary pair of 16-bit characters converted to ints is
guaranteed to fit within an /int/ without wrapping around. If your
comparator is not guaranteed to be given such restricted inputs, better
not to risk it.

*** Comparators that work between different types

Sometimes you might wish to sort a collection of values by some key, but
that key is not unique. You want the values with the same key to be
sorted in some predictable, repeatable order, but you do not care much
what that order is.

As a toy example, you might have a collection of vectors, each with two
elements, where the first element is always a string and the second is
always a number. You want to sort them by the number value in increasing
order, but you know your data can contain more than one vector with the
same number. You want to break ties in some way, consistently across
multiple sorts.

This case is easily implemented using a multi-field comparator as
described in an earlier section.

#+BEGIN_SRC clojure
(defn by-number-then-string [[a-str a-num] [b-str b-num]]
  (compare [a-num a-str]
           [b-num b-str]))
#+END_SRC

If the entire vector values can be compared with ~compare~, because all
vectors are equal length, and the type of each corresponding elements
can be compared to each other with ~compare~, then you can also do this,
using the entire vector values as the final tie-breaker:

#+BEGIN_SRC clojure
(defn by-number-then-whatever [a-vec b-vec]
  (compare [(second a-vec) a-vec]
           [(second b-vec) b-vec]))
#+END_SRC

However, that will throw an exception if some element position in the
vectors contain types too different for ~compare~ to work on, and those
vectors have the same second element:

#+BEGIN_SRC clojure
;; compare throws exception if you try to compare a string and a
;; keyword
user> (sort by-number-then-whatever [["a" 2] ["c" 3] [:b 2]])
Execution error (ClassCastException) at user/by-number-then-whatever (REPL:2).
class java.lang.String cannot be cast to class clojure.lang.Keyword
#+END_SRC

~cc-cmp~ ("cross class compare") below may be useful in such cases. It
can compare values of different types, which it orders based on a string
that represents the type of the value. It is not simply ~(class x)~,
because then numbers like ~Integer~ and ~Long~ would not be sorted in
numeric order.

#+BEGIN_SRC clojure
;; comparison-class throws exceptions for some types that might be
;; useful to include.

(defn comparison-class [x]
  (cond (nil? x) ""
        ;; Lump all numbers together since Clojure's compare can
        ;; compare them all to each other sensibly.
        (number? x) "java.lang.Number"

        ;; sequential? includes lists, conses, vectors, and seqs of
        ;; just about any collection, although it is recommended not
        ;; to use this to compare seqs of unordered collections like
        ;; sets or maps (vectors should be OK).  This should be
        ;; everything we would want to compare using cmp-seq-lexi
        ;; below.  TBD: Does it leave anything out?  Include anything
        ;; it should not?
        (sequential? x) "clojure.lang.Sequential"

        (set? x) "clojure.lang.IPersistentSet"
        (map? x) "clojure.lang.IPersistentMap"
        (.isArray (class x)) "java.util.Arrays"

        ;; Comparable includes Boolean, Character, String, Clojure
        ;; refs, and many others.
        (instance? Comparable x) (.getName (class x))
        :else (throw
               (ex-info (format "cc-cmp does not implement comparison of values with class %s"
                                (.getName (class x)))
                        {:value x}))))

(defn cmp-seq-lexi
  [cmpf x y]
  (loop [x x
         y y]
    (if (seq x)
      (if (seq y)
        (let [c (cmpf (first x) (first y))]
          (if (zero? c)
            (recur (rest x) (rest y))
            c))
        ;; else we reached end of y first, so x > y
        1)
      (if (seq y)
        ;; we reached end of x first, so x < y
        -1
        ;; Sequences contain same elements.  x = y
        0))))

;; The same result can be obtained by calling cmp-seq-lexi on two
;; vectors, but cmp-vec-lexi should allocate less memory comparing
;; vectors.
(defn cmp-vec-lexi
  [cmpf x y]
  (let [x-len (count x)
        y-len (count y)
        len (min x-len y-len)]
    (loop [i 0]
      (if (== i len)
        ;; If all elements 0..(len-1) are same, shorter vector comes
        ;; first.
        (compare x-len y-len)
        (let [c (cmpf (x i) (y i))]
          (if (zero? c)
            (recur (inc i))
            c))))))

(defn cmp-array-lexi
  [cmpf x y]
  (let [x-len (alength x)
        y-len (alength y)
        len (min x-len y-len)]
    (loop [i 0]
      (if (== i len)
        ;; If all elements 0..(len-1) are same, shorter array comes
        ;; first.
        (compare x-len y-len)
        (let [c (cmpf (aget x i) (aget y i))]
          (if (zero? c)
            (recur (inc i))
            c))))))


(defn cc-cmp
  [x y]
  (let [x-cls (comparison-class x)
        y-cls (comparison-class y)
        c (compare x-cls y-cls)]
    (cond (not= c 0) c  ; different classes

          ;; Compare sets to each other as sequences, with elements in
          ;; sorted order.
          (= x-cls "clojure.lang.IPersistentSet")
          (cmp-seq-lexi cc-cmp (sort cc-cmp x) (sort cc-cmp y))

          ;; Compare maps to each other as sequences of [key val]
          ;; pairs, with pairs in order sorted by key.
          (= x-cls "clojure.lang.IPersistentMap")
          (cmp-seq-lexi cc-cmp
                        (sort-by key cc-cmp (seq x))
                        (sort-by key cc-cmp (seq y)))

          (= x-cls "java.util.Arrays")
          (cmp-array-lexi cc-cmp x y)

          ;; Make a special check for two vectors, since cmp-vec-lexi
          ;; should allocate less memory comparing them than
          ;; cmp-seq-lexi.  Both here and for comparing sequences, we
          ;; must use cc-cmp recursively on the elements, because if
          ;; we used compare we would lose the ability to compare
          ;; elements with different types.
          (and (vector? x) (vector? y)) (cmp-vec-lexi cc-cmp x y)

          ;; This will compare any two sequences, if they are not both
          ;; vectors, e.g. a vector and a list will be compared here.
          (= x-cls "clojure.lang.Sequential")
          (cmp-seq-lexi cc-cmp x y)

          :else (compare x y))))
#+END_SRC

Here is a quick example demonstrating `cc-cmp's ability to compare
values of different types.

#+BEGIN_SRC clojure
user> (pprint (sort cc-cmp [true false nil Double/MAX_VALUE 10
                            Integer/MIN_VALUE :a "b" 'c (ref 5)
                            [5 4 3] '(5 4) (seq [5]) (cons 6 '(1))
                            #{1 2 3} #{2 1}
                            {:a 1, :b 2} {:a 1, :b -2}
                            (object-array [1 2 3 4])]))
(nil
 {:a 1, :b -2}
 {:a 1, :b 2}
 #{1 2}
 #{1 2 3}
 :a
 #<Ref@1493d9b3: 5>
 (5)
 (5 4)
 [5 4 3]
 (6 1)
 c
 false
 true
 -2147483648
 10
 1.7976931348623157E308
 "b"
 [1, 2, 3, 4])
nil
#+END_SRC

** Deps and CLI Guide
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/deps_and_cli.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/deps_and_cli
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-09-08
:CUSTOM_ID: content/guides/deps_and_cli
:END:

Clojure provides command line tools for:

- Running an interactive REPL (Read-Eval-Print Loop)
- Running Clojure programs
- Evaluating Clojure expressions

In all the above scenarios you might want to use other Clojure and Java
libraries (dependencies or 'deps'). These may be libraries you are
writing locally, projects in git (e.g. on GitHub) or, commonly,
libraries available in the Maven ecosystem and hosted by central
repositories like Maven Central or Clojars.

In all cases, using a library involves:

1. specifying which library you want to use, providing its name and
   other aspects like version
2. getting it (once) from the git or maven repositories to your local
   machine
3. making it available on the JVM classpath so Clojure can find it while
   your REPL or program is running

Clojure tools specify a syntax and file (deps.edn) for (a), given which
they'll handle (b) and (c) automatically.

See [[#content/guides/getting_started][Getting Started]] for details on how to install the tools. Here we
will demonstrate how to get started. See [[#content/reference/deps_and_cli][Deps and CLI]] for a complete
reference. See the [[#content/community/tools][changelog]] for version information.

*** Running a REPL and using libraries

After you download and install the tools, you can start a REPL by
running the ~clj~ tool:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.3
user=>
#+END_EXAMPLE

Once in the REPL you can type Clojure expressions and press enter to
evaluate them. Type Control-D to exit the REPL:

#+BEGIN_EXAMPLE
user=> (+ 2 3)   # press the `enter` key after typing the expression to evaluate it
5                # result of expression
user=>           # type Ctrl-D here to exit the REPL (does not print)
$
#+END_EXAMPLE

There are many Clojure and Java libraries available that provide
access to practically any functionality you might need. For example,
consider the commonly used Clojure library [[https://github.com/dm3/clojure.java-time][clojure.java-time]] for
working with dates and times.

To work with this library, you need to declare it as a dependency so the
tool can ensure it has been downloaded and add it to the classpath. The
readme in most projects shows the name and version to use. Create a
~deps.edn~ file to declare the dependency:

#+BEGIN_SRC clojure
{:deps
 {clojure.java-time/clojure.java-time {:mvn/version "0.3.2"}}}
#+END_SRC

Alternately, if you don't know the version, you can use the
~find-versions~ tool which will list all available coordinates in sorted
order:

#+BEGIN_EXAMPLE
$ clj -X:deps find-versions :lib clojure.java-time/clojure.java-time
...omitted
{:mvn/version "0.3.1"}
{:mvn/version "0.3.2"}
#+END_EXAMPLE

Restart the REPL with the ~clj~ tool:

#+BEGIN_SRC clojure
$ clj
Downloading: clojure/java-time/clojure.java-time/0.3.2/clojure.java-time-0.3.2.pom from clojars
Downloading: clojure/java-time/clojure.java-time/0.3.2/clojure.java-time-0.3.2.jar from clojars
Clojure 1.10.3
user=> (require '[java-time :as t])
nil
user=> (str (t/instant))
"2020-09-01T03:42:47.691119Z"
#+END_SRC

You will see messages about a library being downloaded the first time
you use a dependency. Once the file is downloaded (usually to ~~/.m2~ or
~~/.gitlibs~), it will be reused in the future. You can use the same
process to add other libraries to your ~deps.edn~ file and explore
Clojure or Java libraries.

*** Writing a program

Soon you will want to build and save your own code that makes use of
these libraries. Create a new directory and copy this deps.edn into it:

#+BEGIN_EXAMPLE
$ mkdir hello-world
$ cp deps.edn hello-world
$ cd hello-world
$ mkdir src
#+END_EXAMPLE

By default, the ~clj~ tool will look for source files in the ~src~
directory. Create ~src/hello.clj~:

#+BEGIN_SRC clojure
(ns hello
  (:require [java-time :as t]))

(defn time-str
  "Returns a string representation of a datetime in the local time zone."
  [instant]
  (t/format
    (t/with-zone (t/formatter "hh:mm a") (t/zone-id))
    instant))

(defn run [opts]
  (println "Hello world, the time is" (time-str (t/instant))))
#+END_SRC

*** Using a main

This program has an entry function ~run~ that can be executed by ~clj~
using ~-X~:

#+BEGIN_EXAMPLE
$ clj -X hello/run
Hello world, the time is 10:53 PM
#+END_EXAMPLE

*** Using local libraries

You might decide to move part of this application into a library. The
~clj~ tool uses local coordinates to support projects that exist only on
your local disk. Let's extract the java-time parts of this application
out into a library in a parallel directory time-lib. The final structure
will look something like this:

#+BEGIN_EXAMPLE
├── time-lib
│   ├── deps.edn
│   └── src
│       └── hello_time.clj
└── hello-world
    ├── deps.edn
    └── src
        └── hello.clj
#+END_EXAMPLE

Under time-lib, use a copy of the deps.edn file you already have, and
create a file ~src/hello_time.clj~:

#+BEGIN_SRC clojure
(ns hello-time
  (:require [java-time :as t]))

(defn now
  "Returns the current datetime"
  []
  (t/instant))

(defn time-str
  "Returns a string representation of a datetime in the local time zone."
  [instant]
  (t/format
    (t/with-zone (t/formatter "hh:mm a") (t/zone-id))
    instant))
#+END_SRC

Update the application at ~hello-world/src/hello.clj~ to use your
library instead:

#+BEGIN_SRC clojure
(ns hello
  (:require [hello-time :as ht]))

(defn run [opts]
  (println "Hello world, the time is" (ht/time-str (ht/now))))
#+END_SRC

Modify ~hello-world/deps.edn~ to use a local coordinate that refers to
the root directory of the time-lib library (make sure to update the path
for your machine):

#+BEGIN_SRC clojure
{:deps
 {time-lib/time-lib {:local/root "../time-lib"}}}
#+END_SRC

You can then test everything from the hello-world directory by running
the application:

#+BEGIN_EXAMPLE
$ clj -X hello/run
Hello world, the time is 02:07 PM
#+END_EXAMPLE

*** Using git libraries

It would be great to share that library with others. You can accomplish
this by pushing the project to a public or private git repository and
letting others use it with a git dependency coordinate.

First, create a git library for the time-lib:

#+BEGIN_EXAMPLE
cd ../time-lib
git init
git add deps.edn src
git commit -m 'init'
#+END_EXAMPLE

Then go to a public git repository host (like GitHub) and follow the
instructions for creating and publishing this git repository.

We also want to tag this release so it has a meaningful version:

#+BEGIN_EXAMPLE
git tag -a 'v0.0.1' -m 'initial release'
git push --tags
#+END_EXAMPLE

Finally, modify your app to use the git dependency instead. You'll need
to gather the following information:

- repository lib - the Clojure CLI uses a convention where the URL does
  not need to be specified if you use a library name like
  ~io.github.yourname/time-lib~ for the GitHub url
  ~https://github.com/yourname/time-lib.git~.
- tag - ~v0.0.1~ is what we created above
- sha - the short sha at the tag, find it with
  ~git rev-parse --short v0.0.1~ if you have the repo locally, or
  ~git ls-remote https://github.com/yourname/time-lib.git v0.0.1~ if
  it's remote.

Update the ~hello-world/deps.edn~ to use a git coordinate instead:

#+BEGIN_SRC clojure
{:deps
 {io.github.yourname/time-lib {:git/tag "v0.0.1" :git/sha "4c4a34d"}}}
#+END_SRC

Now you can run the app again, making use of the (shared) git repository
library. The first time you run it you'll see extra messages on the
console when ~clj~ downloads and caches the repository and the commit
working tree:

#+BEGIN_EXAMPLE
$ clj -X hello/run
Cloning: https://github.com/yourname/time-lib
Checking out: https://github.com/yourname/time-lib at 4c4a34d
Hello world, the time is 02:10 PM
#+END_EXAMPLE

Now your friends can use ~time-lib~ too!

*** Other examples

As your program gets more involved you might need to create variations
on the standard classpath. The Clojure tools supports classpath
modifications using aliases, which are parts of the deps file that are
only used when the corresponding alias is supplied. Some of the things
you can do are:

- [[#content/guides/deps_and_cli#include-a-test-source-directory][Include a test source directory]]
- [[#content/guides/deps_and_cli#use-a-test-runner-to-run-all-tests][Use a test runner to run all tests]]
- [[#content/guides/deps_and_cli#Add-an-optional-dependency][Add an optional dependency]]
- [[#content/guides/deps_and_cli#preparing-source-dependency-libs][Prep source dependency libs]]
- [[#content/guides/deps_and_cli#Override-a-dependency][Override a dependency version]]
- [[#content/guides/deps_and_cli#Include-a-local-jar-on-disk][Use a local jar on disk]]
- [[#content/guides/deps_and_cli#ahead-of-time-compilation][Ahead-of-time (AOT) compilation]]
- [[#content/guides/deps_and_cli#run-a-socket-server-remote-repl][Run a socket server remote repl]]

**** Include a test source directory
:PROPERTIES:
:CUSTOM_ID: content/guides/deps_and_cli#include-a-test-source-directory
:END:

Typically, the project classpath includes only the project source, not
its test source by default. You can add extra paths as modifications to
the primary classpath in the make-classpath step of the classpath
construction. To do so, add an alias ~:test~ that includes the extra
relative source path ~"test"~:

#+BEGIN_SRC clojure
{:deps
 {org.clojure/core.async {:mvn/version "1.3.610"}}

 :aliases
 {:test {:extra-paths ["test"]}}}
#+END_SRC

Apply that classpath modification and examine the modified classpath by
invoking ~clj -A:test -Spath~:

#+BEGIN_EXAMPLE
$ clj -A:test -Spath
test:
src:
/Users/me/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar:
... same as before (split here for readability)
#+END_EXAMPLE

Note that the test dir is now included in the classpath.

**** Use a test runner to run all tests
:PROPERTIES:
:CUSTOM_ID: content/guides/deps_and_cli#use-a-test-runner-to-run-all-tests
:END:

You can extend the ~:test~ alias in the previous section to include the
cognitect-labs [[https://github.com/cognitect-labs/test-runner][test-runner]] for running all clojure.test tests:

Extend the ~:test~ alias:

#+BEGIN_SRC clojure
{:deps
 {org.clojure/core.async {:mvn/version "1.3.610"}}

 :aliases
 {:test {:extra-paths ["test"]
         :extra-deps {io.github.cognitect-labs/test-runner
                      {:git/url "https://github.com/cognitect-labs/test-runner.git"
                       :sha "9e35c979860c75555adaff7600070c60004a0f44"}}
         :main-opts ["-m" "cognitect.test-runner"]
         :exec-fn cognitect.test-runner.api/test}}}
#+END_SRC

And then execute the test runner using the default config (run all tests
in -test namespaces under the test/ dir):

#+BEGIN_EXAMPLE
clj -X:test
#+END_EXAMPLE

**** Add an optional dependency
:PROPERTIES:
:CUSTOM_ID: content/guides/deps_and_cli#Add-an-optional-dependency
:END:

Aliases in the ~deps.edn~ file can also be used to add optional
dependencies that affect the classpath:

#+BEGIN_SRC clojure
{:aliases
 {:bench {:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}}}
#+END_SRC

Here the ~:bench~ alias is used to add an extra dependency, namely the
criterium benchmarking library.

You can add this dependency to your classpath by adding the ~:bench~
alias to modify the dependency resolution: ~clj -A:bench~.

**** Preparing source dependency libs
:PROPERTIES:
:CUSTOM_ID: content/guides/deps_and_cli#preparing-source-dependency-libs
:END:

Some dependencies will require a preparation step before they can be
used on the classpath. These libs should state this need in their
deps.edn:

#+BEGIN_SRC clojure
{:paths ["src" "target/classes"]
 :deps/prep-lib {:alias :build
                 :fn compile
                 :ensure "target/classes"}}
#+END_SRC

Including the top-level key ~:deps/prep-lib~ tells the tools.deps
classpath construction that something extra is needed to prepare this
lib and that can be performed by invoking the ~compile~ function in the
~:build~ alias. Once the prepare step has been done, it should create
the path ~"target/classes"~ and that can be checked for completion.

You depend on this library like any other source-based library (could be
git or local):

#+BEGIN_SRC clojure
{:deps {my/lib {:local/root "../needs-prep"}}}
#+END_SRC

If you then try to include that library on your classpath you'll see an
error:

#+BEGIN_EXAMPLE
$ clj
Error building classpath. The following libs must be prepared before use: [my/lib]
#+END_EXAMPLE

You can then tell the CLI to prep using this command (this is a 1-time
action for a particular lib version):

#+BEGIN_EXAMPLE
$ clj -X:deps prep
Prepping io.github.puredanger/cool-lib in /Users/me/demo/needs-prep
$ clj
Clojure 1.10.3
user=>
#+END_EXAMPLE

**** Override a dependency
:PROPERTIES:
:CUSTOM_ID: content/guides/deps_and_cli#Override-a-dependency
:END:

You can use multiple aliases in combination. For example this ~deps.edn~
file defines two aliases - ~:old-async~ to force the use of an older
core.async version and ~:bench~ to add an extra dependency:

#+BEGIN_SRC clojure
{:deps
 {org.clojure/core.async {:mvn/version "0.3.465"}}

 :aliases
 {:old-async {:override-deps {org.clojure/core.async {:mvn/version "0.3.426"}}}
  :bench {:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}}}
#+END_SRC

Activate both aliases as follows: ~clj -A:bench:old-async~.

**** Include a local jar on disk
:PROPERTIES:
:CUSTOM_ID: content/guides/deps_and_cli#Include-a-local-jar-on-disk
:END:

Occasionally you may need to refer directly to a jar on disk that is not
present in a Maven repository, such as a database driver jar.

Specify local jar dependencies with a local coordinate that points
directly to a jar file instead of a directory:

#+BEGIN_SRC clojure
{:deps
 {db/driver {:local/root "/path/to/db/driver.jar"}}}
#+END_SRC

**** Ahead-of-time (AOT) compilation
:PROPERTIES:
:CUSTOM_ID: content/guides/deps_and_cli#ahead-of-time-compilation
:END:

When using [[clojure:genclass.clj::(defmacro gen-class][gen-class]] or [[clojure:genclass.clj::(defmacro gen-interface][gen-interface]], the Clojure source must be
ahead-of-time compiled to generate the java class(es).

This can be done by calling ~compile~. The default destination for
compiled class files is ~classes/~, which needs to be created and added
to the classpath:

#+BEGIN_EXAMPLE
$ mkdir classes
#+END_EXAMPLE

Edit ~deps.edn~ to add ~"classes"~ to the paths:

#+BEGIN_SRC clojure
{:paths ["src" "classes"]}
#+END_SRC

Declare a class with gen-class in ~src/my_class.clj~:

#+BEGIN_SRC clojure
(ns my-class)

(gen-class
  :name my_class.MyClass
  :methods [[hello [] String]])

(defn -hello [this]
  "Hello, World!")
#+END_SRC

Then you can reference the class with ~:import~ in another source file
~src/hello.clj~. Notice that the namespace is also added in ~:require~
so compilation can automatically find all dependent namespaces and
compile them.

#+BEGIN_SRC clojure
(ns hello
  (:require [my-class])
  (:import (my_class MyClass)))

(defn -main [& args]
  (let [inst (MyClass.)]
    (println (.hello inst))))
#+END_SRC

You can compile in the REPL or run a script to do the compilation:

#+BEGIN_EXAMPLE
$ clj -M -e "(compile 'hello)"
#+END_EXAMPLE

And then run the hello namespace:

#+BEGIN_EXAMPLE
$ clj -M -m hello
Hello, World!
#+END_EXAMPLE

See [[#content/reference/compilation][Compilation and Class Generation]] for a complete reference.

**** Run a socket server remote repl
:PROPERTIES:
:CUSTOM_ID: content/guides/deps_and_cli#run-a-socket-server-remote-repl
:END:

Clojure provides built-in support for running [[clojure:core/server.clj::(defn start-server][socket servers]], and in
particular using them to host remote REPLs.

To configure a socket server repl, add the following base configuration
to your ~deps.edn~:

#+BEGIN_SRC clojure
{:aliases
 {:repl-server
  {:exec-fn clojure.core.server/start-server
   :exec-args {:name "repl-server"
               :port 5555
               :accept clojure.core.server/repl
               :server-daemon false}}}}
#+END_SRC

And then start the server by invoking with the alias:

#+BEGIN_EXAMPLE
clojure -X:repl-server
#+END_EXAMPLE

If you like, you can also override the default parameters (or add
additional options) on the command line:

#+BEGIN_EXAMPLE
clojure -X:repl-server :port 51234
#+END_EXAMPLE

You can use netcat to connect from another terminal:

#+BEGIN_EXAMPLE
nc localhost 51234
user=> (+ 1 1)
2
#+END_EXAMPLE

Use Ctrl-D to exit the repl and Ctrl-C to exit the server.

** Destructuring in Clojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/destructuring.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/destructuring
:CLOJURE_SITE_AUTHOR: Michael Zavarella
:CLOJURE_SITE_DATE: 2015-12-09
:CUSTOM_ID: content/guides/destructuring
:END:
*** What is Destructuring?

Destructuring is a way to concisely bind names to the values inside a
data structure. Destructuring allows us to write more concise and
readable code.

Consider the following example of extracting and naming values in a
vector.

#+BEGIN_SRC clojure
(def my-line [[5 10] [10 20]])

(let [p1 (first my-line)
      p2 (second my-line)
      x1 (first p1)
      y1 (second p1)
      x2 (first p2)
      y2 (second p2)]
  (println "Line from (" x1 "," y1 ") to (" x2 ", " y2 ")"))
;= "Line from ( 5 , 10 ) to ( 10 , 20 )"
#+END_SRC

This is perfectly valid, but the code extracting and naming the values
in the vector obscures our intent. Destructuring allows us to more
concisely extract and name important parts of complex data structures to
make our code cleaner.

#+BEGIN_SRC clojure
;= Using the same vector as above
(let [[p1 p2] my-line
      [x1 y1] p1
      [x2 y2] p2]
 (println "Line from (" x1 "," y1 ") to (" x2 ", " y2 ")"))
;= "Line from ( 5 , 10 ) to ( 10 , 20 )"
#+END_SRC

Rather than explicitly binding each variable, we describe the bindings
based on their sequential order. That's a pretty weird statement,
"describe the bindings," so let's look at it again.

We have a data structure ~my-line~ that looks like this,
~[[5 10] [10 20]]~. In our destructuring form we will create a vector
containing two elements, ~p1~ and ~p2~, each of which are vectors
themselves. This will bind the vector ~[5 10]~ to the symbol ~p1~ and
the vector ~[10 20]~ to the symbol ~p2~. Since we want to work with the
elements of ~p1~ and ~p2~ rather than the structures themselves, we
destructure ~p1~ and ~p2~ within the same let statement. The vector ~p1~
looks like this, ~[5 10]~, so to destructure it, we create a vector
containing two elements, ~x1~ and ~y1~. This binds ~5~ to the symbol
~x1~ and ~10~ to the symbol ~y1~. The same is repeated for ~p2~ binding
~10~ to ~x2~ and ~20~ to ~y2~. At this point, we now have everything we
need to work with our data.

*** Sequential Destructuring
:PROPERTIES:
:CUSTOM_ID: content/guides/destructuring#sequential-destructuring
:END:

Clojure destructuring is broken up into two categories, sequential
destructuring and associative destructuring. Sequential destructuring
represents a sequential data structure as a Clojure vector within a let
binding.

This type of destructuring can be used on any kind of data structure
that can be traversed in linear time, including lists, vectors, and
anything that can produce a sequence.

#+BEGIN_SRC clojure
(def my-vector [1 2 3])
(def my-list '(1 2 3))
(def my-string "abc")

;= It should come as no surprise that this will print out 1 2 3
(let [[x y z] my-vector]
  (println x y z))
;= 1 2 3

;= We can also use a similar technique to destructure a list
(let [[x y z] my-list]
  (println x y z))
;= 1 2 3

;= For strings, the elements are destructured by character.
(let [[x y z] my-string]
  (println x y z)
  (map type [x y z]))
;= a b c
;= (java.lang.Character java.lang.Character java.lang.Character)
#+END_SRC

The key to sequential destructuring is that you bind the values
one-by-one to the symbols in the vector. For instance the vector
~[x y z]~ will match each element one-by-one with the list ~'(1 2 3)~.

In some cases, the collection you are destructuring isn't the exact same
size as the destructuring bindings. If the vector is too small, the
extra symbols will be bound to nil.

#+BEGIN_SRC clojure
(def small-list '(1 2 3))
(let [[a b c d e f g] small-list]
  (println a b c d e f g))
;= 1 2 3 nil nil nil nil
#+END_SRC

On the other hand, if the collection is too large, the extra values are
simply ignored.

#+BEGIN_SRC clojure
(def large-list '(1 2 3 4 5 6 7 8 9 10))
(let [[a b c] large-list]
  (println a b c))
;= 1 2 3
#+END_SRC

Destructuring gives you total control over the elements that you choose
to bind (or not) and how you bind them.

Many times, you don't need access to /every/ element in a collection,
only certain ones.

#+BEGIN_SRC clojure
(def names ["Michael" "Amber" "Aaron" "Nick" "Earl" "Joe"])
#+END_SRC

Say you want to print the first element on one line and the remainder on
another line.

#+BEGIN_SRC clojure
(let [[item1 item2 item3 item4 item5 item6] names]
  (println item1)
  (println item2 item3 item4 item5 item6))
;= Michael
;= Amber Aaron Nick Earl Joe
#+END_SRC

This binding works but even using destructuring it's pretty clunky.
Instead we can use ~&~ to combine the tail elements into a sequence.

#+BEGIN_SRC clojure
(let [[item1 & remaining] names]
  (println item1)
  (apply println remaining))
;= Michael
;= Amber Aaron Nick Earl Joe
#+END_SRC

You can ignore bindings that you don't intend on using by binding them
to any symbol of your choosing.

#+BEGIN_SRC clojure
(let [[item1 _ item3 _ item5 _] names]
  (println "Odd names:" item1 item3 item5))
;= Odd names: Michael Aaron Earl
#+END_SRC

The convention for this is to use an underscore like above.

You can use ~:as all~ to bind the entire vector to the symbol ~all~.

#+BEGIN_SRC clojure
(let [[item1 :as all] names]
  (println "The first name from" all "is" item1))
;= The first name from [Michael Amber Aaron Nick Earl Joe] is Michael
#+END_SRC

Let's stop for a bit and look a little further into the types of ~:as~
and ~&~.

#+BEGIN_SRC clojure
(def numbers [1 2 3 4 5])
(let [[x & remaining :as all] numbers]
  (apply prn [remaining all]))
;= (2 3 4 5) [1 2 3 4 5]
#+END_SRC

Here ~remaining~ is bound to a sequence containing the remaining
elements of the ~numbers~ vector while ~all~ has been bound to the
original ~vector~. What happens when we destructure a string instead?

#+BEGIN_SRC clojure
(def word "Clojure")
(let [[x & remaining :as all] word]
  (apply prn [x remaining all]))
;= \C (\l \o \j \u \r \e) "Clojure"
#+END_SRC

Here ~all~ is bound to the original structure (String, vector, list,
whatever it may be) and ~x~ is bound to the character ~\C~, and
~remaining~ is the remaining list of characters.

You can combine any or all of these techniques at the same time at your
discretion.

#+BEGIN_SRC clojure
(def fruits ["apple" "orange" "strawberry" "peach" "pear" "lemon"])
(let [[item1 _ item3 & remaining :as all-fruits] fruits]
  (println "The first and third fruits are" item1 "and" item3)
  (println "These were taken from" all-fruits)
  (println "The fruits after them are" remaining))
;= The first and third fruits are apple and strawberry
;= These were taken from [apple orange strawberry peach pear lemon]
;= The fruits after them are (peach pear lemon)
#+END_SRC

Destructuring can also be nested to get access to arbitrary levels of
sequential structure. Let's go back to our vector from the very
beginning, ~my-line~.

#+BEGIN_SRC clojure
(def my-line [[5 10] [10 20]])
#+END_SRC

This vector is comprised of nested vectors that we can access directly.

#+BEGIN_SRC clojure
(let [[[x1 y1][x2 y2]] my-line]
  (println "Line from (" x1 "," y1 ") to (" x2 ", " y2 ")"))
;= "Line from ( 5 , 10 ) to ( 10 , 20 )"
#+END_SRC

When you have nested vectors, you can use ~:as~ or ~&~ at any level as
well.

#+BEGIN_SRC clojure
(let [[[a b :as group1] [c d :as group2]] my-line]
  (println a b group1)
  (println c d group2))
;= 5 10 [5 10]
;= 10 20 [10 20]
#+END_SRC

*** Associative Destructuring

Associative destructuring is similar to sequential destructuring, but
applied instead to associative (key-value) structures (including maps,
records, vectors, etc). The associative bindings are concerned with
concisely extracting values of the map by key.

Let's first consider an example that extracts values from a map without
destructuring:

#+BEGIN_SRC clojure
(def client {:name "Super Co."
             :location "Philadelphia"
             :description "The worldwide leader in plastic tableware."})

(let [name (:name client)
      location (:location client)
      description (:description client)]
  (println name location "-" description))
;= Super Co. Philadelphia - The worldwide leader in plastic tableware.
#+END_SRC

Note that each line of the let binding is essentially the same - it
extracts a value from the map by the name of the key, then binds it to a
local with the same name.

Below is a first example of doing the same thing with associative
destructuring:

#+BEGIN_SRC clojure
(let [{name :name
       location :location
       description :description} client]
  (println name location "-" description))
;= Super Co. Philadelphia - The worldwide leader in plastic tableware.
#+END_SRC

The destructuring form is now a map rather than a vector, and instead of
a symbol on the left side of the let, we have a map. The keys of the map
are the symbols we want to bind in the let. The values of the
destructuring map are the keys we will look up in the associative value.
Here they are keywords (the most common case), but they could be any key
value - numbers, strings, symbols, etc.

Similar to sequential destructuring, if you try to bind a key that is
not present in the map, the binding value will be nil.

#+BEGIN_SRC clojure
(let [{category :category} client]
  (println category))
;= nil
#+END_SRC

Associative destructuring, however, also allows you to supply a default
value if the key is not present in the associative value with the ~:or~
key.

#+BEGIN_SRC clojure
(let [{category :category, :or {category "Category not found"}} client]
  (println category))
;= Category not found
#+END_SRC

The value for ~:or~ is a map where the bound symbol (here ~category~) is
bound to the expression ~"Category not found"~. When category is not
found in ~client~, it is instead found in the ~:or~ map and bound to
that value instead.

In sequential destructuring, you generally bind unneeded values with an
~_~. Since associative destructuring doesn't require traversing the
entire structure, you can simply omit any keys you don't plan on using
from the destructuring form.

If you need access to the entire map, you can use the ~:as~ key to bind
the entire incoming value, just as in sequential destructuring.

#+BEGIN_SRC clojure
(let [{name :name :as all} client]
  (println "The name from" all "is" name))
;= The name from {:name Super Co., :location Philadelphia, :description The world wide leader in plastic table-ware.} is Super Co.
#+END_SRC

The ~:as~ and ~:or~ keywords can be combined in a single destructuring.

#+BEGIN_SRC clojure
(def my-map {:a "A" :b "B" :c 3 :d 4})
(let [{a :a, x :x, :or {x "Not found!"}, :as all} my-map]
  (println "I got" a "from" all)
  (println "Where is x?" x))
;= I got A from {:a "A" :b "B" :c 3 :d 4}
;= Where is x? Not found!
#+END_SRC

You might have noticed that our original example still contains
redundant information (the local binding name and the key name) in the
associative destructuring form. The ~:keys~ key can be used to further
remove the duplication:

#+BEGIN_SRC clojure
(let [{:keys [name location description]} client]
  (println name location "-" description))
;= Super Co. Philadelphia - The worldwide leader in plastic tableware.
#+END_SRC

This example is exactly the same as the prior version - it binds ~name~
to ~(:name client)~, ~location~ to ~(:location client)~, and
~description~ to ~(:description client)~.

The ~:keys~ key is for associative values with keyword keys, but there
are also ~:strs~ and ~:syms~ for string and symbol keys respectively. In
all of these cases the vector contains symbols which are the local
binding names.

#+BEGIN_SRC clojure
(def string-keys {"first-name" "Joe" "last-name" "Smith"})

(let [{:strs [first-name last-name]} string-keys]
  (println first-name last-name))
;= Joe Smith

(def symbol-keys {'first-name "Jane" 'last-name "Doe"})

(let [{:syms [first-name last-name]} symbol-keys]
  (println first-name last-name))
;= Jane Doe
#+END_SRC

Associative destructuring can be nested and combined with sequential
destructuring as needed.

#+BEGIN_SRC clojure
(def multiplayer-game-state
  {:joe {:class "Ranger"
         :weapon "Longbow"
         :score 100}
   :jane {:class "Knight"
          :weapon "Greatsword"
          :score 140}
   :ryan {:class "Wizard"
          :weapon "Mystic Staff"
          :score 150}})

(let [{{:keys [class weapon]} :joe} multiplayer-game-state]
  (println "Joe is a" class "wielding a" weapon))
;= Joe is a Ranger wielding a Longbow
#+END_SRC

**** Keyword arguments

One special case is using associative destructuring for keyword-arg
parsing. Consider a function that takes options ~:debug~ and ~:verbose~.
These could be specified in an options map:

#+BEGIN_SRC clojure
(defn configure [val options]
  (let [{:keys [debug verbose] :or {debug false, verbose false}} options]
    (println "val =" val " debug =" debug " verbose =" verbose)))

(configure 12 {:debug true})
;;val = 12  debug = true  verbose = false
#+END_SRC

However, it would be nicer to type if we could pass those optional
arguments as just additional "keyword" arguments like this:

#+BEGIN_SRC clojure
(configure 12 :debug true)
#+END_SRC

To support this style of invocation, associative destructuring also
works with lists or sequences of key-value pairs for keyword argument
parsing. The sequence comes from the rest arg of a variadic function but
is destructured not with sequential destructuring, but with associative
destructuring (so a sequence destructured as if it were the key-value
pairs in a map):

#+BEGIN_SRC clojure
(defn configure [val & {:keys [debug verbose]
                        :or {debug false, verbose false}}]
  (println "val =" val " debug =" debug " verbose =" verbose))

(configure 10)
;;val = 10  debug = false  verbose = false

(configure 5 :debug true)
;;val = 5  debug = true  verbose = false

;; Note that any order is ok for the kwargs
 (configure 12 :verbose true :debug true)
;;val = 12  debug = true  verbose = true
#+END_SRC

The use of keyword arguments had fallen in and out of fashion in the
Clojure community over the years. They are now mostly used when
presenting interfaces that people are expected to type at the REPL or
the outermost layers of an API. In general, inner layers of the code
found it easier to pass options as an explicit map. However, in Clojure
1.11 the capability was added to allow passing of alternating
key→values, or a map of those same mappings, or even a map with
key→values before it to functions expecting keyword arguments.
Therefore, the call to ~configure~ above can take any of the following
forms in addition to those shown above:

#+BEGIN_SRC clojure
(configure 12 {:verbose true :debug true})
;val = 12  debug = true  verbose = true

(configure 12 :debug true {:verbose true})
;val = 12  debug = true  verbose = true
#+END_SRC

The trailing map to functions expecting keyword aguments is often useful
in overriding the default keys provided as key→value pairs.

**** Namespaced keywords

If the keys in your map are namespaced keywords, you can also use
destructuring with it, even though local binding symbols are not allowed
to have namespaces. Destructuring a namespaced key will bind a value to
the local name part of the key and drop the namespace. (Thus you can use
~:or~ as with a non-namespaced key.)

#+BEGIN_SRC clojure
(def human {:person/name "Franklin"
            :person/age 25
            :hobby/hobbies "running"})
(let [{:keys [hobby/hobbies]
       :person/keys [name age]
       :or {age 0}} human]
  (println name "is" age "and likes" hobbies))
;= Franklin is 25 and likes running
#+END_SRC

Destructuring namespaced keywords using ~:keys~ alone can result in
local bindings that clash. Because all map destructuring options can be
combined, any local binding form can be defined individually.

#+BEGIN_SRC clojure
(def human {:person/name "Franklin"
            :person/age 25
            :hobby/name "running"})
(let [{:person/keys [age]
       hobby-name :hobby/name
       person-name :person/name} human]
  (println person-name "is" age "and likes" hobby-name))
;= Franklin is 25 and likes running
#+END_SRC

You can even destructure using auto-resolved keywords, which will again
be bound to only the name part of the key:

#+BEGIN_SRC clojure
;; this assumes you have a person.clj namespace in your project
;; if not do the following at your repl instead: (create-ns 'person) (alias 'p 'person)
(require '[person :as p])

(let [person {::p/name "Franklin", ::p/age 25}
      {:keys [::p/name ::p/age]} person]
  (println name "is" age))

;= Franklin is 25
#+END_SRC

Creating and destructuring maps with auto-resolved keywords allow us to
write code using a namespace alias (here ~p~) that is defined by a
~require~ in the current namespace, giving us a means of namespace
indirection that can be changed at a single place in the code.

All symbols bound in the context of destructuring can be further
destructured - this allows destructuring to be used in a nested fashion
for both sequential and associative destructuring. It is less obvious,
but this also extends to the symbol defined after ~&~.

This example destructures the ~&~ seq in place to decode the rest of the
arguments as options (note that we are thus destructuring the two
arguments sequentially and the rest associatively):

#+BEGIN_SRC clojure
(defn f-with-options
  [a b & {:keys [opt1]}]
  (println "Got" a b opt1))

(f-with-options 1 2 :opt1 true)
;= Got 1 2 true
#+END_SRC

*** Where to destructure

You can utilize destructuring anywhere that there is an explicit or
implicit let binding.

One of the most common places to see destructuring is in pulling apart
the arguments passed to a function.

Here we have the standard let x equal this, let y equal that, etc...
Again, this is perfectly valid code, it's just verbose.

#+BEGIN_SRC clojure
(defn print-coordinates-1 [point]
  (let [x (first point)
        y (second point)
        z (last point)]
    (println "x:" x ", y:" y ", z:" z)))
#+END_SRC

Any time we see code that is using ~first~, ~second~, ~nth~, or ~get~ to
pull apart a data structure, it's likely that destructuring can clean
that up - we can start by rewriting the ~let~:

#+BEGIN_SRC clojure
(defn print-coordinates-2 [point]
  (let [[x y z] point]
    (println "x:" x ", y:" y ", z:" z)))
#+END_SRC

When defining a function in clojure, destructuring can be applied on the
incoming parameters, just like in a let:

#+BEGIN_SRC clojure
(defn print-coordinates-3 [[x y z]]
  (println "x:" x ", y:" y ", z:" z))
#+END_SRC

We have replaced several lines of code that pulled apart the incoming
point data with a concise statement about the structure of that data
that also binds the data to local values.

For a more realistic example, let's create a map containing some basic
contact information for the infamous John Smith.

#+BEGIN_SRC clojure
(def john-smith {:f-name "John"
                 :l-name "Smith"
                 :phone "555-555-5555"
                 :company "Functional Industries"
                 :title "Sith Lord of Git"})
#+END_SRC

Now that we have John's personal information we need to access the
values within this map.

#+BEGIN_SRC clojure
(defn print-contact-info [{:keys [f-name l-name phone company title]}]
  (println f-name l-name "is the" title "at" company)
  (println "You can reach him at" phone))

(print-contact-info john-smith)
;= John Smith is the Sith Lord of Git at Functional Industries
;= You can reach him at 555-555-5555
#+END_SRC

This function will associatively destructure the input using the ~:keys~
shortcut and then print out the contact information that we provided.

But what about when we want to send John a nice letter?

#+BEGIN_SRC clojure
(def john-smith {:f-name "John"
                 :l-name "Smith"
                 :phone "555-555-5555"
                 :address {:street "452 Lisp Ln."
                           :city "Macroville"
                           :state "Kentucky"
                           :zip "81321"}
                 :hobbies ["running" "hiking" "basketball"]
                 :company "Functional Industries"
                 :title "Sith Lord of Git"})
#+END_SRC

We have an address in there now, but we needed to nest a map into our
original structure in order to accomplish this.

#+BEGIN_SRC clojure
(defn print-contact-info
  [{:keys [f-name l-name phone company title]
    {:keys [street city state zip]} :address
    [fav-hobby second-hobby] :hobbies}]
  (println f-name l-name "is the" title "at" company)
  (println "You can reach him at" phone)
  (println "He lives at" street city state zip)
  (println "Maybe you can write to him about" fav-hobby "or" second-hobby))

(print-contact-info john-smith)
;= John Smith is the Sith Lord of Git at Functional Industries
;= You can reach him at 555-555-5555
;= He lives at 452 Lisp Ln. Macroville Kentucky 81321
;= Maybe you can write to him about running or hiking
#+END_SRC

*** Macros

Macro writers may find the need to write a macro that incorporates
destructuring. The most common way to do so is to produce a call to
something that already does destructuring (like ~let~, ~loop~, ~fn~,
etc). Some examples of this in ~clojure.core~ include ~if-let~,
~when-let~, ~when-some~, etc.

However, in rare cases you might want to instead resolve the
destructuring yourself in a macro. In this case, use the (undocumented)
~clojure.core/destructure~ function, which implements the destructuring
logic and is what ~let~ and ~loop~ actually invoke. The ~destructure~
function is designed to be invoked in a macro and expects to take a form
and return a form:

#+BEGIN_SRC clojure
(destructure '[[x & remaining :as all] numbers])
;= [vec__1 numbers
;=  x (clojure.core/nth vec__1 0 nil)
;=  remaining (clojure.core/nthnext vec__1 1)
;=  all vec__1]
#+END_SRC

The result was formatted here to give it a little more clarity. This
example should also give you some insight into how destructuring works
under the hood.

** Equality
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/equality.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/equality
:CLOJURE_SITE_AUTHOR: Andy Fingerhut
:CLOJURE_SITE_DATE: 2018-05-08
:CUSTOM_ID: content/guides/equality
:END:

This document discusses the concept of equality in Clojure, including
the functions ~=~, ~==~, and ~identical?~, and how they differ from
Java's ~equals~ method. It also has some description of Clojure's
~hash~, and how it differs from Java's ~hashCode~. The beginning of this
guide provides a summary of the most important information for quick
reference followed by a much more extensive review of the details.

/Information in this guide describes the behavior of Clojure 1.10.0
unless noted otherwise./

*** Summary

Clojure's ~=~ is true when comparing immutable values that represent the
same value, or when comparing mutable objects that are the identical
object. As a convenience, ~=~ also returns true when used to compare
Java collections against each other, or against Clojure's immutable
collections, if their contents are equal. However, there are important
caveats if you use non-Clojure collections.

Clojure's ~=~ is true when called with two immutable scalar values, if:

- Both arguments are ~nil~, ~true~, ~false~, the same character, or the
  same string (i.e. the same sequence of characters).
- Both arguments are symbols, or both keywords, with equal namespaces
  and names.
- Both arguments are numbers in the same 'category', and numerically
  the same, where category is one of:
  - integer or ratio
  - floating point (float or double)
  - [[https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html][BigDecimal]].

Clojure's ~=~ is true when called with two collections, if:

- Both arguments are /sequential/ (sequences, lists, vectors, queues,
  or Java collections implementing ~java.util.List~) with ~=~ elements
  in the same order.
- Both arguments are sets (including Java sets implementing
  ~java.util.Set~), with ~=~ elements, ignoring order.
- Both arguments are maps (including Java maps implementing
  ~java.util.Map~), with ~=~ keys *and* values, ignoring entry order.
- Both arguments are records created with ~defrecord~, with ~=~ keys
  *and* values, ignoring order, /and/ they have the same type. ~=~
  returns ~false~ when comparing a record to a map, regardless of their
  keys and values, because they do not have the same type.

Clojure's ~=~ is true when called with two mutable Clojure objects, i.e.
vars, refs, atoms, or agents, or with two "pending" Clojure objects,
i.e. futures, promises, or delays, if:

- Both arguments are the identical object, i.e. ~(identical?  x y)~ is
  true.

For all other types:

- Both arguments are the same type defined with ~deftype~. The type's
  ~equiv~ method is called and its return value becomes the value of
  ~(= x y)~.
- For other types, Java's ~x.equals(y)~ is true.

Clojure's ~==~ is intended specifically for numerical values:

- ~==~ can be used with numbers across different number categories
  (such as integer ~0~ and floating point ~0.0~).
- If any value being compared is not a number, an exception is thrown.

If you call ~=~ or ~==~ with more than two arguments, the result will be
true when all consecutive pairs are ~=~ or ~==~. ~hash~ is consistent
with ~=~, with the exceptions given below.

Exceptions, or possible surprises:

- When using non-Clojure collections in a Clojure hash-based
  collection (as map keys, or set elements), it will not appear equal
  to a similar collection with Clojure counterparts, due to the
  difference in hashing behavior. (see [[#content/guides/equality#equality-and-hash][Equality and hash]] and [[https://clojure.atlassian.net/browse/CLJ-1372][CLJ-1372]])
- When comparing collections with ~=~, numbers within the collections
  are also compared with ~=~, so the three numeric categories above are significant.
- 'Not a Number' values ~##NaN~, ~Float/NaN~, and ~Double/NaN~ are not
  ~=~ or ~==~ to anything, not even themselves. /Recommendation:/ Avoid
  including ~##NaN~ inside of Clojure data structures where you want to
  compare them to each other using ~=~, and sometimes get ~true~ as the
  result.
- 0.0 is ~=~ to -0.0
- Clojure regex's, e.g. ~#"a.*bc"~, are implemented using Java
  ~java.util.regex.Pattern~ objects, and Java's ~equals~ on two
  ~Pattern~ objects returns ~(identical? re1 re2)~, even though they
  are documented as immutable objects. Thus ~(= #"abc" #"abc")~ returns
  false, and ~=~ only returns true if two regex's happen to be the same
  identical object in memory. /Recommendation:/ Avoid using regex
  instances inside of Clojure data structures where you want to compare
  them to each other using ~=~, and get ~true~ as the result even if
  the regex instances are not identical objects. If you feel the need
  to, consider converting them to strings first, e.g. ~(str
  #"abc")~ → ~"abc"~ (see [[https://clojure.atlassian.net/browse/CLJ-1182][CLJ-1182]])
- Clojure persistent queues are never ~=~ to Java collections
  implementing ~java.util.List~, not even if they have ~=~ elements in
  the same order (see [[https://clojure.atlassian.net/browse/CLJ-1059][CLJ-1059]])
- Using ~=~ to compare a sorted map with another map, where ~compare~
  throws an exception when comparing their keys to each other because
  they have different types (e.g. keywords vs. numbers), will in some
  cases throw an exception (see [[https://clojure.atlassian.net/browse/CLJ-2325][CLJ-2325]])

In most cases, ~hash~ is consistent with ~=~, meaning: if ~(= x y)~,
then ~(= (hash x) (hash y))~. For any values or objects where this does
not hold, Clojure hash-based collections will not be able to find or
remove those items correctly, i.e. for hash-based sets with those items
as elements, or hash-based maps with those items as keys.

- ~hash~ is consistent with ~=~ for numbers, except for special float
  and double values. /Recommendation:/ Convert floats to doubles with
  ~(double x)~ to avoid this issue.
- ~hash~ is not consistent with ~=~ for immutable Clojure collections and
  their non-Clojure counterparts. See the [[#content/guides/equality#equality-and-hash][Equality and hash]] section
  for more details. /Recommendation:/ Convert non-Clojure collections to
  their Clojure immutable counterparts before including them in other
  Clojure data structures.
- ~hash~ is not consistent with ~=~ for objects with class ~VecSeq~,
  returned from calls like ~(seq (vector-of :int 0 1 2))~ (see [[https://clojure.atlassian.net/browse/CLJ-1364][CLJ-1364]])

*** Introduction

Equality in Clojure is most often tested using ~=~.

#+BEGIN_SRC clojure
user> (= 2 (+ 1 1))
true
user> (= (str "fo" "od") "food")
true
#+END_SRC

Unlike Java's ~equals~ method, Clojure's ~=~ returns true for many
values that do not have the same type as each other.

#+BEGIN_SRC clojure
user> (= (float 314.0) (double 314.0))
true
user> (= 3 3N)
true
#+END_SRC

~=~ does *not* always return true when two numbers have the same numeric
value.

#+BEGIN_SRC clojure
user> (= 2 2.0)
false
#+END_SRC

If you want to test for numeric equality across different numeric
categories, use ~==~. See the section [[#content/guides/equality#numbers][Numbers]] below for details.

Sequential collections (sequences, vectors, lists, and queues) with
equal elements in the same order are equal:

#+BEGIN_SRC clojure
user> (range 3)
(0 1 2)
user> (= [0 1 2] (range 3))
true
user> (= [0 1 2] '(0 1 2))
true
;; not = because different order
user> (= [0 1 2] [0 2 1])
false
;; not = because different number of elements
user> (= [0 1] [0 1 2])
false
;; not = because 2 and 2.0 are not =
user> (= '(0 1 2) '(0 1 2.0))
false
#+END_SRC

Two sets are equal if they have equal elements. Sets are normally
unordered but even with sorted sets, the sort order is not considered
when comparing for equality.

#+BEGIN_SRC clojure
user> (def s1 #{1999 2001 3001})
#'user/s1
user> s1
#{2001 1999 3001}
user> (def s2 (sorted-set 1999 2001 3001))
#'user/s2
user> s2
#{1999 2001 3001}
user> (= s1 s2)
true
#+END_SRC

Two maps are equal if they have the same set of keys, and each key maps
to equal values in each map. As with sets, maps are unordered and the
sort order is not considered for sorted maps.

#+BEGIN_SRC clojure
user> (def m1 (sorted-map-by > 3 -7 5 10 15 20))
#'user/m1
user> (def m2 {3 -7, 5 10, 15 20})
#'user/m2
user> m1
{15 20, 5 10, 3 -7}
user> m2
{3 -7, 5 10, 15 20}
user> (= m1 m2)
true
#+END_SRC

Note that while vectors are indexed and possess some map-like qualities,
maps and vectors never compare as ~=~ in Clojure:

#+BEGIN_SRC clojure
user> (def v1 ["a" "b" "c"])
#'user/v1
user> (def m1 {0 "a" 1 "b" 2 "c"})
#'user/m1
user> (v1 0)
"a"
user> (m1 0)
"a"
user> (= v1 m1)
false
#+END_SRC

Any metadata associated with Clojure collections is ignored when
comparing them.

#+BEGIN_SRC clojure
user> (def s1 (with-meta #{1 2 3} {:key1 "set 1"}))
#'user/s1
user> (def s2 (with-meta #{1 2 3} {:key1 "set 2 here"}))
#'user/s2
user> (binding [*print-meta* true] (pr-str s1))
"^{:key1 \"set 1\"} #{1 2 3}"
user> (binding [*print-meta* true] (pr-str s2))
"^{:key1 \"set 2 here\"} #{1 2 3}"
user> (= s1 s2)
true
user> (= (meta s1) (meta s2))
false
#+END_SRC

Records created with ~defrecord~ in many ways behave similarly to
Clojure maps. However, they are only ~=~ to other records of the same
type, and only then if they have the same keys and the same values. They
are never equal to maps, even if they have the same keys and values.

When you define a Clojure record, you are doing so in order to create a
distinct type that can be distinguished from other types --- you want
each type to have its own behavior with Clojure protocols and
multimethods.

#+BEGIN_SRC clojure
user=> (defrecord MyRec1 [a b])
user.MyRec1
user=> (def r1 (->MyRec1 1 2))
#'user/r1
user=> r1
#user.MyRec1{:a 1, :b 2}

user=> (defrecord MyRec2 [a b])
user.MyRec2
user=> (def r2 (->MyRec2 1 2))
#'user/r2
user=> r2
#user.MyRec2{:a 1, :b 2}

user=> (def m1 {:a 1 :b 2})
#'user/m1

user=> (= r1 r2)
false             ; r1 and r2 have different types
user=> (= r1 m1)
false             ; r1 and m1 have different types
user=> (into {} r1)
{:a 1, :b 2}      ; this is one way to "convert" a record to a map
user=> (= (into {} r1) m1)
true              ; the resulting map is = to m1
#+END_SRC

Clojure ~=~ behaves the same as Java's ~equals~ for all types except
numbers and Clojure collections.

Booleans and characters are straightforward in their equality.

Strings are straightforward, too, except in some cases involving
Unicode where strings that consist of different sequences of Unicode
characters can look the same when displayed, and in some applications
should be treated as equal even though ~=~ returns false. See
"Normalization" on the Wikipedia page on [[http://en.wikipedia.org/wiki/Unicode_equivalence][Unicode equivalence]] if you
are interested. There are libraries like [[http://site.icu-project.org/][ICU]] (International Components
for Unicode for Java) that can help if you need to do this.

Two symbols are equal if they have the same namespace and symbol name.
Two keywords are equal given the same conditions. Clojure makes equality
testing for keywords particularly quick (a simple pointer comparison).
It achieves this by its ~intern~ method of the Keyword class
guaranteeing that all keywords with the same namespace and name will
return the same keyword object.

*** Numbers
:PROPERTIES:
:CUSTOM_ID: content/guides/equality#numbers
:END:

Java ~equals~ is only true for two numbers if the types and numeric
values are the same. Thus ~equals~ is false even for Integer 1 and Long
1, because they have different types. Exception: Java ~equals~ is also
false for two BigDecimal values that are numerically equal if they have
different scales, e.g. 1.50M and 1.500M are not equal. This behavior is
documented for BigDecimal method
[[https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#equals-java.lang.Object-][equals]].

Clojure ~=~ is true if the 'category' and numeric values are the same.
Category is one of:

- integer or ratios, where integer includes all Java integer types such
  as ~Byte~, ~Short~, ~Integer~, ~Long~, ~BigInteger~, and
  ~clojure.lang.BigInt~, and ratios are represented with the Java type
  named ~clojure.lang.Ratio~.
- floating point: ~Float~ and ~Double~
- decimal: ~BigDecimal~

So ~(= (int 1) (long 1))~ is true because they are in the same integer
category, but ~(= 1 1.0)~ is false because they are in different
categories (integer vs. floating). While integers and ratios are
separate types in the Clojure implementation, for the purposes of ~=~
they are effectively in the same category. The results of arithmetic
operations on ratios are auto-converted to integers if they are whole
numbers. Thus any Clojure number that has type Ratio cannot equal any
integer, so ~=~ always gives the correct numerical answer (~false~) when
comparing a ratio to an integer.

Clojure also has ~==~ that is only useful for comparing numbers. It
returns true whenever ~=~ does. It also returns true for numbers that
are numerically equal, even if they are in different categories. Thus
~(= 1 1.0)~ is false, but ~(= 1 1.0)~ is true.

Why does ~=~ have different categories for numbers, you might wonder? It
would be difficult (if it is even possible) to make ~hash~ consistent
with ~=~ if it behaved like ~==~ (see section [[#content/guides/equality#equality-and-hash][Equality and hash]]).  Imagine
trying to write ~hash~ such that it was guaranteed to return the same
hash value for all of ~(float 1.5)~, ~(double 1.5)~, BigDecimal values
1.50M, 1.500M, etc. and the ratio ~(/ 3 2)~.

Clojure uses ~=~ to compare values for equality when they are used as
elements in sets, or keys in maps. Thus Clojure's numeric categories
come into play if you use sets with numeric elements or maps with
numeric keys.

**** Floating point numbers are usually approximations

Note that floating point values might behave in ways that surprise you,
if you have not learned of their approximate nature before. They are
often approximations simply because they are represented with a fixed
number of bits, and thus many values cannot be represented exactly and
must be approximated (or be out of range). This is true for floating
point numbers in any programming language.

#+BEGIN_SRC clojure
user> (def d1 (apply + (repeat 100 0.1)))
#'user/d1
user> d1
9.99999999999998
user> (== d1 10.0)
false
#+END_SRC

There is a whole field called [[https://en.wikipedia.org/wiki/Numerical_analysis][Numerical Analysis]] dedicated to studying
algorithms that use numerical approximation. There are libraries of
Fortran code that are used because their order of floating point
operations is carefully crafted to give guarantees on the difference
between their approximate answers and the exact answers.  [[http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html]["What Every
Computer Scientist Should Know About Floating-Point Arithmetic"]] is
good reading if you want quite a few details.

If you want exact answers for at least some kinds of problems, ratios or
BigDecimals might suit your needs. Realize that these require variable
amounts of memory if the number of digits required grow (e.g. after many
arithmetic operations), and significantly more computation time. They
also won't help if you want exact values of pi or the square root of 2.

**** Floating point "Not A Number"

Clojure uses the underlying Java double-size floating point numbers
(64-bit) with representation and behavior defined by a standard, IEEE
754. There is a special value [[http://en.wikipedia.org/wiki/NaN][NaN]] ("Not A Number") that is not even
equal to itself. Clojure represents this value as the symbolic value
~##NaN~.

#+BEGIN_SRC clojure
user> (Math/sqrt -1)
##NaN
user> (= ##NaN ##NaN)
false
user> (== ##NaN ##NaN)
false
#+END_SRC

This leads to some odd behavior if this "value" appears in your data.
While no error occurs when adding ~##NaN~ as a set element or a key in a
map, you cannot then search for it and find it. You also cannot remove
it using functions like ~disj~ or ~dissoc~. It will appear normally in
sequences created from collections containing it.

#+BEGIN_SRC clojure
user> (def s1 #{1.0 2.0 ##NaN})
#'user/s1
user> s1
#{2.0 1.0 ##NaN}
user> (s1 1.0)
1.0
user> (s1 1.5)
nil
user> (s1 ##NaN)
nil             ; cannot find ##NaN in a set, because it is not = to itself

user> (disj s1 2.0)
#{1.0 ##NaN}
user> (disj s1 ##NaN)
#{2.0 1.0 ##NaN}    ; ##NaN is still in the result!
#+END_SRC

In many cases, collections that contain ~##NaN~ will not be ~=~ to
another collection, even if they look like they should be, because
~(= ##NaN ##NaN)~ is ~false~:

#+BEGIN_SRC clojure
user> (= [1 ##NaN] [1 ##NaN])
false
#+END_SRC

Oddly enough, there are exceptions where collections contain ~##NaN~
that look like they should be ~=~, and they are, because
~(identical? ##NaN ##NaN)~ is ~true~:

#+BEGIN_SRC clojure
user> (def s2 #{##NaN 2.0 1.0})
#'user/s2
user> s2
#{2.0 1.0 ##NaN}
user> (= s1 s2)
true
#+END_SRC

Java has a special case in its ~equals~ method for floating point values
that makes ~##NaN~ equal to itself. Clojure ~=~ and ~==~ do not.

#+BEGIN_SRC clojure
user> (.equals ##NaN ##NaN)
true
#+END_SRC

*** Equality and hash
:PROPERTIES:
:CUSTOM_ID: content/guides/equality#equality-and-hash
:END:

Java has ~equals~ to compare pairs of objects for equality.

Java has a method ~hashCode~ that is /consistent/ with this notion of
equality (or is documented that it should be, at least). This means that
for any two objects ~x~ and ~y~ where ~equals~ is true, ~x.hashCode()~
and ~y.hashCode()~ are equal, too.

This hash consistency property makes it possible to use ~hashCode~ to
implement hash-based data structures like maps and sets that use hashing
techniques internally. For example, a hash table could be used to
implement a set, and it will be guaranteed that objects with different
~hashCode~ values can be put into different hash buckets, and objects in
different hash buckets will never be equal to each other.

Clojure has ~=~ and ~hash~ for similar reasons. Since Clojure ~=~
considers more pairs of things equal to each other than Java ~equals~,
Clojure ~hash~ must return the same hash value for more pairs of
objects. For example, ~hash~ always returns the same value regardless of
whether a sequence of ~=~ elements is in a sequence, vector, list, or
queue:

#+BEGIN_SRC clojure
user> (hash ["a" 5 :c])
1698166287
user> (hash (seq ["a" 5 :c]))
1698166287
user> (hash '("a" 5 :c))
1698166287
user> (hash (conj clojure.lang.PersistentQueue/EMPTY "a" 5 :c))
1698166287
#+END_SRC

However, since ~hash~ is not consistent with ~=~ when comparing Clojure
immutable collections with their non-Clojure counterparts, mixing the
two can lead to undesirable behavior, as shown in the examples below.

#+BEGIN_SRC clojure
user=> (def java-list (java.util.ArrayList. [1 2 3]))
#'user/java-list
user=> (def clj-vec [1 2 3])
#'user/clj-vec

;; They are ~, even though they are different classes
user=> (~ java-list clj-vec)
true
user=> (class java-list)
java.util.ArrayList
user=> (class clj-vec)
clojure.lang.PersistentVector

;; Their hash values are different, though.

user=> (hash java-list)
30817
user=> (hash clj-vec)
736442005

;; If java-list and clj-vec are put into collections that do not use
;; their hash values, like a vector or array-map, then those
;; collections will be equal, too.

user=> (= [java-list] [clj-vec])
true
user=> (class {java-list 5})
clojure.lang.PersistentArrayMap
user=> (= {java-list 5} {clj-vec 5})
true
user=> (assoc {} java-list 5 clj-vec 3)
{[1 2 3] 3}

;; However, if java-list and clj-vec are put into collections that do
;; use their hash values, like a hash-set, or a key in a hash-map,
;; then those collections will not be equal because of the different
;; hash values.

user=> (class (hash-map java-list 5))
clojure.lang.PersistentHashMap
user=> (= (hash-map java-list 5) (hash-map clj-vec 5))
false               ; sorry, not true
user=> (= (hash-set java-list) (hash-set clj-vec))
false               ; also not true

user=> (get (hash-map java-list 5) java-list)
5
user=> (get (hash-map java-list 5) clj-vec)
nil                 ; you were probably hoping for 5

user=> (conj #{} java-list clj-vec)
#{[1 2 3] [1 2 3]}          ; you may have been expecting #{[1 2 3]}
user=> (hash-map java-list 5 clj-vec 3)
{[1 2 3] 5, [1 2 3] 3}      ; I bet you wanted {[1 2 3] 3} instead
#+END_SRC

Most of the time you use maps in Clojure, you do not specify whether you
want an array map or a hash map. By default array maps are used if there
are at most 8 keys, and hash maps are used if there are over 8 keys.
Clojure functions choose the implementation for you as you do operations
on the maps. Thus even if you tried to use array maps consistently, you
are likely to frequently get hash maps as you create larger maps.

We do /not/ recommend trying to avoid the use of hash-based sets and
maps in Clojure. They use hashing to help achieve high performance in
their operations. Instead we would recommend avoiding the use of
non-Clojure collections as parts within Clojure collections. Primarily
this advice is because most such non-Clojure collections are mutable,
and mutability often leads to subtle bugs. Another reason is the
inconsistency of ~hash~ with ~=~.

Similar behavior occurs for Java collections that implement
~java.util.List~, ~java.util.Set~, and ~java.util.Map~, and any of the
few kinds of values for which Clojure's ~hash~ is not consistent with
~=~.

If you use hash-inconsistent values as parts within /any/ Clojure
collection, even as elements in a sequential collection like a list or
vector, those collections become hash-inconsistent with each other, too.
This occurs because the hash value of collections is calculated by
combining the hash values of their parts.

**** Historical notes on hash inconsistency for non-Clojure collections

You are likely wondering /why/ ~hash~ is not consistent with ~=~ for
non-Clojure collections. Non-Clojure collections have used Java's
~hashCode~ method long before Clojure existed. When Clojure was
initially developed, it used the same formula for calculating a hash
function from collection elements as ~hashCode~ did.

Before the release of Clojure 1.6.0 it was discovered that this use of
~hashCode~ for Clojure's ~hash~ function can lead to many hash
collisions when small collections are used as set elements or map keys.

For example, imagine a Clojure program that represents the contents of a
2-dimensional grid with 100 rows and 100 columns using a map with keys
that are vectors of two numbers in the range [0, 99]. There are 10,000
such points in this grid, so 10,000 keys in the map, but ~hashCode~ only
gives 3,169 different results.

#+BEGIN_SRC clojure
user=> (def grid-keys (for [x (range 100), y (range 100)]
                        [x y]))
#'user/grid-keys
user=> (count grid-keys)
10000
user=> (take 5 grid-keys)
([0 0] [0 1] [0 2] [0 3] [0 4])
user=> (take-last 5 grid-keys)
([99 95] [99 96] [99 97] [99 98] [99 99])
user=> (count (group-by #(.hashCode %) grid-keys))
3169
#+END_SRC

Thus there are an average of 10,000 / 3,169 = 3.16 collisions per hash
bucket if the map uses the default Clojure implementation of a hash-map.

The Clojure developers [[https://archive.clojure.org/design-wiki/display/design/Better%2Bhashing.html][analyzed]] several alternate hash functions, and
chose one based on the Murmur3 hash function, which has been in use
since Clojure 1.6.0. It also uses a different way than Java's
~hashCode~ does to combine the hashes of multiple elements in a collection.

At that time, Clojure could have changed ~hash~ to use the new technique
for non-Clojure collections as well, but it was judged that doing so
would significantly slow down a Java method called ~hasheq~, used to
implement ~hash~. See [[https://clojure.atlassian.net/browse/CLJ-1372][CLJ-1372]] for approaches that have been considered
so far, but as of this time no one has discovered a competitively fast
way to do it.

**** Other cases of ~hash~ inconsistent with ~=~

For some Float and Double values that are ~=~ to each other, their
~hash~ values are inconsistent:

#+BEGIN_SRC clojure
user> (= (float 1.0e9) (double 1.0e9))
true
user> (map hash [(float 1.0e9) (double 1.0e9)])
(1315859240 1104006501)
user> (hash-map (float 1.0e9) :float-one (double 1.0e9) :oops)
{1.0E9 :oops, 1.0E9 :float-one}
#+END_SRC

You can avoid the ~Float~ vs ~Double~ hash inconsistency by consistently
using one or the other types in floating point code. Clojure defaults to
doubles for floating point values, so that may be the most convenient
choice.

Rich Hickey has decided that changing this inconsistency in hash
values for types ~Float~ and ~Double~ is out of scope for Clojure
(mentioned in a comment of [[https://clojure.atlassian.net/browse/CLJ-1036][CLJ-1036]]). Ticket [[https://clojure.atlassian.net/browse/CLJ-1649][CLJ-1649]] has been filed
suggesting a change that ~=~ always return false when comparing floats
to doubles, which would make ~hash~ consistent with ~=~ by eliminating the
restriction on ~hash~, but there is no decision on that yet.

*** Defining equality for your own types

See the code of the projects below for examples of how to do this, and
much more. In particular, the Java methods ~equals~ and ~hashCode~ from
standard Java objects, and the Clojure Java methods ~equiv~ and ~hasheq~
are the most relevant for how ~=~ and ~hash~ behave.

- [[https://github.com/clojure/data.priority-map][org.clojure/data.priority-map]]
- [[https://github.com/clj-commons/ordered][org.flatland/ordered]] but note that it needs a change so that its
  custom ordered map data structure is not ~=~ to any Clojure record: [[https://github.com/clj-commons/ordered/pull/34][PR
  #34]]

*** References

The paper [[http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=1?doi=10.1.1.23.9999&rep=rep1&type=pdf]["Equal Rights for Functional Objects, or, the More Things
Change, The More They Are the Same"]] by Henry Baker includes code
written in Common Lisp for a function ~EGAL~ that was an inspiration for
Clojure's ~=~. The idea of "deep equality" making sense for immutable
values, but not as much sense for mutable objects (unless the mutable
objects are the same object in memory), is independent of programming
language.

Some differences between ~EGAL~ and Clojure's ~=~ are described below.
These are fairly esoteric details about the behavior of ~EGAL~, and are
not necessary to know for an understanding of Clojure's ~=~.

**** Comparing mutable collections to other things

~EGAL~ is defined to be ~false~ when comparing mutable objects to
anything else, unless that other thing is the same identical mutable
object in memory.

As a convenience, Clojure's ~=~ is designed to return ~true~ in some
cases when comparing Clojure immutable collections to non-Clojure
collections.

There is no Java method to determine whether an arbitrary collection is
mutable or immutable, so it is not possible in Clojure to implement the
intended behavior of ~EGAL~, although one might consider ~=~ "closer" to
~EGAL~ if it always returned ~false~ when one of the arguments was a
non-Clojure collection.

**** Lazy and pending values

Baker recommends that ~EGAL~ force lazy values when comparing them (see
Section 3. J. "Lazy Values" in the "Equal Rights for Functional Objects"
paper). When comparing a lazy sequence to another sequential thing,
Clojure's ~=~ does force the evaluation of the lazy sequence, stopping
if it reaches a non-~=~ sequence element. Chunked sequences, e.g. as
produced by ~range~, can cause evaluation to proceed a little bit
further than that point, as is the case for any event in Clojure that
causes evaluation of part of a lazy sequence.

Clojure's ~=~ does not ~deref~ delay, promise, or future objects when
comparing them. Instead, it compares them via ~identical?~, thus
returning ~true~ only if they are the same identical object in memory,
even if calling ~deref~ on them would result in values that were ~=~.

**** Closures

Baker describes in detail how ~EGAL~ can return ~true~ in some cases when
comparing [[https://en.wikipedia.org/wiki/Closure_(computer_programming)][closures]] to each other (see Section 3. D. "Equality of
Functions and Function-Closures" in the "Equal Rights for Functional
Objects" paper).

When given a function or closure as an argument, Clojure's ~=~ only
returns ~true~ if they are ~identical?~ to each other.

Baker appeared to be motivated to define ~EGAL~ this way because of the
prevalence in some Lisp family languages of using closures to represent
objects, where those objects could contain mutable state, or immutable
values (see the example below). Given that Clojure has multiple other
ways of creating immutable values and mutable objects (e.g. records,
reify, proxy, deftype), using closures to do so is uncommon.

#+BEGIN_SRC clojure
(defn make-point [init-x init-y]
  (let [x init-x
        y init-y]
    (fn [msg]
      (cond (= msg :get-x) x
            (= msg :get-y) y
        (= msg :get-both) [x y]
        :else nil))))

user=> (def p1 (make-point 5 7))
#'user/p1
user=> (def p2 (make-point -3 4))
#'user/p2
user=> (p1 :get-x)
5
user=> (p2 :get-both)
[-3 4]
user=> (= p1 p2)
false             ; We expect this to be false,
                  ; because p1 and p2 have different x, y values
user=> (def p3 (make-point 5 7))
#'user/p3
user=> (= p1 p3)
false             ; Baker's EGAL would return true here.  Clojure
                  ; = returns false because p1 and p3 are not identical?
#+END_SRC

** Frequently Asked Questions
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/faq.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/faq
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2016-03-08
:CUSTOM_ID: content/guides/faq
:END:

These questions and answers are adapted from mailing lists and other
Clojure community forums.

*** Reader and Syntax
**** What's the advantage of representing text tokens as keywords (instead of as strings)?

Keywords are cached and interned. This means that a keyword is reused
(reducing memory) everywhere in your program and that checks for
equality really become checks for identity (which are fast).
Additionally, keywords are invokable to look themselves up in a map and
thus this enables the common pattern of extracting a particular field
from a collection of maps possible.

**** Is :1 a valid keyword?

The [[#content/reference/reader][reader]] page defines keywords as "like symbols" and symbols "begin
with a non-numeric character" so the original intent was that ~:1~ would
be invalid. In fact, the only reason it is readable at all is due to a
[[https://clojure.atlassian.net/browse/CLJ-1252][bug]] in the keyword regex. This bug was fixed in a 1.6 alpha but we
quickly discovered that these keywords were in use in many actual
projects. To avoid breaking existing working code, the change was
rolled back and this form will continue to be supported. (There are
still some [[https://clojure.atlassian.net/browse/CLJ-1286][open]] [[https://clojure.atlassian.net/browse/CLJ-1527][issues]] to clarify this in code and/or docs.)

Note that namespaced keywords with names starting with numbers have
never been readable or valid, ie ~:foo/1~. However, auto-resolved
keywords like ~::1~ can be read but not round-tripped from print to
read.

In general, it's best to avoid using keywords that start with a number
unless it is in a narrow and controlled scope.

**** Why is it possible to create keywords that can't be read by the reader?

The [[clojure:core.clj::616][keyword]] function can be used to programmatically create keywords
based on user data or other sources of input. Similarly, the [[clojure:core.clj::(defn namespace][namespace]]
and [[clojure:core.clj::(defn name][name]] functions can be used to pull a keyword back apart into
components. It is common for programs to use this functionality to
create keywords to be used as identifiers or map keys without ever
printing and reading that data back.

Because of this use case (and also for general performance), no
validation check is performed on the inputs to ~keyword~ (or ~symbol~),
which makes it possible to create keywords that, when printed, cannot be
read back into a keyword (due to spaces or other non-allowed
characters). If this is important to you, you should validate the
keyword inputs first, before creating the keyword.

**** Why does Clojure not have user-extensible reader macros?
:PROPERTIES:
:CUSTOM_ID: content/guides/faq#reader-macros
:END:

The reader takes text (Clojure source) and returns Clojure data, which
is subsequently compiled and evaluated. Reader macros tell the Clojure
reader how to read something that is not a typical s-expression
(examples are things like quoting ~'~ and anonymous functions ~#()~).
Reader macros can be used to define entirely new syntaxes read by the
reader (for example: JSON, XML, or other formats) - this is a more
powerful syntactic capability than regular macros (which come into play
later at compile time).

However, unlike Lisp, Clojure does not allow the user to extend this set
of reader macros. This avoids the possibility of creating code that
another user cannot read (because they do not have the proper reader
macros). Clojure gives back some of the power of reader macros with
tagged literals, allowing you to create generically readable /data/,
that is still extensible.

Also see the [[#content/about/history][History of Clojure]] paper section about this (search for
"reader macros").

**** What does an _ mean in a let binding or parameter?

~_~ has no special meaning in Clojure as a symbol. However, it is a
convention to use ~_~ (or a leading ~_~) to denote a binding that will
not be used in the expression. A common case for this is skipping
unneeded values in [[#content/guides/destructuring#sequential-destructuring][sequential destructuring]]:

#+BEGIN_SRC clojure
(defn get-y [point]
  (let [[_ y] point]   ;; x-value of point is unused, so mark it with _
    y))
#+END_SRC

**** What does a ? or ! mean in a function name?

~?~ and ~!~ have no special meaning in Clojure as part of a function
name. However, it is a convention to use a trailing ~?~ to denote a
predicate function and a trailing ~!~ to denote a function with
side-effects. More specifically, a trailing ~?~ indicates that a
predicate strictly returns a boolean result (~true~ or ~false~). A
trailing ~!~ was originally intended to indicate that a function has
side-effects that would make it unsafe to use inside a [[#content/reference/refs][ref transaction]]
(in the Software Transactional Memory sense). In the wild, the use of
~!~ is less consistent and is sometimes used in a broader way to
indicate any sort of side-effecting behavior.

**** Why doesn't the anonymous function ~#([%1])~ work to construct a vector?

~#()~ always expands to include parens around the expression you give
it, thus in this case it yields ~(fn [x] ([x]))~ which fails when the
vector is invoked. Instead, use the vector function ~#(vector %)~ or
just ~vector~, which is the function being described.

*** Collections, Sequences, and Transducers
**** Why does ~conj~ add to the front of a list, but the back of a vector?

Most Clojure data structure operations, including ~conj~ (conjoin), are
designed to give the user a performance expectation. With ~conj~, the
expectation is that insertion should happen at the place where this
operation is efficient. Lists (as linked lists) can make a constant time
insertion only at the front. Vectors (indexed) are designed to expand at
the back. As the user, you should consider this when you choose which
data structure to use. In Clojure, vectors are used with much greater
frequency.

If your goal is specifically to "add to the front of the collection",
then the appropriate function to use is ~cons~, which will always add to
the front. Note however that this will produce a sequence, not an
instance of the original collection type.

**** I keep forgetting that after calling sequence functions on vectors/sets, the return value is no longer a vector or a set.

Generally you should divide the Clojure core functions into these two
categories:

- Data structure functions - take a data structure and return a
  modified versions of that data structure (conj, disj, assoc, dissoc,
  etc). These functions always take the data structure /first/.
- Sequence functions - take a "seqable" and return a seqable.
  [Generally we try to avoid committing to the return values actually
  being an instance of ISeq - this allows for performance optimizations
  in some cases.] Examples are map, filter, remove, etc. All of these
  functions take the seqable /last/.

It sounds like you are using the latter but expecting the semantics of
the former (which is a common issue for new Clojurists!). If you want to
apply sequence functions but have more control over the output data
structure, there are a number of ways to do that.

1. Use data-structure equivalents like mapv or filterv, etc - this is a
   very limited set that lets you perform these ops but return a data
   structure rather than a seqable. ~(mapv inc (filterv odd? [1 2 3]))~
2. Pour the results of your sequence transformations back into a data
   structure with into: ~(into [] (map inc (filter odd? [1 2 3])))~
3. Use transducers (likely with ~into~) - this has much the same effect
   as #2, but combinations of transformations can be applied more
   efficiently without creating any sequences - only the final result is
   built: ~(into [] (comp (filter odd?) (map inc)) [1 2 3])~. As you
   work with larger sequences or more transformations, this makes a
   significant difference in performance.

Note that all of these are eager transformations - they produce the
output vector when you invoke them. The original sequence version
~(map inc (filter odd? [1 2 3]))~ is lazy and will only produce values
as needed (with chunking under the hood for greater performance).
Neither of these is right or wrong, but they are both useful in
different circumstances.

**** What are the rules of thumb for arg order in core functions?

Primary collection operands come first. That way one can write ~->~ and
its ilk, and their position is independent of whether or not they have
variable arity parameters. There is a tradition of this in OO languages
and Common Lisp (~slot-value~, ~aref~, ~elt~).

One way to think about sequences is that they are read from the left,
and fed from the right:

#+BEGIN_EXAMPLE
<- [1 2 3 4]
#+END_EXAMPLE

Most of the sequence functions consume and produce sequences. So one way
to visualize that is as a chain:

#+BEGIN_EXAMPLE
map <- filter <- [1 2 3 4]
#+END_EXAMPLE

and one way to think about many of the seq functions is that they are
parameterized in some way:

#+BEGIN_EXAMPLE
(map f) <- (filter pred) <- [1 2 3 4]
#+END_EXAMPLE

So, sequence functions take their source(s) last, and any other
parameters before them, and partial allows for direct parameterization
as above. There is a tradition of this in functional languages and
Lisps.

Note that this is not the same as taking the primary operand last. Some
sequence functions have more than one source (concat, interleave). When
sequence functions are variadic, it is usually in their sources.

/Adapted from [[https://groups.google.com/d/msg/clojure/iyyNyWs53dc/Q_8BtjRthqgJ][comments by Rich Hickey]]./

**** What are good use cases for transducers?

When performing a series of transformations, sequences will create an
intermediate (cached) sequence between each transformation. Transducers
create a single compound transformation that is executed in one eager
pass over the input. These are different models, which are both useful.

Performance benefits of transducers:

- Source collection iteration - when used on reducible inputs
  (collections and other things), avoid creating an unnecessary input
  collection sequence - helps memory and time.
- Intermediate sequences and cached values - as the transformation
  happens in a single pass, you remove all intermediate sequence and
  cached value creation - again, helps memory and time. The combination
  of the prior item and this one will start to win big as the size of
  the input collection or number of transformations goes up (but for
  small numbers of either, chunked sequences can be surprisingly fast
  and will compete).

Design / usage benefits of transducers:

- Transformation composition - some use cases will have a cleaner
  design if they separate transformation composition from
  transformation application. Transducers support this.
- Eagerness - transducers are great for cases where eagerly processing
  a transformation (and potentially encountering any errors) is more
  important than laziness
- Resource control - because you have more control over when the input
  collection is traversed, you also know when processing is complete.
  It's thus easier to release or clean up input resources because you
  know when that happens.

Performance benefits of sequences:

- Laziness - if you will only need some of the outputs (for example a
  user is deciding how many to use), then lazy sequences can often be
  more efficient in deferring processing. In particular, sequences can
  be lazy with intermediate results, but transducers use a pull model
  that will eagerly produce all intermediate values.
- Infinite streams - because transducers are typically eagerly
  consumed, they don't match well with infinite streams of values

Design benefits of sequences:

- Consumer control - returning a seq from an API lets you combine input
  + transformation into something that gives the consumer control.
  Transducers don't work as well for this (but will work better for
  cases where input and transformation are separated).

*** Core functions
**** Why ~defn-~ but no ~def-~?

At one point, metadata was more cumbersome to use than now (the syntax
for a private defn was ~#^{:private true}~), and ~defn-~ seemed worth
creating as an "easy" version. The metadata support improved and became
"stackable" which allowed easier composition of independent metadata.
Rather than create private variants of all the def forms, it is simply
preferred to use ~^:private~ metadata when needed on ~def~ or other def
forms..

*** Spec
**** Why is spec alpha?

spec is in alpha to indicate that the API may still change. spec was
broken out of Clojure core so that spec can be updated independently
from the main Clojure version. At some point spec's API will be
considered stable and at that point the alpha will be removed. The
next version of spec is being developed at [[https://github.com/clojure/spec-alpha2][alpha.spec]].

**** Where should I put my specs?

There is no single right answer to this question. For data specs, it is
often useful to put them in their own namespace, which may or may not
match the qualifier used in the data specs. Matching the qualifier to
the namespace allows the use of auto-resolved keywords both within the
specs and in aliases in other namespaces, but also entwines them, making
refactoring more complicated.

For function specs, most people either put them immediately before or
after the function they apply to, or in a separate namespace that can
optionally be required when needed (for testing or validation). In the
latter case, Clojure core has followed the pattern of using
foo.bar.specs to hold function specs for the functions in foo.bar.

**** How do nested regex ops work?

Regex ops (cat, alt, *, +, ?, etc) always describe the elements in a
sequential collection. They are not, by themselves, specs. When used in
a spec context they are coerced into specs. Nested regex ops combine to
form a single regex spec over the same sequential collection.

To validate a nested collection, use ~s/spec~ to wrap the inner regex,
forcing a spec boundary between regex ops.

**** Why doesn't ~instrument~ check return values?

Instrument is intended to verify that a function is being invoked
according to its args spec. That is, is the function being called
correctly? This functionality should be used during development.

Checking whether a function operates correctly is a test-time activity
and this should be checked with the ~check~ function which will actually
invoke the function with generated args and verify the ret and fn specs
on each invocation.

**** Is there a way to skip checking macro specs?

Yes, set the Java system property ~-Dclojure.spec.skip-macros=true~ and
no macro specs will be checked during macroexpansion.

**** How do I write a map that only allows certain keys?

Spec's general philosophy is one of "open" specs where maps can contain
additional keys beyond what is specified as required or optional in an
s/keys spec. One way to accomplish a constrained key set is to ~s/and~
an additional constraint:

#+BEGIN_SRC clojure
(s/def ::auth
  (s/and
    (s/keys :req [::user ::password])
    #(every? #{::user ::password} (keys %))))
#+END_SRC

**** Can I add docs or metadata for specs?

Currently, no. This is under consideration for the next version of spec.

*** State and Concurrency
**** What are the trade-offs between reducers, core.async, futures, and pmap?

Each of these really addresses a different use case.

- Reducers are best for fine-grained data parallelism when computing a
  transformation over existing in-memory data (in a map or vector).
  Generally it's best when you have thousands of small data items to
  compute over and many cores to do the work. Anything described as
  "embarrassingly parallel".
- Futures are best for pushing work onto a background thread and
  picking it up later (or for doing I/O waits in parallel). It's better
  for big chunky tasks (go fetch a bunch of data in the background).
- core.async is primarily used to organize the subsystems or internal
  structure of your application. It has channels (queues) to convey
  values from one "subprocess" (go block) to another. So you're really
  getting concurrency and architectural benefits in how you break up
  your program. The killer feature you can really only get in
  core.async is the ability to wait on I/O events from multiple
  channels for the first response on any of them (via alt/alts).
  Promises can also be used to convey single values between independent
  threads/subprocesses but they are single delivery only.
- Tools like pmap, java.util queues and executors, and libraries like
  claypoole are doing coarse-level "task" concurrency. There is some
  overlap with core.async here which has a very useful
  transducer-friendly pipeline functionality.

**** Why does Clojure "hang" for 1 minute when my program ends?

This is most commonly asked in the context of programs that use
~future~, ~pmap~, ~agent-send~, or other functions that invoke those
functions. When a program like this finishes, there will be a 60 second
pause before exit. To fix this problem, call
[[clojure:core.clj::(defn shutdown-agents][shutdown-agents]] as the program exits.

Clojure uses two internal thread pools to service futures and agent
function executions. Both pools use non-daemon threads and the JVM will
not exit while any non-daemon thread is alive. In particular, the pool
that services futures and agent send-off calls uses an Executor cached
thread pool with a 60 second timeout. In the scenario above, the program
will wait until the background threads have completed their work and the
threads expire before it can exit.

**** Why the Clojure STM does not guarantee serializability but only snapshot isolation?

If reads were included by default, then STM would be slower (as more
transactions would require serializability). However, in many cases,
reads do not need to be included. Thus, users can choose to accept the
performance penalty when it is necessary and get faster performance when
it is not.

*** Namespaces
**** Do namespaces map 1-to-1 with files?

No (although that is typical). One namespace can be split across
multiple files by using ~load~ to load secondary files and ~in-ns~ in
those files to retain the namespace (clojure.core is defined in this
way). Also, it is possible to declare multiple namespaces in a single
file (although this is very unusual).

**** Do namespaces work like regular functions? Looking at the syntax, it seems ns could be returning a function that makes a namespace, and then if you just stick parens around the contents of the file, that would be a regular S expression too. Does that imply you can put more than one in a file?

ns is a macro that does a number of things:

- creates a new internal Namespace object (if it does not yet exist)
- makes that namespace the new current namespace (~*ns*~)
- auto-refers all vars from clojure.core and imports all classes from
  java.lang
- requires/refers other namespaces and vars as specified
- (and other optional things)

ns does not return a function or anything invokable as you suggest.

While ns is typically placed at the top of a clj file, it is actually
just a normal macro and can be invoked at the repl just the same. It
could also be used more than once in a single file (although this would
be surprising to most clj programmers and would likely not work as
desired in AOT).

*** Compiler
**** How does direct linking affect the REPL experience?

Anything that has been direct linked will not see redefinitions to vars.
For example, if you redefine something in clojure.core, other parts of
core that use that var will not see the redefinition (however anything
that you newly compile at the REPL will). In practice, this is not
typically a problem.

For parts of your own app, you may wish to only enable direct linking
when you build and deploy for production, rather than using it when you
developing at the REPL. Or you may need to mark parts of your app with
\^:redef if you want to always allow redefinition or \^:dynamic for
dynamic vars.

*** Java and Interop
**** How do you refer to a nested or inner class?

Use a $ to separate outer from inner class name. For example:
~java.util.Map$Entry~ is the Entry inner class inside Map.

**** How do you refer to the class representing a primitive?

Primitive types can be found as the static TYPE field on the boxed
class, for example: ~Integer/TYPE~.

**** How do you invoke a Java method with a vararg signature?
:PROPERTIES:
:CUSTOM_ID: content/guides/faq#varargs
:END:

Java treats a trailing varargs parameter as an array and it can be
invoked from Clojure by passing an explicit array.

Examples:

#+BEGIN_SRC clojure
;; Invoke static Arrays.asList(T... a)
(java.util.Arrays/asList (object-array [0 1 2]))

;; Invoke static String.format(String format, Object... args)
(String/format "%s %s, %s" (object-array ["March" 1 2016]))

;; For a primitive vararg, use the appropriate primitive array constructor
;; Invoke put(int row, int col, double... data)
(.put o 1 1 (double-array [2.0]))

;; Passing at least an empty array is required if there are no varargs
(.put o 1 1 (double-array []))

;; into-array can be used to create an empty typed array
;; Invoke getMethod(String name, Class... parameterTypes) on a Class instance
(.getMethod String "getBytes" (into-array Class []))
#+END_SRC

**** Why do I get an illegal access warning?

Java 9 added a module system, allowing code to be partitioned into
modules where code outside a module cannot invoke code inside the module
unless it has been exported by the module. One of the areas affected by
this change in Java is reflective access. Clojure uses reflection when
it encounters a Java interop call without sufficient type information
about the target object or the function arguments. For example:

#+BEGIN_SRC clojure
(def fac (javax.xml.stream.XMLInputFactory/newInstance))
(.createXMLStreamReader fac (java.io.StringReader. ""))
#+END_SRC

Here ~fac~ is an instance of
~com.sun.xml.internal.stream.XMLInputFactoryImpl~, which is an extension
of ~javax.xml.stream.XMLInputFactory~. In the java.xml module,
javax.xml.stream is an exported package, but the XMLInputFactoryImpl is
an internal implementation of the public abstract class in that package.
The invocation of ~createXMLStreamReader~ here will be reflective and
the Reflector will attempt to invoke the method based on the
implementation class, which is not accessible outside the module,
yielding:

#+BEGIN_EXAMPLE
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by clojure.lang.Reflector (file:/.m2/repository/org/clojure/clojure/1.10.0/clojure-1.10.0.jar) to method com.sun.xml.internal.stream.XMLInputFactoryImpl.createXMLStreamReader(java.io.Reader)
WARNING: Please consider reporting this to the maintainers of clojure.lang.Reflector
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
#+END_EXAMPLE

The first thing to note here is that this is a warning. Java 9 through
all current releases will permit the call to be made and the code will
continue to work.

There are several potential workarounds:

- Perhaps the best is to provide type hints to the exported types so
  the call is no longer reflective:

  #+BEGIN_EXAMPLE
  (.createXMLStreamReader ^javax.xml.stream.XMLInputFactory fac (java.io.StringReader. ""))
  #+END_EXAMPLE

- As of Clojure 1.10, turn off illegal access with
  ~--illegal-access=deny~. The Java reflection system will then
  provide the necessary feedback to Clojure to detect that calling
  through the inaccessible class is not an option. Clojure will find
  the public invocation path instead and no warning will be issued.
- Use JVM module system flags (~--add-exports~ etc ) to forcibly
  export the internal packages to avoid the warning. This is not
  recommended.

If it is difficult to tell from the warning where the reflection is
occurring, it may help to add the flag:

#+BEGIN_EXAMPLE
--illegal-access=debug
#+END_EXAMPLE

*** Design and Use
**** How do you achieve encapsulation with Clojure?

Because of its focus on immutable data, there is generally not a high
value placed on data encapsulation. Because data is immutable, there is
no need to worry about someone else modifying a value. Likewise, because
Clojure data is designed to be manipulated directly, there is
significant value in providing direct access to data, rather than
wrapping it in APIs.

All Clojure vars are globally available so again there is not much in
the way of encapsulation of functions within namespaces. However, the
ability to mark vars private (either using ~defn-~ for functions or
~def~ with ~^:private~ for values) is a convenience for a developer to
indicate which parts of an API should be considered public for use vs
part of the implementation.

*** Deps and CLI
**** Are clj and tools.deps.alpha done?

No. There are lots of known gaps and ideas still to implement. But it is
useful now. :)

**** Is clj a replacement for lein and boot?

No. The clojure tools are focused on a) building classpaths and b)
launching clojure programs. They do not (and will not) create artifacts,
deploy artifacts, etc.

tools.deps.alpha aims to provide programmatic building blocks for
dependency resolution and classpath construction. clj/clojure wraps
these into a command-line form that can be used to run Clojure programs.
You can compose these pieces to do many other things.

**** Do these tools allow you to dynamically add dependencies to a running repl?

No. Other tools exist to do this now or could be added on top of the
existing functionality but this was not part of the initial goal.

**** How can I create a single-file Clojure script, ideally self-invokable via a [[https://en.wikipedia.org/wiki/Shebang_(Unix)][shebang line]]?

If you don't need any extra dependencies, just put
~#!/usr/bin/env clojure~ as the first line. Note that ~clojure~ won't
automatically call a ~-main~ function, so be sure your file does more
than just define functions. You can find command-line arguments in
~*command-line-args*~.

If you do need extra dependencies, try the following, courtesy Dominic
Monroe, substituting whatever deps you need in place of ~funcool/tubax~:

#+BEGIN_EXAMPLE
#!/bin/sh

"exec" "clojure" "-Sdeps" '{:deps {funcool/tubax {:mvn/version "0.2.0"}}}' "$0" "$@"

;; Clojure code goes here.
#+END_EXAMPLE

*** Contributing
**** Why does Clojure require that contributors first sign a contributor agreement (CA)?

See [[http://clojure.org/contributing]]

It boils down to two reasons:

1. To protect Clojure from future legal challenges that might discourage
   businesses from adopting it.
2. To enable Clojure to be relicensed under a different open-source
   license if that would be advantageous.

Signing the Contributor Agreement grants Rich Hickey joint ownership of
your contributions. In exchange, Rich Hickey guarantees that Clojure
will always be available under an open-source license approved by either
the [[http://www.fsf.org/][Free Software Foundation]] or the [[http://opensource.org/][Open Source Initiative]].

**** Why does my CA email confirmation say "Clojure CA (between <my-company> and Rich Hickey) is Signed and Filed!"?

This is a quirk of Adobe EchoSign specific to users whose email account
is already associated with an Adobe EchoSign account. In those cases,
EchoSign will use the company name from your existing profile in the
subject line rather than the individual name that was signed on the
form. Don't worry! This has no effect - the agreement is as signed and
attached in the email.

**** Other projects hosted on GitHub accept pull requests. Why not Clojure?

Rich Hickey prefers to evaluate patches attached to JIRA tickets. This
is not to make it more difficult for contributors, or for legal
reasons, but because of workflow preferences. See [[#content/dev/dev][the development page]]
for more details.

[[https://groups.google.com/forum/#!msg/clojure/jWMaop_eVaQ/3M4gddaXDZoJ][Link]] to Oct 2012 Clojure Google group message from Rich Hickey on this
topic.

*** Future ideas
**** Will there be a native version of Clojure in the future?

Frequently people ask for a "native" version of Clojure, ie one that
does not rely on the JVM. ClojureScript self-hosting is one current
path but probably only useful for a subset of use cases. The [[https://www.graalvm.org/][GraalVM]]
project includes standalone execution using the SubstrateVM. Native
images produced with Graal start extremely fast but may have fewer
opportunities to optimize performance than the full JVM.

However, neither of these is likely what people are envisioning when
they ask for a "native version of Clojure", which is a version of the
language that is not JVM-hosted and compiles directly to a native
executable, probably via something like LLVM. Clojure leverages an
enormous amount of performance, portability, and functionality from the
JVM and relies heavily on things like a world-class garbage collector.
Building a "Clojure native" would require a large amount of work to make
a version of Clojure that was slower (probably much slower), less
portable, and with significantly less functionality (as the Clojure
library relies heavily on the JDK). The Clojure core team has no plans
to work on this but it would be an amazing learning project for anyone
and we encourage you to go for it!

** Getting Started
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/getting_started.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/getting_started
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2016-01-14
:CUSTOM_ID: content/guides/getting_started
:END:

Welcome to Clojure!

Check out [[#content/guides/learn/syntax][Learn Clojure]], [[#content/community/resources][Resources]], or [[#content/community/books][Books]] to learn the language! If
you have questions, you can search or ask at the official forum [[https://ask.clojure.org][Ask
Clojure]].

*** Dependencies

Clojure requires Java. Clojure officially supports Java LTS releases
(currently Java 8 and Java 11), but also tries to ensure interim
versions work as well. You can use any Java installation, whether it's a
commercial release from Oracle or an open source version based on
OpenJDK (like adoptopenjdk).

The Clojure tools require that either the ~java~ command is on the path
or that the ~JAVA_HOME~ environment variable is set.

*** Clojure installer and CLI tools

Clojure provides [[#content/reference/deps_and_cli][command line tools]] that can be used to start a
Clojure repl, use Clojure and Java libraries, and start Clojure
programs.

Follow these instructions to install the latest release of the ~clj~ and
~clojure~ tools:

**** Installation on Mac via [[https://brew.sh][Homebrew]]

Install the command line tools with ~brew~ from the [[https://github.com/clojure/homebrew-tools][clojure/tools tap]]:

#+BEGIN_EXAMPLE
brew install clojure/tools/clojure
#+END_EXAMPLE

If you've already installed this way in the past, you can upgrade to the
latest release with:

#+BEGIN_EXAMPLE
brew upgrade clojure/tools/clojure
#+END_EXAMPLE

**** Installation on Linux

To install with the Linux script installer:

1. Ensure that the following dependencies are installed: ~bash~, ~curl~,
   ~rlwrap~, and ~Java~.
2. Use the ~linux-install~ script to download and run the install, which
   will create the executables ~/usr/local/bin/clj~,
   ~/usr/local/bin/clojure~, and the directory ~/usr/local/lib/clojure~:

#+BEGIN_EXAMPLE
curl -O https://download.clojure.org/install/linux-install-1.10.3.1020.sh
chmod +x linux-install-1.10.3.1020.sh
sudo ./linux-install-1.10.3.1020.sh
#+END_EXAMPLE

***** Custom location

To install to a custom location (like ~/opt/infrastructure/clojure~),
use the option ~--prefix~:

#+BEGIN_EXAMPLE
sudo ./linux-install-1.10.3.1020.sh --prefix /opt/infrastructure/clojure
#+END_EXAMPLE

Extend the MANPATH in ~/etc/man_db.conf~ to include the manual pages:

#+BEGIN_EXAMPLE
MANPATH_MAP /opt/infrastructure/clojure/bin /opt/infrastructure/clojure/man
#+END_EXAMPLE

The ~linux-install~ script can be removed after installation.

**** Installation on Windows

An early release version of clj on Windows is available at [[https://github.com/clojure/tools.deps.alpha/wiki/clj-on-Windows][clj on
Windows]]. Please provide feedback on [[https://ask.clojure.org][Ask Clojure]] or Clojurians slack in
#clj-on-windows.

**** Other versions

See the [[#content/community/tools][changelog]] for version history and the [[https://github.com/clojure/homebrew-tools][Clojure tap]] for info on
installing older versions or newer prereleases instead.

*** Other ways to run Clojure
:PROPERTIES:
:CUSTOM_ID: content/guides/getting_started#other-ways-to-run-clojure
:END:

*Local build*

Most Clojure users use Clojure jars downloaded from the Maven central
repository (by the tools above or other Clojure build tools). However,
you can also build Clojure from source with necessary dependent jars
into a single executable jar (requires Git, Java, and Maven):

#+BEGIN_EXAMPLE
git clone https://github.com/clojure/clojure.git
cd clojure
mvn -Plocal -Dmaven.test.skip=true package
#+END_EXAMPLE

Then start the REPL with the local jar (note this will not work with the
jars in Maven as they do not include dependencies):

#+BEGIN_EXAMPLE
java -jar clojure.jar
#+END_EXAMPLE

*Try Clojure online*

[[https://repl.it/languages/clojure][repl.it]] provides a browser-based Clojure repl for interactive
exploration.

*** Next steps

- [[#content/community/tools][Install editors and build tools]]
- [[#content/guides/learn/syntax][Start learning the Clojure basics]]
- [[#content/community/books][Learn Clojure from a book]]
- [[#content/community/resources][Explore Clojure communities and resources]]
- [[https://ask.clojure.org][Ask questions about Clojure]]

** Go Block Best Practices
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/core_async_go.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/core_async_go
:CLOJURE_SITE_AUTHOR: Timothy Baldridge
:CLOJURE_SITE_DATE: 2017-05-24
:CUSTOM_ID: content/guides/core_async_go
:END:
*** General advice

It's very tempting to do the following to send a message without waiting
for a reply:

#+BEGIN_SRC clojure
(go (>! c 42))
#+END_SRC

Although go blocks are cheap, they aren't completely free. Thus it's
recommended to use

#+BEGIN_SRC clojure
(async/put! c 42)
#+END_SRC

~go~ just ends up calling ~put!~ eventually anyway, so there really
isn't a downside.

Also, if the code is being called inside a callback and you want to
respect back-pressure, it's fairly easy to use a recursive function
along with ~put!~ to respect back-pressure.

#+BEGIN_SRC clojure
(defn http-call
  "Makes an async call to a web browser"
  [url callback] ...)


(def urls [url1 url2 url3])

(defn load-urls
  "Spools the results of loading several urls onto a channel.
   does this without creating temporary channels or go blocks"
  [urls out-c]
  (http-call
    (first urls)
    (fn [response]
      (put! out-c response (fn [_] (load-urls (next urls) out-c))))))

(load-urls urls response-chan)
#+END_SRC

In this example we have some nice clean interop code that allows us to
start working with channels in our app, without creating tons of
channels or gos only to dispose of them shortly after they're created.

Keep in mind that it is important to respect back-pressure. A general
principle in core.async is that unbounded queues are bad and the number
of pending puts is limited (currently to 1024). Another option is to use
a channel with a buffer that always accepts puts immediately, such as
~dropping-buffer~ or ~sliding-buffer~.

*** Unsupported constructs and other limitations in go blocks

The go macro stops translating at function creation boundaries. This
means the following code will fail to compile, or may just throw a
runtime error stating that ~<!~ was used outside of a go block:

#+BEGIN_SRC clojure
(go (let [my-fn (fn [] (<! c))] (my-fn)))
#+END_SRC

This is one thing to remember since many Clojure constructs create
functions inside macros. The following are examples of code that will
not work as one would expect:

#+BEGIN_SRC clojure
(go (map <! some-chan))
(go (for [x xs]
      (<! x)))
#+END_SRC

However, other Clojure constructs, such as ~doseq~ do not allocate
closures internally:

#+BEGIN_SRC clojure
; This works just fine
(go (doseq [c cs]
      (println (<! c)))
#+END_SRC

Unfortunately, currently there isn't a good way to know if a given macro
will work as expected inside a go block unless one either looks at the
source, or tests the code generated by the macro.

*** Why is this?

The best explanation for "why does go block translation stop at function
creation?" basically comes down to a question of types. Examine the
following snippet:

#+BEGIN_SRC clojure
(map str [1 2 3])
#+END_SRC

We can easily see that this produces a ~seq~ of strings since the output
type of ~str~ is a string. So what is the return type of ~async/<!~? In
the context of a go block it is an object taken from a channel. But the
go block has to translate that to a parking call to ~async/put!~. The
return type of ~async/<!~ should really be thought of as something akin
to ~Async<Object>~ or ~Promise<Object>~. Thus the result of
~(map async/<! chans)~ is something like "a seq of pending channel
operations" which makes no sense at all.

In short, the go macro can't do these operations without some serious
work. Other languages such as [[https://github.com/trifork/erjang][Erjang]], allow for such constructs via
translating all code in the entire JVM. This is something we'd like to
avoid in core.async, as it complicates things and causes the logic of
one library to infect the code of an entire JVM. So we're left with
the practical compromise, translation stops when it sees a ~(fn [] …​)~.

** Guides
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/guides.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/guides
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2015-11-25
:CUSTOM_ID: content/guides/guides
:END:

*** Learning

- [[#content/guides/getting_started][Getting Started]]
- [[#content/guides/learn/syntax][Learn Clojure]]
- [[#content/guides/repl/introduction][Programming at the REPL]]
- [[#content/guides/faq][FAQ]]

*** Language

- [[#content/about/spec][spec]]
- [[#content/guides/weird_characters][Reading Clojure Characters]]
- [[#content/guides/destructuring][Destructuring]]
- [[#content/guides/threading_macros][Threading Macros]]
- [[#content/guides/comparators][Comparators]]
- [[#content/guides/reader_conditionals][Reader Conditionals]]

*** Tools

- [[#content/reference/deps_and_cli][Deps and CLI]]
- [[#content/guides/test_check_beginner][test.check]]

*** Libraries

- [[#content/guides/core_async_go][Go Block Best Practices]]

** Higher Order Functions
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/higher_order_functions.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/higher_order_functions
:CLOJURE_SITE_AUTHOR: Michael Zavarella
:CLOJURE_SITE_DATE: 2017-09-15
:CUSTOM_ID: content/guides/higher_order_functions
:END:

*** First Class Functions

In functional programming, functions are first class citizens. This
means functions can be treated as values. They can be assigned as
values, passed into functions, and returned from functions.

It's common to see function definitions in Clojure using ~defn~ like
~(defn foo …​)~. However, this is just syntactic sugar for
~(def foo (fn …​))~ ~fn~ returns a function object. ~defn~ returns a var
which points to a function object.

*** Higher Order Functions

A higher order function is a function that either:

1. Takes one or more functions as arguments
2. Returns a function as its result

This is an important concept in functional programming in any language.

Higher order functions allow us to /compose/ functions. This means we
can write small functions and combine them to create larger functions.
Like putting a bunch of small LEGO bricks together to build a house.

Let's move away from theory a bit and look at an example.

**** Functions as Arguments

Let's look at two functions

#+BEGIN_SRC clojure
(defn double-+
    [a b]
    (* 2 (+ a b)))
#+END_SRC

#+BEGIN_SRC clojure
(defn double-*
    [a b]
    (* 2 (* a b)))
#+END_SRC

These functions share a common pattern. They only differ in name and the
function used in the computation of ~a~ and ~b~. In general, the pattern
looks like this.

#+BEGIN_SRC clojure
(defn double-<f>
    [a b]
    (* 2 (f a b)))
#+END_SRC

We can generalize our ~double-~ function by passing ~f~ in as an
argument.

#+BEGIN_SRC clojure
(defn double-op
    [f a b]
    (* 2 (f a b)))
#+END_SRC

We can use this to express the concept of doubling the result of an
operation rather than having to write functions that perform specific
doubled operations individually.

*** Function Literals

An anonymous function is a function without a name. In Clojure these can
be defined in two ways, ~fn~ and the literal ~#(…​)~. Creating a
function with ~defn~ immediately binds it to a name, ~fn~ just creates a
function.

Let's have an example with a few music bands:

#+BEGIN_SRC clojure
(def bands [
    {:name "Brown Beaters"   :genre :rock}
    {:name "Sunday Sunshine" :genre :blues}
    {:name "Foolish Beaters" :genre :rock}
    {:name "Monday Blues"    :genre :blues}
    {:name "Friday Fewer"    :genre :blues}
    {:name "Saturday Stars"  :genre :jazz}
    {:name "Sunday Brunch"   :genre :jazz}
])
#+END_SRC

We want to retrieve only rock bands. This is a one-off operation, we're
not going to use it anywhere else in our code. We can save ourselves
some keystrokes by using an anonymous function.

#+BEGIN_SRC clojure
(def rock-bands
    (filter
        (fn [band] (= :rock (:genre band)))
        bands))
#+END_SRC

Even more concisely, using the function literal, we can define
~rock-bands~ like so.

#+BEGIN_SRC clojure
(def rock-bands (filter #(= :rock (:genre %)) bands))
#+END_SRC

The function literal supports multiple arguments via ~%~, ~%n~, and
~%&~.

#+BEGIN_SRC clojure
#(println %1 %2 %3)
#+END_SRC

If you're writing an anonymous function, the literal syntax is nice
because it's so compact. However, beyond a few arguments, the syntax can
become difficult to read. In that case, using ~fn~ may be more
appropriate.

**** Functions Returning Functions and Closures

Our first function will be called ~adder~. It will take a number, ~x~,
as its only argument and return a function. The function returned by
~adder~ will also take a single number, ~a~, as its argument and return
~x + a~.

#+BEGIN_SRC clojure
(defn adder [x]
  (fn [a] (+ x a)))

(def add-five (adder 5))

(add-five 100)
;; => 105
#+END_SRC

The returned function form ~adder~ is a closure. This means, it can
access all of the variables that were in scope when the function was
created. ~add-five~ has access to ~x~ even though it is outside of the
~adder~ function definition.

**** Filter

Filtering is a common operation in computer programming. Take this set
of animals

#+BEGIN_SRC clojure
(def pets [
    {:name "Fluffykins" :type :cat}
    {:name "Sparky" :type :dog}
    {:name "Tibby" :type :dog}
    {:name "Al" :type :fish}
    {:name "Victor" :type :bear}
])
#+END_SRC

We want to filter out the non-dog animals because we're writing
enterprise grade software. First, let's look at a normal for loop.

#+BEGIN_SRC clojure
(defn loop-dogs [pets]
    (loop [pets pets
           dogs []]
        (if (first pets)
            (recur (rest pets)
                   (if (= :dog (:type (first pets)))
                       (conj dogs (first pets))
                       dogs))
            dogs)))
#+END_SRC

This code works fine, but it's bulky and confusing. We can simplify this
using ~filter~, a higher order function.

#+BEGIN_SRC clojure
(defn filter-dogs [pets]
    (filter #(= :dog (:type %)) pets))
#+END_SRC

The solution using ~filter~ is much clearer and allows us to show intent
rather than just give commands. We can break this into even smaller
pieces by breaking the filtering function out into a separate ~var~.

#+BEGIN_SRC clojure
(defn dog? [pet] (= :dog (:type pet)))

(defn filter-dogs [pets] (filter dog? pets))
#+END_SRC

** Improving Development Startup Time
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/dev_startup_time.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/dev_startup_time
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-03-12
:CUSTOM_ID: content/guides/dev_startup_time
:END:

Did you know:

- Most libraries are distributed as source and you compile them over
  and over
- You can compile namespaces explicitly using [[clojure:core.clj::(defn compile][compile]]
- Namespace compilation is transitive
- ~compile~ writes these files to disk and ~require~ will use them
- You can use ~compile~ on the namespace you load when you start
  development, or on your ~user.clj~, or on the main namespace you run
  as a server to improve your startup time

The ~compile~ function takes a namespace symbol and compiles that
namespace and all the namespaces it requires into [[clojure:core.clj::(add-doc-and-meta *compile-path*][*compile-path*]]
(which defaults to ~classes~). That directory must exist and be on your
classpath:

#+BEGIN_SRC clojure
(compile 'my.namespace)    ;; writes .class files to *compile-path*
#+END_SRC

Subsequently, when any of those compiled namespaces are required, the
class file will be loaded, rather than the original ~.clj~ file. If a
source file is updated (and thus newer), it will be loaded instead.
Periodically, you will need to re-compile to account for new
dependencies or changing code.

One special case is the ~user.clj~ file loaded automatically by the
Clojure runtime, before any other code is loaded. If you are using a
~user.clj~ in dev, you need to force a reload because it has already
been loaded automatically:

#+BEGIN_SRC clojure
(binding [*compile-files* true] (require 'user :reload-all))
#+END_SRC

That's it! This technique can substantially reduce your startup time
during development, particularly as the number of dependencies you load
increases.

*** Using an alias for development

In a deps.edn project, you should create a development alias (like
~:dev~) that includes the ~classes~ directory:

#+BEGIN_SRC clojure
{:deps { ... }
 :aliases
 {:dev {:extra-paths ["classes"]}}}
#+END_SRC

You will also need to ensure the ~classes~ directory exists. It may be
useful to include the empty ~classes~ directory as part of your version
controlled project structure (make sure to ignore and NOT include the
compiled .class files).

You can then start your REPL with the alias and ~compile~ to populate
your ~classes~ directory and start seeing the benefits:

#+BEGIN_EXAMPLE
$ clj -A:dev
Clojure 1.10.1
user=> (compile 'my.namespace)
#+END_EXAMPLE

*** Incorporating user.clj into your development alias

If you want to use an automatically loaded user.clj, you should
incorporate that into your dev alias by adding a source path ~dev~:

#+BEGIN_SRC clojure
{:deps { ... }
 :aliases
 {:dev {:extra-paths ["dev" "classes"]}}}
#+END_SRC

And then create ~dev/user.clj~:

#+BEGIN_SRC clojure
(ns user
  (:require ... ))

;; dev-only functions, etc
#+END_SRC

Remember to use the modified compilation process for user.clj:

#+BEGIN_EXAMPLE
$ clj -A:dev
Clojure 1.10.1
user=> (binding [*compile-files* true] (require 'user :reload-all))
#+END_EXAMPLE

** Learn
*** Learn Clojure - Syntax
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/learn/syntax.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/learn/syntax
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-09-02
:NEXTPAGE_CUSTOM_ID: content/guides/learn/functions
:CUSTOM_ID: content/guides/learn/syntax
:END:
**** Literals

Below are some examples of literal representations of common primitives
in Clojure. All of these literals are valid Clojure expressions.

The ~;~ creates a comment to the end of the line. Sometimes multiple
semicolons are used to indicate header comment sections, but this is
just a convention.

***** Numeric types

#+BEGIN_SRC clojure
42        ; integer
-1.5      ; floating point
22/7      ; ratio
#+END_SRC

Integers are read as fixed precision 64-bit integers when they are in
range and arbitrary precision otherwise. A trailing ~N~ can be used to
force arbitrary precision. Clojure also supports the Java syntax for
octal (prefix ~0~), hexadecimal (prefix ~0x~) and arbitrary radix
(prefix with base then ~r~) integers. Ratios are provided as their own
type combining a numerator and denominator.

Floating point values are read as double-precision 64-bit floats, or
arbitrary precision with an ~M~ suffix. Exponential notation is also
supported. The special symbolic values ~##Inf~, ~##-Inf~, and ~##NaN~
represent positive infinity, negative infinity, and "not a number"
values respectively.

***** Character types

#+BEGIN_SRC clojure
"hello"         ; string
\e              ; character
#"[0-9]+"       ; regular expression
#+END_SRC

Strings are contained in double quotes and may span multiple lines.
Individual characters are represented with a leading backslash. There
are a few special named characters: ~\newline~ ~\spec~ ~\tab~, etc.
Unicode characters can be represented with ~\uNNNN~ or in octal with
~\oNNN~.

Literal regular expressions are strings with a leading ~#~. These are
compiled to java.util.regex.Pattern objects.

***** Symbols and idents

#+BEGIN_SRC clojure
map             ; symbol
+               ; symbol - most punctuation allowed
clojure.core/+  ; namespaced symbol
nil             ; null value
true false      ; booleans
:alpha          ; keyword
:release/alpha  ; keyword with namespace
#+END_SRC

Symbols are composed of letters, numbers, and other punctuation and are
used to refer to something else, like a function, value, namespace, etc.
Symbols may optionally have a namespace, separated with a forward slash
from the name.

There are three special symbols that are read as different types - ~nil~
is the null value, and ~true~ and ~false~ are the boolean values.

Keywords start with a leading colon and always evaluate to themselves.
They are frequently used as enumerated values or attribute names in
Clojure.

***** Literal collections

Clojure also includes literal syntax for four collection types:

#+BEGIN_SRC clojure
'(1 2 3)     ; list
[1 2 3]      ; vector
#{1 2 3}     ; set
{:a 1, :b 2} ; map
#+END_SRC

We'll talk about these in much greater detail later - for now it's
enough to know that these four data structures can be used to create
composite data.

**** Evaluation

Next we will consider how Clojure reads and evaluates expressions.

***** Traditional Evaluation (Java)

[[./assets/images/content/guides/learn/syntax/traditional-evaluation.png]]

In Java, source code (.java files) are read as characters by the
compiler (javac), which produces bytecode (.class files) which can be
loaded by the JVM.

***** Clojure Evaluation

[[./assets/images/content/guides/learn/syntax/clojure-evaluation.png]]

In Clojure, source code is read as characters by the [[#content/reference/reader][Reader]]. The
Reader may read the source either from .clj files or be given a series
of expressions interactively. The Reader produces Clojure data. The
Clojure compiler then produces the bytecode for the JVM.

There are two important points here:

1. The unit of source code is a *Clojure expression*, not a Clojure
   source file. Source files are read as a series of expressions, just
   as if you typed those expressions interactively at the REPL.
2. Separating the Reader and the Compiler is a key separation that makes
   room for macros. Macros are special functions that take code (as
   data), and emit code (as data). Can you see where a loop for macro
   expansion could be inserted in the evaluation model?

***** Structure vs Semantics

Consider a Clojure expression:

[[./assets/images/content/guides/learn/syntax/structure-and-semantics.png]]

This diagram illustrates the difference between syntax in green (the
Clojure data structure produced by the Reader) and semantics in blue
(how that data is understood by the Clojure runtime).

Most literal Clojure forms evaluate to themselves, *except* symbols and
lists. Symbols are used to refer to something else and when evaluated,
return what they refer to. Lists (as in the diagram) are evaluated as
invocation.

In the diagram, (+ 3 4) is read as a list containing the symbol (+) and
two numbers (3 and 4). The first element (where + is found) can be
called "function position", that is, a place to find the thing to
invoke. While functions are an obvious thing to invoke, there are also a
few special operators known to the runtime, macros, and a handful of
other invokable things.

Considering the evaluation of the expression above:

- 3 and 4 evaluate to themselves (longs)
- + evaluates to a function that implements ~+~
- evaluating the list will invoke the ~+~ function with 3 and 4 as
  arguments

Many languages have both statements and expressions, where statements
have some stateful effect but do not return a value. In Clojure,
everything is an expression that evaluates to a value. Some expressions
(but not most) also have side effects.

Now let's consider how we can interactively evaluate expressions in
Clojure.

***** Delaying evaluation with quoting

Sometimes it's useful to suspend evaluation, in particular for symbols
and lists. Sometimes a symbol should just be a symbol without looking up
what it refers to:

#+BEGIN_EXAMPLE
user=> 'x
x
#+END_EXAMPLE

And sometimes a list should just be a list of data values (not code to
evaluate):

#+BEGIN_EXAMPLE
user=> '(1 2 3)
(1 2 3)
#+END_EXAMPLE

One confusing error you might see is the result of accidentally trying
to evaluate a list of data as if it were code:

#+BEGIN_EXAMPLE
user=> (1 2 3)
Execution error (ClassCastException) at user/eval156 (REPL:1).
class java.lang.Long cannot be cast to class clojure.lang.IFn
#+END_EXAMPLE

For now, don't worry too much about quote but you will see it
occasionally in these materials to avoid evaluation of symbols or lists.

**** REPL

Most of the time when you are using Clojure, you will do so in an editor
or a REPL (Read-Eval-Print-Loop). The REPL has the following parts:

1. Read an expression (a string of characters) to produce Clojure data.
2. Evaluate the data returned from #1 to yield a result (also Clojure
   data).
3. Print the result by converting it from data back to characters.
4. Loop back to the beginning.

One important aspect of #2 is that Clojure always compiles the
expression before executing it; Clojure is *always* compiled to JVM
bytecode. There is no Clojure interpreter.

#+BEGIN_EXAMPLE
user=> (+ 3 4)
7
#+END_EXAMPLE

The box above demonstrates evaluating an expression (+ 3 4) and
receiving a result.

***** Exploring at the REPL

Most REPL environments support a few tricks to help with interactive
use. For example, some special symbols remember the results of
evaluating the last three expressions:

- ~*1~ (the last result)
- ~*2~ (the result two expressions ago)
- ~*3~ (the result three expressions ago)

#+BEGIN_EXAMPLE
user=> (+ 3 4)
7
user=> (+ 10 *1)
17
user=> (+ *1 *2)
24
#+END_EXAMPLE

In addition, there is a namespace ~clojure.repl~ that is included in the
standard Clojure library that provides a number of helpful functions. To
load that library and make its functions available in our current
context, call:

#+BEGIN_SRC clojure
(require '[clojure.repl :refer :all])
#+END_SRC

For now, you can treat that as a magic incantation. Poof! We'll unpack
it when we get to namespaces.

We now have access to some additional functions that are useful at the
REPL: ~doc~, ~find-doc~, ~apropos~, ~source~, and ~dir~.

The ~doc~ function displays the documentation for any function. Let's
call it on ~+~:

#+BEGIN_SRC clojure
user=> (doc +)

clojure.core/+
([] [x] [x y] [x y & more])
  Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +'
#+END_SRC

The ~doc~ function prints the documentation for ~+~, including the valid
signatures.

The doc function prints the documentation, then returns nil as the
result - you will see both in the evaluation output.

We can invoke ~doc~ on itself too:

#+BEGIN_EXAMPLE
user=> (doc doc)

clojure.repl/doc
([name])
Macro
  Prints documentation for a var or special form given its name
#+END_EXAMPLE

Not sure what something is called? You can use the ~apropos~ command to
find functions that match a particular string or regular expression.

#+BEGIN_EXAMPLE
user=> (apropos "+")
(clojure.core/+ clojure.core/+')
#+END_EXAMPLE

You can also widen your search to include the docstrings themselves with
~find-doc~:

#+BEGIN_EXAMPLE
user=> (find-doc "trim")

clojure.core/subvec
([v start] [v start end])
  Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done.

clojure.string/trim
([s])
  Removes whitespace from both ends of string.

clojure.string/trim-newline
([s])
  Removes all trailing newline \n or return \r characters from
  string.  Similar to Perl's chomp.

clojure.string/triml
([s])
  Removes whitespace from the left side of string.

clojure.string/trimr
([s])
  Removes whitespace from the right side of string.
#+END_EXAMPLE

If you'd like to see a full listing of the functions in a particular
namespace, you can use the ~dir~ function. Here we can use it on the
~clojure.repl~ namespace:

#+BEGIN_EXAMPLE
user=> (dir clojure.repl)

apropos
demunge
dir
dir-fn
doc
find-doc
pst
root-cause
set-break-handler!
source
source-fn
stack-element-str
thread-stopper
#+END_EXAMPLE

And finally, we can see not only the documentation but the underlying
source for any function accessible by the runtime:

#+BEGIN_EXAMPLE
user=> (source dir)

(defmacro dir
  "Prints a sorted directory of public vars in a namespace"
  [nsname]
  `(doseq [v# (dir-fn '~nsname)]
     (println v#)))
#+END_EXAMPLE

As you go through this workshop, please feel free to examine the
docstring and source for the functions you are using. Exploring the
implementation of the Clojure library itself is an excellent way to
learn more about the language and how it is used.

It is also an excellent idea to keep a copy of the [[#content/api/cheatsheet][Clojure Cheatsheet]]
open while you are learning Clojure. The cheatsheet categorizes the
functions available in the standard library and is an invaluable
reference.

Now let's consider some Clojure basics to get you going...​.

**** Clojure basics

***** ~def~

When you are evaluating things at a REPL, it can be useful to save a
piece of data for later. We can do this with ~def~:

#+BEGIN_EXAMPLE
user=> (def x 7)
#'user/x
#+END_EXAMPLE

~def~ is a special form that associates a symbol (x) in the current
namespace with a value (7). This linkage is called a ~var~. In most
actual Clojure code, vars should refer to either a constant value or a
function, but it's common to define and re-define them for convenience
when working at the REPL.

Note the return value above is ~#'user/x~ - that's the literal
representation for a var: ~#'~ followed by the namespaced symbol. ~user~
is the default namespace.

Recall that symbols are evaluated by looking up what they refer to, so
we can get the value back by just using the symbol:

#+BEGIN_EXAMPLE
user=> (+ x x)
14
#+END_EXAMPLE

***** Printing

One of the most common things you do when learning a language is to
print out values. Clojure provides several functions for printing
values:

|                 | For humans | Readable as data |
|-----------------+------------+------------------|
| With newline    | println    | prn              |
| Without newline | print      | pr               |

The human-readable forms will translate special print characters (like
newlines and tabs) to their printed form and omit quotes in strings. We
often use ~println~ to debug functions or print a value at the REPL.
~println~ takes any number of arguments and interposes a space between
each argument's printed value:

#+BEGIN_SRC clojure
user=> (println "What is this:" (+ 1 2))
What is this: 3
#+END_SRC

The println function has side-effects (printing) and returns nil as a
result.

Note that "What is this:" above did not print the surrounding quotes and
is not a string that the Reader could read again as data.

For that purpose, use prn to print as data:

#+BEGIN_EXAMPLE
user=> (prn "one\n\ttwo")
"one\n\ttwo"
#+END_EXAMPLE

Now the printed result is a valid form that the Reader could read again.
Depending on context, you may prefer either the human form or the data
form.

**** Test your knowledge
:PROPERTIES:
:CUSTOM_ID: content/guides/learn/syntax#test-your-knowledge
:END:

1. Using the REPL, compute the sum of 7654 and 1234.
2. Rewrite the following algebraic expression as a Clojure expression:
   ~( 7 + 3 * 4 + 5 ) / 10~.
3. Using REPL documentation functions, find the documentation for the
   ~rem~ and ~mod~ functions. Compare the results of the provided
   expressions based on the documentation.
4. Using ~find-doc~, find the function that prints the stack trace of
   the most recent REPL exception.

[[#content/guides/learn/answers#syntax][Check your answers]]
*** Learn Clojure - Functions
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/learn/functions.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/learn/functions
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-09-02
:PREVPAGE_CUSTOM_ID: content/guides/learn/syntax
:NEXTPAGE_CUSTOM_ID: content/guides/learn/sequential_colls
:CUSTOM_ID: content/guides/learn/functions
:END:
**** Creating Functions

Clojure is a functional language. Functions are first-class and can be
passed-to or returned-from other functions. Most Clojure code consists
primarily of pure functions (no side effects), so invoking with the same
inputs yields the same output.

~defn~ defines a named function:

#+BEGIN_SRC clojure
;;    name   params         body
;;    -----  ------  -------------------
(defn greet  [name]  (str "Hello, " name) )
#+END_SRC

This function has a single parameter ~name~, however you may include any
number of parameters in the params vector.

Invoke a function with the name of the function in "function position"
(the first element of a list):

#+BEGIN_EXAMPLE
user=> (greet "students")
"Hello, students"
#+END_EXAMPLE

***** Multi-arity functions

Functions can be defined to take different numbers of parameters
(different "arity"). Different arities must all be defined in the same
~defn~ - using ~defn~ more than once will replace the previous function.

Each arity is a list ~([param*] body*)~. One arity can invoke another.
The body can contain any number of expressions and the return value is
the result of the last expression.

#+BEGIN_SRC clojure
(defn messenger
  ([]     (messenger "Hello world!"))
  ([msg]  (println msg)))
#+END_SRC

This function declares two arities (0 parameters and 1 parameter). The
0-parameter arity calls the 1-parameter arity with a default value to
print. We invoke these functions by passing the appropriate number of
arguments:

#+BEGIN_EXAMPLE
user=> (messenger)
Hello world!
nil

user=> (messenger "Hello class!")
Hello class!
nil
#+END_EXAMPLE

***** Variadic functions

Functions may also define a variable number of parameters - this is
known as a "variadic" function. The variable parameters must occur at
the end of the parameter list. They will be collected in a sequence for
use by the function.

The beginning of the variable parameters is marked with ~&~.

#+BEGIN_SRC clojure
(defn hello [greeting & who]
  (println greeting who))
#+END_SRC

This function takes a parameter ~greeting~ and a variable number of
parameters (0 or more) that will be collected in a list named ~who~. We
can see this by invoking it with 3 arguments:

#+BEGIN_EXAMPLE
user=> (hello "Hello" "world" "class")
Hello (world class)
#+END_EXAMPLE

You can see that when ~println~ prints ~who~, it is printed as a list of
two elements that were collected.

***** Anonymous Functions

An anonymous function can be created with ~fn~:

#+BEGIN_SRC clojure
;;    params         body
;;   ---------  -----------------
(fn  [message]  (println message) )
#+END_SRC

Because the anonymous function has no name, it cannot be referred to
later. Rather, the anonymous function is typically created at the point
it is passed to another function.

Or it's possible to immediately invoke it (this is not a common usage):

#+BEGIN_SRC clojure
;;     operation (function)             argument
;; --------------------------------  --------------
(  (fn [message] (println message))  "Hello world!" )

;; Hello world!
#+END_SRC

Here we defined the anonymous function in the function position of a
larger expression that immediately invokes the expression with the
argument.

Many languages have both statements, which imperatively do something and
do not return a value, and expressions which do. Clojure has *only*
expressions that return a value. We'll see later that this includes even
flow control expressions like ~if~.

***** ~defn~ vs ~fn~

It might be useful to think of ~defn~ as a contraction of ~def~ and
~fn~. The ~fn~ defines the function and the ~def~ binds it to a name.
These are equivalent:

#+BEGIN_SRC clojure
(defn greet [name] (str "Hello, " name))

(def greet (fn [name] (str "Hello, " name)))
#+END_SRC

***** Anonymous function syntax

There is a shorter form for the ~fn~ anonymous function syntax
implemented in the Clojure reader: ~#()~. This syntax omits the
parameter list and names parameters based on their position.

- ~%~ is used for a single parameter
- ~%1~, ~%2~, ~%3~, etc are used for multiple parameters
- ~%&~ is used for any remaining (variadic) parameters

Nested anonymous functions would create an ambiguity as the parameters
are not named, so nesting is not allowed.

#+BEGIN_SRC clojure
;; Equivalent to: (fn [x] (+ 6 x))
#(+ 6 %)

;; Equivalent to: (fn [x y] (+ x y))
#(+ %1 %2)

;; Equivalent to: (fn [x y & zs] (println x y zs))
#(println %1 %2 %&)
#+END_SRC

***** Gotcha

One common need is an anonymous function that takes an element and wraps
it in a vector. You might try writing that as:

#+BEGIN_SRC clojure
;; DO NOT DO THIS
#([%])
#+END_SRC

This anonymous function expands to the equivalent:

#+BEGIN_SRC clojure
(fn [x] ([x]))
#+END_SRC

This form will wrap in a vector *and* try to invoke the vector with no
arguments (the extra pair of parentheses). Instead:

#+BEGIN_SRC clojure
;; Instead do this:
#(vector %)

;; or this:
(fn [x] [x])

;; or most simply just the vector function itself:
vector
#+END_SRC

**** Applying Functions

***** ~apply~

The ~apply~ function invokes a function with 0 or more fixed arguments,
and draws the rest of the needed arguments from a final sequence. The
final argument *must* be a sequence.

#+BEGIN_SRC clojure
(apply f '(1 2 3 4))    ;; same as  (f 1 2 3 4)
(apply f 1 '(2 3 4))    ;; same as  (f 1 2 3 4)
(apply f 1 2 '(3 4))    ;; same as  (f 1 2 3 4)
(apply f 1 2 3 '(4))    ;; same as  (f 1 2 3 4)
#+END_SRC

All 4 of these calls are equivalent to ~(f 1 2 3 4)~. ~apply~ is useful
when arguments are handed to you as a sequence but you must invoke the
function with the values in the sequence.

For example, you can use ~apply~ to avoid writing this:

#+BEGIN_SRC clojure
(defn plot [shape coords]   ;; coords is [x y]
  (plotxy shape (first coords) (second coords)))
#+END_SRC

Instead you can simply write:

#+BEGIN_SRC clojure
(defn plot [shape coords]
  (apply plotxy shape coords))
#+END_SRC

**** Locals and Closures
***** ~let~

~let~ binds symbols to values in a "lexical scope". A lexical scope
creates a new context for names, nested inside the surrounding context.
Names defined in a ~let~ take precedence over the names in the outer
context.

#+BEGIN_SRC clojure
;;      bindings     name is defined here
;;    ------------  ----------------------
(let  [name value]  (code that uses name))
#+END_SRC

Each ~let~ can define 0 or more bindings and can have 0 or more
expressions in the body.

#+BEGIN_SRC clojure
(let [x 1
      y 2]
  (+ x y))
#+END_SRC

This ~let~ expression creates two local bindings for ~x~ and ~y~. The
expression ~(+ x y)~ is in the lexical scope of the ~let~ and resolves x
to 1 and y to 2. Outside the ~let~ expression, x and y will have no
continued meaning, unless they were already bound to a value.

#+BEGIN_SRC clojure
(defn messenger [msg]
  (let [a 7
        b 5
        c (clojure.string/capitalize msg)]
    (println a b c)
  ) ;; end of let scope
) ;; end of function
#+END_SRC

The messenger function takes a ~msg~ argument. Here the ~defn~ is also
creating lexical scope for ~msg~ - it only has meaning within the
~messenger~ function.

Within that function scope, the ~let~ creates a new scope to define ~a~,
~b~, and ~c~. If we tried to use ~a~ after the let expression, the
compiler would report an error.

***** Closures

The ~fn~ special form creates a "closure". It "closes over" the
surrounding lexical scope (like ~msg~, ~a~, ~b~, or ~c~ above) and
captures their values beyond the lexical scope.

#+BEGIN_SRC clojure
(defn messenger-builder [greeting]
  (fn [who] (println greeting who))) ; closes over greeting

;; greeting provided here, then goes out of scope
(def hello-er (messenger-builder "Hello"))

;; greeting value still available because hello-er is a closure
(hello-er "world!")
;; Hello world!
#+END_SRC

**** Java Interop
***** Invoking Java code

Below is a summary of calling conventions for calling into Java from
Clojure:

| Task            | Java              | Clojure          |
|-----------------+-------------------+------------------|
| Instantiation   | ~new Widget("foo")~ | ~(Widget. "foo")~  |
| Instance method | ~rnd.nextInt()~     | ~(.nextInt rnd)~   |
| Instance field  | ~object.field~      | ~(.-field object)~ |
| Static method   | ~Math.sqrt(25)~     | ~(Math/sqrt 25)~   |
| Static field    | ~Math.PI~           | ~Math/PI~          |

***** Java Methods vs Functions

- Java methods are not Clojure functions
- Can't store them or pass them as arguments
- Can wrap them in functions when necessary

#+BEGIN_SRC clojure
;; make a function to invoke .length on arg
(fn [obj] (.length obj))

;; same thing
#(.length %)
#+END_SRC

**** Test your knowledge
:PROPERTIES:
:CUSTOM_ID: content/guides/learn/functions#test-your-knowledge
:END:

/[[#content/guides/learn/answers#functions][Check your answers]]/

1) Define a function ~greet~ that takes no arguments and prints "Hello".
   Replace the ~___~ with the implementation: ~(defn greet [] _)~

2) Redefine ~greet~ using ~def~, first with the ~fn~ special form and then
   with the ~#()~ reader macro.

   #+BEGIN_SRC clojure
   ;; using fn
   (def greet __)

   ;; using #()
   (def greet __)
   #+END_SRC

3) Define a function ~greeting~ which:
   - Given no arguments, returns "Hello, World!"
   - Given one argument x, returns "Hello, *x*!"
   - Given two arguments x and y, returns "*x*, *y*!"

   #+BEGIN_SRC clojure
   ;; Hint use the str function to concatenate strings
   (doc str)

   (defn greeting ___)

   ;; For testing
   (assert (= "Hello, World!" (greeting)))
   (assert (= "Hello, Clojure!" (greeting "Clojure")))
   (assert (= "Good morning, Clojure!" (greeting "Good morning" "Clojure")))
   #+END_SRC

4) Define a function ~do-nothing~ which takes a single argument ~x~ and
   returns it, unchanged.

   #+BEGIN_SRC clojure
   (defn do-nothing [x] ___)
   #+END_SRC

   In Clojure, this is the ~identity~ function. By itself, identity is not
   very useful, but it is sometimes necessary when working with
   higher-order functions.

   #+BEGIN_SRC clojure
   (source identity)
   #+END_SRC

5) Define a function ~always-thing~ which takes any number of arguments,
   ignores all of them, and returns the number ~100~.

   #+BEGIN_SRC clojure
   (defn always-thing [__] ___)
   #+END_SRC

6) Define a function ~make-thingy~ which takes a single argument ~x~. It
   should return another function, which takes any number of arguments
   and always returns x.

   #+BEGIN_SRC clojure
   (defn make-thingy [x] ___)

   ;; Tests
   (let [n (rand-int Integer/MAX_VALUE)
         f (make-thingy n)]
     (assert (= n (f)))
     (assert (= n (f 123)))
     (assert (= n (apply f 123 (range)))))
   #+END_SRC

   In Clojure, this is the ~constantly~ function.

   #+BEGIN_SRC clojure
   (source constantly)
   #+END_SRC

7) Define a function ~triplicate~ which takes another function and calls
   it three times, without any arguments.

   #+BEGIN_SRC clojure
   (defn triplicate [f] ___)
   #+END_SRC

8) Define a function ~opposite~ which takes a single argument ~f~. It
   should return another function which takes any number of arguments,
   applies ~f~ on them, and then calls ~not~ on the result. The
   ~not~

function in Clojure does logical negation.

   #+BEGIN_SRC clojure
   (defn opposite [f]
     (fn [& args] ___))
   #+END_SRC

   In Clojure, this is the complement function.

   #+BEGIN_SRC clojure
   (defn complement
     "Takes a fn f and returns a fn that takes the same arguments as f,
     has the same effects, if any, and returns the opposite truth value."
     [f]
     (fn
       ([] (not (f)))
       ([x] (not (f x)))
       ([x y] (not (f x y)))
       ([x y & zs] (not (apply f x y zs)))))
   #+END_SRC

9) Define a function ~triplicate2~ which takes another function and any
   number of arguments, then calls that function three times on those
   arguments. Re-use the function you defined in the earlier
   triplicate exercise.

   #+BEGIN_SRC clojure
   (defn triplicate2 [f & args]
     (triplicate ___))
   #+END_SRC

10) Using the [[http://docs.oracle.com/javase/8/docs/api/java/lang/Math.html][java.lang.Math]] class (~Math/pow~, ~Math/cos~, ~Math/sin~,
    ~Math/PI~), demonstrate the following mathematical facts:

    - The cosine of pi is -1
    - For some x, sin(x)\^2 + cos(x)\^2 = 1

11) Define a function that takes an HTTP URL as a string, fetches that
    URL from the web, and returns the content as a string.

    Hint: Using the [[http://docs.oracle.com/javase/8/docs/api/java/net/URL.html][java.net.URL]] class and its ~openStream~ method. Then
    use the Clojure ~slurp~ function to get the content as a string.

    #+BEGIN_SRC clojure
    (defn http-get [url]
      ___)

    (assert (.contains (http-get "https://www.w3.org") "html"))
    #+END_SRC

    In fact, the Clojure ~slurp~ function interprets its argument as a URL
    first before trying it as a file name. Write a simplified http-get:

    #+BEGIN_SRC clojure
    (defn http-get [url]
      ___)
    #+END_SRC

12) Define a function ~one-less-arg~ that takes two arguments:
    - ~f~, a function
    - ~x~, a value
    and returns another function which calls ~f~ on ~x~ plus any
    additional arguments.

    #+BEGIN_SRC clojure
    (defn one-less-arg [f x]
      (fn [& args] ___))
    #+END_SRC

    In Clojure, the ~partial~ function is a more general version of
    this.

13) Define a function ~two-fns~ which takes two functions as arguments,
    ~f~ and ~g~. It returns another function which takes one argument,
    calls ~g~ on it, then calls ~f~ on the result, and returns that.

    That is, your function returns the composition of ~f~ and ~g~.

    #+BEGIN_SRC clojure
    (defn two-fns [f g]
      ___)
    #+END_SRC

*** Learn Clojure - Sequential Collections
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/learn/sequential_colls.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/learn/sequential_colls
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-09-02
:PREVPAGE_CUSTOM_ID: content/guides/learn/functions
:NEXTPAGE_CUSTOM_ID: content/guides/learn/hashed_colls
:CUSTOM_ID: content/guides/learn/sequential_colls
:END:

Clojure collections "collect" values into compound values. There are
four key Clojure collection types: vectors, lists, sets, and maps. Of
those four collection types, vectors and lists are ordered.

**** Vectors

Vectors are an indexed, sequential data structure. Vectors are
represented with ~[ ]~ like this:

#+BEGIN_SRC clojure
[1 2 3]
#+END_SRC

***** Indexed access

"Indexed" means that elements of a vector can be retrieved by index. In
Clojure (as in Java), indexes start at 0, not 1. Use the ~get~ function
to retrieve an element at an index:

#+BEGIN_EXAMPLE
user=> (get ["abc" false 99] 0)
"abc"
user=> (get ["abc" false 99] 1)
false
#+END_EXAMPLE

Calling get with an invalid index returns ~nil~:

#+BEGIN_EXAMPLE
user=> (get ["abc" false 99] 14)
nil
#+END_EXAMPLE

***** ~count~

All Clojure collections can be counted:

#+BEGIN_EXAMPLE
user=> (count [1 2 3])
3
#+END_EXAMPLE

***** Constructing

In addition to the literal ~[ ]~ syntax, Clojure vectors can be created
with the ~vector~ function:

#+BEGIN_EXAMPLE
user=> (vector 1 2 3)
[1 2 3]
#+END_EXAMPLE

***** Adding elements

Elements are added to a vector with ~conj~ (short for conjoin). Elements
are always added to a vector at the end:

#+BEGIN_EXAMPLE
user=> (conj [1 2 3] 4 5 6)
[1 2 3 4 5 6]
#+END_EXAMPLE

***** Immutability

Clojure collections share important properties of simple values like
strings and numbers, such as immutability and equality comparison by
value.

For example, lets create a vector and modify it with ~conj~.

#+BEGIN_EXAMPLE
user=> (def v [1 2 3])
#'user/v
user=> (conj v 4 5 6)
[1 2 3 4 5 6]
#+END_EXAMPLE

Here ~conj~ returned a new vector but if we examine the original vector,
we see it's unchanged:

#+BEGIN_EXAMPLE
user=> v
[1 2 3]
#+END_EXAMPLE

Any function that "changes" a collection returns a new instance. Your
program will need to remember or pass along the changed instance to take
advantage of it.

**** Lists

Lists are sequential linked lists that add new elements at the head of
the list, instead of at the tail like vectors.

***** Constructing

Because lists are evaluated by invoking the first element as a function,
we must quote a list to prevent evaluation:

#+BEGIN_SRC clojure
(def cards '(10 :ace :jack 9))
#+END_SRC

Lists are not indexed so they must be walked using ~first~ and ~rest~.

#+BEGIN_EXAMPLE
user=> (first cards)
10
user=> (rest cards)
'(:ace :jack 9)
#+END_EXAMPLE

***** Adding elements

~conj~ can be used to add elements to a list just as with vectors.
However, ~conj~ always adds elements where it can be done in constant
time for the data structure. In the case of lists, elements are added at
the front:

#+BEGIN_EXAMPLE
user=> (conj cards :queen)
(:queen 10 :ace :jack 9)
#+END_EXAMPLE

***** Stack access

Lists can also be used as a stack with peek and pop:

#+BEGIN_EXAMPLE
user=> (def stack '(:a :b))
#'user/stack
user=> (peek stack)
:a
user=> (pop stack)
(:b)
#+END_EXAMPLE

*** Learn Clojure - Hashed Collections
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/learn/hashed_colls.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/learn/hashed_colls
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-09-02
:PREVPAGE_CUSTOM_ID: content/guides/learn/sequential_colls
:NEXTPAGE_CUSTOM_ID: content/guides/learn/flow
:CUSTOM_ID: content/guides/learn/hashed_colls
:END:

As described in the previous section, there are four key Clojure
collection types: vectors, lists, sets, and maps. Of those four
collection types, sets and maps are hashed collections, designed for
efficient lookup of elements.

**** Sets

Sets are like mathematical sets - unordered and with no duplicates. Sets
are ideal for efficiently checking whether a collection contains an
element, or to remove any arbitrary element.

#+BEGIN_SRC clojure
(def players #{"Alice", "Bob", "Kelly"})
#+END_SRC

***** Adding to a set

As with vectors and lists, ~conj~ is used to add elements.

#+BEGIN_EXAMPLE
user=> (conj players "Fred")
#{"Alice" "Fred" "Bob" "Kelly"}
#+END_EXAMPLE

***** Removing from a set

The ~disj~ ("disjoin") function is used to remove one or more elements
from a set.

#+BEGIN_EXAMPLE
user=> (disj players "Bob" "Sal")
#{"Alice" "Kelly"}
#+END_EXAMPLE

***** Checking containment

#+BEGIN_EXAMPLE
user=> (contains? players "Kelly")
true
#+END_EXAMPLE

***** Sorted sets

Sorted sets are sorted according to a comparator function which can
compare two elements. By default, Clojure's ~compare~ function is used,
which sorts in "natural" order for numbers, strings, etc.

#+BEGIN_EXAMPLE
user=> (conj (sorted-set) "Bravo" "Charlie" "Sigma" "Alpha")
#{"Alpha" "Bravo" "Charlie" "Sigma"}
#+END_EXAMPLE

A custom comparator can also be used with ~sorted-set-by~.

***** ~into~

~into~ is used for putting one collection into another.

#+BEGIN_EXAMPLE
user=> (def players #{"Alice" "Bob" "Kelly"})
user=> (def new-players ["Tim" "Sue" "Greg"])
user=> (into players new-players)
#{"Alice" "Greg" "Sue" "Bob" "Tim" "Kelly"}
#+END_EXAMPLE

~into~ returns a collection of the same type as its first argument.

**** Maps

Maps are commonly used for two purposes - to manage an association of
keys to values and to represent domain application data. The first use
case is often referred to as dictionaries or hash maps in other
languages.

***** Creating a literal map

Maps are represented as alternating keys and values surrounded by ~{~
and ~}~.

#+BEGIN_SRC clojure
(def scores {"Fred"  1400
             "Bob"   1240
             "Angela" 1024})
#+END_SRC

When Clojure prints a map at the REPL, it will put `,'s between each
key/value pair. These are purely used for readability - commas are
treated as whitespace in Clojure. Feel free to use them in cases where
they help you!

#+BEGIN_SRC clojure
;; same as the last one!
(def scores {"Fred" 1400, "Bob" 1240, "Angela" 1024})
#+END_SRC

***** Adding new key-value pairs

New values are added to maps with the ~assoc~ (short for "associate")
function:

#+BEGIN_EXAMPLE
user=> (assoc scores "Sally" 0)
{"Angela" 1024, "Bob" 1240, "Fred" 1400, "Sally" 0}
#+END_EXAMPLE

If the key used in ~assoc~ already exists, the value is replaced.

#+BEGIN_EXAMPLE
user=> (assoc scores "Bob" 0)
{"Angela" 1024, "Bob" 0, "Fred" 1400}
#+END_EXAMPLE

***** Removing key-value pairs

The complementary operation for removing key-value pairs is ~dissoc~
("dissociate"):

#+BEGIN_EXAMPLE
user=> (dissoc scores "Bob")
{"Angela" 1024, "Fred" 1400}
#+END_EXAMPLE

***** Looking up by key

There are several ways to look up a value in a map. The most obvious is
the function ~get~:

#+BEGIN_EXAMPLE
user=> (get scores "Angela")
1024
#+END_EXAMPLE

When the map in question is being treated as a constant lookup table,
its common to invoke the map itself, treating it as a function:

#+BEGIN_EXAMPLE
user=> (def directions {:north 0
                        :east 1
                        :south 2
                        :west 3})
#'user/directions

user=> (directions :north)
0
#+END_EXAMPLE

You should not directly invoke a map unless you can guarantee it will be
non-nil:

#+BEGIN_EXAMPLE
user=> (def bad-lookup-map nil)
#'user/bad-lookup-map

user=> (bad-lookup-map :foo)
Execution error (NullPointerException) at user/eval154 (REPL:1).
null
#+END_EXAMPLE

***** Looking up with a default

If you want to do a lookup and fall back to a default value when the key
is not found, specify the default as an extra parameter:

#+BEGIN_EXAMPLE
user=> (get scores "Sam" 0)
0

user=> (directions :northwest -1)
-1
#+END_EXAMPLE

Using a default is also helpful to distinguish between a missing key and
an existing key with a ~nil~ value.

***** Checking contains

There are two other functions that are helpful in checking whether a map
contains an entry.

#+BEGIN_EXAMPLE
user=> (contains? scores "Fred")
true

user=> (find scores "Fred")
["Fred" 1400]
#+END_EXAMPLE

The ~contains?~ function is a predicate for checking containment. The
~find~ function finds the key/value entry in a map, not just the value.

***** Keys or values

You can also get just the keys or just the values in a map:

#+BEGIN_EXAMPLE
user=> (keys scores)
("Fred" "Bob" "Angela")

user=> (vals scores)
(1400 1240 1024)
#+END_EXAMPLE

While maps are unordered, there is a guarantee that keys, vals, and
other functions that walk in "sequence" order will always walk a
particular map instance entries in the same order.

***** Building a map

The ~zipmap~ function can be used to "zip" together two sequences (the
keys and vals) into a map:

#+BEGIN_EXAMPLE
user=> (def players #{"Alice" "Bob" "Kelly"})
#'user/players

user=> (zipmap players (repeat 0))
{"Kelly" 0, "Bob" 0, "Alice" 0}
#+END_EXAMPLE

There are a variety of other ways to build up a map using Clojure's
sequence functions (which we have not yet discussed). Come back to these
later!

#+BEGIN_SRC clojure
;; with map and into
(into {} (map (fn [player] [player 0]) players))

;; with reduce
(reduce (fn [m player]
          (assoc m player 0))
        {} ; initial value
        players)
#+END_SRC

***** Combining maps

The ~merge~ function can be used to combine multiple maps into a single
map:

#+BEGIN_EXAMPLE
user=> (def new-scores {"Angela" 300 "Jeff" 900})
#'user/new-scores

user=> (merge scores new-scores)
{"Fred" 1400, "Bob" 1240, "Jeff" 900, "Angela" 300}
#+END_EXAMPLE

We merged two maps here but you can pass more as well.

If both maps contain the same key, the rightmost one wins. Alternately,
you can use ~merge-with~ to supply a function to invoke when there is a
conflict:

#+BEGIN_EXAMPLE
user=> (def new-scores {"Fred" 550 "Angela" 900 "Sam" 1000})
#'user/new-scores

user=> (merge-with + scores new-scores)
{"Sam" 1000, "Fred" 1950, "Bob" 1240, "Angela" 1924}
#+END_EXAMPLE

In the case of a conflict, the function is called on both values to get
the new value.

***** Sorted maps

Similar to sorted sets, sorted maps maintain the keys in sorted order
based on a comparator, using ~compare~ as the default comparator
function.

#+BEGIN_EXAMPLE
user=> (def sm (sorted-map
         "Bravo" 204
         "Alfa" 35
         "Sigma" 99
         "Charlie" 100))
{"Alfa" 35, "Bravo" 204, "Charlie" 100, "Sigma" 99}

user=> (keys sm)
("Alfa" "Bravo" "Charlie" "Sigma")

user=> (vals sm)
(35 204 100 99)
#+END_EXAMPLE

**** Representing application domain information

When we need to represent many domain information with the same set of
fields known in advance, you can use a map with keyword keys.

#+BEGIN_SRC clojure
(def person
  {:first-name "Kelly"
   :last-name "Keen"
   :age 32
   :occupation "Programmer"})
#+END_SRC

***** Field accessors

Since this is a map, the ways we've already discussed for looking up a
value by key also work:

#+BEGIN_EXAMPLE
user=> (get person :occupation)
"Programmer"

user=> (person :occupation)
"Programmer"
#+END_EXAMPLE

But really, the most common way to get field values for this use is by
invoking the keyword. Just like with maps and sets, keywords are also
functions. When a keyword is invoked, it looks itself up in the
associative data structure that it was passed.

#+BEGIN_EXAMPLE
user=> (:occupation person)
"Programmer"
#+END_EXAMPLE

Keyword invocation also takes an optional default value:

#+BEGIN_EXAMPLE
user=> (:favorite-color person "beige")
"beige"
#+END_EXAMPLE

***** Updating fields

Since this is a map, we can just use ~assoc~ to add or modify fields:

#+BEGIN_EXAMPLE
user=> (assoc person :occupation "Baker")
{:age 32, :last-name "Keen", :first-name "Kelly", :occupation "Baker"}
#+END_EXAMPLE

***** Removing a field

Use dissoc to remove fields:

#+BEGIN_EXAMPLE
user=> (dissoc person :age)
{:last-name "Keen", :first-name "Kelly", :occupation "Programmer"}
#+END_EXAMPLE

***** Nested entities

It is common to see entities nested within other entities:

#+BEGIN_SRC clojure
(def company
  {:name "WidgetCo"
   :address {:street "123 Main St"
             :city "Springfield"
             :state "IL"}})
#+END_SRC

You can use ~get-in~ to access fields at any level inside nested
entities:

#+BEGIN_EXAMPLE
user=> (get-in company [:address :city])
"Springfield"
#+END_EXAMPLE

You can also use ~assoc-in~ or ~update-in~ to modify nested entities:

#+BEGIN_EXAMPLE
user=> (assoc-in company [:address :street] "303 Broadway")
{:name "WidgetCo",
 :address
 {:state "IL",
  :city "Springfield",
  :street "303 Broadway"}}
#+END_EXAMPLE

***** Records

An alternative to using maps is to create a "record". Records are
designed specifically for this use case and generally have better
performance. In addition, they have a named "type" which can be used for
polymorphic behavior (more on that later).

Records are defined with the list of field names for record instances.
These will be treated as keyword keys in each record instance.

#+BEGIN_SRC clojure
;; Define a record structure
(defrecord Person [first-name last-name age occupation])

;; Positional constructor - generated
(def kelly (->Person "Kelly" "Keen" 32 "Programmer"))

;; Map constructor - generated
(def kelly (map->Person
             {:first-name "Kelly"
              :last-name "Keen"
              :age 32
              :occupation "Programmer"}))
#+END_SRC

Records are used almost exactly the same as maps, with the caveat that
they cannot be invoked as a function like maps.

#+BEGIN_EXAMPLE
user=> (:occupation kelly)
"Programmer"
#+END_EXAMPLE

*** Learn Clojure - Flow Control
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/learn/flow.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/learn/flow
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-09-02
:PREVPAGE_CUSTOM_ID: content/guides/learn/hashed_colls
:NEXTPAGE_CUSTOM_ID: content/guides/learn/namespaces
:CUSTOM_ID: content/guides/learn/flow
:END:
**** Statements vs. Expressions

In Java, expressions return values, whereas statements do not.

#+BEGIN_SRC java
// "if" is a statement because it doesn't return a value:
String s;
if (x > 10) {
    s = "greater";
} else {
    s = "less or equal";
}
obj.someMethod(s);

// Ternary operator is an expression; it returns a value:
obj.someMethod(x > 10 ? "greater" : "less or equal");
#+END_SRC

In Clojure, however, everything is an expression! /Everything/ returns a
value, and a block of multiple expressions returns the last value.
Expressions that exclusively perform side-effects return ~nil~.

**** Flow Control Expressions

Accordingly, flow control operators are expressions, too!

Flow control operators are composable, so we can use them anywhere. This
leads to less duplicate code, as well as fewer intermediate variables.

Flow control operators are also extensible via macros, which allow the
compiler to be extended by user code. We won't be discussing macros
today, but you can read more about them at [[#content/reference/macros][Macros]], [[https://aphyr.com/posts/305-clojure-from-the-ground-up-macros][Clojure from the
Ground Up]], or [[http://www.braveclojure.com/writing-macros/][Clojure for the Brave and True]], among many other
places.

***** ~if~

~if~ is the most important conditional expression - it consists of a
condition, a "then", and an "else". ~if~ will only evaluate the branch
selected by the conditional.

#+BEGIN_EXAMPLE
user=> (str "2 is " (if (even? 2) "even" "odd"))
2 is even

user=> (if (true? false) "impossible!") ;; else is optional
nil
#+END_EXAMPLE

***** Truth

In Clojure, all values are logically true or false. The only "false"
values are ~false~ and ~nil~ - all other values are logically true.

#+BEGIN_EXAMPLE
user=> (if true :truthy :falsey)
:truthy
user=> (if (Object.) :truthy :falsey) ; objects are true
:truthy
user=> (if [] :truthy :falsey) ; empty collections are true
:truthy
user=> (if 0 :truthy :falsey) ; zero is true
:truthy
user=> (if false :truthy :falsey)
:falsey
user=> (if nil :truthy :falsey)
:falsey
#+END_EXAMPLE

***** ~if~ and ~do~

The ~if~ only takes a single expression for the "then" and "else". Use
~do~ to create larger blocks that are a single expression.

Note that the only reason to do this is if your bodies have side
effects! (Why?)

#+BEGIN_SRC clojure
(if (even? 5)
  (do (println "even")
      true)
  (do (println "odd")
      false))
#+END_SRC

***** ~when~

~when~ is an ~if~ with only a ~then~ branch. It checks a condition and
then evaluates any number of statements as a body (so no ~do~ is
required). The value of the last expression is returned. If the
condition is false, nil is returned.

~when~ communicates to a reader that there is no "else" branch.

#+BEGIN_SRC clojure
(when (neg? x)
  (throw (RuntimeException. (str "x must be positive: " x))))
#+END_SRC

***** ~cond~

~cond~ is a series of tests and expressions. Each test is evaluated in
order and the expression is evaluated and returned for the first true
test.

#+BEGIN_SRC clojure
(let [x 5]
  (cond
    (< x 2) "x is less than 2"
    (< x 10) "x is less than 10"))
#+END_SRC

***** ~cond~ and ~else~

If no test is satisfied, nil is returned. A common idiom is to use a
final test of ~:else~. Keywords (like ~:else~) always evaluate to true
so this will always be selected as a default.

#+BEGIN_SRC clojure
(let [x 11]
  (cond
    (< x 2)  "x is less than 2"
    (< x 10) "x is less than 10"
    :else  "x is greater than or equal to 10"))
#+END_SRC

***** ~case~

~case~ compares an argument to a series of values to find a match. This
is done in constant (not linear) time! However, each value must be a
compile-time literal (numbers, strings, keywords, etc).

Unlike ~cond~, ~case~ will throw an exception if no value matches.

#+BEGIN_EXAMPLE
user=> (defn foo [x]
         (case x
           5 "x is 5"
           10 "x is 10"))
#'user/foo

user=> (foo 10)
x is 10

user=> (foo 11)
IllegalArgumentException No matching clause: 11
#+END_EXAMPLE

***** ~case~ with ~else~-expression

~case~ can have a final trailing expression that will be evaluated if no
test matches.

#+BEGIN_EXAMPLE
user=> (defn foo [x]
         (case x
           5 "x is 5"
           10 "x is 10"
           "x isn't 5 or 10"))
#'user/foo

user=> (foo 11)
x isn't 5 or 10
#+END_EXAMPLE

**** Iteration for Side Effects
***** ~dotimes~

- Evaluate expression ~n~ times
- Returns ~nil~

#+BEGIN_SRC clojure
user=> (dotimes [i 3]
         (println i))
0
1
2
nil
#+END_SRC

***** ~doseq~

- Iterates over a sequence
- If a lazy sequence, forces evaluation
- Returns ~nil~

#+BEGIN_EXAMPLE
user=> (doseq [n (range 3)]
         (println n))
0
1
2
nil
#+END_EXAMPLE

***** ~doseq~ with multiple bindings

- Similar to nested ~foreach~ loops
- Processes all permutations of sequence content
- Returns ~nil~

#+BEGIN_EXAMPLE
user=> (doseq [letter [:a :b]
               number (range 3)] ; list of 0, 1, 2
         (prn [letter number]))
[:a 0]
[:a 1]
[:a 2]
[:b 0]
[:b 1]
[:b 2]
nil
#+END_EXAMPLE

**** Clojure's ~for~

- List comprehension, *not* a for-loop
- Generator function for sequence permutation
- Bindings behave like ~doseq~

#+BEGIN_EXAMPLE
user=> (for [letter [:a :b]
             number (range 3)] ; list of 0, 1, 2
         [letter number])
([:a 0] [:a 1] [:a 2] [:b 0] [:b 1] [:b 2])
#+END_EXAMPLE

**** Recursion
***** Recursion and Iteration

- Clojure provides recur and the sequence abstraction
- ~recur~ is "classic" recursion
  - Consumers don't control it, considered a lower-level facility
- Sequences represent iteration as values
  - Consumers can partially iterate
- Reducers represent iteration as function composition
  - Added in Clojure 1.5, not covered here

***** ~loop~ and ~recur~

- Functional looping construct
  - ~loop~ defines bindings
  - ~recur~ re-executes ~loop~ with new bindings
- Prefer higher-order library functions instead

#+BEGIN_SRC clojure
(loop [i 0]
  (if (< i 10)
    (recur (inc i))
    i))
#+END_SRC

***** ~defn~ and ~recur~

- Function arguments are implicit ~loop~ bindings

#+BEGIN_SRC clojure
(defn increase [i]
  (if (< i 10)
    (recur (inc i))
    i))
#+END_SRC

***** ~recur~ for recursion

- ~recur~ must be in "tail position"
  - The last expression in a branch
- ~recur~ must provide values for all bound symbols by position
  - Loop bindings
  - defn/fn arguments
- Recursion via ~recur~ does not consume stack

**** Exceptions
***** Exception handling

- ~try=/=catch=/=finally~ as in Java

#+BEGIN_SRC clojure
(try
  (/ 2 1)
  (catch ArithmeticException e
    "divide by zero")
  (finally
    (println "cleanup")))
#+END_SRC

***** Throwing exceptions

#+BEGIN_SRC clojure
(try
  (throw (Exception. "something went wrong"))
  (catch Exception e (.getMessage e)))
#+END_SRC

***** Exceptions with Clojure data

- ~ex-info~ takes a message and a map
- ~ex-data~ gets the map back out
  - Or ~nil~ if not created with ~ex-info~

#+BEGIN_SRC clojure
(try
  (throw (ex-info "There was a problem" {:detail 42}))
  (catch Exception e
    (prn (:detail (ex-data e)))))
#+END_SRC

***** ~with-open~

#+BEGIN_SRC clojure
(let [f (clojure.java.io/writer "/tmp/new")]
  (try
    (.write f "some text")
    (finally
      (.close f))))

;; Can be written:
(with-open [f (clojure.java.io/writer "/tmp/new")]
  (.write f "some text"))
#+END_SRC

*** Learn Clojure - Namespaces
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/learn/namespaces.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/learn/namespaces
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-01-25
:PREVPAGE_CUSTOM_ID: content/guides/learn/flow
:CUSTOM_ID: content/guides/learn/namespaces
:END:
**** Namespaces and names

Namespaces provide a means to organize our code and the names we use in
our code. Specifically, they let us give new unambiguous names to
functions or other values. These full names are naturally long because
they include context. Thus namespaces also provide a means to
unambiguously reference the names of other functions and values but
using names that are shorter and easier to type.

A namespace is both a name context and a container for vars. Namespace
names are symbols where periods are used to separate namespace parts,
such as ~clojure.string~. By convention, namespace names are typically
lower-case and use ~-~ to separate words, although this is not required.

***** Vars

Vars are associations between a name (a symbol) and a value. Vars in a
namespace have a fully-qualified name that is the combination of the
namespace name and the var name. For example, ~clojure.string/join~ is a
fully-qualified var name where ~clojure.string~ refers to the namespace
and ~join~ refers to the var inside the namespace. All vars are globally
accessible via their fully-qualified name. By convention vars have lower
case names with ~-~ separating words, although this is also not
required. Var names may contain most non-whitespace characters.

Vars are created using ~def~ and other special forms or macros that
start with ~def~, like ~defn~. Vars are created in the "current"
namespace. The Clojure runtime tracks the current namespace in the var
~clojure.core/*ns*~. The current namespace can be changed using the
~in-ns~ function.

***** Loading

In addition to providing a naming context, namespace names also provide
a convention for where a namespace's code should be found for loading. A
path is created based on the namespace name:

- Periods become directory separators
- Hyphens become underscores
- The file extension ~.clj~ is added

Thus the namespace name ~com.some-example.my-app~ becomes the load path
~com/some_example/my_app.clj~. Load paths are searched using the JVM
classpath. The classpath is a series of directory locations or JAR files
(JARs are essentially just zip files).

When a resource is needed, the JVM searches each classpath location in
order for a file at the relative location of the load path. So if the
classpath was ~src:test~, the load path would be checked at
~src/com/some_example/my_app.clj~ then
~test/com/some_example/my_app.clj~.

There are several ways to load code in Clojure, but most commonly
loading is accomplished via ~require~.

Due to this loading convention, most Clojure is structured with a 1-to-1
mapping of namespaces to files, stored in hierarchical fashion that maps
to the namespace structure.

**** Declaring namespaces

Most Clojure files represent a single namespace and declare the
dependencies for that namespace at the top of the file using the ~ns~
macro, which often looks like this:

#+BEGIN_SRC clojure
(ns com.some-example.my-app
  "My app example"
  (:require
    [clojure.set :as set]
    [clojure.string :as str]))
#+END_SRC

The ~ns~ macro specifies the namespace name (this should match the file
path location using the conventions above), an optional docstring, and
then one or more clauses that declare things about the namespace.

***** Refer

By default, we can refer to or invoke vars in the current namespace
without specifying the namespace (the current namespace is the
"default").

Additionally, you may have noticed that we can usually refer to
~clojure.core~ library functions without fully qualifying them either.
The reason for that is that all of the ~clojure.core~ library vars have
been ~referred~ into the current namespace. ~refer~ makes an entry in
the current namespace's symbol table that refers to the var in the other
namespace.

The ~clojure.core~ referral is done by the ~ns~ macro. (There are ways
to suppress this in part if you'd like to re-use names in core without
warnings.)

***** require

The ~:require~ class corresponds to the ~require~ function which
specifies one or more namespaces to load that this namespace depends on.
For each namespace, ~require~ can do several things:

- Load (or reload) the namespace
- Optionally assign an /alias/ that can be used to refer to vars from
  the loaded namespace only in the scope of this namespace
- Optionally /refer/ vars from the loaded namespace for use by
  unqualified name in this namespace

The last two parts are all about making names easier to use. While vars
can always be referred to by their fully-qualified name, we rarely want
to type fully-qualified names in our code. Aliases let us use shorter
versions of longer fully-qualified aliases. Refer allows us to use names
without a namespace qualifier at all.

In require, namespaces most commonly take one of three forms:

- ~clojure.set~ - just loads ~clojure.set~ namespace (if not already
  loaded)
- ~[clojure.set :as set]~ - load and create an alias ~set~ for the
  namespace ~clojure.set~
  - This allows you to refer to vars in ~set~ with for example
    ~set/union~ instead of ~clojure.set/union~
- ~[clojure.set :refer [union intersection]]~ - load and refer specific
  vars into this namespace
  - This allows you to use just ~union~ instead of ~clojure.set/union~

***** Java classes and imports

In addition to vars, Clojure also provides support for Java interop and
access to Java classes, which live in packages. Java classes can always
be referred to using their fully-qualified class name, such as
~java.util.Date~.

The ~ns~ macro also imports the classes in the java.lang package so that
they can be used as just the class name, rather than the fully-qualified
class name. For example, just ~String~ rather than ~java.lang.String~.

Similar to ~:refer~, the ~ns~ macro has an ~:import~ clause (that is
supported by the ~import~ macro) that lets you import other classes so
they can be used with unqualified names:

#+BEGIN_SRC clojure
(ns com.some-example.my-app2
  (:import
    [java.util Date UUID]
    [java.io File]))
#+END_SRC

This example imports the ~Date~ and ~UUID~ class from the ~java.util~
package and the ~File~ class from the ~java.io~ package.

*** ----
*** Learn Clojure - Answers
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/learn/answers.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/learn/answers
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-08-20
:CUSTOM_ID: content/guides/learn/answers
:END:

This page contains solutions to the "Test your knowledge" sections of
the [[#content/guides/learn/syntax][Learn Clojure]] guide.

**** [[#content/guides/learn/syntax#test-your-knowledge][Syntax]]
:PROPERTIES:
:CUSTOM_ID: content/guides/learn/answers#syntax
:END:

1. Using the REPL, compute the sum of 7654 and 1234.

   #+BEGIN_SRC clojure
    user=> (+ 7654 1234)
    8888
   #+END_SRC

2. Rewrite the following algebraic expression as a Clojure expression:
   ~( 7 + 3 * 4 + 5 ) / 10~.

   #+BEGIN_SRC clojure
    (/ (+ 7 (* 3 4) 5) 10)
   #+END_SRC

3. Using REPL documentation functions, find the documentation for the
   rem and mod functions. Compare the results of the provided
   expressions based on the documentation.

   #+BEGIN_SRC clojure
    user=> (doc rem)
    clojure.core/rem
    ([num div])
      remainder of dividing numerator by denominator.
    nil

    user=> (doc mod)
    clojure.core/mod
    ([num div])
      Modulus of num and div. Truncates toward negative infinity.
    nil
   #+END_SRC

4. Using find-doc, find the function that prints the stack trace of the
   most recent REPL exception.

   ~pst~

**** [[#content/guides/learn/functions#test-your-knowledge][Functions]]
:PROPERTIES:
:CUSTOM_ID: content/guides/learn/answers#functions
:END:

1. Define a function ~greet~ that takes no arguments and prints
   "Hello".

   #+BEGIN_SRC clojure
   (defn greet []
     (println "Hello"))
   #+END_SRC

2. Redefine greet using ~def~ with ~fn~ and ~#()~.

   #+BEGIN_SRC clojure
   ;; using fn
   (def greet
     (fn [] (println "Hello")))

   ;; using #()
   (def greet
     #(println "Hello"))
   #+END_SRC

3. Define a function ~greeting~ ...

   #+BEGIN_SRC clojure
   (defn greeting
     ([] (greeting "Hello" "World"))
     ([x] (greeting "Hello" x))
     ([x y] (str x ", " y "!")))
   #+END_SRC

4. Define a function ~do-nothing~ ...

   #+BEGIN_SRC clojure
   (defn do-nothing [x] x)
   #+END_SRC

5. Define a function ~always-thing~ ...

   #+BEGIN_SRC clojure
   (defn always-thing [& xs] 100)
   #+END_SRC

6. Define a function ~make-thingy~ ...

   #+BEGIN_SRC clojure
   (defn make-thingy [x]
     (fn [& args] x))
   #+END_SRC

7. Define a function ~triplicate~ ...

   #+BEGIN_SRC clojure
   (defn triplicate [f]
     (f) (f) (f))
   #+END_SRC

8. Define a function ~opposite~ ...

   #+BEGIN_SRC clojure
   (defn opposite [f]
     (fn [& args] (not (apply f args))))
   #+END_SRC

9. Define a function ~triplicate2~ ...

   #+BEGIN_SRC clojure
   (defn triplicate2 [f & args]
     (triplicate (fn [] (apply f args))))
   #+END_SRC

10. Using the ~java.lang.Math~ class ...

    #+BEGIN_SRC clojure
    user=> (Math/cos Math/PI)
    -1.0
    user=> (+ (Math/pow (Math/sin 0.2) 2)
              (Math/pow (Math/cos 0.2) 2))
    1.0
    #+END_SRC

11. Define a function that takes an HTTP URL as a string...

    #+BEGIN_SRC clojure
    (defn http-get [url]
      (slurp
        (.openStream
          (java.net.URL. url))))
    #+END_SRC

    #+BEGIN_SRC clojure
    (defn http-get [url]
      (slurp url))
    #+END_SRC

12. Define a function ~one-less-arg~:

    #+BEGIN_SRC clojure
    (defn one-less-arg [f x]
      (fn [& args] (apply f x args)))
    #+END_SRC

13. Define a function ~two-fns~:

    #+BEGIN_SRC clojure
    (defn two-fns [f g]
      (fn [x] (f (g x))))
    #+END_SRC

** Reader Conditionals Guide
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/reader_conditionals.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/reader_conditionals
:CLOJURE_SITE_AUTHOR: Daniel Compton
:CLOJURE_SITE_DATE: 2016-01-14
:CUSTOM_ID: content/guides/reader_conditionals
:END:
*** Introduction

Reader conditionals were added in Clojure 1.7. They are designed to
allow different dialects of Clojure to share common code that is mostly
platform independent, but contains some platform dependent code. If you
are writing code across multiple platforms that is mostly independent
you should separate ~.clj~ and ~.cljs~ files instead.

Reader conditionals are integrated into the Clojure reader, and don't
require any extra tooling. To use reader conditionals, all you need is
for your file to have a ~.cljc~ extension. Reader conditionals are
expressions, and can be manipulated like ordinary Clojure expressions.
For more technical details, see the reference page on
[[#content/reference/reader][the reader]].

There are two types of reader conditionals, standard and splicing. The
standard reader conditional behaves similarly to a traditional ~cond~.
The syntax for usage is ~#?~ and looks like:

#+BEGIN_SRC clojure
#?(:clj  (Clojure expression)
   :cljs (ClojureScript expression)
   :cljr (Clojure CLR expression)
   :default (fallthrough expression))
#+END_SRC

The platform tags ~:clj~, etc are a fixed set of tags hard-coded into
each platform. The ~:default~ tag is a well-known tag to catch and
provide an expression if no platform tag matches. If no tags match and
~:default~ is not provided, the reader conditional will read nothing
(not nil, but as if nothing was read from the stream at all).

The syntax for a splicing reader conditional is ~#?@~. It is used to
splice lists into the containing form. So the Clojure reader would read
this:

#+BEGIN_SRC clojure
(defn build-list []
  (list #?@(:clj  [5 6 7 8]
            :cljs [1 2 3 4])))
#+END_SRC

as this:

#+BEGIN_SRC clojure
(defn build-list []
  (list 5 6 7 8))
#+END_SRC

One important thing to note is that in Clojure a splicing conditional
reader cannot be used to splice in multiple top level forms. In concrete
terms, this means you can't do this:

#+BEGIN_SRC clojure
;; Don't do this!, will throw an error
#?@(:clj
    [(defn clj-fn1 [] :abc)
     (defn clj-fn2 [] :cde)])
;; CompilerException java.lang.RuntimeException: Reader conditional splicing not allowed at the top level.
#+END_SRC

Instead you'd need to do wrap each function individually:

#+BEGIN_SRC clojure
#?(:clj (defn clj-fn1 [] :abc))
#?(:clj (defn clj-fn2 [] :cde))
#+END_SRC

or use a ~do~ to wrap all of the top level functions:

#+BEGIN_SRC clojure
#?(:clj
    (do (defn clj-fn1 [] :abc)
        (defn clj-fn2 [] :cde)))
#+END_SRC

Let's go through some examples of places you might want to use these new
reader conditionals.

*** Host interop

Host interop is one of the biggest pain points solved by reader
conditionals. You may have a Clojure file that is almost pure Clojure,
but needs to call out to the host environment for one function.  [[https://github.com/lymingtonprecision/route-ccrs/blob/c579aea05504736f2cfbd31c3c755f7e25fdad77/src/route_ccrs/manufacturing_methods.cljc#L8-L10][This]]
is a classic example:

#+BEGIN_SRC clojure
(defn str->int [s]
  #?(:clj  (java.lang.Integer/parseInt s)
     :cljs (js/parseInt s)))
#+END_SRC

*** Namespaces

Namespaces are the other big pain point for sharing code between
Clojure and ClojureScript. ClojureScript has different syntax for
[[https://clojurescript.org/about/differences#_macros][requiring macros]] than Clojure. To use macros that work in both Clojure
and ClojureScript in a ~.cljc~ file, you'll need reader conditionals in
the namespace declaration.

Here is an example from a [[https://github.com/lymingtonprecision/route-ccrs/blob/c579aea05504736f2cfbd31c3c755f7e25fdad77/test/route_ccrs/schema/ids/part_no_test.cljc][test]] in [[https://github.com/lymingtonprecision/route-ccrs][route-ccrs]]

#+BEGIN_SRC clojure
(ns route-ccrs.schema.ids.part-no-test
  (:require #?(:clj  [clojure.test :refer :all]
               :cljs [cljs.test :refer-macros [is]])
            #?(:cljs [cljs.test.check :refer [quick-check]])
            #?(:clj  [clojure.test.check.properties :as prop]
               :cljs [cljs.test.check.properties :as prop
                       :include-macros true])
            [schema.core :as schema :refer [check]]))
#+END_SRC

Here is another example, we want to be able to use the ~rethinkdb.query~
namespace in Clojure and ClojureScript. However we can't load the
required ~rethinkdb.net~ in ClojureScript as it uses Java sockets to
communicate with the database. Instead we use a reader conditional so
the namespace is only required when read by Clojure programs.

#+BEGIN_SRC clojure
(ns rethinkdb.query
  (:require [clojure.walk :refer [postwalk postwalk-replace]]
            #?(:clj [rethinkdb.net :as net])))

;; snip...

#?(:clj (defn run [query conn]
      (let [token (get-token conn)]
        (net/send-start-query conn token (replace-vars query)))))
#+END_SRC

*** Exception handling

Exception handling is another area that benefits from reader
conditionals. ClojureScript supports ~(catch :default)~ to catch
everything, however you will often still want to handle host specific
exceptions. Here's an [[https://github.com/runexec/lemon-disc/blob/c24c6638f1d476a0f5470387e52a2b702117c4a9/src/lemon_disc/core.cljc#L65-L72][example]] from [[https://github.com/runexec/lemon-disc][lemon-disc]].

#+BEGIN_SRC clojure
(defn message-container-test [f]
  (fn [mc]
      (passed?
        (let [failed* (failed mc)]
          (try
            (let [x (:data mc)]
              (if (f x) mc failed*))
            (catch #?(:clj Exception :cljs js/Object) _ failed*))))))
#+END_SRC

*** Splicing

The splicing reader conditional is not as widely used as the standard
one. For an example on its usage, let's look at the [[https://github.com/clojure/clojure-clr/blob/544e9354e121e10a656702222d47c8398468fb02/Clojure/Clojure.Tests/clojure/test_clojure/reader.cljc#L672-L677][tests]] for reader
conditionals in the ClojureCLR reader. What might not be obvious at
first glance is that the vectors inside the splicing reader
conditional are being wrapped by a surrounding vector.

#+BEGIN_SRC clojure
(deftest reader-conditionals
     ;; snip
     (testing "splicing"
              (is (= [] [#?@(:clj [])]))
              (is (= [:a] [#?@(:clj [:a])]))
              (is (= [:a :b] [#?@(:clj [:a :b])]))
              (is (= [:a :b :c] [#?@(:clj [:a :b :c])]))
              (is (= [:a :b :c] [#?@(:clj [:a :b :c])]))))
#+END_SRC

*** File organisation

There isn't a clear community consensus yet around where to put ~.cljc~
files. Two options are to have a single ~src~ directory with ~.clj~,
~.cljs~, and ~.cljc~ files, or to have separate ~src/clj~, ~src/cljc~,
and ~src/cljs~ directories.

*** cljx

Before reader conditionals were introduced, the same goal of sharing
code between platforms was solved by a Leiningen plugin called
[[https://github.com/lynaghk/cljx][cljx]]. cljx processes files with the ~.cljx~ extension and outputs
multiple platform specific files to a generated sources
directory. These were then read as normal Clojure or ClojureScript
files by the Clojure [[#content/reference/reader][reader]]. This worked well, but required another
piece of tooling to run. cljx was deprecated on June 13 2015 in favour
of reader conditionals.

Sente previously used cljx for sharing code between Clojure and
ClojureScript. I've rewritten the [[https://github.com/ptaoussanis/sente/blob/v1.4.1/src/taoensso/sente.cljx][main]] namespace to use reader
conditionals. Notice that we've used the splicing reader conditional
to splice the vector into the parent ~:require~. Notice also that some
of the requires are duplicated between ~:clj~ and ~:cljs~.

#+BEGIN_SRC clojure
(ns taoensso.sente
  (:require
    #?@(:clj  [[clojure.string :as str]
               [clojure.core.async :as async]
               [taoensso.encore :as enc]
               [taoensso.timbre :as timbre]
               [taoensso.sente.interfaces :as interfaces]]
        :cljs [[clojure.string :as str]
               [cljs.core.async :as async]
               [taoensso.encore :as enc]
               [taoensso.sente.interfaces :as interfaces]]))
  #?(:cljs (:require-macros
             [cljs.core.async.macros :as asyncm :refer (go go-loop)]
             [taoensso.encore :as enc :refer (have? have have-in)])))
#+END_SRC

#+BEGIN_SRC clojure
(ns taoensso.sente
  #+clj
  (:require
   [clojure.string     :as str]
   [clojure.core.async :as async)]
   [taoensso.encore    :as enc]
   [taoensso.timbre    :as timbre]
   [taoensso.sente.interfaces :as interfaces])

  #+cljs
  (:require
   [clojure.string  :as str]
   [cljs.core.async :as async]
   [taoensso.encore :as enc]
   [taoensso.sente.interfaces :as interfaces])

  #+cljs
  (:require-macros
   [cljs.core.async.macros :as asyncm :refer (go go-loop)]
   [taoensso.encore        :as enc    :refer (have? have have-in)]))
#+END_SRC

** Reading Clojure Characters
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/weird_characters.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/weird_characters
:CLOJURE_SITE_AUTHOR: James Hughes
:CLOJURE_SITE_DATE: 2017-05-27
:CUSTOM_ID: content/guides/weird_characters
:END:

This page explains the Clojure syntax for characters that are
difficult to "google". Sections are not in any particular order, but
related items are grouped for ease. Please refer to [[#content/reference/reader][the reader
reference page]] as the authoritative reference on the Clojure
reader. This guide is based on [[http://twitter.com/kouphax][James Hughes]] original [[https://yobriefca.se/blog/2014/05/19/the-weird-and-wonderful-characters-of-clojure/][blog post]] and has
been updated and expanded here with the permission of the author.

*** ~( …​ )~ - List

Lists are sequential heterogeneous collections implemented as a linked
list.

- [[#content/reference/data_structures#lists][Clojure Documentation: Lists]]

A list of three values:

#+BEGIN_SRC clojure
(1 "two" 3.0)
#+END_SRC

*** ~[ …​ ]~ - Vector

Vectors are sequential, indexed, heterogeneous collections. Indexing is
0-based.

An example of retrieving the value at index 1 in a vector of three
values:

#+BEGIN_SRC clojure
user=> (get ["a" 13.7 :foo] 1)
13.7
#+END_SRC

- [[#content/reference/data_structures#vectors][Clojure Documentation: Vectors]]

*** ~{ …​ }~ - Map

Maps are heterogeneous collections specified with alternating keys and
values:

#+BEGIN_SRC clojure
user=> (keys {:a 1 :b 2})
(:a :b)
#+END_SRC

- [[#content/reference/data_structures#maps][Clojure Documentation: Maps]]

*** ~#~ - Dispatch character
:PROPERTIES:
:CUSTOM_ID: content/guides/weird_characters#dispatch
:END:

You'll see this character beside another e.g. ~#(~ or ~#"~.

~#~ is a special character that tells the Clojure reader (the component
that takes Clojure source and "reads" it as Clojure data) how to
interpret the next character using a /read table/. Although some Lisps
allow the read table to be extended by users, Clojure [[#content/guides/faq#reader-macros][does not]].

The ~#~ is also used at the /end/ of a symbol when creating [[#content/guides/weird_characters#gensym][generated
symbols]] inside a syntax quote.

*** ~#{ …​ }~ - Set

See [[#content/guides/weird_characters#dispatch][#]] for additional details.

~#{…​}~ defines a set (a collection of unique values), specifically a
~hash-set~. The following are equivalent:

#+BEGIN_SRC clojure
user=> #{1 2 3 4}
#{1 2 3 4}
user=> (hash-set 1 2 3 4)
#{1 2 3 4}
#+END_SRC

Sets cannot contain duplicates and thus the ~set~ reader will throw an
exception in this case as it is an invalid literal. When items are added
to a set, they are simply dropped if the value is already present.

#+BEGIN_SRC clojure
user=> #{1 2 3 4 1}
Syntax error reading source at (REPL:83:13).
Duplicate key: 1
#+END_SRC

- [[#content/reference/data_structures#sets][Clojure Documentation: Sets]]

*** ~#_~ - Discard

See [[#content/guides/weird_characters#dispatch][#]] for additional details.

~#_~ tells the reader to ignore the next form completely.

#+BEGIN_SRC clojure
user=> [1 2 3 #_ 4 5]
[1 2 3 5]
#+END_SRC

Note that the space following ~#_~ is optional, so

#+BEGIN_SRC clojure
user=> [1 2 3 #_4 5]
[1 2 3 5]
#+END_SRC

also works. Also note that the discard character works in edn.

A neat trick is that multiple ~#_~ can be stacked to omit multiple forms

#+BEGIN_SRC clojure
user=> {:a 1, #_#_ :b 2, :c 3}
{:a 1, :c 3}
#+END_SRC

The docs suggest that "The form following ~#_~ is completely skipped by
the reader (This is a more complete removal than the ~comment~ macro
which yields ~nil~).". This can prove useful for debugging situations or
for multiline comments.

- [[#content/reference/reader][Clojure Documentation - Reader]]
- [[https://github.com/edn-format/edn#tagged-elements][edn Tagged Elements]]

*** ~#"…​"~ - Regular Expression

See [[#content/guides/weird_characters#dispatch][#]] for additional
details.

~#"~ indicates the start of a regular expression

#+BEGIN_SRC clojure
user=> (re-matches #"^test$" "test")
"test"
#+END_SRC

This form is compiled at /read time/ into a host-specific regex
machinery, but it is not available in edn. Note that when using regexes
in Clojure, Java string escaping is not required

- [[#content/reference/other_functions#regex-support][Clojure Documentation: Regex Support]]
- [[http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html][Java Regex]]

*** ~#(…​)~ - Anonymous function

See [[#content/guides/weird_characters#dispatch][#]] for additional details.

~#(~ begins the short hand syntax for an inline function definition. The
following two snippets of code are similar:

#+BEGIN_SRC clojure
; anonymous function taking a single argument and printing it
(fn [line] (println line))

; anonymous function taking a single argument and printing it - shorthand
#(println %)
#+END_SRC

The reader expands an anonymous function into a function definition
whose arity (the number of arguments it takes) is defined by how the ~%~
placeholders are declared. See the ~%~ character for discussion around
arity.

#+BEGIN_SRC clojure
user=> (macroexpand `#(println %))
(fn* [arg] (clojure.core/println arg)) ; argument names shortened for clarity
#+END_SRC

*** ~#'~ - Var quote

~#'~ is the var quote which expands into a call to the ~var~ function:

#+BEGIN_SRC clojure
user=> (read-string "#'foo")
(var foo)
user=> (def nine 9)
#'user/nine
user=> nine
9
user=> (var nine)
#'user/nine
user=> #'nine
#'user/nine
#+END_SRC

When used it will attempt to return the referenced var. This is useful
when you want to talk about the reference/declaration instead of the
value it represents. See the use of ~meta~ in the metadata
([[#content/guides/weird_characters#metadata][^]]) discussion.

Note that var quote is not available in edn.

- [[#content/reference/special_forms#var][Clojure Official Documentation: Special Forms]]

*** ~##~ - Symbolic values

Clojure can read and print the symbolic values ~##Inf~, ~##-Inf~, and
~##NaN~. These are also available in edn.

#+BEGIN_SRC clojure
user=> (/ 1.0 0.0)
##Inf
user=> (/ -1.0 0.0)
##-Inf
user=> (Math/sqrt -1.0)
##NaN
#+END_SRC

*** ~#inst~, ~#uuid~, and ~#js~ etc. - tagged literals

Tagged literals are defined in edn and supported by the Clojure and
ClojureScript readers natively. The ~#inst~ and ~#uuid~ tags are defined
by edn, whereas the #js tag is defined by ClojureScript.

We can use Clojure's ~read-string~ to read a tagged literal (or use it
directly):

#+BEGIN_SRC clojure
user=> (type #inst "2014-05-19T19:12:37.925-00:00")
java.util.Date ;; this is host dependent
user=> (read-string "#inst \"2014-05-19T19:12:37.925-00:00\"")
#inst "2014-05-19T19:12:37.925-00:00"
#+END_SRC

A tagged literal tells the reader how to parse the literal value. Other
common uses include ~#uuid~ for expressing UUIDs and in the
ClojureScript world an extremely common use of tagged literals is ~#js~
which can be used to convert ClojureScript data structures into
JavaScript structures directly. Note that ~#js~ doesn't convert
recursively, so if you have a nested data-structure, use [[https://cljs.github.io/api/cljs.core/js-GTclj][js->clj]].

Note that while ~#inst~ and ~#uuid~ are available in edn, ~#js~ is not.

- [[https://github.com/edn-format/edn#tagged-elements][edn Tagged Elements]]

*** ~%~, ~%n~, ~%&~ - Anonymous function arguments

~%~ is an argument in an anonymous function ~#(...)~ as in ~#(* % %)~.

When an anonymous function is expanded, it becomes an ~fn~ form and ~%~
args are replaced with gensym'ed names (here we use arg1, etc for
readability):

#+BEGIN_SRC clojure
user=> (macroexpand `#(println %))
(fn* [arg1] (clojure.core/println arg1))
#+END_SRC

Numbers can be placed directly after the ~%~ to indicate the argument
positions (1-based). Anonymous function arity is determined based on the
highest number ~%~ argument.

#+BEGIN_SRC clojure
user=> (#(println %1 %2) "Hello " "Clojure")
Hello Clojure ; takes 2 args
user=> (macroexpand `#(println %1 %2))
(fn* [arg1 arg2] (clojure.core/println arg1 arg2)) ; takes 2 args

user=> (#(println %4) "Hello " "Clojure " ", Thank " "You!!")
You!! ; takes 4 args, doesn't use first 3 args
user=> (macroexpand `#(println %4))
(fn* [arg1 arg2 arg3 arg4] (clojure.core/println arg4)) ; takes 4 args doesn't use 3
#+END_SRC

You don't have to use the arguments, but you do need to declare them in
the order you'd expect an external caller to pass them in.

~%~ and ~%1~ can be used interchangeably:

#+BEGIN_SRC clojure
user=> (macroexpand `#(println % %1)) ; use both % and %1
(fn* [arg1] (clojure.core/println arg1 arg1)) ; still only takes 1 argument
#+END_SRC

There is also ~%&~ which is the symbol used in a variadic anonymous
function to represent the "rest" of the arguments (after the highest
named anonymous argument).

#+BEGIN_SRC clojure
user=> (#(println %&) "Hello " "Clojure " ", Thank " "You!!")
(Hello Clojure , Thank You!! ) ; takes n args
user=> (macroexpand '#(println %&))
(fn* [& rest__11#] (println rest__11#))
#+END_SRC

Anonymous functions and ~%~ are not part of edn.

*** ~@~ - Deref

~@~ expands into a call to the ~deref~ function, so these two forms are
the same:

#+BEGIN_SRC clojure
user=> (def x (atom 1))
#'user/x
user=> @x
1
user=> (deref x)
1
user=>
#+END_SRC

~@~ is used to get the current value of a reference. The above example
uses ~@~ to get the current value of an [[#content/reference/atoms][atom]], but ~@~ can be applied to
other things such as ~future~ s, ~delay~ s, ~promises~ s etc. to force
computation and potentially block.

Note that ~@~ is not available in edn.

*** ~^~ (and ~#^~) - Metadata
:PROPERTIES:
:CUSTOM_ID: content/guides/weird_characters#metadata
:END:

~^~ is the metadata marker. Metadata is a map of values (with shorthand
option) that can be attached to various forms in Clojure. This provides
extra information for these forms and can be used for documentation,
compilation warnings, typehints, and other features.

#+BEGIN_SRC clojure
user=> (def ^{:debug true} five 5) ; meta map with single boolean value
#'user/five
#+END_SRC

We can access the metadata by the ~meta~ function which should be
executed against the declaration itself (rather than the returned
value):

#+BEGIN_SRC clojure
user=> (def ^{:debug true} five 5)
#'user/five
user=> (meta #'five)
{:ns #<Namespace user>, :name five, :column 1, :debug true, :line 1, :file "NO_SOURCE_PATH"}
#+END_SRC

As we have a single value here, we can use a shorthand notation for
declaring the metadata ~^:name~ which is useful for flags, as the value
will be set to true.

#+BEGIN_SRC clojure
user=> (def ^:debug five 5)
#'user/five
user=> (meta #'five)
{:ns #<Namespace user>, :name five, :column 1, :debug true, :line 1, :file "NO_SOURCE_PATH"}
#+END_SRC

Another use of ~^~ is for type hints. These are used to tell the
compiler what type the value will be and allow it to perform type
specific optimizations thus potentially making resultant code faster:

#+BEGIN_SRC clojure
user=> (def ^Integer five 5)
#'user/five
user=> (meta #'five)
{:ns #<Namespace user>, :name five, :column 1, :line 1, :file "NO_SOURCE_PATH", :tag java.lang.Integer}
#+END_SRC

We can see in that example the ~:tag~ property is set.

You can also stack the shorthand notations:

#+BEGIN_SRC clojure
user=> (def ^Integer ^:debug ^:private five 5)
#'user/five
user=> (meta #'five)
{:ns #<Namespace user>, :name five, :column 1, :private true, :debug true, :line 1, :file "NO_SOURCE_PATH", :tag java.lang.Integer}
#+END_SRC

Originally, meta was declared with ~#^~, which is now deprecated (but
still works). Later, this was simplified to just ~^~ and that is what
you will see in most Clojure, but occasionally you will encounter the
~#^~ syntax in older code.

Note that metadata is available in edn, but type hints are not.

- [[#content/reference/metadata][Clojure Official Documentation]]
- [[http://en.wikibooks.org/wiki/Learning_Clojure/Meta_Data][Learning Clojure: Meta Data]]

*** ~'~ - Quote

Quoting is used to indicate that the next form should be read but not evaluated. The reader expands ~'~ into a call to the ~quote~ special form.

#+BEGIN_SRC clojure
user=> (1 3 4) ; fails as it tries to invoke 1 as a function

Execution error (ClassCastException) at myproject.person-names/eval230 (REPL:1).
class java.lang.Long cannot be cast to class clojure.lang.IFn

user=> '(1 3 4) ; quote
(1 3 4)

user=> (quote (1 2 3)) ; using the longer quote method
(1 2 3)
user=>
#+END_SRC

- [[#content/reference/special_forms#quote][Clojure Special Forms]]

*** ~;~ - Comment

~;~ starts a line comment and ignores all input from its starting point
to the end of the line.

#+BEGIN_SRC clojure
user=> (def x "x") ; this is a comment
#'user/x
user=> ; this is a comment too
<returns nothing>
#+END_SRC

It is common in Clojure to use multiple semicolons for readability or
emphasis, but these are all the same to Clojure

#+BEGIN_SRC clojure
;; This is probably more important than

; this
#+END_SRC

*** ~:~ - Keyword

~:~ is the indicator for a keyword. Keywords are often used as keys in
maps and they provide faster comparisons and lower memory overhead than
strings (because instances are cached and reused).

#+BEGIN_SRC clojure
user=> (type :test)
clojure.lang.Keyword
#+END_SRC

Alternatively you can use the ~keyword~ function to create a keyword
from a string

#+BEGIN_SRC clojure
user=> (keyword "test")
:test
#+END_SRC

Keywords can also be invoked as functions to look themselves up as a key
in a map:

#+BEGIN_SRC clojure
user=> (def my-map {:one 1 :two 2})
#'user/my-map
user=> (:one my-map) ; get the value for :one by invoking it as function
1
user=> (:three my-map) ; it can safely check for missing keys
nil
user=> (:three my-map 3) ; it can return a default if specified
3
user => (get my-map :three 3) ; same as above, but using get
3
#+END_SRC

- [[#content/reference/data_structures#keywords][Data Structures - Keywords]]

*** ~::~ - Auto-resolved keyword
:PROPERTIES:
:CUSTOM_ID: content/guides/weird_characters#autoresolved-keys
:END:

~::~ is used to auto-resolve a keyword in the current namespace. If no
qualifier is specified, it will auto-resolve to the current namespace.
If a qualifier is specified, it may use aliases in the current
namespace:

#+BEGIN_SRC clojure
user=> :my-keyword
:my-keyword
user=> ::my-keyword
:user/my-keyword
user=> (= ::my-keyword :my-keyword)
false
#+END_SRC

This is useful when creating macros. If you want to ensure that a macro
that calls another function in the macro namespace correctly expands to
call the function, you could use ~::my-function~ to refer to the fully
qualified name.

Note that ~::~ is not available in edn.

- [[#content/reference/reader][Reader]]

*** ~#:~ and ~#::~ - Namespace Map Syntax

Namespace map syntax was added in Clojure 1.9 and is used to specify a
default namespace context when keys or symbols in a map where they share
a common namespace.

The ~#:ns~ syntax specifies a fully-qualified namespace map prefix n
alias in the namespace map prefix with, where ~ns~ is the name of a
namespace and the prefix precedes the opening brace ~{~ of the map.

For example, the following map literal with namespace syntax:

#+BEGIN_SRC clojure
#:person{:first "Han"
         :last "Solo"
         :ship #:ship{:name "Millennium Falcon"
                      :model "YT-1300f light freighter"}}
#+END_SRC

is read as:

#+BEGIN_SRC clojure
{:person/first "Han"
 :person/last "Solo"
 :person/ship {:ship/name "Millennium Falcon"
               :ship/model "YT-1300f light freighter"}}
#+END_SRC

Note that these maps represent the identical object - these are just
alternate syntaxes.

~#::~ can be used to auto-resolve the namespace of keyword or symbol
keys in a map using the current namespace.

These two examples are equivalent:

#+BEGIN_SRC clojure
user=> (keys {:user/a 1, :user/b 2})
(:user/a :user/b)
user=> (keys #::{:a 1, :b 2})
(:user/a :user/b)
#+END_SRC

Similar to [[#content/guides/weird_characters#autoresolved-keys][autoresolved keywords]], you can also use ~#::alias~ to
auto-resolve with a namespace alias defined in the ~ns~ form:

#+BEGIN_SRC clojure
(ns rebel.core
  (:require
    [rebel.person :as p]
    [rebel.ship   :as s] ))

#::p{:first "Han"
     :last "Solo"
     :ship #::s{:name "Millennium Falcon"
                :model "YT-1300f light freighter"}}
#+END_SRC

is read the same as:

#+BEGIN_SRC clojure
{:rebel.person/first "Han"
 :rebel.person/last "Solo"
 :rebel.person/ship {:rebel.ship/name "Millennium Falcon"
                     :rebel.ship/model "YT-1300f light freighter"}}
#+END_SRC

- [[#content/reference/reader#map-namespace-syntax][Reader]]

*** ~/~ - Namespace separator

~/~ can be the division function ~clojure.core//~, but can also act as a
separator in a symbol name to separate a symbol's name and namespace
qualifier, e.g. ~my-namespace/utils~. Namespace qualifiers can thus
prevent naming collisions for simple names.

- [[#content/reference/reader][Reader]]

*** ~\~ - Character literal

~\~ indicates a literal character as in:

#+BEGIN_SRC clojure
user=> (str \h \i)
"hi"
#+END_SRC

There are also a small number of special characters to name special
ASCII characters: ~\newline~, ~\space~, ~\tab~, ~\formfeed~,
~\backspace~, and ~\return~.

The ~\~ can also be followed by a Unicode literal of the form ~\uNNNN~.
For example, ~\u03A9~ is the literal for Ω.

*** ~$~ - Inner class reference

Used to reference inner classes and interfaces in Java. Separates the
container class name and the inner class name.

#+BEGIN_SRC clojure
(import (basex.core BaseXClient$EventNotifier)

(defn- build-notifier [notifier-action]
  (reify BaseXClient$EventNotifier
    (notify [this value]
      (notifier-action value))))
#+END_SRC

~EventNotifier~ is an inner interface of the ~BaseXClient~ class which
is an imported Java class

- [[http://blog.jayfields.com/2011/01/clojure-using-java-inner-classes.html][Clojure: Using Java Inner Classes]]
- [[#content/reference/java_interop][Official Documentation]]

*** ~->~, ~->>~, ~some->~, ~cond->~, ~as->~ etc. - Threading macros

These are threading macros. Please refer to [[#content/guides/threading_macros][Official Clojure Documentation]]

- [[http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/][Understanding the Clojure -> macro]]

*** ~`~ - Syntax quote
:PROPERTIES:
:CUSTOM_ID: content/guides/weird_characters#syntax-quote
:END:

~`~ is the syntax quote. Syntax quote is similar to quoting (to delay
evaluation) but has some additional effects.

Basic syntax quote may look similar to normal quoting:

#+BEGIN_SRC clojure
user=> (1 2 3)
Execution error (ClassCastException) at myproject.person-names/eval232 (REPL:1).
class java.lang.Long cannot be cast to class clojure.lang.IFn
user=> `(1 2 3)
(1 2 3)
#+END_SRC

However, symbols used within a syntax quote are fully resolved with
respect to the current namespace:

#+BEGIN_SRC clojure
user=> (def five 5)
#'user/five
user=> `five
user/five
#+END_SRC

Syntax quote is most used as a "template" mechanism within macros. We
can write one now:

#+BEGIN_SRC clojure
user=> (defmacro debug [body]
  #_=>   `(let [val# ~body]
  #_=>      (println "DEBUG: " val#)
  #_=>      val#))
#'user/debug
user=> (debug (+ 2 2))
DEBUG:  4
4
#+END_SRC

Macros are functions invoked by the compiler with code as data. They are
expected to return code (as data) that can be further compiled and
evaluated. This macro takes a single body expression and returns a ~let~
form that will evaluate the body, print its value, and then return the
value. Here the syntax quote creates a list, but does not evaluate it.
That list is actually code.

See [[#content/guides/weird_characters#unquote-splice][~@]] and [[#content/guides/weird_characters#unquote][~]] for additional syntax allowed only within syntax quote.

- [[http://www.braveclojure.com/writing-macros/][Clojure for the Brave and True - Writing Macros]]
- [[http://aphyr.com/posts/305-clojure-from-the-ground-up-macros][Clojure from the ground up: macros]]
- [[#content/reference/macros][Clojure Official Documentation]]

*** ~~~ - Unquote
:PROPERTIES:
:CUSTOM_ID: content/guides/weird_characters#unquote
:END:

See [[#content/guides/weird_characters#syntax-quote][`]] for
additional information.

~~~ is unquote. Syntax quote, like quote, means that evaluation is not
occurring within the syntax quoted form. Unquoting turns off quoting and
evaluates an expression inside the syntax quoted expression.

#+BEGIN_SRC clojure
user=> (def five 5) ; create a named var with the value 5
#'user/five
user=> five ; the symbol five is evaluated to its value
5
user=> `five ; syntax quoting five will avoid evaluating the symbol, and fully resolve it
user/five
user=> `~five ; within a syntax quoted block, ~ will turn evaluation back on just for the next form
5
user=> `[inc ~(+ 1 five)]
[clojure.core/inc 6]
#+END_SRC

Syntax quoting and unquote are essential tools for writing macros, which
are functions invoked during compilation that take code and return code.

- [[http://www.braveclojure.com/writing-macros/][Clojure for the Brave and True - Writing Macros]]
- [[http://aphyr.com/posts/305-clojure-from-the-ground-up-macros][Clojure from the ground up: macros]]
- [[#content/reference/macros][Clojure Official Documentation]]

*** ~~@~ - Unquote splicing
:PROPERTIES:
:CUSTOM_ID: content/guides/weird_characters#unquote-splice
:END:

See [[#content/guides/weird_characters#syntax-quote][`]] and [[#content/guides/weird_characters#unquote][~]] for additional information.

~~@~ is unquote-splicing. Where unquote [[#content/guides/weird_characters#unquote][(~~~)]] evaluates a form and places
the result into the quoted result, ~~@~ expects the evaluated value to
be a collection and splices the /contents/ of that collection into the
quoted result.

#+BEGIN_SRC clojure
user=> (def three-and-four (list 3 4))
#'user/three-and-four
user=> `(1 ~three-and-four) ; evaluates `three-and-four` and places it in the result
(1 (3 4))
user=> `(1 ~@three-and-four) ;  evaluates `three-and-four` and places its contents in the result
(1 3 4)
#+END_SRC

Again, this is a powerful tool for writing macros.

- [[http://www.braveclojure.com/writing-macros/][Clojure for the Brave and True - Writing Macros]]
- [[http://aphyr.com/posts/305-clojure-from-the-ground-up-macros][Clojure from the ground up: macros]]
- [[#content/reference/macros][Clojure Official Documentation]]

*** ~<symbol>#~ - Gensym
:PROPERTIES:
:CUSTOM_ID: content/guides/weird_characters#gensym
:END:

A ~#~ /at the end/ of a symbol is used to automatically generate a new
symbol. This is useful inside macros to keep macro specifics from
leaking into the userspace. A regular ~let~ will fail in a macro
definition:

#+BEGIN_SRC clojure
user=> (defmacro m [] `(let [x 1] x))
#'user/m
user=> (m)
Syntax error macroexpanding clojure.core/let at (REPL:1:1).
myproject.person-names/x - failed: simple-symbol? at: [:bindings :form :local-symbol]
  spec: :clojure.core.specs.alpha/local-name
myproject.person-names/x - failed: vector? at: [:bindings :form :seq-destructure]
  spec: :clojure.core.specs.alpha/seq-binding-form
myproject.person-names/x - failed: map? at: [:bindings :form :map-destructure]
  spec: :clojure.core.specs.alpha/map-bindings
myproject.person-names/x - failed: map? at: [:bindings :form :map-destructure]
  spec: :clojure.core.specs.alpha/map-special-binding
#+END_SRC

This is because symbols inside a syntax quote are fully resolved,
including the local binding ~x~ here.

Instead you can append ~#~ to the end of the variable name and let
Clojure generate a unique (unqualified) symbol:

#+BEGIN_SRC clojure
user=> (defmacro m [] `(let [x# 1] x#))
#'user/m
user=> (m)
1
user=>
#+END_SRC

Importantly, every time a particular ~x#~ is used within a single syntax
quote, the /same/ generated name will be used.

If we expand this macro, we can see the ~gensym~ 'd name:

#+BEGIN_SRC clojure
user=> (macroexpand '(m))
(let* [x__681__auto__ 1] x__681__auto__)
#+END_SRC

- [[http://clojuredocs.org/clojure_core/clojure.core/gensym][ClojureDocs - gensym]]

*** ~#?~ - Reader conditional

Reader conditionals are designed to allow different dialects of Clojure
to share common code. The reader conditional behaves similarly to a
traditional ~cond~. The syntax for usage is ~#?~ and looks like this:

#+BEGIN_SRC clojure
#?(:clj  (Clojure expression)
   :cljs (ClojureScript expression)
   :cljr (Clojure CLR expression)
   :default (fallthrough expression))
#+END_SRC

- [[#content/guides/reader_conditionals][Reader conditionals]]

*** ~#?@~ - Splicing Reader conditional

The syntax for a splicing reader conditional is ~#?@~. It is used to
splice lists into the containing form. So the Clojure reader would read
this:

#+BEGIN_SRC clojure
(defn build-list []
  (list #?@(:clj  [5 6 7 8]
            :cljs [1 2 3 4])))
#+END_SRC

as this:

#+BEGIN_SRC clojure
(defn build-list []
  (list 5 6 7 8))
#+END_SRC

- [[#content/guides/reader_conditionals][Reader conditonals]]

*** ~*var-name*~ - "Earmuffs"

Earmuffs (a pair of asterisk bookending var names) is a naming
convention in many LISPs used to denote /special vars/. Most commonly in
Clojure this is used to denote /dynamic/ vars, i.e. ones that can change
depending on dynamic scope. The earmuffs act as a warning that "here be
dragons" and to never assume the state of the var. Remember, this is a
convention, not a rule.

Core Clojure examples include ~*out*~ and ~*in*~ which represent the
standard in and out streams for Clojure.

- [[http://stackoverflow.com/questions/1986961/how-is-the-var-name-naming-convention-used-in-clojure][How is the var-name naming-convention used in clojure?]]
- [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/*out*][Clojure API Docs]]

*** ~>!!~, ~<!!~, ~>!~, and ~<!~ - core.async channel macros
:PROPERTIES:
:CUSTOM_ID: content/guides/weird_characters#core.async-channel-macros
:END:

These symbols are channel operations in [[https://github.com/clojure/core.async][core.async]] - a
Clojure/ClojureScript library for channel based asynchronous
programming (specifically [[http://en.wikipedia.org/wiki/Communicating_sequential_processes][CSP - Communicating Sequential Processes]]).

If you imagine, for the sake of argument, a channel is a bit like a
queue that things can put stuff on and take stuff off, then these
symbols support that simple API.

- ~>!!~ and ~<!!~ are /blocking put/ and /take/ respectively
- ~>!~ and ~<!~ are, simply /put/ and /take/

The difference being the blocking version operate outside ~go~ blocks
and block the thread they operate on.

#+BEGIN_SRC clojure
user=> (def my-channel (chan 10)) ; create a channel
user=> (>!! my-channel "hello")   ; put stuff on the channel
user=> (println (<!! my-channel)) ; take stuff off the channel
hello
#+END_SRC

The non-blocking versions need to be executed within a ~go~ block,
otherwise they'll throw an exception.

#+BEGIN_SRC clojure
user=> (def c (chan))
#'user/c
user=> (>! c "nope")
AssertionError Assert failed: >! used not in (go ...) block
nil  clojure.core.async/>! (async.clj:123)
#+END_SRC

While the difference between these is well outside the scope of this
guide, fundamentally the ~go~ blocks operate and manage their own
resources pausing *execution* of code without blocking threads. This
makes asynchronously executed code appear to be synchronous, removing
the pain of managing asynchronous code from the code base.

- [[https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj][core.async Code Walkthrough]]
- [[https://github.com/clojure/core.async/wiki][core.async Wiki]]
- [[#content/guides/core_async_go][Go Block Best Practices]]

*** ~<symbol>?~ - Predicate Suffix

Putting ~?~ at the end of a symbol is a naming convention common across many languages that support special characters in their symbol names. It is used to indicate that the thing is a predicate, i.e. that it /poses a question/. For example, imagine using an API that dealt with buffer manipulation:

#+BEGIN_SRC clojure
(def my-buffer (buffers/create-buffer [1 2 3]))
(buffers/empty my-buffer)
#+END_SRC

At a glance, how would you know if the function ~empty~ in this case,

- Returned ~true~ if the passed in buffer was empty, or,
- Cleared the buffer

While the author could have renamed ~empty~ to ~is-empty~, the richness
of symbol naming in Clojure allows us to express intent more
symbolically.

#+BEGIN_SRC clojure
(def my-buffer (buffers/create-buffer [1 2 3]))
(buffers/empty? my-buffer)
false
#+END_SRC

This is simply a recommended convention, not a requirement.

- [[https://github.com/bbatsov/clojure-style-guide#naming][Clojure Style Guide]]

*** ~<symbol>!~ - Unsafe Operations

[[https://github.com/bbatsov/clojure-style-guide#changing-state-fns-with-exclamation-mark][The Clojure style guide has this to say]]:

#+BEGIN_HTML
<div class="informalexample">
#+END_HTML

The names of functions/macros that are not safe in STM transactions
should end with an exclamation mark (e.g ~reset!~).

#+BEGIN_HTML
</div>
#+END_HTML

You'll most commonly see this appended to function names whose purpose
is to mutate state, e.g. connecting to a data store, updating an atom or
closing a file stream

#+BEGIN_SRC clojure
user=> (def my-stateful-thing (atom 0))
#'user/my-stateful-thing
user=> (swap! my-stateful-thing inc)
1
user=> @my-stateful-thing
1
#+END_SRC

This is simply a recommended convention and not a requirement.

Note that the exclamation mark is often pronounced as bang.

- [[https://github.com/bbatsov/clojure-style-guide#naming][Clojure Style Guide]]

*** ~_~ - Unused argument

When you see the underscore character used as function arguments or in
a ~let~ binding, ~_~ is a common naming convention to indicate you won't
be using this argument.

This is an example using the ~add-watch~ function that can be used to
add callback style behaviour when atoms change value. Imagine, given an
atom, we want to print the new value every time it changes:

#+BEGIN_SRC clojure
(def value (atom 0))

(add-watch value nil (fn [_ _ _ new-value]
                       (println new-value))

(reset! value 6)
; prints 6
(reset! value 9)
; prints 9
#+END_SRC

~add-watch~ takes four arguments, but in our case we only really care
about the last argument - the new value of the atom so we use ~_~ for
the others.

*** ~,~ - Whitespace character

In Clojure, ~,~ is treated as whitespace, exactly the same as spaces,
tabs, or newlines. Commas are thus never required in literal
collections, but are often used to enhance readability:

#+BEGIN_SRC clojure
user=>(def m {:a 1, :b 2, :c 3}
{:a 1, :b 2, :c 3}
#+END_SRC

#+BEGIN_HTML
<div class="informalexample">
#+END_HTML

Many thanks to everyone who has contributed ideas and [the copious
amounts of] spelling corrections (crikey I'm bad at speelingz - so
thanks Michael R. Mayne, lobsang_ludd). I've tried to call out people
who have specifically asked for things. Sorry if I've missed you.

#+BEGIN_HTML
</div>
#+END_HTML

** REPL
*** Programming at the REPL: Introduction
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/introduction.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/introduction
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-02-10
:NEXTPAGE_CUSTOM_ID: guides/repl/launching_a_basic_repl
:CUSTOM_ID: content/guides/repl/introduction
:END:

This guide is for developers who have at least a [[#content/guides/learn/syntax][basic understanding]]
of Clojure, and want to become more proficient at using the Clojure
REPL.

**** What is a REPL?

A Clojure /REPL/ (standing for /Read-Eval-Print Loop/) is a programming
environment which enables the programmer to interact with a running
Clojure program and modify it, by evaluating one code expression at a
time.

#+CAPTION: A Clojure REPL in a terminal window
[[./assets/images/content/guides/repl/show-terminal-repl.gif]]

#+CAPTION: An editor-integrated Clojure REPL
[[./assets/images/content/guides/repl/show-editor-repl.gif]]

**** Why use a REPL?

The Clojure REPL gives the programmer an interactive development
experience. When developing new functionality, it enables her to build
programs first by performing small tasks manually, as if she /were/ the
computer, then gradually make them more and more automated, until the
desired functionality is fully programmed. When debugging, the REPL
makes the execution of her programs feel /tangible:/ it enables the
programmer to rapidly reproduce the problem, observe its symptoms
closely, then improvise experiments to rapidly narrow down the cause of
the bug and iterate towards a fix.

Many Clojure programmers consider the REPL, and the tight feedback loop
it provides, to be the most compelling reason to use Clojure. This does
not mean that the language features of Clojure, such as immutable data
structures, are not valuable: the Clojure REPL gets most of its leverage
/because/ of these features, in particular because Clojure was designed
with interactive development in mind.

In Clojure, a programmer will typically use the REPL for a wide spectrum
of programming tasks, when in another language she would turn to other
sorts of tools. Such tasks include:

- launching local development environments,
- running automated test suites,
- one-off database queries and interventions,
- debugging,
- orchestrating remote machines,
- getting familiar with libraries and APIs,
- ...​and many forms of exploration.

Fundamentally, the reason programmers use the REPL for all these tasks
is always the same: because they want a mix of automation and
improvisation that can be provided neither by fully manual tools (such
as dashboard, consoles, etc.) nor by fully automated ones (such as
scripts), while keeping their workflow focused in one full-featured
programming environment.

**** What this guide will cover

This guide will start by getting you started with a Clojure REPL, then
gradually move to more and more advanced ways of using Clojure REPLs.

Depending on your needs, you may not need to read the entirety of this
guide:

- If you are *just starting to learn Clojure*, the first 2 chapters
  [[#content/guides/repl/launching_a_basic_repl][Launching a basic Clojure REPL]] and [[#content/guides/repl/basic_usage][Basic Usage]] are enough to get you
  started with a productive learning environment.
- As soon as you start *developing non-trivial programs* (such as a
  hobby web app), you will need the ideas presented in at least the
  next 2 chapters: [[#content/guides/repl/data_visualization_at_the_repl][Data visualization at the REPL]] and [[#content/guides/repl/navigating_namespaces][Navigating
  namespaces]].
- For *working on Clojure projects at a professional level*, [[#content/guides/repl/enhancing_your_repl_workflow][Enhancing
  your REPL workflow]] and [[#content/guides/repl/guidelines_for_repl_aided_development][Guidelines for REPL-Aided Development]] are
  must-reads.

First, we'll learn how to [[#content/guides/repl/launching_a_basic_repl][launch a basic Clojure REPL]].

*** Programming at the REPL: Launching a Basic REPL
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/launching_a_basic_repl.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/launching_a_basic_repl
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-02-10
:PREVPAGE_CUSTOM_ID: content/guides/repl/introduction
:NEXTPAGE_CUSTOM_ID: content/guides/repl/basic_usage
:CUSTOM_ID: content/guides/repl/launching_a_basic_repl
:END:

Use any of the following methods to start a basic Clojure REPL in a
terminal window:

**** Using the CLI tools

The easiest way to start a Clojure REPL is with using the ~clj~ command
of the Clojure [[#content/reference/deps_and_cli][CLI tools]]:

#+BEGIN_EXAMPLE
clj ## run this command in a terminal window
#+END_EXAMPLE

You should see output like the following:

#+BEGIN_EXAMPLE
Clojure 1.9.0
user=>
#+END_EXAMPLE

See [[#content/guides/getting_started][Getting Started]] to learn how to install the Clojure CLI.

You can exit the REPL by typing ~Ctrl+D~ (pressing the ~Ctrl~ and ~D~
keys at the same time).

**** Using a project management tool
***** Leiningen

If you have installed [[https://leiningen.org/][Leiningen]], you can use it to launch a REPL:

#+BEGIN_EXAMPLE
lein repl
#+END_EXAMPLE

You should see output like the following:

#+BEGIN_EXAMPLE
nREPL server started on port 64411 on host 127.0.0.1 - nrepl://127.0.0.1:64411
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_05-b13
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=>
#+END_EXAMPLE

If you run ~lein repl~ from inside a Leiningen project directory, the
library dependencies and source code of the project will be available at
the REPL.

***** Boot

If you have installed [[https://boot-clj.github.io/][Boot]], you can use it to launch a REPL:

#+BEGIN_EXAMPLE
boot repl
#+END_EXAMPLE

You should see output like the following:

#+BEGIN_EXAMPLE
nREPL server started on port 50109 on host 127.0.0.1 - nrepl://127.0.0.1:50109
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.9.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_05-b13
        Exit: Control+D or (exit) or (quit)
    Commands: (user/help)
        Docs: (doc function-name-here)
              (find-doc "part-of-name-here")
Find by Name: (find-name "part-of-name-here")
      Source: (source function-name-here)
     Javadoc: (javadoc java-object-or-class-here)
    Examples from clojuredocs.org: [clojuredocs or cdoc]
              (user/clojuredocs name-here)
              (user/clojuredocs "ns-here" "name-here")
boot.user=>
#+END_EXAMPLE

**** Using Java and the Clojure JAR

If you have [[#content/guides/getting_started#other-ways-to-run-clojure][downloaded and built Clojure]], you can use Java to launch a
Clojure REPL:

#+BEGIN_EXAMPLE
java -jar clojure.jar
#+END_EXAMPLE

You should see output like the following:

#+BEGIN_EXAMPLE
Clojure 1.9.0
user=>
#+END_EXAMPLE

*** Programming at the REPL: Basic Usage
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/basic_usage.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/basic_usage
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-02-10
:PREVPAGE_CUSTOM_ID: content/guides/repl/launching_a_basic_repl
:NEXTPAGE_CUSTOM_ID: content/guides/repl/data_visualization_at_the_repl
:CUSTOM_ID: content/guides/repl/basic_usage
:END:
**** Evaluating Clojure expressions

Having started the REPL (as described [[#content/guides/repl/launching_a_basic_repl][in the previous chapter]]), you
can now evaluate Clojure expressions by simply typing them into the
REPL and pressing ENTER:

#+BEGIN_EXAMPLE
user=> (+ 2 3)
5
user=> (defn factorial [n]
(if (= n 0)
  1
  (* n (factorial (dec n)))))
#'user/factorial
user=> (factorial 10)
3628800
user=>
#+END_EXAMPLE

Under each expression, we see the /result/ of evaluating the expression.
This is what a REPL does: for each expression that we submit to it, the
REPL Reads it, Evaluates it, then Prints the result, all of this
in a Loop.

#+BEGIN_QUOTE
*Note*

If you are in the process of learning Clojure, take some time to
experiment at the REPL. The rapid feedback loop it provides makes for
a very effective learning environment.
#+END_QUOTE

Although the above examples are very basic, you can run full-featured
Clojure programs in this way. Clojure was designed so that its REPL
environment provides the full power of the language: you could actually
run any existing Clojure program simply by pasting the content of the
source files in the right order into the REPL.

#+BEGIN_QUOTE
*Tip*

*TIP: using an editor next to your REPL*

Editing Clojure code inside the terminal window can get tedious; when
that is the case, one simple trick is to write the code in a text
editor of your choosing that has a syntax-aware Clojure mode, and copy
and paste code from the editor to the REPL terminal window. Here's an
example of what this looks like (the editor used is
[[https://atom.io/packages/language-clojure/][Atom]]):

[[./assets/images/content/guides/repl/editor-cli-repl.gif]]

In the /[[#content/guides/repl/enhancing_your_repl_workflow][Enhancing your REPL workflow]]/ chapter of this guide, we will see
more ergonomic configurations for using the REPL. However, this
minimalist setup is sufficient for the scope of this tutorial, and is
important for mastering the fundamentals.
#+END_QUOTE

**** The 2 flavors of printing

Consider the following evaluation:

#+BEGIN_EXAMPLE
user=> (println "Hello World")
Hello World
nil
#+END_EXAMPLE

This is strange: unlike the previous examples, it looks like evaluating
the ~(println "Hello World")~ expression yielded 2 results:
~Hello World~ and ~nil~.

This is because the [[clojure:core.clj::(defn println][println]] function /prints/ its argument to the
standard output but /returns/ nil.  Therefore, the 2 lines we see under
our expression are very different in nature:

- ~Hello World~ is a /side effect/ of evaluating the expression
  (printing to standard output): the printing was done by our code.
- ~nil~ is the /result/ of evaluating the expression: the printing was
  done by the REPL.

**** Calling Clojure libs from the REPL

So far, we have only called code that we had defined manually at the
REPL (for instance our ~factorial~ function defined above). But the REPL
also lets you use pre-existing Clojure code, i.e Clojure
[[#content/reference/libs][libs]].[fn:lib] Given a Clojure lib with namespace ~my.name.space~, you
can evaluate ~(require '[my.name.space])~ to make that lib's code loaded
and available in the REPL.

[fn:lib] Note that what we call a Clojure [[#content/reference/libs][lib]] is not necessarily a
[[https://en.wikipedia.org/wiki/Library_(computing)][library]]: it can also be a source code file in your current project.

***** Example: using clojure.string

For example, ~clojure.string~ is a lib bundled with Clojure for
manipulating text. Let's require ~clojure.string~ and call its
~clojure.string/upper-case~ function:

#+BEGIN_EXAMPLE
user=> (require '[clojure.string])
nil
user=> (clojure.string/upper-case "clojure")
"CLOJURE"
#+END_EXAMPLE

~require~ also lets us define an /alias/ for the ~clojure.string~
namespace, by adding an ~:as~ clause. This enables us to refer to names
defined in the ~clojure.string~ namespace more concisely:

#+BEGIN_EXAMPLE
user=> (require '[clojure.string :as str])
nil
user=> (str/upper-case "clojure")
"CLOJURE"
#+END_EXAMPLE

Finally, if we're /very/ lazy and don't want to type an alias at all, we
can add a ~:refer~ clause:

#+BEGIN_EXAMPLE
user=> (require '[clojure.string :refer [upper-case]])
nil
user=> (upper-case "clojure")
"CLOJURE"
#+END_EXAMPLE

**** Looking up documentation

The REPL can also be used for looking up API documentation, using the
~clojure.repl~ lib. Evaluate the following expression at the REPL:

#+BEGIN_EXAMPLE
user=> (require '[clojure.repl :refer :all])
nil
#+END_EXAMPLE

This expression makes all the names defined in the ~clojure.repl~
namespace available in the REPL.

***** doc

You can print the API documentation of a given Var by evaluating
~(doc MY-VAR-NAME)~:

#+BEGIN_EXAMPLE
user=> (doc nil?)
-------------------------
clojure.core/nil?
([x])
  Returns true if x is nil, false otherwise.
nil
user=> (doc clojure.string/upper-case)
-------------------------
clojure.string/upper-case
([s])
  Converts string to all upper-case.
nil
#+END_EXAMPLE

***** source

You can also view the source code that was used to define a Var using
~source~:

#+BEGIN_EXAMPLE
user=> (source some?)
(defn some?
  "Returns true if x is not nil, false otherwise."
  {:tag Boolean
   :added "1.6"
   :static true}
  [x] (not (nil? x)))
nil
#+END_EXAMPLE

***** dir

You can use ~dir~ to list the names of all the Vars defined a given
namespace. Let's do this with the ~clojure.string~ namespace:

#+BEGIN_EXAMPLE
user=> (dir clojure.string)
blank?
capitalize
ends-with?
escape
includes?
index-of
join
last-index-of
lower-case
re-quote-replacement
replace
replace-first
reverse
split
split-lines
starts-with?
trim
trim-newline
triml
trimr
upper-case
nil
#+END_EXAMPLE

As another example, let's use ~dir~ to see what's available in
~clojure.repl~ itself:

#+BEGIN_EXAMPLE
user=> (dir clojure.repl)
apropos
demunge
dir
dir-fn
doc
find-doc
pst
root-cause
set-break-handler!
source
source-fn
stack-element-str
thread-stopper
nil
#+END_EXAMPLE

We recognize the ~doc~, ~source~ and ~dir~ operations we've used so far.

***** apropos

If you don't exactly remember the name of some Var, you can search for
it using ~apropos~:

#+BEGIN_EXAMPLE
user=> (apropos "index")
(clojure.core/indexed? clojure.core/keep-indexed clojure.core/map-indexed clojure.string/index-of clojure.string/last-index-of)
#+END_EXAMPLE

~apropos~ only searches Var names; you can search docstrings (the text
that is printed by ~doc~) using ~find-doc~:

***** find-doc

#+BEGIN_EXAMPLE
user=> (find-doc "indexed")
-------------------------
clojure.core/contains?
([coll key])
 Returns true if key is present in the given collection, otherwise
 returns false.  Note that for numerically indexed collections like
 vectors and Java arrays, this tests if the numeric key is within the
 range of indexes. 'contains?' operates constant or logarithmic time;
 it will not perform a linear search for a value.  See also 'some'.
-------------------------
clojure.core/indexed?
([coll])
 Return true if coll implements Indexed, indicating efficient lookup by index
-------------------------
clojure.core/keep-indexed
([f] [f coll])
 Returns a lazy sequence of the non-nil results of (f index item). Note,
 this means false return values will be included.  f must be free of
 side-effects.  Returns a stateful transducer when no collection is
 provided.
-------------------------
clojure.core/map-indexed
([f] [f coll])
 Returns a lazy sequence consisting of the result of applying f to 0
 and the first item of coll, followed by applying f to 1 and the second
 item in coll, etc, until coll is exhausted. Thus function f should
 accept 2 arguments, index and item. Returns a stateful transducer when
 no collection is provided.
nil
#+END_EXAMPLE

#+BEGIN_QUOTE
*Warning*

*Documentation is available only for libs that have been required.*

For instance, if you have not required the ~clojure.set~ namespace,
you won't be able to search documentation for ~clojure.set/union~.
This is illustrated by this example REPL session:

#+BEGIN_EXAMPLE
    clj
    Clojure 1.10.0
    user=> (doc clojure.set/union)
    nil                             ;; no doc found
    user=> (apropos "union")
    ()
    user=> (require '[clojure.set]) ;; now we're requiring clojure.set
    nil
    user=> (doc clojure.set/union)
    -------------------------
    clojure.set/union
    ([] [s1] [s1 s2] [s1 s2 & sets])
      Return a set that is the union of the input sets
    nil
    user=> (apropos "union")
    (clojure.set/union)
    user=>
#+END_EXAMPLE
#+END_QUOTE

*** Programming at the REPL: Data Visualization
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/data_visualization_at_the_repl.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/data_visualization_at_the_repl
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-02-10
:PREVPAGE_CUSTOM_ID: content/guides/repl/basic_usage
:NEXTPAGE_CUSTOM_ID: content/guides/repl/navigating_namespaces
:CUSTOM_ID: content/guides/repl/data_visualization_at_the_repl
:END:

Each time we evaluate an expression, the REPL shows us a textual
representation of the result: that's the /Print/ part of
/Read-Eval-Print-Loop/. Most of the time, this textual representation is
clear enough for the programmer, but sometimes it becomes difficult to
read - especially when dealing with big or deeply nested data
structures.

Fortunately, the REPL provides sharper tools for data visualization,
which we will describe in this chapter.

**** Pretty-printing using ~clojure.pprint~
:PROPERTIES:
:CUSTOM_ID: content/guides/repl/data_visualization_at_the_repl#pretty-printing-using-clojure.pprint
:END:

As an example, consider the following code, which computes a summary of
the arithmetic properties of some numbers:

#+BEGIN_EXAMPLE
user=> (defn number-summary
  "Computes a summary of the arithmetic properties of a number, as a data structure."
  [n]
  (let [proper-divisors (into (sorted-set)
                          (filter
                            (fn [d]
                              (zero? (rem n d)))
                            (range 1 n)))
        divisors-sum (apply + proper-divisors)]
    {:n n
     :proper-divisors proper-divisors
     :even? (even? n)
     :prime? (= proper-divisors #{1})
     :perfect-number? (= divisors-sum n)}))
#'user/number-summary
user=> (mapv number-summary [5 6 7 12 28 42])
[{:n 5, :proper-divisors #{1}, :even? false, :prime? true, :perfect-number? false} {:n 6, :proper-divisors #{1 2 3}, :even? true, :prime? false, :perfect-number? true} {:n 7, :proper-divisors #{1}, :even? false, :prime? true, :perfect-number? false} {:n 12, :proper-divisors #{1 2 3 4 6}, :even? true, :prime? false, :perfect-number? false} {:n 28, :proper-divisors #{1 2 4 7 14}, :even? true, :prime? false, :perfect-number? true} {:n 42, :proper-divisors #{1 2 3 6 7 14 21}, :even? true, :prime? false, :perfect-number? false}]
user=>
#+END_EXAMPLE

#+BEGIN_QUOTE
*Note*

For now, you don't need to understand the code of the ~number-summary~
function defined above: we're just using it as a pretext to synthetize
some hairy data structures. Real-world Clojure programming for a
specific domain will provide you with many examples of such hairy data
structures.
#+END_QUOTE

As we can see, the result of our last expression is condensed on a
single line, which makes it hard to read:

#+BEGIN_EXAMPLE
user=> (mapv number-summary [5 6 7 12 28 42])
[{:n 5, :proper-divisors #{1}, :even? false, :prime? true, :perfect-number? false} {:n 6, :proper-divisors #{1 2 3}, :even? true, :prime? false, :perfect-number? true} {:n 7, :proper-divisors #{1}, :even? false, :prime? true, :perfect-number? false} {:n 12, :proper-divisors #{1 2 3 4 6}, :even? true, :prime? false, :perfect-number? false} {:n 28, :proper-divisors #{1 2 4 7 14}, :even? true, :prime? false, :perfect-number? true} {:n 42, :proper-divisors #{1 2 3 6 7 14 21}, :even? true, :prime? false, :perfect-number? false}]
#+END_EXAMPLE

We can use the ~clojure.pprint~ lib to print the result in a more
'visual' format:

#+BEGIN_EXAMPLE
user=> (require '[clojure.pprint :as pp])
nil
user=> (pp/pprint (mapv number-summary [5 6 7 12 28 42]))
[{:n 5,
  :proper-divisors #{1},
  :even? false,
  :prime? true,
  :perfect-number? false}
 {:n 6,
  :proper-divisors #{1 2 3},
  :even? true,
  :prime? false,
  :perfect-number? true}
 {:n 7,
  :proper-divisors #{1},
  :even? false,
  :prime? true,
  :perfect-number? false}
 {:n 12,
  :proper-divisors #{1 2 3 4 6},
  :even? true,
  :prime? false,
  :perfect-number? false}
 {:n 28,
  :proper-divisors #{1 2 4 7 14},
  :even? true,
  :prime? false,
  :perfect-number? true}
 {:n 42,
  :proper-divisors #{1 2 3 6 7 14 21},
  :even? true,
  :prime? false,
  :perfect-number? false}]
nil
#+END_EXAMPLE

#+BEGIN_QUOTE
*Tip*

*TIP: Using an editor for syntax-highlighting the results*

If you want your pretty-printed result to be displayed with more
visual contrast, you can also copy it to your editor buffer (the
editor used below is [[https://www.gnu.org/software/emacs/][Emacs]]):

[[./assets/images/content/guides/repl/repl-copy-pprint-editor.gif]]
#+END_QUOTE

Needing to pretty-print the last REPL result is so common that
~clojure.pprint~ has a function for that: [[clojure:pprint/pprint_base.clj::(defmacro pp][clojure.pprint/pp]]

#+BEGIN_EXAMPLE
user=> (mapv number-summary [12 28])
[{:n 12, :proper-divisors #{1 2 3 4 6}, :even? true, :prime? false, :perfect-number? false} {:n 28, :proper-divisors #{1 2 4 7 14}, :even? true, :prime? false, :perfect-number? true}]
user=> (pp/pp)
[{:n 12,
  :proper-divisors #{1 2 3 4 6},
  :even? true,
  :prime? false,
  :perfect-number? false}
 {:n 28,
  :proper-divisors #{1 2 4 7 14},
  :even? true,
  :prime? false,
  :perfect-number? true}]
nil
#+END_EXAMPLE

Finally, for a result which is a sequence of maps (like the above),
you can use [[clojure:pprint/print_table.clj::(defn print-table][clojure.pprint/print-table]] to print it as a table:

#+BEGIN_EXAMPLE
user=> (pp/print-table (mapv number-summary [6 12 28]))

| :n | :proper-divisors | :even? | :prime? | :perfect-number? |
|----+------------------+--------+---------+------------------|
|  6 |         #{1 2 3} |   true |   false |             true |
| 12 |     #{1 2 3 4 6} |   true |   false |            false |
| 28 |    #{1 2 4 7 14} |   true |   false |             true |
nil
#+END_EXAMPLE

**** Truncating REPL output

When an expression evaluates to a large or deeply nested data structure,
reading REPL output can become difficult.

When a structure is too deeply nested, you can truncate the output by
setting the ~*print-level*~ Var:

#+BEGIN_EXAMPLE
user=> (set! *print-level* 3)
3
user=> {:a {:b [{:c {:d {:e 42}}}]}} ;; a deeply nested data structure
{:a {:b [#]}}
#+END_EXAMPLE

You can undo this setting by evaluating ~(set! *print-level* nil)~.

Likewise, when a data structure contains long collections, you can limit
the number of displayed item by setting the ~*print-length*~ Var:

#+BEGIN_EXAMPLE
user=> (set! *print-length* 3)
3
user=> (repeat 100 (vec (range 100))) ;; a data structure containing looooong collections.
([0 1 2 ...] [0 1 2 ...] [0 1 2 ...] ...)
#+END_EXAMPLE

Like the above, evaluate ~(set! *print-length* nil)~ to undo this
setting.

~*print-level*~ and ~*print-length*~ affect both ordinary REPL printing
and pretty-pretting.

**** Accessing recent results: ~*1~, ~*2~, ~*3~

In the REPL, the last evaluated result can be retrieved by evaluating
~*1~; the one before that is saved in ~*2~, and the one before that in
~*3~:

#+BEGIN_EXAMPLE
user=> (mapv number-summary [6 12 28])
[{:n 6, :proper-divisors #{1 2 3}, :even? true, :prime? false, :perfect-number? true} {:n 12, :proper-divisors #{1 2 3 4 6}, :even? true, :prime? false, :perfect-number? false} {:n 28, :proper-divisors #{1 2 4 7 14}, :even? true, :prime? false, :perfect-number? true}]
user=> (pp/pprint *1) ;; using *1 instead of re-typing the previous expression (or its result)
[{:n 6,
 :proper-divisors #{1 2 3},
 :even? true,
 :prime? false,
 :perfect-number? true}
{:n 12,
 :proper-divisors #{1 2 3 4 6},
 :even? true,
 :prime? false,
 :perfect-number? false}
{:n 28,
 :proper-divisors #{1 2 4 7 14},
 :even? true,
 :prime? false,
 :perfect-number? true}]
nil
user=> *1 ;; now *1 has changed to become nil (because pp/pprint returns nil)
nil
user=> *3 ;; ... which now means that our initial result is in *3:
[{:n 6, :proper-divisors #{1 2 3}, :even? true, :prime? false, :perfect-number? true} {:n 12, :proper-divisors #{1 2 3 4 6}, :even? true, :prime? false, :perfect-number? false} {:n 28, :proper-divisors #{1 2 4 7 14}, :even? true, :prime? false, :perfect-number? true}]
user=>
#+END_EXAMPLE

#+BEGIN_QUOTE
*Tip*

*TIP: saving a result by ~def~-ining it*

If you want to keep a result around for longer than 3 evaluations, you
can simply evaluate ~(def <some-name> *1)~:

#+BEGIN_EXAMPLE
    user=> (mapv number-summary [6 12 28])
    [{:n 6, :proper-divisors #{1 2 3}, :even? true, :prime? false ; ...
    user=> (def my-summarized-numbers *1) ;; saving the result
    #'user/my-summarized-numbers
    user=> my-summarized-numbers
    [{:n 6, :proper-divisors #{1 2 3}, :even? true, :prime? false ; ...
    user=> (count my-summarized-numbers)
    3
    user=> (first my-summarized-numbers)
    {:n 6, :proper-divisors #{1 2 3}, :even? true, :prime? false, ; ...
    user=> (pp/print-table my-summarized-numbers)

    | :n | :proper-divisors | :even? | :prime? | :perfect-number? |
    |----+------------------+--------+---------+------------------|
    |  6 |         #{1 2 3} |   true |   false |             true |
    | 12 |     #{1 2 3 4 6} |   true |   false |            false |
    | 28 |    #{1 2 4 7 14} |   true |   false |             true |
    nil
    user=>
#+END_EXAMPLE
#+END_QUOTE

**** Investigating Exceptions

Some expressions won't return a result when you evaluate them, but
throw an [[https://en.wikipedia.org/wiki/Exception_handling][Exception]] instead. Throwing an Exception is your program
saying to you: "something went wrong when evaluating the expression,
and I don't know how to deal with it, so I gave up."

For instance, an Exception will be thrown if you divide a number by
zero:

#+BEGIN_EXAMPLE
user=> (/ 1 0)
Execution error (ArithmeticException) at user/eval163 (REPL:1).
Divide by zero
#+END_EXAMPLE

By default, the REPL prints a two-line summary of the Exception. The
first line reports the error phase (execution, compilation,
macroexpansion, etc) and its location. The second line reports the
cause.

This can be enough in many cases, but there is more information
available.

First, you can visualize the /stacktrace/ of the Exception - that is,
the chain of function calls which led to the faulty instruction. The
stacktrace can be printed using [[clojure:repl.clj::(defn pst][clojure.repl/pst]]:

#+BEGIN_EXAMPLE
user=> (pst *e)
ArithmeticException Divide by zero
    clojure.lang.Numbers.divide (Numbers.java:163)
    clojure.lang.Numbers.divide (Numbers.java:3833)
    user/eval15 (NO_SOURCE_FILE:3)
    user/eval15 (NO_SOURCE_FILE:3)
    clojure.lang.Compiler.eval (Compiler.java:7062)
    clojure.lang.Compiler.eval (Compiler.java:7025)
    clojure.core/eval (core.clj:3206)
    clojure.core/eval (core.clj:3202)
    clojure.main/repl/read-eval-print--8572/fn--8575 (main.clj:243)
    clojure.main/repl/read-eval-print--8572 (main.clj:243)
    clojure.main/repl/fn--8581 (main.clj:261)
    clojure.main/repl (main.clj:261)
nil
#+END_EXAMPLE

#+BEGIN_QUOTE
*Tip*

*TIP:* the last thrown Exception can be obtained by evaluating ~*e~.
#+END_QUOTE

Finally, just evaluating the Exception at the REPL can provide a useful
visualization:

#+BEGIN_EXAMPLE
user=> *e
#error {
 :cause "Divide by zero"
 :via
 [{:type java.lang.ArithmeticException
   :message "Divide by zero"
   :at [clojure.lang.Numbers divide "Numbers.java" 163]}]
 :trace
 [[clojure.lang.Numbers divide "Numbers.java" 163]
  [clojure.lang.Numbers divide "Numbers.java" 3833]
  [user$eval15 invokeStatic "NO_SOURCE_FILE" 3]
  [user$eval15 invoke "NO_SOURCE_FILE" 3]
  [clojure.lang.Compiler eval "Compiler.java" 7062]
  [clojure.lang.Compiler eval "Compiler.java" 7025]
  [clojure.core$eval invokeStatic "core.clj" 3206]
  [clojure.core$eval invoke "core.clj" 3202]
  [clojure.main$repl$read_eval_print__8572$fn__8575 invoke "main.clj" 243]
  [clojure.main$repl$read_eval_print__8572 invoke "main.clj" 243]
  [clojure.main$repl$fn__8581 invoke "main.clj" 261]
  [clojure.main$repl invokeStatic "main.clj" 261]
  [clojure.main$repl_opt invokeStatic "main.clj" 325]
  [clojure.main$main invokeStatic "main.clj" 424]
  [clojure.main$main doInvoke "main.clj" 387]
  [clojure.lang.RestFn invoke "RestFn.java" 397]
  [clojure.lang.AFn applyToHelper "AFn.java" 152]
  [clojure.lang.RestFn applyTo "RestFn.java" 132]
  [clojure.lang.Var applyTo "Var.java" 702]
  [clojure.main main "main.java" 37]]}
#+END_EXAMPLE

In this simplistic example, displaying all this information may be more
than what is needed to diagnose the issue; but this visualization
becomes more helpful for 'real-world' Exceptions, which tend to have the
following charateristics in Clojure programs:

- *Exceptions convey data:* in Clojure programs, it's common to attach
  additional data to an Exception (not just a human-readable error
  message): this is done by creating the Exception via [[clojure:core.clj::(defn
  ex-info][clojure.core/ex-info]].
- *Exceptions are chained:* an Exception can be annotated with an
  optional /cause/, which is another (lower-level) Exception.

Here's an example program which demonstrates these sort of Exceptions.

#+BEGIN_SRC clojure
(defn divide-verbose
  "Divides two numbers `x` and `y`, but throws more informative Exceptions when it goes wrong.
  Returns a (double-precision) floating-point number."
  [x y]
  (try
    (double (/ x y))
    (catch Throwable cause
      (throw
        (ex-info
          (str "Failed to divide " (pr-str x) " by " (pr-str y))
          {:numerator x
           :denominator y}
          cause)))))

(defn average
  "Computes the average of a collection of numbers."
  [numbers]
  (try
    (let [sum (apply + numbers)
          cardinality (count numbers)]
      (divide-verbose sum cardinality))
    (catch Throwable cause
      (throw
        (ex-info
          "Failed to compute the average of numbers"
          {:numbers numbers}
          cause)))))
#+END_SRC

We don't know it yet, but our ~average~ function fails when applied to
an empty collection of numbers. However, visualizing the Exception makes
it easy to diagnose. In the below REPL session, we can see that we
calling our function with an empty vector of numbers led to dividing
zero by zero:

#+BEGIN_EXAMPLE
user=> (average [])
Execution error (ArithmeticException) at user/divide-verbose (REPL:6).
Divide by zero
user=> *e  ;; notice the `:data` key inside the chain of Exceptions represented in `:via`
#error {
 :cause "Divide by zero"
 :via
 [{:type clojure.lang.ExceptionInfo
   :message "Failed to compute the average of numbers"
   :data {:numbers []}
   :at [user$average invokeStatic "NO_SOURCE_FILE" 10]}
  {:type clojure.lang.ExceptionInfo
   :message "Failed to divide 0 by 0"
   :data {:numerator 0, :denominator 0}
   :at [user$divide_verbose invokeStatic "NO_SOURCE_FILE" 9]}
  {:type java.lang.ArithmeticException
   :message "Divide by zero"
   :at [clojure.lang.Numbers divide "Numbers.java" 188]}]
 :trace
 [[clojure.lang.Numbers divide "Numbers.java" 188]
  [user$divide_verbose invokeStatic "NO_SOURCE_FILE" 6]
  [user$divide_verbose invoke "NO_SOURCE_FILE" 1]
  [user$average invokeStatic "NO_SOURCE_FILE" 7]
  [user$average invoke "NO_SOURCE_FILE" 1]
  [user$eval173 invokeStatic "NO_SOURCE_FILE" 1]
  [user$eval173 invoke "NO_SOURCE_FILE" 1]
  [clojure.lang.Compiler eval "Compiler.java" 7176]
  [clojure.lang.Compiler eval "Compiler.java" 7131]
  [clojure.core$eval invokeStatic "core.clj" 3214]
  [clojure.core$eval invoke "core.clj" 3210]
  [clojure.main$repl$read_eval_print__9068$fn__9071 invoke "main.clj" 414]
  [clojure.main$repl$read_eval_print__9068 invoke "main.clj" 414]
  [clojure.main$repl$fn__9077 invoke "main.clj" 435]
  [clojure.main$repl invokeStatic "main.clj" 435]
  [clojure.main$repl_opt invokeStatic "main.clj" 499]
  [clojure.main$main invokeStatic "main.clj" 598]
  [clojure.main$main doInvoke "main.clj" 561]
  [clojure.lang.RestFn invoke "RestFn.java" 397]
  [clojure.lang.AFn applyToHelper "AFn.java" 152]
  [clojure.lang.RestFn applyTo "RestFn.java" 132]
  [clojure.lang.Var applyTo "Var.java" 705]
  [clojure.main main "main.java" 37]]}
#+END_EXAMPLE

**** Graphical and web-based visualizations

Finally, the REPL being a full-featured programming environment, it is
not limited to text-based visualizations. Here are some handy
"graphical" visualization tools bundled Clojure:

[[clojure:java/javadoc.clj][clojure.java.javadoc]] lets you view the [[https://en.wikipedia.org/wiki/Javadoc][Javadoc]] of a class or
object. Here is how to view the Javadoc for a Java [[https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html][regex Pattern]]:

#+BEGIN_EXAMPLE
user=> (require '[clojure.java.javadoc :as jdoc])
nil
user=> (jdoc/javadoc #"a+") ;; opens the Javadoc page for java.util.Pattern in a Web browser
true
user=> (jdoc/javadoc java.util.regex.Pattern) ;; equivalent to the above
true
#+END_EXAMPLE

[[clojure:inspector.clj][clojure.inspector]] lets you open GUI-based visualizations of data, for
instance:

#+BEGIN_EXAMPLE
user=> (require '[clojure.inspector :as insp])
nil
user=> (insp/inspect-table (mapv number-summary [2 5 6 28 42]))
#object[javax.swing.JFrame 0x26425897 "javax.swing.JFrame[frame1,0,23,400x600,layout=java.awt.BorderLayout,title=Clojure Inspector,resizable,normal,defaultCloseOperation=HIDE_ON_CLOSE,rootPane=javax.swing.JRootPane[,0,22,400x578,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]
#+END_EXAMPLE

[[./assets/images/content/guides/repl/clj-inspect-table.png]]

[[clojure:java/browse.clj::(defn browse-url][clojure.java.browse/browse-url]] lets you open any URL in a Web browser,
which can be handy for specific needs.

Finally, there also exist 3rd-party Clojure tools for data
visualization; we will see a selection of them in chapter [[#content/guides/repl/enhancing_your_repl_workflow][Enhancing
your REPL workflow]].

**** Dealing with mysterious values (advanced)

Sometimes, the printed representation of a value in the REPL is not very
informative; sometimes, it can even be misleading as to the nature of
that value.[fn:value_repl] This often happens with values which are
obtained via Java interop.

As an example, we'll create an InputStream object using the
[[https://clojuredocs.org/clojure.java.io][clojure.java.io]] lib. If you don't know what an InputStream is, all the
better - the point of this section is to teach you how to find your
footing in uncharted territory:

#+BEGIN_EXAMPLE
user=> (require '[clojure.java.io :as io])
nil
user=> (def v (io/input-stream "https://www.clojure.org")) ;; NOTE won't work if you're not connected to the Internet
#'user/v
user=> v
#object[java.io.BufferedInputStream 0x4ee37ca3 "java.io.BufferedInputStream@4ee37ca3"]
#+END_EXAMPLE

The above code sample defined an InputStream named ~v~.

Now imagine you don't know where ~v~ comes from, and let's try to
interact with it at the REPL so as to gain more understanding of it.

[fn:value_repl] For instance, [[https://docs.datomic.com/on-prem/entities.html][Datomic]] and [[https://github.com/tonsky/datascript][DataScript]] Entity objects
are printed like Clojure maps, even though they are significantly
different from ordinary maps.

***** Viewing the type hierarchy using ~type~ and ~ancestors~

The printed representation of ~v~ tells us one thing about it: its
/runtime type/, in this case ~java.io.BufferedInputStream~. The /type/
of a value can help us know what operations we may call on it. We can
evaluate ~(type v)~ to obtain the /concrete type/ of ~v~, and
~(ancestors (type v))~ to obtain its entire /type hierarchy:/

#+BEGIN_EXAMPLE
user=> (type v) ;; what is the type of our obscure value?
java.io.BufferedInputStream
user=> (ancestors (type v))
#{java.io.InputStream java.lang.AutoCloseable java.io.Closeable java.lang.Object java.io.FilterInputStream}
#+END_EXAMPLE

***** Using Javadoc

As we saw in the previous section, we can use the [[clojure:java/javadoc.clj][clojure.java.javadoc]]
lib to view online documentation about a Java type:

#+BEGIN_EXAMPLE
user=> (require '[clojure.java.javadoc :as jdoc])
nil
user=> (jdoc/javadoc java.io.InputStream) ;; should open a web page about java.io.InputStream
true
#+END_EXAMPLE

***** Inspecting Java types with ~clojure.reflect~

Javadoc is helpful, but sometimes Javadoc won't even be available. In
such cases, we can use the REPL itself to inspect types, via Java
reflection.

We can use the ~clojure.reflect/reflect~ function to obtain information
about a Java type as a plain Clojure data structure:

#+BEGIN_EXAMPLE
user=> (require '[clojure.reflect :as reflect])
nil
user=> (reflect/reflect java.io.InputStream)
{:bases #{java.lang.Object java.io.Closeable}, :flags #{:public :abstract}, :members #{#clojure.reflect.Method{:name close, :return-type void, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [java.io.IOException], :flags #{:public}} #clojure.reflect.Method{:name mark, :return-type void, :declaring-class java.io.InputStream, :parameter-types [int], :exception-types [], :flags #{:public :synchronized}} #clojure.reflect.Method{:name available, :return-type int, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [java.io.IOException], :flags #{:public}} #clojure.reflect.Method{:name read, :return-type int, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [java.io.IOException], :flags #{:public :abstract}} #clojure.reflect.Method{:name markSupported, :return-type boolean, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [], :flags #{:public}} #clojure.reflect.Field{:name MAX_SKIP_BUFFER_SIZE, :type int, :declaring-class java.io.InputStream, :flags #{:private :static :final}} #clojure.reflect.Constructor{:name java.io.InputStream, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [], :flags #{:public}} #clojure.reflect.Method{:name read, :return-type int, :declaring-class java.io.InputStream, :parameter-types [byte<>], :exception-types [java.io.IOException], :flags #{:public}} #clojure.reflect.Method{:name skip, :return-type long, :declaring-class java.io.InputStream, :parameter-types [long], :exception-types [java.io.IOException], :flags #{:public}} #clojure.reflect.Method{:name reset, :return-type void, :declaring-class java.io.InputStream, :parameter-types [], :exception-types [java.io.IOException], :flags #{:public :synchronized}} #clojure.reflect.Method{:name read, :return-type int, :declaring-class java.io.InputStream, :parameter-types [byte<> int int], :exception-types [java.io.IOException], :flags #{:public}}}}
#+END_EXAMPLE

Now, that is a /very/ hairy data structure. Fortunately, we have learned
how to deal with hairy data structures in the [[#content/guides/repl/data_visualization_at_the_repl#pretty-printing-using-clojure.pprint][first section]] of this
chapter: pretty-printing to the rescue! Let's use pretty-printing to
display the methods exposed by ~java.io.InputStream~ in a table:

#+BEGIN_EXAMPLE
user=> (->> (reflect/reflect java.io.InputStream) :members (sort-by :name) (pp/print-table [:name :flags :parameter-types :return-type]))

|                :name |                     :flags | :parameter-types | :return-type |
|----------------------+----------------------------+------------------+--------------|
| MAX_SKIP_BUFFER_SIZE | #{:private :static :final} |                  |              |
|            available |                 #{:public} |               [] |          int |
|                close |                 #{:public} |               [] |         void |
|  java.io.InputStream |                 #{:public} |               [] |              |
|                 mark |   #{:public :synchronized} |            [int] |         void |
|        markSupported |                 #{:public} |               [] |      boolean |
|                 read |       #{:public :abstract} |               [] |          int |
|                 read |                 #{:public} |         [byte<>] |          int |
|                 read |                 #{:public} | [byte<> int int] |          int |
|                reset |   #{:public :synchronized} |               [] |         void |
|                 skip |                 #{:public} |           [long] |         long |
nil
#+END_EXAMPLE

For example, this tells us that we can call a ~.read~ method on ~v~ with
no arguments, which will return an ~int~:

#+BEGIN_EXAMPLE
user=> (.read v)
60
user=> (.read v)
33
user=> (.read v)
68
#+END_EXAMPLE

Without any prior knowledge, we have managed to learn that ~v~ is an
InputStream, and read bytes from it.

*** Programming at the REPL: Navigating Namespaces
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/navigating_namespaces.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/navigating_namespaces
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-02-10
:PREVPAGE_CUSTOM_ID: content/guides/repl/data_visualization_at_the_repl
:NEXTPAGE_CUSTOM_ID: content/guides/repl/enhancing_your_repl_workflow
:CUSTOM_ID: content/guides/repl/navigating_namespaces
:END:

So far we have only used the REPL for small self-contained experiments;
but the REPL is most valuable for *putting yourself in the shoes of
the program* you are developing or debugging, i.e evaluating exactly the
same expressions in the REPL as your program does when it runs.

This is achieved by giving your REPL the same context as your running
program, which implies using REPL in the same [[#content/reference/namespaces][namespaces]] where your
code is defined. We will see how to do that in the following
sections.

*NOTE:* Namespaces are one of the trickiest parts of Clojure. If you're
just learning the language, feel free to skip this chapter for now; you
can come back to it when you start working on 'real-world' Clojure
projects.

**** The current namespace

When you evaluate code in the REPL, you are always evaluating code in
the context of the /current namespace/.

*The current namespace determines:*

- *How the code that you are writing may refer to code from other
  namespaces.*

For example, if the current namespace is ~myapp.foo.bar~ and you
evaluate ~(require [clojure.set :as cset :refer [union]])~, you can now
refer to the ~clojure.set/union~ Var either by ~cset/union~ (because of
the ~:as cset~ alias) or just ~union~ (because of ~:refer [union]~):

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=> *ns*
#object[clojure.lang.Namespace 0x7d1cfb8b "user"]
user=> (ns myapp.foo.bar) ;; creating and switching to the myapp.foo.bar namespace - `ns` will be explained later in this guide.
nil
myapp.foo.bar=> (require '[clojure.set :as cset :refer [union]]) ;; this will only affect the current namespace
nil
myapp.foo.bar=> (cset/union #{1 2} #{2 3})
#{1 3 2}
myapp.foo.bar=> (union #{1 2} #{2 3})
#{1 3 2}
myapp.foo.bar=> (cset/intersection #{1 2} #{2 3})
#{2}
myapp.foo.bar=> (in-ns 'user) ;; now switching back to the `user` namespace - `in-ns` will be explained later in this guide.
#object[clojure.lang.Namespace 0x7d1cfb8b "user"]
user=> (union #{1 2} #{2 3})  ;; won't work, because `union` has not been :refer'ed in the `user` namespace
Syntax error compiling at (REPL:1:1).
Unable to resolve symbol: union in this context
user=> (cset/intersection #{1 2} #{2 3}) ;; won't work, because the `cset` alias has not been defined in the current namespace.
Syntax error compiling at (REPL:1:1).
No such namespace: cset
user=>
#+END_EXAMPLE

#+BEGIN_QUOTE
*Tip*

*TIP:* You can find what aliases are defined in a given namespace by
calling [[https://clojuredocs.org/clojure.core/ns-aliases][ns-aliases]].

#+BEGIN_EXAMPLE
    myapp.foo.bar=> (ns-aliases 'myapp.foo.bar)
    {cset #object[clojure.lang.Namespace 0x4b2a01d4 "clojure.set"]}
#+END_EXAMPLE
#+END_QUOTE

- *In what namespace the Vars that you define (using for example
  ~(def …​)~ or ~(defn …​)~) will exist.*

For example, if the current namespace is ~myapp.foo.bar~ and you define
a Var named ~my-favorite-number~, you will be able to reference that Var
as ~myapp.foo.bar/my-favorite-number~ from other namespaces:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=> (ns myapp.foo.bar) ;; creating and switching to the `myapp.foo.bar` namespace - NOTE `ns` will be explained later in this guide
nil
myapp.foo.bar=> (def my-favorite-number 42) ;; defining a Var named `my-favorite-number`
#'myapp.foo.bar/my-favorite-number
myapp.foo.bar=> my-favorite-number
42
myapp.foo.bar=> (ns myapp.baz) ;; creating and switching to another namespace `myapp.baz`
nil
myapp.baz=> myapp.foo.bar/my-favorite-number ;; referring to `my-favorite-number`
42
myapp.baz=> (require '[myapp.foo.bar :as foobar]) ;; we can also use an alias to make it shorter
nil
myapp.baz=> foobar/my-favorite-number
42
#+END_EXAMPLE

#+BEGIN_QUOTE
*Note*

You can find what the current namespace is by evaluating ~*ns*~:

#+BEGIN_EXAMPLE
    $ clj
    Clojure 1.10.0
    user=> *ns*
    #object[clojure.lang.Namespace 0x7d1cfb8b "user"]
#+END_EXAMPLE

As you can see, by default, when you start a REPL with ~clj~, the
current namespace is ~user~.
#+END_QUOTE

**** Creating a namespace with ~ns~

You can create and switch to a new namespace by evaluating
~(ns MY-NAMESPACE-NAME)~:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=> (ns myapp.foo-bar)
nil
myapp.foo-bar=> *ns*
#object[clojure.lang.Namespace 0xacdb094 "myapp.foo-bar"]
myapp.foo-bar=> (def x 42)
#'myapp.foo-bar/x
#+END_EXAMPLE

*Note:* when you switch to a new namespace, the names and aliases that
were defined in the previous namespaces are no longer available:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=> (ns myapp.ns1) ;; creating a new namespace and defining a Var `x` and an alias `str/`:
nil
myapp.ns1=> (def x 42)
#'myapp.ns1/x
myapp.ns1=> x
42
myapp.ns1=> (require '[clojure.string :as str])
nil
myapp.ns1=> (str/upper-case "hello")
"HELLO"
myapp.ns1=> (ns myapp.ns2) ;; now switching to another namespace:
nil
myapp.ns2=> x ;; won't work, because x has not been defined in namespace `myapp.ns2`
Syntax error compiling at (REPL:0:0).
Unable to resolve symbol: x in this context
myapp.ns2=> (str/upper-case "hello") ;; won't work, because alias `str` has not been defined in namespace `myapp.ns2`
Syntax error compiling at (REPL:1:1).
No such namespace: str
#+END_EXAMPLE

**** Switching to an existing namespace with ~in-ns~

You can switch to an existing namespace by evaluating
~(in-ns 'MY-NAMESPACE-NAME)~. Here's an example REPL session that
creates a namespace ~myapp.some-ns~, defines a Var named ~x~ in it,
moves back to the ~user~ namespace, then moves again to ~myapp.some-ns~:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=> (ns myapp.some-ns) ;;;; creating the namespace `myapp.some-ns`
nil
myapp.some-ns=> *ns* ;; where are we?
#object[clojure.lang.Namespace 0xacdb094 "myapp.some-ns"]
myapp.some-ns=> (def x 42) ;; defining `x`
#'myapp.some-ns/x
myapp.some-ns=> (in-ns 'user) ;;;; switching back to `user`
#object[clojure.lang.Namespace 0x4b45dcb8 "user"]
user=> *ns* ;; where are we?
#object[clojure.lang.Namespace 0x4b45dcb8 "user"]
user=> (in-ns 'myapp.some-ns) ;;;; ...switching back again to `myapp.some-ns`
#object[clojure.lang.Namespace 0xacdb094 "myapp.some-ns"]
myapp.some-ns=> *ns* ;; where are we?
#object[clojure.lang.Namespace 0xacdb094 "myapp.some-ns"]
myapp.some-ns=> x ;; `x` is still here!
42
#+END_EXAMPLE

*What happens if you ~in-ns~ to a namespace that has never been
created?* You will see strange things happening. For instance, you will
not be able to define a function using ~defn~:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=> (in-ns 'myapp.never-created)
#object[clojure.lang.Namespace 0x22356acd "myapp.never-created"]
myapp.never-created=> (defn say-hello [x] (println "Hello, " x "!"))
Syntax error compiling at (REPL:1:1).
Unable to resolve symbol: defn in this context
#+END_EXAMPLE

*Explanation:* in this situation, [[clojure:core.clj::(alter-meta! #'in-ns][in-ns]] creates the new namespace and
switches to it like [[clojure:core.clj::(defmacro ns][ns]] does, but it does a little less work than [[clojure:core.clj::(defmacro ns][ns]],
because it does not automatically make available all the names defined
in ~clojure.core~, such as [[clojure:core.clj::defn (fn defn][defn]].

You can fix that by evaluating ~(clojure.core/refer-clojure)~:

#+BEGIN_EXAMPLE
myapp.never-created=> (clojure.core/refer-clojure)
nil
myapp.never-created=> (defn say-hello [x] (println "Hello, " x "!"))
#'myapp.never-created/say-hello
myapp.never-created=> (say-hello "Jane")
Hello,  Jane !
nil
#+END_EXAMPLE

If you only use [[clojure:core.clj::(alter-meta! #'in-ns][in-ns]] to switch to namespaces that have already been
created, you won't have to deal with these subtleties.

**** Working with libs
:PROPERTIES:
:CUSTOM_ID: content/guides/repl/annex_community_resources#working-with-libs
:END:

Most of the namespaces you will navigate at the REPL will already
exist in source files or dependencies of your project, i.e in [[#content/reference/libs][libs]] of
your project.

There is an important usage precaution for switching to namespaces
defined in libs:

#+BEGIN_QUOTE
*Note*

*If a namespace is defined in a [[#content/reference/libs][lib]] of your project, always make sure
you have /loaded/ the lib in the REPL before switching to it.*
#+END_QUOTE

***** How to make sure a lib is loaded
:PROPERTIES:
:CUSTOM_ID: content/guides/repl/navigating_namespaces#how-to-make-sure-a-lib-is-loaded
:END:

To make sure that a lib with namespace ~mylib.ns1~ has been loaded in
the REPL, you can do any one of the following:

1. ~require~ it directly: ~(require '[mylib.ns1])~
2. load a namespace which itself requires ~mylib.ns1~ (directly or
   indirectly).
3. evaluate manually all the code in the source file ~mylib.ns1~

***** Example: a project for greeting people

For example, assume a Clojure project with the following structure and
content:

#+BEGIN_EXAMPLE
.
└── src
    └── myproject
        ├── person_names.clj
        └── welcome.clj
#+END_EXAMPLE

#+BEGIN_SRC clojure
;; -----------------------------------------------
;; src/myproject/welcome.clj
(ns myproject.welcome
  (:require [myproject.person-names :as pnames])) ;; NOTE: `myproject.welcome` requires `myproject.person-names`

(defn greet
  [first-name last-name]
  (str "Hello, " (pnames/familiar-name first-name last-name)))


;; -----------------------------------------------
;; src/myproject/person_names.clj
(ns myproject.person-names
  (:require [clojure.string :as str]))

(def nicknames
  {"Robert"     "Bob"
   "Abigail"    "Abbie"
   "William"    "Bill"
   "Jacqueline" "Jackie"})

(defn familiar-name
  "What to call someone you may be familiar with."
  [first-name last-name]
  (let [fname (str/capitalize first-name)
        lname (str/capitalize last-name)]
    (or
      (get nicknames fname)
      (str fname " " lname))))
#+END_SRC

Here are 3 ways to make sure ~myproject.person-names~ is loaded:

#+BEGIN_EXAMPLE
$ clj ## APPROACH 1: requiring myproject.person-names directly
Clojure 1.10.0
user=> (require '[myproject.person-names])
nil
user=> myproject.person-names/nicknames ;; checking that the myproject.person-names was loaded.
{"Robert" "Bob", "Abigail" "Abbie", "William" "Bill", "Jacqueline" "Jackie"}
#+END_EXAMPLE

#+BEGIN_EXAMPLE
$ clj ## APPROACH 2: requiring myproject.welcome, which itself requires myproject.person-names
Clojure 1.10.0
user=> (require '[myproject.welcome])
nil
user=> myproject.person-names/nicknames ;; checking that the myproject.person-names was loaded.
{"Robert" "Bob", "Abigail" "Abbie", "William" "Bill", "Jacqueline" "Jackie"}
#+END_EXAMPLE

#+BEGIN_EXAMPLE
$ clj ## APPROACH 3: manually copying the code of myproject.person-names in the REPL.
Clojure 1.10.0
(ns myproject.person-names
  (:require [clojure.string :as str]))

(def nicknames
  {"Robert"     "Bob"
   "Abigail"    "Abbie"
   "William"    "Bill"
   "Jacqueline" "Jackie"})

(defn familiar-name
  "What to call someone you may be familiar with."
  [first-name last-name]
  (let [fname (str/capitalize first-name)
        lname (str/capitalize last-name)]
    (or
      (get nicknames fname)
      (str fname " " lname))))
nil
myproject.person-names=> myproject.person-names=> #'myproject.person-names/nicknames
myproject.person-names=> myproject.person-names=> #'myproject.person-names/familiar-name
myproject.person-names=> myproject.person-names/nicknames ;; checking that the myproject.person-names was loaded.
{"Robert" "Bob", "Abigail" "Abbie", "William" "Bill", "Jacqueline" "Jackie"}
#+END_EXAMPLE

#+BEGIN_QUOTE
*Tip*

*TIP:* you can see (among other things) what libs get loaded by using
the ~:verbose~ tag in ~require~:

#+BEGIN_EXAMPLE
    $ clj
    Clojure 1.10.0
    user=> (require '[myproject.welcome] :verbose)
    (clojure.core/load "/myproject/welcome")
    (clojure.core/in-ns 'clojure.core.specs.alpha)
    (clojure.core/alias 's 'clojure.spec.alpha)
    (clojure.core/load "/myproject/person_names")
    (clojure.core/in-ns 'myproject.person-names)
    (clojure.core/alias 'str 'clojure.string)
    (clojure.core/in-ns 'myproject.welcome)
    (clojure.core/alias 'pnames 'myproject.person-names)
    nil
#+END_EXAMPLE
#+END_QUOTE

***** How things can go wrong

Continuing with the above example project, here is a REPL session
showing how things can go wrong if you switch to a lib namespace without
loading it first:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=> (ns myproject.person-names)
nil
myproject.person-names=> nicknames ;; #'nicknames won't be defined, because the lib has not been loaded.
Syntax error compiling at (REPL:0:0).
Unable to resolve symbol: nicknames in this context
myproject.person-names=> (require '[myproject.person-names]) ;; won't fix the situation, because the namespaces has already been created
nil
myproject.person-names=> nicknames
Syntax error compiling at (REPL:0:0).
Unable to resolve symbol: nicknames in this context
#+END_EXAMPLE

*** Programming at the REPL: Enhancing your REPL workflow
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/enhancing_your_repl_workflow.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/enhancing_your_repl_workflow
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-02-10
:PREVPAGE_CUSTOM_ID: content/guides/repl/navigating_namespaces
:NEXTPAGE_CUSTOM_ID: content/guides/repl/guidelines_for_repl_aided_development
:CUSTOM_ID: content/guides/repl/enhancing_your_repl_workflow
:END:

At this point, you know enough to understand how the REPL works; we'll
now focus on giving you a more streamlined development experience with
the REPL. There are a variety of things you may want to improve:

#+BEGIN_QUOTE
*Switching between my editor and the REPL is tedious.*
#+END_QUOTE

Most Clojure programmers don't use the terminal-based REPL for
everyday development: instead, they use a REPL integration in their
editor, which enables them to write expressions directly in their
editor buffer and have them evaluated in the REPL with one hotkey. See
the [[#content/guides/repl/annex_community_resources#editor-integrations][Editor integrations]] section below for more details.

#+BEGIN_QUOTE
*I want to do small experiments in Clojure, but it's painful to write
code in the default CLI tool.*
#+END_QUOTE

As mentioned above, one solution could be to use an [[#content/guides/repl/annex_community_resources#editor-integrations][editor
integration]]. Note that some editors such as *[[https://sekao.net/nightcode/][Nightcode]]* are designed
specifically to provide a 'batteries-included' experience for
Clojure.

However, if setting up an editor is too heavy for your taste, there also
exist more ergonomic terminal REPL clients:

- *[[https://github.com/bhauman/rebel-readline][rebel-readline]]* is a terminal readline library made by Bruce
  Hauman. If you have already installed the [[#content/reference/deps_and_cli][Clojure CLI tools]], you can
  launch it in [[https://github.com/bhauman/rebel-readline#quick-try][one line at the terminal]] without any additional
  installation steps.
- *[[https://github.com/Unrepl/unravel][Unravel]]* by Paulus Esterhazy is another option, based on the [[https://github.com/Unrepl/unrepl][unrepl]]
  communication protocol.

#+BEGIN_QUOTE
*I need to debug a program I'm running from the REPL.* #+END_QUOTE

The REPL can definitely help you do that: see the [[#content/guides/repl/annex_community_resources#debugging-tools-and-techniques][Debugging Tools and
Techniques]] section below.

#+BEGIN_QUOTE
*I find myself repeating a lot of manual steps at the REPL for
running my development environment.*
#+END_QUOTE

Consider creating a 'dev' namespace in your project (e.g
~myproject.dev~) in which you define functions for automating common
development tasks (for example: starting a local web server, running a
database query, turning on/off email sending, etc.)

#+BEGIN_QUOTE
*When I make changes to my code, it's often difficult to reflect that
change in my running program: I have to do a lot of manual work in the
REPL to make it happen..*
#+END_QUOTE

Depending on the choices you make when writing your programs,
interacting with them at the REPL will become more or less practical.
See the [[#content/guides/repl/annex_community_resources#writing-repl-friendly-programs][Writing REPL-friendly programs]] section below.

#+BEGIN_QUOTE
*I would like to save my REPL sessions in a 'notebook' format.*
#+END_QUOTE

[[http://gorilla-repl.org/][Gorilla REPL]] was made for this very purpose.

#+BEGIN_QUOTE
*I want better data visualization than what the REPL provides.*
#+END_QUOTE

You may get improved visualization features from a specialized Clojure
editor: see the [[#content/guides/repl/annex_community_resources#editor-integrations][Editor Integrations]] section below.

Having said that, keep in mind that the REPL is a full-feature execution
environment: in particular, you can use it to launch special-purpose
visualization tools (including ones that you develop yourself). For
instance:

- *[[https://vlaaad.github.io/reveal/][Reveal]]* and *[[https://docs.datomic.com/cloud/other-tools/REBL.html][Cognitect REBL]]* are graphical tools for navigating and
  visualizing Clojure data, supporting two-way interaction with
  Clojure REPLs.
- *[[https://github.com/metasoarous/oz][oz]]* is a Clojure library for displaying numerical charts
- *[[https://github.com/eggsyntax/datawalk][datawalk]]* is a Clojure library for interactively exploring complex
  Clojure data structures
- *[[https://github.com/walmartlabs/system-viz][system-viz]]* is a Clojure library for visualizing the components of a
  running Clojure system

#+BEGIN_QUOTE
*I want to customize my REPL.*
#+END_QUOTE

You can usually customize how your REPL reads, evaluates and prints, but
the method to do it depends on your toolchain. For instance:

- when using a REPL started from [[#content/reference/repl_and_main][clojure.main]] (as is the case when
  using the ~clj~ tool) you can customize the REPL by launching a
  'sub-REPL': see [[clojure:main.clj::368][clojure.main/repl]].
- when using [[https://nrepl.org][nREPL]].[fn:nrepl_2018], this can be done by writing custom
  [[https://nrepl.org/nrepl/design/middleware.html][middleware]].

#+BEGIN_QUOTE
*I want to use the REPL to connect to a live production system.* #+END_QUOTE

The Clojure [[#content/reference/repl_and_main#launching-a-socket-server][socket server]] feature can be used to that end. Tools like
*[[https://nrepl.org][nREPL]]* and *[[https://github.com/Unrepl/unrepl][unrepl]]* can be used to provide a richer experience.

#+BEGIN_QUOTE
*Warning*

*NOTE: You may not need all of this!*

Depending on your projects and personal taste, you will most likely
use only a fraction of the tools and techniques presented in this
section. It's important to know that these options exist, but don't
try to adopt all of them at once!
#+END_QUOTE

**** Editor integrations
:PROPERTIES:
:CUSTOM_ID: content/guides/repl/annex_community_resources#editor-integrations
:END:

All [[#content/community/tools#editors][major Clojure editors]] support a way of evaluating code in the REPL
without leaving the current code buffer, which reduces the amount of
context switching a programmer has to do. Here's what it looks like
(the editor used in this example is [[https://cursive-ide.com/userguide/repl.html][Cursive]]):

[[./assets/images/content/guides/repl/cursive-repl-demo.gif]]

#+BEGIN_QUOTE
*Tip*

*TIP:* You can wrap some expressions in a ~(comment …​)~ block so that
they don't get evaluated by accident when the file is loaded:

#+BEGIN_SRC clojure
    ;; you would NOT want this function to get called by accident.
    (defn transfer-money!
      [from-accnt to-accnt amount]
      ...)

    (comment
      (transfer-money! "accnt243251" "accnt324222" 12000)
      )
#+END_SRC
#+END_QUOTE

***** What to expect from an in-editor REPL integration?

Here are some common editor commands provided by REPL integrations. All
major Clojure editors support a majority of them:

- *Send form before caret to REPL:* evaluate the expression before the
  cursor in the REPL, in the namespace of the current file. Useful for
  experimenting in the context of the current namespace.
- *Send top-level form to REPL:* evaluate the biggest expression in
  which the cursor is currently contained -typically a ~(defn …​)~ or
  ~(def …​)~ expression-in the namespace of the current file. Useful
  for defining or re-defining Vars in a namespace.
- *Load the current file in the REPL.* Useful to avoid [[#content/guides/repl/annex_community_resources#working-with-libs][loading libs
  manually]].
- *Switch the REPL's namespace to current file:* useful to avoid typing
  ~(in-ns '…​)~.
- *Show evaluation inline:* displays the evaluation of the current
  expression next to it.
- *Replace expression with its evaluation:* replaces the current
  expression in the editor with its evaluation (as printed by the
  REPL).

**** Debugging tools and techniques
:PROPERTIES:
:CUSTOM_ID: content/guides/repl/annex_community_resources#debugging-tools-and-techniques
:END:

While traditional debuggers can be used with Clojure, the REPL itself is
a powerful debugging environment, because it lets you inspect and alter
the flow of a running program. In this section, we'll study some tools
and techniques to leverage the REPL for debugging.

***** Printing in-flight values with ~prn~

~(prn …​)~ expressions can be added in strategic places in your code to
print intermediary values:

#+BEGIN_EXAMPLE
(defn average
  "a buggy function for computing the average of some numbers."
  [numbers]
  (let [sum (first numbers)
        n (count numbers)]
    (prn sum) ;; HERE printing an intermediary value
    (/ sum n)))
#'user/average
user=> (average [12 14])
12 ## HERE
6
#+END_EXAMPLE

#+BEGIN_QUOTE
*Tip*

*TIP:* you can combine prn with the ~(doto …​)~ macro, i.e
~(doto MY-EXPR prn)~, to make adding ~prn~ calls less invasive:

#+BEGIN_SRC clojure
    (defn average
      "a buggy function for computing the average of some numbers."
      [numbers]
      (let [sum (first numbers)
            n (count numbers)]
        (/
          (doto sum prn) ;; HERE
          n)))
#+END_SRC
#+END_QUOTE

****** Going further: 'spying' macros

Some Clojure libraries provide 'enhanced' versions of ~prn~ that are
more informative, by also printing information about the wrapped
expression. For example:

- the *[[https://github.com/clojure/tools.logging][tools.logging]]* logging library provides a [[http://clojure.github.io/tools.logging/#clojure.tools.logging/spy][spy]] macro to log an
  expression's code along with its value
- the *[[https://github.com/dgrnbrg/spyscope][spyscope]]* library lets you to insert these printing calls with
  very lightweight syntax.

****** Going further: tracing libraries

/Tracing/ libraries such as *[[https://github.com/clojure/tools.trace][tools.trace]]* and *[[https://github.com/clojure-emacs/sayid][Sayid]]* can help you
instrument larger portions of your code, for example by automatically
printing all the function calls in a given namespace, or all
intermediary values in a given expression.

***** Intercepting and saving values on-the-fly

Sometimes you want to do more with intermediary values than just print
them: you want to save them to conduct further experiments on them at
the REPL. This can be done by inserting a ~(def …​)~ call inside the
expression where the value appears:

#+BEGIN_SRC clojure
(defn average
  [numbers]
  (let [sum (apply + numbers)
        n (count numbers)]
    (def n n) ;; FIXME remove when you're done debugging
    (/ sum n)))
#+END_SRC

#+BEGIN_EXAMPLE
user=> (average [1 2 3])
2
user=> n
3
#+END_EXAMPLE

This 'inline-def' technique is described in more depth in [[https://blog.michielborkent.nl/2017/05/25/inline-def-debugging/][this blog
post by Michiel Borkent]].

***** Reproducing the context of an expression

When debugging at the REPL, we often want to reproduce manually
something that our program did automatically, that is evaluating some
expressions inside a function body. To do that, we need to recreate the
context of the expressions of interest: one trick to achieve that is to
define Vars (using ~def~) with the same names and values as the locals
used by the expressions. The 'physics' example below illustrates this
approach:

#+BEGIN_SRC clojure
(def G 6.67408e-11)
(def earth-radius 6.371e6)
(def earth-mass 5.972e24)

(defn earth-gravitational-force
  "Computes (an approximation of) the gravitational force between Earth and an object
  of mass `m`, at distance `r` of Earth's center."
  [m r]
  (/
    (*
      G
      m
      (if (>= r earth-radius)
        earth-mass
        (*
          earth-mass
          (Math/pow (/ r earth-radius) 3.0))))
    (* r r)))

;;;; calling our function for an object of 80kg at distance 5000km.
(earth-gravitational-force 80 5e6) ; => 616.5217226636292

;;;; recreating the context of our call
(def m 80)
(def r 5e6)
;; note: the same effect could be achieved using the 'inline-def' technique described in the previous section.

;;;; we can now directly evaluate any expression in the function body:
(* r r) ; ~> 2.5E13
(>~ r earth-radius) ; => false
(Math/pow (/ r earth-radius) 3.0) ; => 0.48337835316173317
#+END_SRC

This technique is described in more depth in Stuart Halloway's article
[[http://blog.cognitect.com/blog/2017/6/5/repl-debugging-no-stacktrace-required][REPL Debugging: No Stacktrace Required]]. The *[[https://github.com/vvvvalvalval/scope-capture][scope-capture]]* library was
made to automate the manual task of saving and re-creating the context
of an expression.

***** Community resources about REPL debugging

- [[https://www.clojure-toolbox.com/][The Clojure Toolbox]] provides a list a Clojure libraries for
  debugging.
- [[https://cambium.consulting/articles/2018/2/8/the-power-of-clojure-debugging][The Power of Clojure: debugging]] is an article by Cambium Consulting
  which provides a list of techniques for debugging at the REPL.
- /Clojure From the Ground Up/ by Aphyr contains a [[https://aphyr.com/posts/319-clojure-from-the-ground-up-debugging][chapter about
  debugging]], presenting techniques for debugging Clojure in particular
  and a principled approach to debugging in general.
- In his article
  [[http://blog.cognitect.com/blog/2017/6/5/repl-debugging-no-stacktrace-required][REPL Debugging: No Stacktrace Required]], Stuart Halloway demonstrates
  how the quick feedback loop at the REPL can be used to narrow down
  the cause of a bug without using error information at all.
- Eli Bendersky has written some [[https://eli.thegreenplace.net/2017/notes-on-debugging-clojure-code/#id3][Notes on debugging Clojure code]].
- [[https://www.youtube.com/watch?v=FihU5JxmnBg][Debugging with the Scientific Method]] is a conference talk by Stuart
  Halloway promoting a scientific approach to debugging in general.

**** Writing REPL-friendly programs
:PROPERTIES:
:CUSTOM_ID: content/guides/repl/annex_community_resources#writing-repl-friendly-programs
:END:

While interactive development at the REPL gives a lot of power to
programmers, it also adds new challenges: programs must be designed so
that they lend themselves well to REPL interaction, which is a new
constraint to be vigilant of when writing code.[fn:automated_testing]

Covering this topic extensively would take us too far for the scope of
this guide, so we will merely provide some tips and resources to guide
your own research and problem-solving.

*REPL-friendly code can be re-defined.* Code is more easily redefined
when it is called via a Var (defined e.g via ~(def …​)~ or ~(defn …​)~),
because a Var can be redefined without touching the code that calls it.
This is illustrated in the following example, which prints some numbers
at a regular time interval:

#+BEGIN_SRC clojure
;; Each of these 4 code examples start a loop in another thread
;; which prints numbers at a regular time interval.

;;;; 1. NOT REPL-friendly
;; We won't be able to change the way numbers are printed without restarting the REPL.
(future
  (run!
    (fn [i]
      (println i "green bottles, standing on the wall. ♫")
      (Thread/sleep 1000))
    (range)))

;;;; 2. REPL-friendly
;; We can easily change the way numbers are printed by re-defining print-number-and-wait.
;; We can even stop the loop by having print-number-and-wait throw an Exception.
(defn print-number-and-wait
  [i]
  (println i "green bottles, standing on the wall. ♫")
  (Thread/sleep 1000))

(future
  (run!
    (fn [i] (print-number-and-wait i))
    (range)))

;;;; 3. NOT REPL-friendly
;; Unlike the above example, the loop can't be altered by re-defining print-number-and-wait,
;; because the loop uses the value of print-number-and-wait, not the #'print-number-and-wait Var.
(defn print-number-and-wait
  [i]
  (println i "green bottles, standing on the wall. ♫")
  (Thread/sleep 1000))

(future
  (run!
    print-number-and-wait
    (range)))

;;;; 4. REPL-friendly
;; The following works because a Clojure Var is (conveniently) also a function,
;; which consist of looking up its value (presumably a function) and calling it.
(defn print-number-and-wait
  [i]
  (println i "green bottles, standing on the wall. ♫")
  (Thread/sleep 1000))

(future
  (run!
    #'print-number-and-wait ;; mind the #' - the expression evaluates to the #'print-number-and-wait Var, not its value.
    (range)))
#+END_SRC

*Beware of derived Vars.* If Var ~b~ is defined in terms of the value
of Var ~a~, then you will need to re-define ~b~ each time you re-define
~a~; it may be better to define ~b~ as a 0-arity function which uses
~a~. Example:

#+BEGIN_SRC clojure
;;; NOT REPL-friendly
;; if you re-define `solar-system-planets`, you have to think of re-defining `n-planets` too.
(def solar-system-planets
  "The set of planets which orbit the Sun."
  #{"Mercury" "Venus" "Earth" "Mars" "Jupiter" "Saturn" "Uranus" "Neptune"})

(def n-planets
  "The number of planets in the solar system"
  (count solar-system-planets))


;;;; REPL-friendly
;; if you re-define `solar-system-planets`, the behaviour of `n-planets` will change accordingly.
(def solar-system-planets
  "The set of planets which orbit the Sun."
  #{"Mercury" "Venus" "Earth" "Mars" "Jupiter" "Saturn" "Uranus" "Neptune"})

(defn n-planets
  "The number of planets in the solar system"
  []
  (count solar-system-planets))
#+END_SRC

That being said, the problem of derived Vars becoming obsolete might be
satisfactorily mitigated:

1. either by making sure that Vars are not derived across different
   files, and by taking care to reload entire files when changes are
   made;
2. or by using utilities like [[https://github.com/clojure/tools.namespace#clojuretoolsnamespace][clojure.tools.namespace]], which let you
   keep track of changed files and reload them in order.

*REPL-friendly code can be reloaded.* Make sure that reloading a
namespace will not alter the behaviour of the running program. If a
Var needs to be defined exactly once (which should be very rare),
consider defining it with ~defonce~.

When dealing with a codebase with many namespaces, reloading the
appropriate namespaces in the correct order can become difficult: the
*[[https://github.com/clojure/tools.namespace][tools.namespace]]* library was made to assist the programmer in this
task.

*Program state and source code should be kept in sync.* You usually want
to make sure that your program state reflects your source code and
vice-versa, but this is not automatic. Reloading the code is often not
enough: you also need to transform the program state
accordingly. Stuart Sierra has expounded on this problem in his
article [[http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded][My Clojure Workflow, Reloaded]] and his talk [[https://www.youtube.com/watch?v=13cmHf_kt-Q][Components Just
Enough Structure]].

This has motivated the creation of *state management libraries:*

- *[[https://github.com/stuartsierra/component][Component]]*, which promotes a representation of program state as a
  managed map of Clojure records called a *system*.
- *[[https://github.com/danielsz/system][System]]* is a library on top of [[https://github.com/stuartsierra/component][Component]] which provides a set of
  ready-made components.
- *[[https://github.com/tolitius/mount][Mount]]* takes a radically different approach as Component, choosing to
  use Vars and namespaces as the supporting infrastructure for
  state.[fn:controversy]
- *[[https://github.com/weavejester/integrant][Integrant]]* is a more recent library which shares Component's approach
  while addressing some of its perceived limitations.

[fn:nrepl_2018] At the time of writing (March 2018), [[https://nrepl.org][nREPL]] is the most
popular toolchain for REPL-editor integration

[fn:automated_testing] A similar phenomenon happens with the
well-known technique of [[https://en.wikipedia.org/wiki/Software_testing][automated testing]]: while testing can bring a
lot of value to programmers, it requires extra care to write code that
is 'testable'. Just like tests, the REPL should not be an afterthought
when writing Clojure code.

[fn:controversy] At the time of writing, there is controversy in the
Clojure community regarding the relative merits of both approaches.

*** Programming at the REPL: Guidelines for REPL-Aided Development
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/guidelines_for_repl_aided_development.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/guidelines_for_repl_aided_development
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-04-14
:PREVPAGE_CUSTOM_ID: content/guides/repl/enhancing_your_repl_workflow
:NEXTPAGE_CUSTOM_ID: content/guides/repl/annex_community_resources
:CUSTOM_ID: content/guides/repl/guidelines_for_repl_aided_development
:END:

Clojure REPLs are used for a broad spectrum of purposes, from learning
the language to data exploration to live music performance. This chapter
will provide some guiding principles for applying Clojure REPLs to the
more common use case of pragmatic software development.

**** The REPL is a User Interface to your program

Programs commonly offer User Interfaces through a variety of media:

- Graphical: web pages, mobile and desktop apps
- Network-based: Web Services / HTTP APIs / ...
- Storage-based: the program keeps a database up to date, which can
  then be queried
- Command-Line Interfaces (CLI): from interaction via a terminal

You should think of the REPL as another medium for user-to-program
interaction; compared to those listed above, it requires advanced
knowledge (programming in Clojure!), but it is also extremely expressive
and cheap to develop, since it requires almost no anticipation of what
parts of the code users will want to leverage. For instance, the REPL is
a very suitable UI for /ad hoc/ data exports.

In Clojure projects, it is common practice to define functions and
namespaces solely intended for REPL interaction: consider it an
alternative to CLI, dashboards, etc.

**** Don't get carried away by the REPL

The REPL can give you a lot of velocity, but do not mistake motion for
progress. You should *always come to the REPL with a plan*, otherwise
the REPL will bring you more distraction than focus. If you find it
difficult to keep the plan in your head while using the REPL, *consider
writing it down*.

The REPL will only guide you through very incremental changes, which is
prone to getting you stuck in 'local maxima'. When more strategic
thinking is required, force yourself to take a step back. In particular,
*rapid feedback is no substitute for software design and methodic
problem-solving.*

**** Don't forget to save your work, and make it accessible

The REPL is a very ephemeral and exclusive medium. If there is anything
to take away from a REPL session, it should probably reside in other
places than your flawed human memory (for instance in code, tests,
commented-out code, documentation, data files, etc.).

If what you learned in the REPL is a prerequisite to your project, you
should do some extra work to make it accessible to other contributors
(including yourself in a few months).

**** The REPL is not the only tool for interactive development

There are other tools which provide a tight feedback loop while
programming:

- auto-reloading test suites (example: [[https://github.com/marick/Midje][Midje]])
- static code analysis tools (linters, static type checkers)
- hot-code reloading (example: [[https://github.com/bhauman/lein-figwheel][Figwheel]])
- 'visual' test suites (example: [[https://github.com/bhauman/devcards][Devcards]])

There is no reason to see these approaches as 'competing' with
REPL-aided development, and oftentimes the REPL can assist you in using
them. Each of these approaches has its strengths and weaknesses: for
instance, the REPL makes the execution of programs very tangible, but is
a poor tool for detecting breakage.

*** Programming at the REPL: Community resources about the REPL
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/annex_community_resources.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/annex_community_resources
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-02-10
:PREVPAGE_CUSTOM_ID: content/guides/repl/guidelines_for_repl_aided_development
:NEXTPAGE_CUSTOM_ID: content/guides/repl/annex_troubleshooting
:CUSTOM_ID: content/guides/repl/annex_community_resources
:END:

Here is a list of useful REPL-related resources by the Clojure
community:

- In [[https://www.youtube.com/watch?v=Qx0-pViyIDU][Running with Scissors: Live Coding with Data]] (slides [[https://github.com/stuarthalloway/presentations/wiki/Running-with-Scissors][here]]),
  Stuart Halloway presents his workflow for solving problems with the
  REPL, including little-known opportunities offered by the Clojure
  REPL without 3rd-party tools (such as custom reading). "You're
  living in your program invoking your tools, instead of living in
  your tools invoking your program".
- [[https://lambdaisland.com/guides/clojure-repls][The Ultimate Guide to Clojure REPLs]] on Lambda Island: this tutorial
  notably explores the wide variety of Clojure REPLs and related
  technology.
- [[https://vimeo.com/223309989][Stuart Halloway on REPL Driven Development]]: a talk which reflects on
  the added value of REPLs compared to shells, and provides guidelines
  for using the Clojure REPL.
- [[https://clojureverse.org/t/share-the-nitty-gritty-details-of-your-clojure-workflow/1208][Share the nitty-gritty details of your Clojure workflow]]: a
  ClojureVerse discussion where community members describe their
  development configurations and how they use it them in details.
- [[https://vvvvalvalval.github.io/posts/what-makes-a-good-repl.html][What makes a good REPL?]]: this blog post provides a general
  reflection on the benefits of REPLs, and the programming language
  features which enable them.
- [[https://www.youtube.com/watch?v=gIoadGfm5T8][REPL-Driven Development: Clojure's Superpower]]: Sean Corfield at the
  London Clojurians online meetup, talking about why Clojure's REPL is
  so powerful, including a live, 40 minute demo, building a simple web
  app via the REPL (starting at about 11 minutes in).
- [[https://vimeo.com/230220635][REPL-Based Development Demo]]: a video showing how the REPL is used
  for development on an example project.
- The [[https://gist.github.com/daveray/1441520][Seesaw REPL Tutorial]] teaches you to build Graphical User
  Interfaces at the Clojure REPL.

*** Programming at the REPL: Troubleshooting
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/repl/annex_troubleshooting.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/repl/annex_troubleshooting
:CLOJURE_SITE_AUTHOR: Valentin Waeselynck
:CLOJURE_SITE_DATE: 2018-02-10
:PREVPAGE_CUSTOM_ID: content/guides/repl/annex_community_resources
:CUSTOM_ID: content/guides/repl/annex_troubleshooting
:END:

This section lists common issues when using the REPL, and how to
diagnose them:

**** Calling a Var that has not been defined

*Symptoms:*

#+BEGIN_EXAMPLE
user=> my-nonexistent-name
Syntax error compiling at (REPL:0:0).
Unable to resolve symbol: my-nonexistent-name in this context
#+END_EXAMPLE

*Explanations:*

- Maybe you made a typo in the Var name, e.g you should have written
  ~my-non-existent-name~ instead of ~my-nonexistent-name~.
- Maybe you forgot to define ~my-nonexistent-name~ in the REPL (using
  e.g ~def~ or ~defn~): this could happen if you wrote a
  ~(def my-nonexistent-name …​)~ in your code file but forgot to
  evaluate it in the REPL.
- Maybe you defined ~my-non-existent-name~, but in another namespace.
  You should either write ~myapp.ns23/my-non-existent-name~ or switch
  to namespace ~myapp.ns23/my-non-existent-name~.

**** Using a missing namespace alias

*Symptoms:*

#+BEGIN_EXAMPLE
user=> ns3/foo-bar
Syntax error compiling at (REPL:0:0).
No such namespace: ns3
#+END_EXAMPLE

*Explanations:*

- Maybe you made a typo in the namespace alias, e.g you should have
  written ~n3/foo-bar~ instead of ~ns3/foo-bar~
- Maybe you have never defined the ~ns3~ alias in the current
  namespace: you can fix that by evaluating
  ~(require '[myapp.ns3 :as ns3])~
- Maybe you have defined the ~ns3~ alias, but in a different namespace
  that the one your REPL is in at the moment.

**** Referring to a namespace that has not been loaded

*Symptoms:*

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=> clojure.set/union
Syntax error (ClassNotFoundException) compiling at (REPL:0:0).
clojure.set
#+END_EXAMPLE

*Explanations:*

You are using a namespace that has yet not been created in the REPL.
Note that the error message (‘ClassNotFoundException') is particularly
confusing in this case: the reason is that the Clojure compiler,
having found no loaded namespace named ~clojure.set~, is trying to
interpret clojure.set as a Java class. The solution is to make sure
the clojure.set lib [[#content/guides/repl/navigating_namespaces#how-to-make-sure-a-lib-is-loaded][has been loaded]].

**** Trying to require a namespace that does not exist

*Symptoms:*

#+BEGIN_EXAMPLE
user=> (require '[a.b.c])
Execution error (FileNotFoundException) at user/eval161 (REPL:1).
Could not locate a/b/c__init.class, a/b/c.clj or a/b/c.cljc on classpath.
#+END_EXAMPLE

*Explanations:* Clojure did not find any existing namespace named ~a.b.c~,
then searched the classpath for a [[#content/reference/libs][lib]] that would define it,
eventualling failing with the above Exception. The cause may vary:

- maybe you just made a typo in the namespace name
- maybe you forgot to add the lib to your classpath, which is usually
  done by adding it to the configuration of your project's dependencies
  (e.g in the ~deps.edn~ or ~project.clj~ file), and sometimes
  (depending on the project management tool) running an installation
  command (e.g ~lein deps~).
- maybe you did add the library to the classpath, but that was after
  you started the REPL: in this case, you should re-start the REPL.

** spec Guide
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/spec.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/spec
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2016-05-24
:CUSTOM_ID: content/guides/spec
:END:
*** Getting started

The [[#content/about/spec][spec]] library ([[https://clojure.github.io/spec.alpha][API docs]]) specifies the structure of data, validates
or conforms it, and can generate data based on the spec.

To use spec, declare a dependency on Clojure 1.9.0 or higher:

#+BEGIN_SRC clojure
[org.clojure/clojure "1.10.3"]
#+END_SRC

To start working with spec, require the ~clojure.spec.alpha~ namespace
at the REPL:

#+BEGIN_SRC clojure
(require '[clojure.spec.alpha :as s])
#+END_SRC

Or include spec in your namespace:

#+BEGIN_SRC clojure
(ns my.ns
  (:require [clojure.spec.alpha :as s]))
#+END_SRC

*** Predicates

Each spec describes a set of allowed values. There are several ways to
build specs and all of them can be composed to build more sophisticated
specs.

Any existing Clojure function that takes a single argument and returns
a truthy value is a valid predicate spec. We can check whether a
particular data value conforms to a spec using [[spec.alpha:clojure/spec/alpha.clj::(defn conform][conform]]:

#+BEGIN_SRC clojure
(s/conform even? 1000)
;;=> 1000
#+END_SRC

The ~conform~ function takes something that can be a spec and a data
value. Here we are passing a predicate which is implicitly converted
into a spec. The return value is "conformed". Here, the conformed value
is the same as the original value - we'll see later where that starts to
deviate. If the value does not conform to the spec, the special value
~:clojure.spec.alpha/invalid~ is returned.

If you don't want to use the conformed value or check for
~:clojure.spec.alpha/invalid~, the helper [[spec.alpha:clojure/spec/alpha.clj::(defn valid?][valid?]] can be used instead to
return a boolean.

#+BEGIN_SRC clojure
(s/valid? even? 10)
;;=> true
#+END_SRC

Note that again ~valid?~ implicitly converts the predicate function into
a spec. The spec library allows you to leverage all of the functions you
already have - there is no special dictionary of predicates. Some more
examples:

#+BEGIN_SRC clojure
(s/valid? nil? nil)  ;; true
(s/valid? string? "abc")  ;; true

(s/valid? #(> % 5) 10) ;; true
(s/valid? #(> % 5) 0) ;; false

(import java.util.Date)
(s/valid? inst? (Date.))  ;; true
#+END_SRC

Sets can also be used as predicates that match one or more literal
values:

#+BEGIN_SRC clojure
(s/valid? #{:club :diamond :heart :spade} :club) ;; true
(s/valid? #{:club :diamond :heart :spade} 42) ;; false

(s/valid? #{42} 42) ;; true
#+END_SRC

*** Registry

Until now, we've been using specs directly. However, spec provides a
central registry for globally declaring reusable specs. The registry
associates a namespaced keyword with a specification. The use of
namespaces ensures that we can define reusable non-conflicting specs
across libraries or applications.

Specs are registered using [[spec.alpha:clojure/spec/alpha.clj::(defmacro def][s/def]].

It's up to you to register the specification in a namespace that makes
sense (typically a namespace you control).

#+BEGIN_SRC clojure
(s/def :order/date inst?)
(s/def :deck/suit #{:club :diamond :heart :spade})
#+END_SRC

A registered spec identifier can be used in place of a spec definition
in the operations we've seen so far - ~conform~ and ~valid?~.

#+BEGIN_SRC clojure
(s/valid? :order/date (Date.))
;;=> true
(s/conform :deck/suit :club)
;;=> :club
#+END_SRC

You will see later that registered specs can (and should) be used
anywhere we compose specs.

#+BEGIN_QUOTE
*Important*

Spec names are always fully-qualified keywords. Generally, Clojure
code should use keyword namespaces that are sufficiently unique such
that they will not conflict with specs provided by other libraries. If
you are writing a library for public use, spec namespaces should
include the project name, url, or organization. Within a private
organization, you may be able to use shorter names - the important
thing is that they are sufficiently unique to avoid conflicts.

In this guide we will often use shorter qualified names for example
brevity.
#+END_QUOTE

Once a spec has been added to the registry, ~doc~ knows how to find it
and print it as well:

#+BEGIN_SRC clojure
(doc :order/date)
-------------------------
:order/date
Spec
  inst?

(doc :deck/suit)
-------------------------
:deck/suit
Spec
  #{:spade :heart :diamond :club}
#+END_SRC

*** Composing predicates

The simplest way to compose specs is with [[spec.alpha:clojure/spec/alpha.clj::(defmacro and][and]] and [[spec.alpha:clojure/spec/alpha.clj::(defmacro or][or]].

Let's create a spec that combines several predicates into a composite
spec with ~s/and~:

#+BEGIN_SRC clojure
(s/def :num/big-even (s/and int? even? #(> % 1000)))
(s/valid? :num/big-even :foo) ;; false
(s/valid? :num/big-even 10) ;; false
(s/valid? :num/big-even 100000) ;; true
#+END_SRC

We can also use ~s/or~ to specify two alternatives:

#+BEGIN_SRC clojure
(s/def :domain/name-or-id (s/or :name string?
                                :id   int?))
(s/valid? :domain/name-or-id "abc") ;; true
(s/valid? :domain/name-or-id 100) ;; true
(s/valid? :domain/name-or-id :foo) ;; false
#+END_SRC

This ~or~ spec is the first case we've seen that involves a choice
during validity checking. Each choice is annotated with a tag (here,
between ~:name~ and ~:id~) and those tags give the branches names that
can be used to understand or enrich the data returned from ~conform~ and
other spec functions.

When an ~or~ is conformed, it returns a vector with the tag name and
conformed value:

#+BEGIN_SRC clojure
(s/conform :domain/name-or-id "abc")
;;=> [:name "abc"]
(s/conform :domain/name-or-id 100)
;;=> [:id 100]
#+END_SRC

Many predicates that check an instance's type do not allow ~nil~ as a
valid value (~string?~, ~number?~, ~keyword?~, etc). To include ~nil~ as a
valid value, use the provided function [[spec.alpha:clojure/spec/alpha.clj::(defmacro nilable][nilable]] to make a spec:

#+BEGIN_SRC clojure
(s/valid? string? nil)
;;=> false
(s/valid? (s/nilable string?) nil)
;;=> true
#+END_SRC

*** Explain

[[spec.alpha:clojure/spec/alpha.clj::267][explain]] is another high-level operation in spec that can be used to
report (to ~*out*~) why a value does not conform to a spec. Let's see
what explain says about some non-conforming examples we've seen so
far.

#+BEGIN_SRC clojure
(s/explain :deck/suit 42)
;; 42 - failed: #{:spade :heart :diamond :club} spec: :deck/suit
(s/explain :num/big-even 5)
;; 5 - failed: even? spec: :num/big-even
(s/explain :domain/name-or-id :foo)
;; :foo - failed: string? at: [:name] spec: :domain/name-or-id
;; :foo - failed: int? at: [:id] spec: :domain/name-or-id
#+END_SRC

Let's examine the output of the final example more closely. First note
that there are two errors being reported - spec will evaluate all
possible alternatives and report errors on every path. The parts of each
error are:

- val - the value in the user's input that does not match
- spec - the spec that was being evaluated
- at - a path (a vector of keywords) indicating the location within the
  spec where the error occurred - the tags in the path correspond to
  any tagged part in a spec (the alternatives in an ~or~ or ~alt~, the
  parts of a ~cat~, the keys in a map, etc)
- predicate - the actual predicate that was not satisfied by val
- in - the key path through a nested data val to the failing value. In
  this example, the top-level value is the one that is failing so this
  is essentially an empty path and is omitted.

For the first reported error we can see that the value ~:foo~ did not
satisfy the predicate ~string?~ at the path ~:name~ in the spec
~:domain/name-or-id~. The second reported error is similar but fails on
the ~:id~ path instead. The actual value is a keyword so neither is a
match.

In addition to ~explain~, you can use [[spec.alpha:clojure/spec/alpha.clj::(defn explain-str][explain-str]] to receive the error
messages as a string or [[spec.alpha:clojure/spec/alpha.clj::225][explain-data]] to receive the errors as data.

#+BEGIN_SRC clojure
(s/explain-data :domain/name-or-id :foo)
;;=> #:clojure.spec.alpha{
;;     :problems ({:path [:name],
;;                 :pred clojure.core/string?,
;;                 :val :foo,
;;                 :via [:domain/name-or-id],
;;                 :in []}
;;                {:path [:id],
;;                 :pred clojure.core/int?,
;;                 :val :foo,
;;                 :via [:domain/name-or-id],
;;                 :in []})}
#+END_SRC

#+BEGIN_QUOTE
*Note*

This result also demonstrates the namespace map literal syntax added
in Clojure 1.9. Maps may be prefixed with ~#:~ or ~#::~ (for
autoresolve) to specify a default namespace for all keys in the map.
In this example, this is equivalent to
~{:clojure.spec.alpha/problems …​}~
#+END_QUOTE

*** Entity Maps

Clojure programs rely heavily on passing around maps of data. A common
approach in other libraries is to describe each entity type, combining
both the keys it contains and the structure of their values. Rather than
define attribute (key+value) specifications in the scope of the entity
(the map), specs assign meaning to individual attributes, then collect
them into maps using set semantics (on the keys). This approach allows
us to start assigning (and sharing) semantics at the attribute level
across our libraries and applications.

For example, most Ring middleware functions modify the request or
response map with unqualified keys. However, each middleware could
instead use namespaced keys with registered semantics for those keys.
The keys could then be checked for conformance, creating a system with
greater opportunities for collaboration and consistency.

Entity maps in spec are defined with [[spec.alpha:clojure/spec/alpha.clj::(defmacro keys][keys]]:

#+BEGIN_SRC clojure
(def email-regex #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$")
(s/def :acct/email-type (s/and string? #(re-matches email-regex %)))

(s/def :acct/acctid int?)
(s/def :acct/first-name string?)
(s/def :acct/last-name string?)
(s/def :acct/email :acct/email-type)

(s/def :acct/person (s/keys :req [:acct/first-name :acct/last-name :acct/email]
                            :opt [:acct/phone]))
#+END_SRC

This registers a ~:acct/person~ spec with the required keys
~:acct/first-name~, ~:acct/last-name~, and ~:acct/email~, with optional
key ~:acct/phone~. The map spec never specifies the value spec for the
attributes, only what attributes are required or optional.

When conformance is checked on a map, it does two things - checking that
the required attributes are included, and checking that every registered
key has a conforming value. We'll see later where optional attributes
can be useful. Also note that ALL attributes are checked via ~keys~, not
just those listed in the ~:req~ and ~:opt~ keys. Thus a bare ~(s/keys)~
is valid and will check all attributes of a map without checking which
keys are required or optional.

#+BEGIN_SRC clojure
(s/valid? :acct/person
  {:acct/first-name "Bugs"
   :acct/last-name "Bunny"
   :acct/email "bugs@example.com"})
;;=> true

;; Fails required key check
(s/explain :acct/person
  {:acct/first-name "Bugs"})
;; #:acct{:first-name "Bugs"} - failed: (contains? % :acct/last-name)
;;   spec: :acct/person
;; #:acct{:first-name "Bugs"} - failed: (contains? % :acct/email)
;;   spec: :acct/person

;; Fails attribute conformance
(s/explain :acct/person
  {:acct/first-name "Bugs"
   :acct/last-name "Bunny"
   :acct/email "n/a"})
;; "n/a" - failed: (re-matches email-regex %) in: [:acct/email]
;;   at: [:acct/email] spec: :acct/email-type
#+END_SRC

Let's take a moment to examine the explain error output on that final
example:

- in - the path within the data to the failing value (here, a key in
  the person instance)
- val - the failing value, here ~"n/a"~
- spec - the spec that failed, here ~:acct/email-type~
- at - the path in the spec where the failing value is located
- predicate - the predicate that failed, here
  ~(re-matches email-regex %)~

Much existing Clojure code does not use maps with namespaced keys and so
~keys~ can also specify ~:req-un~ and ~:opt-un~ for required and
optional unqualified keys. These variants specify namespaced keys used
to find their specification, but the map only checks for the unqualified
version of the keys.

Let's consider a person map that uses unqualified keys but checks
conformance against the namespaced specs we registered earlier:

#+BEGIN_SRC clojure
(s/def :unq/person
  (s/keys :req-un [:acct/first-name :acct/last-name :acct/email]
          :opt-un [:acct/phone]))

(s/conform :unq/person
  {:first-name "Bugs"
   :last-name "Bunny"
   :email "bugs@example.com"})
;;=> {:first-name "Bugs", :last-name "Bunny", :email "bugs@example.com"}

(s/explain :unq/person
  {:first-name "Bugs"
   :last-name "Bunny"
   :email "n/a"})
;; "n/a" - failed: (re-matches email-regex %) in: [:email] at: [:email]
;;   spec: :acct/email-type

(s/explain :unq/person
  {:first-name "Bugs"})
;; {:first-name "Bugs"} - failed: (contains? % :last-name) spec: :unq/person
;; {:first-name "Bugs"} - failed: (contains? % :email) spec: :unq/person
#+END_SRC

Unqualified keys can also be used to validate record attributes:

#+BEGIN_SRC clojure
(defrecord Person [first-name last-name email phone])

(s/explain :unq/person
           (->Person "Bugs" nil nil nil))
;; nil - failed: string? in: [:last-name] at: [:last-name] spec: :acct/last-name
;; nil - failed: string? in: [:email] at: [:email] spec: :acct/email-type

(s/conform :unq/person
  (->Person "Bugs" "Bunny" "bugs@example.com" nil))
;;=> #user.Person{:first-name "Bugs", :last-name "Bunny",
;;=>              :email "bugs@example.com", :phone nil}
#+END_SRC

One common occurrence in Clojure is the use of "keyword args" where
keyword keys and values are passed in a sequential data structure as
options. Spec provides special support for this pattern with the regex
op [[spec.alpha:clojure/spec/alpha.clj::(defmacro keys*][keys*]].  ~keys*~ has the same syntax and semantics as ~keys~ but can be
embedded inside a sequential regex structure.

#+BEGIN_SRC clojure
(s/def :my.config/port number?)
(s/def :my.config/host string?)
(s/def :my.config/id keyword?)
(s/def :my.config/server (s/keys* :req [:my.config/id :my.config/host]
                                  :opt [:my.config/port]))
(s/conform :my.config/server [:my.config/id :s1
                              :my.config/host "example.com"
                              :my.config/port 5555])
;;=> #:my.config{:id :s1, :host "example.com", :port 5555}
#+END_SRC

Sometimes it will be convenient to declare entity maps in parts, either
because there are different sources for requirements on an entity map or
because there is a common set of keys and variant-specific parts. The
~s/merge~ spec can be used to combine multiple ~s/keys~ specs into a
single spec that combines their requirements. For example consider two
~keys~ specs that define common animal attributes and some dog-specific
ones. The dog entity itself can be described as a ~merge~ of those two
attribute sets:

#+BEGIN_SRC clojure
(s/def :animal/kind string?)
(s/def :animal/says string?)
(s/def :animal/common (s/keys :req [:animal/kind :animal/says]))
(s/def :dog/tail? boolean?)
(s/def :dog/breed string?)
(s/def :animal/dog (s/merge :animal/common
                            (s/keys :req [:dog/tail? :dog/breed])))
(s/valid? :animal/dog
  {:animal/kind "dog"
   :animal/says "woof"
   :dog/tail? true
   :dog/breed "retriever"})
;;=> true
#+END_SRC

*** multi-spec

One common occurrence in Clojure is to use maps as tagged entities and a
special field that indicates the "type" of the map where type indicates
a potentially open set of types, often with shared attributes across the
types.

As previously discussed, the attributes for all types are
well-specified using attributes stored in the registry by namespaced
keyword.  Attributes shared across entity types automatically gain
shared semantics. However, we also want to be able to specify the
required keys per entity type and for that spec provides [[spec.alpha:clojure/spec/alpha.clj::(defmacro multi-spec][multi-spec]]
which leverages a multimethod to provide for the specification of an
open set of entity types based on a type tag.

For example, imagine an API that received event objects which shared
some common fields but also had type-specific shapes. First we would
register the event attributes:

#+BEGIN_SRC clojure
(s/def :event/type keyword?)
(s/def :event/timestamp int?)
(s/def :search/url string?)
(s/def :error/message string?)
(s/def :error/code int?)
#+END_SRC

We then need a multimethod that defines a dispatch function for choosing
the selector (here our ~:event/type~ field) and returns the appropriate
spec based on the value:

#+BEGIN_SRC clojure
(defmulti event-type :event/type)
(defmethod event-type :event/search [_]
  (s/keys :req [:event/type :event/timestamp :search/url]))
(defmethod event-type :event/error [_]
  (s/keys :req [:event/type :event/timestamp :error/message :error/code]))
#+END_SRC

The methods should ignore their argument and return the spec for the
specified type. Here we've fully spec'ed two possible events - a
"search" event and an "error" event.

And then finally we are ready to declare our ~multi-spec~ and try it
out.

#+BEGIN_SRC clojure
(s/def :event/event (s/multi-spec event-type :event/type))

(s/valid? :event/event
  {:event/type :event/search
   :event/timestamp 1463970123000
   :search/url "https://clojure.org"})
;=> true
(s/valid? :event/event
  {:event/type :event/error
   :event/timestamp 1463970123000
   :error/message "Invalid host"
   :error/code 500})
;=> true
(s/explain :event/event
  {:event/type :event/restart})
;; #:event{:type :event/restart} - failed: no method at: [:event/restart]
;;   spec: :event/event
(s/explain :event/event
  {:event/type :event/search
   :search/url 200})
;; 200 - failed: string? in: [:search/url]
;;   at: [:event/search :search/url] spec: :search/url
;; {:event/type :event/search, :search/url 200} - failed: (contains? % :event/timestamp)
;;   at: [:event/search] spec: :event/event
#+END_SRC

Let's take a moment to examine the explain error output on that final
example. There were two different kinds of failures detected. The first
failure is due to the missing required ~:event/timestamp~ key in the
event. The second is from the invalid ~:search/url~ value (a number
instead of a string). We see the same parts as prior explain errors:

- in - the path within the data to the failing value. This is omitted
  on the first error as it's at the root value but is the key in the
  map on the second error.
- val - the failing value, either the full map or the individual key in
  the map
- spec - the actual spec that failed
- at - the path in the spec where the failing value occurred
- predicate - the actual predicate that failed

The ~multi-spec~ approach allows us to create an *open* system for spec
validation, just like multimethods and protocols. New event types can be
added later by just extending the ~event-type~ multimethod.

*** Collections

A few helpers are provided for other special collection cases - [[spec.alpha:clojure/spec/alpha.clj::(defmacro
coll-of][coll-of]],
[[spec.alpha:clojure/spec/alpha.clj::(defmacro tuple][tuple]], and [[spec.alpha:clojure/spec/alpha.clj::(defmacro map-of][map-of]].

For the special case of a homogenous collection of arbitrary size, you
can use ~coll-of~ to specify a collection of elements satisfying a
predicate.

#+BEGIN_SRC clojure
(s/conform (s/coll-of keyword?) [:a :b :c])
;;=> [:a :b :c]
(s/conform (s/coll-of number?) #{5 10 2})
;;=> #{2 5 10}
#+END_SRC

Additionally, ~coll-of~ can be passed a number of keyword arg options:

- ~:kind~ - a predicate that the incoming collection must satisfy, such
  as ~vector?~
- ~:count~ - specifies exact expected count
- ~:min-count~, ~:max-count~ - checks that collection has
  ~(< min-count count max-count)~
- ~:distinct~ - checks that all elements are distinct
- ~:into~ - one of [], (), {}, or #{} for output conformed value. If
  ~:into~ is not specified, the input collection type will be used.

Following is an example utilizing some of these options to spec a vector
containing three distinct numbers conformed as a set and some of the
errors for different kinds of invalid values:

#+BEGIN_SRC clojure
(s/def :ex/vnum3 (s/coll-of number? :kind vector? :count 3 :distinct true :into #{}))
(s/conform :ex/vnum3 [1 2 3])
;;=> #{1 2 3}
(s/explain :ex/vnum3 #{1 2 3})   ;; not a vector
;; #{1 3 2} - failed: vector? spec: :ex/vnum3
(s/explain :ex/vnum3 [1 1 1])    ;; not distinct
;; [1 1 1] - failed: distinct? spec: :ex/vnum3
(s/explain :ex/vnum3 [1 2 :a])   ;; not a number
;; :a - failed: number? in: [2] spec: :ex/vnum3
#+END_SRC

#+BEGIN_QUOTE
*Note*

Both ~coll-of~ and ~map-of~ will conform all of their elements, which may
make them unsuitable for large collections. In that case, consider
[[spec.alpha:clojure/spec/alpha.clj::(defmacro
every][every]] or for maps [[spec.alpha:clojure/spec/alpha.clj::(defmacro every-kv][every-kv]].
#+END_QUOTE

While ~coll-of~ is good for homogenous collections of any size, another
case is a fixed-size positional collection with fields of known type at
different positions. For that we have ~tuple~.

#+BEGIN_SRC clojure
(s/def :geom/point (s/tuple double? double? double?))
(s/conform :geom/point [1.5 2.5 -0.5])
=> [1.5 2.5 -0.5]
#+END_SRC

Note that in this case of a "point" structure with x/y/z values we
actually had a choice of three possible specs:

- Regular expression - ~(s/cat :x double? :y double? :z double?)~
  - Allows for matching nested structure (not needed here)
  - Conforms to map with named keys based on the ~cat~ tags
- Collection - ~(s/coll-of double?)~
  - Designed for arbitrary size homogenous collections
  - Conforms to a vector of the values
- Tuple - ~(s/tuple double? double? double?)~
  - Designed for fixed size with known positional "fields"
  - Conforms to a vector of the values

In this example, ~coll-of~ will match other (invalid) values as well
(like ~[1.0]~ or ~[1.0 2.0 3.0 4.0])~, so it is not a suitable choice -
we want fixed fields. The choice between a regular expression and tuple
here is to some degree a matter of taste, possibly informed by whether
you expect either the tagged return values or error output to be better
with one or the other.

In addition to the support for information maps via ~keys~, spec also
provides ~map-of~ for maps with homogenous key and value predicates.

#+BEGIN_SRC clojure
(s/def :game/scores (s/map-of string? int?))
(s/conform :game/scores {"Sally" 1000, "Joe" 500})
;=> {"Sally" 1000, "Joe" 500}
#+END_SRC

By default ~map-of~ will validate but not conform keys because conformed
keys might create key duplicates that would cause entries in the map to
be overridden. If conformed keys are desired, pass the option
~:conform-keys true~.

You can also use the various count-related options on ~map-of~ that you
have with ~coll-of~.

*** Sequences

Sometimes sequential data is used to encode additional structure
(typically new syntax, often used in macros). spec provides the
standard [[https://en.wikipedia.org/wiki/Regular_expression][regular expression]] operators to describe the structure of a
sequential data value:

- [[spec.alpha:clojure/spec/alpha.clj::(defmacro cat][cat]] - concatenation of predicates/patterns
- [[spec.alpha:clojure/spec/alpha.clj::(defmacro alt][alt]] - choice among alternative predicates/patterns
- [[spec.alpha:clojure/spec/alpha.clj::(defmacro *][*]] - 0 or more of a predicate/pattern
- [[spec.alpha:clojure/spec/alpha.clj::(defmacro +][+]] - 1 or more of a predicate/pattern
- [[spec.alpha:clojure/spec/alpha.clj::(defmacro ?][?]] - 0 or 1 of a predicate/pattern

Like ~or~, both ~cat~ and ~alt~ tag their "parts" - these tags are then
used in the conformed value to identify what was matched, to report
errors, and more.

Consider an ingredient represented by a vector containing a quantity
(number) and a unit (keyword). The spec for this data uses ~cat~ to
specify the right components in the right order. Like predicates, regex
operators are implicitly converted to specs when passed to functions
like ~conform~, ~valid?~, etc.

#+BEGIN_SRC clojure
(s/def :cook/ingredient (s/cat :quantity number? :unit keyword?))
(s/conform :cook/ingredient [2 :teaspoon])
;;=> {:quantity 2, :unit :teaspoon}
#+END_SRC

The data is conformed as a map with the tags as keys. We can use
~explain~ to examine non-conforming data.

#+BEGIN_SRC clojure
;; pass string for unit instead of keyword
(s/explain :cook/ingredient [11 "peaches"])
;; "peaches" - failed: keyword? in: [1] at: [:unit] spec: :cook/ingredient

;; leave out the unit
(s/explain :cook/ingredient [2])
;; () - failed: Insufficient input at: [:unit] spec: :cook/ingredient
#+END_SRC

Let's now see the various occurrence operators ~*~, ~+~, and ~?~:

#+BEGIN_SRC clojure
(s/def :ex/seq-of-keywords (s/* keyword?))
(s/conform :ex/seq-of-keywords [:a :b :c])
;;=> [:a :b :c]
(s/explain :ex/seq-of-keywords [10 20])
;; 10 - failed: keyword? in: [0] spec: :ex/seq-of-keywords

(s/def :ex/odds-then-maybe-even (s/cat :odds (s/+ odd?)
                                       :even (s/? even?)))
(s/conform :ex/odds-then-maybe-even [1 3 5 100])
;;=> {:odds [1 3 5], :even 100}
(s/conform :ex/odds-then-maybe-even [1])
;;=> {:odds [1]}
(s/explain :ex/odds-then-maybe-even [100])
;; 100 - failed: odd? in: [0] at: [:odds] spec: :ex/odds-then-maybe-even

;; opts are alternating keywords and booleans
(s/def :ex/opts (s/* (s/cat :opt keyword? :val boolean?)))
(s/conform :ex/opts [:silent? false :verbose true])
;;=> [{:opt :silent?, :val false} {:opt :verbose, :val true}]
#+END_SRC

Finally, we can use ~alt~ to specify alternatives within the sequential
data. Like ~cat~, ~alt~ requires you to tag each alternative but the
conformed data is a vector of tag and value.

#+BEGIN_SRC clojure
(s/def :ex/config (s/*
                    (s/cat :prop string?
                           :val  (s/alt :s string? :b boolean?))))
(s/conform :ex/config ["-server" "foo" "-verbose" true "-user" "joe"])
;;=> [{:prop "-server", :val [:s "foo"]}
;;    {:prop "-verbose", :val [:b true]}
;;    {:prop "-user", :val [:s "joe"]}]
#+END_SRC

If you need a description of a specification, use ~describe~ to retrieve
one. Let's try it on some of the specifications we've already defined:

#+BEGIN_SRC clojure
(s/describe :ex/seq-of-keywords)
;;=> (* keyword?)
(s/describe :ex/odds-then-maybe-even)
;;=> (cat :odds (+ odd?) :even (? even?))
(s/describe :ex/opts)
;;=> (* (cat :opt keyword? :val boolean?))
#+END_SRC

Spec also defines one additional regex operator, [[spec.alpha:clojure/spec/alpha.clj::(defmacro &][&]], which takes a
regex operator and constrains it with one or more additional
predicates. This can be used to create regular expressions with
additional constraints that would otherwise require custom
predicates. For example, consider wanting to match only sequences with
an even number of strings:

#+BEGIN_SRC clojure
(s/def :ex/even-strings (s/& (s/* string?) #(even? (count %))))
(s/valid? :ex/even-strings ["a"])  ;; false
(s/valid? :ex/even-strings ["a" "b"])  ;; true
(s/valid? :ex/even-strings ["a" "b" "c"])  ;; false
(s/valid? :ex/even-strings ["a" "b" "c" "d"])  ;; true
#+END_SRC

When regex ops are combined, they describe a single sequence. If you
need to spec a nested sequential collection, you must use an explicit
call to [[spec.alpha:clojure/spec/alpha.clj::(defmacro spec][spec]] to start a new nested regex context. For example to
describe a sequence like ~[:names ["a" "b"] :nums [1 2 3]]~, you need
nested regular expressions to describe the inner sequential data:

#+BEGIN_SRC clojure
(s/def :ex/nested
  (s/cat :names-kw #{:names}
         :names (s/spec (s/* string?))
         :nums-kw #{:nums}
         :nums (s/spec (s/* number?))))
(s/conform :ex/nested [:names ["a" "b"] :nums [1 2 3]])
;;=> {:names-kw :names, :names ["a" "b"], :nums-kw :nums, :nums [1 2 3]}
#+END_SRC

If the specs were removed this spec would instead match a sequence like
~[:names "a" "b" :nums 1 2 3]~.

#+BEGIN_SRC clojure
(s/def :ex/unnested
  (s/cat :names-kw #{:names}
         :names (s/* string?)
         :nums-kw #{:nums}
         :nums (s/* number?)))
(s/conform :ex/unnested [:names "a" "b" :nums 1 2 3])
;;=> {:names-kw :names, :names ["a" "b"], :nums-kw :nums, :nums [1 2 3]}
#+END_SRC

*** Using spec for validation

Now is a good time to step back and think about how spec can be used for
runtime data validation.

One way to use spec is to explicitly call ~valid?~ to verify input data
passed to a function. You can, for example, use the existing pre- and
post-condition support built into ~defn~:

#+BEGIN_SRC clojure
(defn person-name
  [person]
  {:pre [(s/valid? :acct/person person)]
   :post [(s/valid? string? %)]}
  (str (:acct/first-name person) " " (:acct/last-name person)))

(person-name 42)
;; Execution error (AssertionError) at user/person-name (REPL:1).
;; Assert failed: (s/valid? :acct/person person)

(person-name {:acct/first-name "Bugs"
              :acct/last-name "Bunny"
              :acct/email "bugs@example.com"})
;;=> "Bugs Bunny"
#+END_SRC

When the function is invoked with something that isn't valid
~:acct/person~ data, the pre-condition fails. Similarly, if there was a
bug in our code and the output was not a string, the post-condition
would fail.

Another option is to use ~s/assert~ within your code to assert that a
value satisfies a spec. On success the value is returned and on failure
an assertion error is thrown. By default assertion checking is off -
this can be changed at the REPL with ~s/check-asserts~ or on startup by
setting the system property ~clojure.spec.check-asserts=true~.

#+BEGIN_SRC clojure
(defn person-name
  [person]
  (let [p (s/assert :acct/person person)]
    (str (:acct/first-name p) " " (:acct/last-name p))))

(s/check-asserts true)
(person-name 100)
;; Execution error - invalid arguments to user/person-name at (REPL:3).
;; 100 - failed: map?
#+END_SRC

A deeper level of integration is to call conform and use the return
value with destructuring to pull apart the input. This will be
particularly useful for complex inputs with alternate options.

Here we conform using the config specification defined above:

#+BEGIN_SRC clojure
(defn- set-config [prop val]
  ;; dummy fn
  (println "set" prop val))

(defn configure [input]
  (let [parsed (s/conform :ex/config input)]
    (if (s/invalid? parsed)
      (throw (ex-info "Invalid input" (s/explain-data :ex/config input)))
      (for [{prop :prop [_ val] :val} parsed]
        (set-config (subs prop 1) val)))))

(configure ["-server" "foo" "-verbose" true "-user" "joe"])
#+END_SRC

Here configure calls ~conform~ to produce data good for destructuring
the config input. The result is either the special ~::s/invalid~ value
or an annotated form of the result:

#+BEGIN_SRC clojure
[{:prop "-server", :val [:s "foo"]}
 {:prop "-verbose", :val [:b true]}
 {:prop "-user", :val [:s "joe"]}]
#+END_SRC

In the success case, the parsed input is transformed into the desired
shape for further processing. In the error case, we call ~explain-data~
to generate error message data. The explain data contains information
about what expression failed to conform, the path to that expression in
the specification, and the predicate it was attempting to match.

*** Spec'ing functions

The pre- and post-condition example in the previous section hinted at an
interesting question - how do we define the input and output
specifications for a function or macro?

Spec has explicit support for this using [[spec.alpha:clojure/spec/alpha.clj::(defmacro fdef][fdef]], which defines
specifications for a function - the arguments and/or the return value
spec, and optionally a function that can specify a relationship
between args and return.

Let's consider a ~ranged-rand~ function that produces a random number in
a range:

#+BEGIN_SRC clojure
(defn ranged-rand
  "Returns random int in range start <= rand < end"
  [start end]
  (+ start (long (rand (- end start)))))
#+END_SRC

We can then provide a specification for that function:

#+BEGIN_SRC clojure
(s/fdef ranged-rand
  :args (s/and (s/cat :start int? :end int?)
               #(< (:start %) (:end %)))
  :ret int?
  :fn (s/and #(>= (:ret %) (-> % :args :start))
             #(< (:ret %) (-> % :args :end))))
#+END_SRC

This function spec demonstrates a number of features. First the ~:args~
is a compound spec that describes the function arguments. This spec is
invoked with the args in a list, as if they were passed to
~(apply fn (arg-list))~. Because the args are sequential and the args
are positional fields, they are almost always described using a regex
op, like ~cat~, ~alt~, or ~*~.

The second ~:args~ predicate takes as input the conformed result of the
first predicate and verifies that start < end. The ~:ret~ spec indicates
the return is also an integer. Finally, the ~:fn~ spec checks that the
return value is >= start and < end.

Once a spec has been created for a function, the ~doc~ for the function
will also include it:

#+BEGIN_SRC clojure
(doc ranged-rand)
-------------------------
user/ranged-rand
([start end])
  Returns random int in range start <= rand < end
Spec
  args: (and (cat :start int? :end int?) (< (:start %) (:end %)))
  ret: int?
  fn: (and (>= (:ret %) (-> % :args :start)) (< (:ret %) (-> % :args :end)))
#+END_SRC

We'll see later how we can use a function spec for development and
testing.

*** Higher order functions

Higher order functions are common in Clojure and spec provides [[spec.alpha:clojure/spec/alpha.clj::(defmacro fspec][fspec]]
to support spec'ing them.

For example, consider the ~adder~ function:

#+BEGIN_SRC clojure
(defn adder [x] #(+ x %))
#+END_SRC

~adder~ returns a function that adds x. We can declare a function spec
for ~adder~ using ~fspec~ for the return value:

#+BEGIN_SRC clojure
(s/fdef adder
  :args (s/cat :x number?)
  :ret (s/fspec :args (s/cat :y number?)
                :ret number?)
  :fn #(= (-> % :args :x) ((:ret %) 0)))
#+END_SRC

The ~:ret~ spec uses ~fspec~ to declare that the returning function
takes and returns a number. Even more interesting, the ~:fn~ spec can
state a general property that relates the ~:args~ (where we know x) and
the result we get from invoking the function returned from ~adder~,
namely that adding 0 to it should return x.

*** Macros

As macros are functions that take code and produce code, they can also
be spec'ed like functions. One special consideration however is that you
must keep in mind that you are receiving code as data, not evaluated
arguments, and that you are most commonly producing new code as data, so
often it's not helpful to spec the :ret value of a macro (as it's just
code).

For example, we could spec the ~clojure.core/declare~ macro like this:

#+BEGIN_SRC clojure
(s/fdef clojure.core/declare
    :args (s/cat :names (s/* simple-symbol?))
    :ret any?)
#+END_SRC

The Clojure macroexpander will look for and conform :args specs
registered for macros at macro expansion time (not runtime!). If an
error is detected, ~explain~ will be invoked to explain the error:

#+BEGIN_SRC clojure
(declare 100)
;; Syntax error macroexpanding clojure.core/declare at (REPL:1:1).
;; 100 - failed: simple-symbol? at: [:names]
#+END_SRC

Because macros are always checked during macro expansion, you do not
need to call instrument for macro specs.

*** A game of cards

Here's a bigger set of specs to model a game of cards:

#+BEGIN_SRC clojure
(def suit? #{:club :diamond :heart :spade})
(def rank? (into #{:jack :queen :king :ace} (range 2 11)))
(def deck (for [suit suit? rank rank?] [rank suit]))

(s/def :game/card (s/tuple rank? suit?))
(s/def :game/hand (s/* :game/card))

(s/def :game/name string?)
(s/def :game/score int?)
(s/def :game/player (s/keys :req [:game/name :game/score :game/hand]))

(s/def :game/players (s/* :game/player))
(s/def :game/deck (s/* :game/card))
(s/def :game/game (s/keys :req [:game/players :game/deck]))
#+END_SRC

We can validate a piece of this data against the schema:

#+BEGIN_SRC clojure
(def kenny
  {:game/name "Kenny Rogers"
   :game/score 100
   :game/hand []})
(s/valid? :game/player kenny)
;;=> true
#+END_SRC

Or look at the errors we'll get from some bad data:

#+BEGIN_SRC clojure
(s/explain :game/game
  {:game/deck deck
   :game/players [{:game/name "Kenny Rogers"
                   :game/score 100
                   :game/hand [[2 :banana]]}]})
;; :banana - failed: suit? in: [:game/players 0 :game/hand 0 1]
;;   at: [:game/players :game/hand 1] spec: :game/card
#+END_SRC

The error indicates the key path in the data structure down to the
invalid value, the non-matching value, the spec part it's trying to
match, the path in that spec, and the predicate that failed.

If we have a function ~deal~ that doles out some cards to the players we
can spec that function to verify the arg and return value are both
suitable data values. We can also specify a ~:fn~ spec to verify that
the count of cards in the game before the deal equals the count of cards
after the deal.

#+BEGIN_SRC clojure
(defn total-cards [{:keys [:game/deck :game/players] :as game}]
  (apply + (count deck)
    (map #(-> % :game/hand count) players)))

(defn deal [game] .... )

(s/fdef deal
  :args (s/cat :game :game/game)
  :ret :game/game
  :fn #(= (total-cards (-> % :args :game))
          (total-cards (-> % :ret))))
#+END_SRC

*** Generators

A key design constraint of spec is that all specs are also designed to
act as generators of sample data that conforms to the spec (a critical
requirement for property-based testing).

**** Project Setup

spec generators rely on the Clojure property testing library
[[https://github.com/clojure/test.check][test.check]]. However, this dependency is dynamically loaded and you can
use the parts of spec other than ~gen~, ~exercise~, and testing without
declaring test.check as a runtime dependency. When you wish to use
these parts of spec (typically during testing), you will need to
declare a dev dependency on test.check.

In a deps.edn project, create a dev alias:

#+BEGIN_SRC clojure
{...
 :aliases {
   :dev {:extra-deps {org.clojure/test.check {:mvn/version "0.9.0"}}}}}
#+END_SRC

In Leiningen add this to project.clj:

#+BEGIN_SRC clojure
:profiles {:dev {:dependencies [[org.clojure/test.check "0.9.0"]]}}
#+END_SRC

In Leiningen the dev profile dependencies are included during testing
but not published as a dependency or included in uber jars.

In Maven, declare your dependency as a test scope dependency:

#+BEGIN_EXAMPLE
<project>
  ...
  <dependencies>
    <dependency>
      <groupId>org.clojure</groupId>
      <artifactId>test.check</artifactId>
      <version>0.9.0</version>
      <scope>test</scope>
    </dependency>
  </dependency>
</project>
#+END_EXAMPLE

In your code you also need to include the ~clojure.spec.gen.alpha~
namespace:

#+BEGIN_SRC clojure
(require '[clojure.spec.gen.alpha :as gen])
#+END_SRC

**** Sampling Generators

The [[spec.alpha:clojure/spec/alpha.clj::292][gen]] function can be used to obtain the generator for any spec.

Once you have obtained a generator with ~gen~, there are several ways to
use it. You can generate a single sample value with [[spec.alpha:clojure/spec/gen/alpha.clj::(defn generate][generate]] or a
series of samples with [[spec.alpha:clojure/spec/gen/alpha.clj::(lazy-combinators hash-map list map][sample]].  Let's see some basic examples:

#+BEGIN_SRC clojure
(gen/generate (s/gen int?))
;;=> -959
(gen/generate (s/gen nil?))
;;=> nil
(gen/sample (s/gen string?))
;;=> ("" "" "" "" "8" "W" "" "G74SmCm" "K9sL9" "82vC")
(gen/sample (s/gen #{:club :diamond :heart :spade}))
;;=> (:heart :diamond :heart :heart :heart :diamond :spade :spade :spade :club)

(gen/sample (s/gen (s/cat :k keyword? :ns (s/+ number?))))
;;=> ((:D -2.0)
;;=>  (:q4/c 0.75 -1)
;;=>  (:*!3/? 0)
;;=>  (:+k_?.p*K.*o!d/*V -3)
;;=>  (:i -1 -1 0.5 -0.5 -4)
;;=>  (:?!/! 0.515625 -15 -8 0.5 0 0.75)
;;=>  (:vv_z2.A??!377.+z1*gR.D9+G.l9+.t9/L34p -1.4375 -29 0.75 -1.25)
;;=>  (:-.!pm8bS_+.Z2qB5cd.p.JI0?_2m.S8l.a_Xtu/+OM_34* -2.3125)
;;=>  (:Ci 6.0 -30 -3 1.0)
;;=>  (:s?cw*8.t+G.OS.xh_z2!.cF-b!PAQ_.E98H4_4lSo/?_m0T*7i 4.4375 -3.5 6.0 108 0.33203125 2 8 -0.517578125 -4))
#+END_SRC

What about generating a random player in our card game?

#+BEGIN_SRC clojure
(gen/generate (s/gen :game/player))
;;=> {:game/name "sAt8r6t",
;;    :game/score 233843,
;;    :game/hand ([8 :spade] [5 :heart] [9 :club] [3 :heart])}
#+END_SRC

What about generating a whole game?

#+BEGIN_SRC clojure
(gen/generate (s/gen :game/game))
;; it works! but the output is really long, so not including it here
#+END_SRC

So we can now start with a spec, extract a generator, and generate some
data. All generated data will conform to the spec we used as a
generator. For specs that have a conformed value different than the
original value (anything using s/or, s/cat, s/alt, etc) it can be useful
to see a set of generated samples plus the result of conforming that
sample data.

**** Exercise

For this we have [[spec.alpha:clojure/spec/alpha.clj::(defn exercise][exercise]], which returns pairs of generated and
conformed values for a spec.  ~exercise~ by default produces 10 samples
(like ~sample~) but you can pass both functions a number indicating the
number of samples to produce.

#+BEGIN_SRC clojure
(s/exercise (s/cat :k keyword? :ns (s/+ number?)) 5)
;;=>
;;([(:y -2.0) {:k :y, :ns [-2.0]}]
;; [(:_/? -1.0 0.5) {:k :_/?, :ns [-1.0 0.5]}]
;; [(:-B 0 3.0) {:k :-B, :ns [0 3.0]}]
;; [(:-!.gD*/W+ -3 3.0 3.75) {:k :-!.gD*/W+, :ns [-3 3.0 3.75]}]
;; [(:_Y*+._?q-H/-3* 0 1.25 1.5) {:k :_Y*+._?q-H/-3*, :ns [0 1.25 1.5]}])

(s/exercise (s/or :k keyword? :s string? :n number?) 5)
;;=> ([:H [:k :H]]
;;    [:ka [:k :ka]]
;;    [-1 [:n -1]]
;;    ["" [:s ""]]
;;    [-3.0 [:n -3.0]])
#+END_SRC

For spec'ed functions we also have [[spec.alpha:clojure/spec/alpha.clj::(defn exercise-fn][exercise-fn]], which generates sample
args, invokes the spec'ed function and returns the args and the return
value.

#+BEGIN_SRC clojure
(s/exercise-fn `ranged-rand)
=>
([(-2 -1)   -2]
 [(-3 3)     0]
 [(0 1)      0]
 [(-8 -7)   -8]
 [(3 13)     7]
 [(-1 0)    -1]
 [(-69 99) -41]
 [(-19 -1)  -5]
 [(-1 1)    -1]
 [(0 65)     7])
#+END_SRC

**** Using ~s/and~ Generators

All of the generators we've seen worked fine but there are a number of
cases where they will need some additional help. One common case is when
the predicate implicitly presumes values of a particular type but the
spec does not specify them:

#+BEGIN_SRC clojure
(gen/generate (s/gen even?))
;; Execution error (ExceptionInfo) at user/eval1281 (REPL:1).
;; Unable to construct gen at: [] for: clojure.core$even_QMARK_@73ab3aac
#+END_SRC

In this case spec was not able to find a generator for the ~even?~
predicate. Most of the primitive generators in spec are mapped to the
common type predicates (strings, numbers, keywords, etc).

However, spec is designed to support this case via ~and~ - the first
predicate will determine the generator and subsequent branches will act
as filters by applying the predicate to the produced values (using
test.check's ~such-that~).

If we modify our predicate to use an ~and~ and a predicate with a mapped
generator, the ~even?~ can be used as a filter for generated values
instead:

#+BEGIN_SRC clojure
(gen/generate (s/gen (s/and int? even?)))
;;=> -15161796
#+END_SRC

We can use many predicates to further refine the generated values. For
example, say we only wanted to generate numbers that were positive
multiples of 3:

#+BEGIN_SRC clojure
(defn divisible-by [n] #(zero? (mod % n)))

(gen/sample (s/gen (s/and int?
                     #(> % 0)
                     (divisible-by 3))))
;;=> (3 9 1524 3 1836 6 3 3 927 15027)
#+END_SRC

However, it is possible to go too far with refinement and make
something that fails to produce any values. The test.check [[https://clojure.github.io/test.check/clojure.test.check.generators.html#var-such-that][such-that]]
that implements the refinement will throw an error if the refinement
predicate cannot be resolved within a relatively small number of
attempts. For example, consider trying to generate strings that happen
to contain the word "hello":

#+BEGIN_SRC clojure
;; hello, are you the one I'm looking for?
(gen/sample (s/gen (s/and string? #(clojure.string/includes? % "hello"))))
;; Error printing return value (ExceptionInfo) at clojure.test.check.generators/such-that-helper (generators.cljc:320).
;; Couldn't satisfy such-that predicate after 100 tries.
#+END_SRC

Given enough time (maybe a lot of time), the generator probably would
come up with a string like this, but the underlying ~such-that~ will
make only 100 attempts to generate a value that passes the filter. This
is a case where you will need to step in and provide a custom generator.

**** Custom Generators

Building your own generator gives you the freedom to be either narrower
and/or be more explicit about what values you want to generate.
Alternately, custom generators can be used in cases where conformant
values can be generated more efficiently than using a base predicate
plus filtering. Spec does not trust custom generators and any values
they produce will also be checked by their associated spec to guarantee
they pass conformance.

There are three ways to build up custom generators - in decreasing order
of preference:

1. Let spec create a generator based on a predicate/spec
2. Create your own generator from the tools in clojure.spec.gen.alpha
3. Use test.check or other test.check compatible libraries (like
  [[https://github.com/gfredericks/test.chuck][test.chuck]])

#+BEGIN_QUOTE
*Warning*

The last option requires a runtime dependency on test.check so the
first two options are strongly preferred over using test.check
directly.
#+END_QUOTE

First consider a spec with a predicate to specify keywords from a
particular namespace:

#+BEGIN_SRC clojure
(s/def :ex/kws (s/and keyword? #(= (namespace %) "my.domain")))
(s/valid? :ex/kws :my.domain/name) ;; true
(gen/sample (s/gen :ex/kws)) ;; unlikely we'll generate useful keywords this way
#+END_SRC

The simplest way to start generating values for this spec is to have
spec create a generator from a fixed set of options. A set is a valid
predicate spec so we can create one and ask for it's generator:

#+BEGIN_SRC clojure
(def kw-gen (s/gen #{:my.domain/name :my.domain/occupation :my.domain/id}))
(gen/sample kw-gen 5)
;;=> (:my.domain/occupation :my.domain/occupation :my.domain/name :my.domain/id :my.domain/name)
#+END_SRC

To redefine our spec using this custom generator, use [[spec.alpha:clojure/spec/alpha.clj::(defn with-gen][with-gen]] which
takes a spec and a replacement generator:

#+BEGIN_SRC clojure
(s/def :ex/kws (s/with-gen (s/and keyword? #(= (namespace %) "my.domain"))
                 #(s/gen #{:my.domain/name :my.domain/occupation :my.domain/id})))
(s/valid? :ex/kws :my.domain/name)  ;; true
(gen/sample (s/gen :ex/kws))
;;=> (:my.domain/occupation :my.domain/occupation :my.domain/name  ...)
#+END_SRC

Note that ~with-gen~ (and other places that take a custom generator)
take a no-arg function that returns the generator, allowing it to be
lazily realized.

One downside to this approach is we are missing what property testing is
really good at: automatically generating data across a wide search space
to find unexpected problems.

The clojure.spec.gen.alpha namespace has a number of functions for
generator "primitives" as well as "combinators" for combining them into
more complicated generators.

#+BEGIN_QUOTE
*Note*

Nearly all of the functions in the clojure.spec.gen.alpha namespace
are merely wrappers that dynamically load functions of the same name
in test.check. You should refer to the documentation for [[https://clojure.github.io/test.check/][test.check]]
for more details on how all of the clojure.spec.gen.alpha generator
functions work.
#+END_QUOTE

In this case we want our keyword to have open names but fixed
namespaces. There are many ways to accomplish this but one of the
simplest is to use [[spec.alpha:clojure/spec/gen/alpha.clj::(lazy-combinators hash-map list map][fmap]] to build up a keyword based on generated
strings:

#+BEGIN_SRC clojure
(def kw-gen-2 (gen/fmap #(keyword "my.domain" %) (gen/string-alphanumeric)))
(gen/sample kw-gen-2 5)
;;=> (:my.domain/ :my.domain/ :my.domain/1 :my.domain/1O :my.domain/l9p2)
#+END_SRC

~gen/fmap~ takes a function to apply and a generator. The function will
be applied to each sample produced by the generator allowing us to build
one generator on another.

However, we can spot a problem in the example above - generators are
often designed to return "simpler" values first and any
string-oriented generator will often return an empty string which is
not a valid keyword. We can make a slight adjustment to omit that
particular value using [[spec.alpha:clojure/spec/gen/alpha.clj::(lazy-combinators hash-map list map][such-that]] which lets us specify a filtering
condition:

#+BEGIN_SRC clojure
(def kw-gen-3 (gen/fmap #(keyword "my.domain" %)
               (gen/such-that #(not= % "")
                 (gen/string-alphanumeric))))
(gen/sample kw-gen-3 5)
;;=> (:my.domain/O :my.domain/b :my.domain/ZH :my.domain/31 :my.domain/U)
#+END_SRC

Returning to our "hello" example, we now have the tools to make that
generator:

#+BEGIN_SRC clojure
(s/def :ex/hello
  (s/with-gen #(clojure.string/includes? % "hello")
    #(gen/fmap (fn [[s1 s2]] (str s1 "hello" s2))
      (gen/tuple (gen/string-alphanumeric) (gen/string-alphanumeric)))))
(gen/sample (s/gen :ex/hello))
;;=> ("hello" "ehello3" "eShelloO1" "vhello31p" "hello" "1Xhellow" "S5bhello" "aRejhellorAJ7Yj" "3hellowPMDOgv7" "UhelloIx9E")
#+END_SRC

Here we generate a tuple of a random prefix and random suffix strings,
then insert "hello" between them.

**** Range Specs and Generators

There are several cases where it's useful to spec (and generate) values
in a range and spec provides helpers for these cases.

For example, in the case of a range of integer values (for example, a
bowling roll), use [[spec.alpha:clojure/spec/alpha.clj::1916][int-in]] to spec a range (end is exclusive):

#+BEGIN_SRC clojure
(s/def :bowling/roll (s/int-in 0 11))
(gen/sample (s/gen :bowling/roll))
;;=> (1 0 0 3 1 7 10 1 5 0)
#+END_SRC

spec also includes [[spec.alpha:clojure/spec/alpha.clj::1898][inst-in]] for a range of instants:

#+BEGIN_SRC clojure
(s/def :ex/the-aughts (s/inst-in #inst "2000" #inst "2010"))
(drop 50 (gen/sample (s/gen :ex/the-aughts) 55))
;;=> (#inst"2005-03-03T08:40:05.393-00:00"
;;    #inst"2008-06-13T01:56:02.424-00:00"
;;    #inst"2000-01-01T00:00:00.610-00:00"
;;    #inst"2006-09-13T09:44:40.245-00:00"
;;    #inst"2000-01-02T10:18:42.219-00:00")
#+END_SRC

Due to the generator implementation, it takes a few samples to get
"interesting" so I skipped ahead a bit.

Finally, [[spec.alpha:clojure/spec/alpha.clj::(defmacro double-in][double-in]] has support for double ranges and special options
for checking special double values like ~NaN~ (not a number), ~Infinity~,
and ~-Infinity~.

#+BEGIN_SRC clojure
(s/def :ex/dubs (s/double-in :min -100.0 :max 100.0 :NaN? false :infinite? false))
(s/valid? :ex/dubs 2.9)
;;=> true
(s/valid? :ex/dubs Double/POSITIVE_INFINITY)
;;=> false
(gen/sample (s/gen :ex/dubs))
;;=> (-1.0 -1.0 -1.5 1.25 -0.5 -1.0 -3.125 -1.5625 1.25 -0.390625)
#+END_SRC

To learn more about generators, read the test.check [[https://clojure.github.io/test.check/intro.html][tutorial]] or
[[https://clojure.github.io/test.check/generator-examples.html][examples]].  Do keep in mind that while clojure.spec.gen.alpha is a
large subset of clojure.test.check.generators, not everything is
included.

*** Instrumentation and Testing

spec provides a set of development and testing functionality in the
~clojure.spec.test.alpha~ namespace, which we can include with:

#+BEGIN_SRC clojure
(require '[clojure.spec.test.alpha :as stest])
#+END_SRC

**** Instrumentation

Instrumentation validates that the ~:args~ spec is being invoked on
instrumented functions and thus provides validation for external uses of
a function. Let's turn on instrumentation for our previously spec'ed
~ranged-rand~ function:

#+BEGIN_SRC clojure
(stest/instrument `ranged-rand)
#+END_SRC

Instrument takes a fully-qualified symbol so we use ~`~ here to resolve
it in the context of the current namespace. If the function is invoked
with args that do not conform with the ~:args~ spec you will see an
error like this:

#+BEGIN_SRC clojure
(ranged-rand 8 5)
Execution error - invalid arguments to user/ranged-rand at (REPL:1).
{:start 8, :end 5} - failed: (< (:start %) (:end %))
#+END_SRC

The error fails in the second args predicate that checks
~(< start end)~. Note that the ~:ret~ and ~:fn~ specs are not checked
with instrumentation as validating the implementation should occur at
testing time.

Instrumentation can be turned off using the complementary function
~unstrument~. Instrumentation is likely to be useful at both development
time and during testing to discover errors in calling code. It is not
recommended to use instrumentation in production due to the overhead
involved with checking args specs.

**** Testing

We mentioned earlier that ~clojure.spec.test.alpha~ provides tools for
automatically testing functions. When functions have specs, we can use
[[spec.alpha:clojure/spec/test/alpha.clj::373][check]], to automatically generate tests that check the function using
the specs.

~check~ will generate arguments based on the ~:args~ spec for a
function, invoke the function, and check that the ~:ret~ and ~:fn~ specs
were satisfied.

#+BEGIN_SRC clojure
(require '[clojure.spec.test.alpha :as stest])

(stest/check `ranged-rand)
;;=> ({:spec #object[clojure.spec.alpha$fspec_impl$reify__13728 ...],
;;     :clojure.spec.test.check/ret {:result true, :num-tests 1000, :seed 1466805740290},
;;     :sym spec.examples.guide/ranged-rand,
;;     :result true})
#+END_SRC

#+BEGIN_QUOTE
*Note*

A keen observer will notice that ~ranged-rand~ contains a subtle bug.
If the difference between start and end is very large (larger than is
representable by ~Long/MAX_VALUE~), then ~ranged-rand~ will produce an
IntegerOverflowException. If you run ~check~ several times you will
eventually cause this case to occur.
#+END_QUOTE

~check~ also takes a number of options that can be passed to test.check
to influence the test run, as well as the option to override generators
for parts of the spec, by either name or path.

Imagine instead that we made an error in the ranged-rand code and
swapped start and end:

#+BEGIN_SRC clojure
(defn ranged-rand  ;; BROKEN!
  "Returns random int in range start <= rand < end"
  [start end]
  (+ start (long (rand (- start end)))))
#+END_SRC

This broken function will still create random integers, just not in the
expected range. Our ~:fn~ spec will detect the problem when checking the
var:

#+BEGIN_SRC clojure
(stest/abbrev-result (first (stest/check `ranged-rand)))
;;=> {:spec (fspec
;;            :args (and (cat :start int? :end int?) (fn* [p1__3468#] (< (:start p1__3468#) (:end p1__3468#))))
;;            :ret int?
;;            :fn (and
;;                  (fn* [p1__3469#] (>= (:ret p1__3469#) (-> p1__3469# :args :start)))
;;                  (fn* [p1__3470#] (< (:ret p1__3470#) (-> p1__3470# :args :end))))),
;;     :sym spec.examples.guide/ranged-rand,
;;     :result {:clojure.spec.alpha/problems [{:path [:fn],
;;                                             :pred (>= (:ret %) (-> % :args :start)),
;;                                             :val {:args {:start -3, :end 0}, :ret -5},
;;                                             :via [],
;;                                             :in []}],
;;              :clojure.spec.test.alpha/args (-3 0),
;;              :clojure.spec.test.alpha/val {:args {:start -3, :end 0}, :ret -5},
;;              :clojure.spec.alpha/failure :test-failed}}
#+END_SRC

~check~ has reported an error in the ~:fn~ spec. We can see the
arguments passed were -3 and 0 and the return value was -5, which is out
of the expected range.

To test all of the spec'ed functions in a namespace (or multiple
namespaces), use [[spec.alpha:clojure/spec/test/alpha.clj::(defn enumerate-namespace][enumerate-namespace]] to generate the set of symbols
naming vars in the namespace:

#+BEGIN_SRC clojure
(-> (stest/enumerate-namespace 'user) stest/check)
#+END_SRC

And you can check all of the spec'ed functions by calling ~stest/check~
without any arguments.

**** Combining ~check~ and ~instrument~

While both ~instrument~ (for enabling ~:args~ checking) and ~check~ (for
generating tests of a function) are useful tools, they can be combined
to provide even deeper levels of test coverage.

~instrument~ takes a number of options for changing the behavior of
instrumented functions, including support for swapping in alternate
(narrower) specs, stubbing functions (by using the ~:ret~ spec to
generate results), or replacing functions with an alternate
implementation.

Consider the case where we have a low-level function that invokes a
remote service and a higher-level function that calls it.

#+BEGIN_SRC clojure
;; code under test

(defn invoke-service [service request]
  ;; invokes remote service
  )

(defn run-query [service query]
  (let [{:svc/keys [result error]} (invoke-service service {:svc/query query})]
    (or result error)))
#+END_SRC

We can spec these functions using the following specs:

#+BEGIN_SRC clojure
(s/def :svc/query string?)
(s/def :svc/request (s/keys :req [:svc/query]))
(s/def :svc/result (s/coll-of string? :gen-max 3))
(s/def :svc/error int?)
(s/def :svc/response (s/or :ok (s/keys :req [:svc/result])
                          :err (s/keys :req [:svc/error])))

(s/fdef invoke-service
  :args (s/cat :service any? :request :svc/request)
  :ret :svc/response)

(s/fdef run-query
  :args (s/cat :service any? :query string?)
  :ret (s/or :ok :svc/result :err :svc/error))
#+END_SRC

And then we want to test the behavior of ~run-query~ while stubbing out
~invoke-service~ with ~instrument~ so that the remote service is not
invoked:

#+BEGIN_SRC clojure
(stest/instrument `invoke-service {:stub #{`invoke-service}})
;;=> [user/invoke-service]
(invoke-service nil {:svc/query "test"})
;;=> #:svc{:error -11}
(invoke-service nil {:svc/query "test"})
;;=> #:svc{:result ["kq0H4yv08pLl4QkVH8" "in6gH64gI0ARefv3k9Z5Fi23720gc"]}
(stest/summarize-results (stest/check `run-query))  ;; might take a bit
;;=> {:total 1, :check-passed 1}
#+END_SRC

The first call here instruments and stubs ~invoke-service~. The second
and third calls demonstrate that calls to ~invoke-service~ now return
generated results (rather than hitting a service). Finally, we can use
~check~ on the higher level function to test that it behaves properly
based on the generated stub results returned from ~invoke-service~.

*** Wrapping Up

In this guide we have covered most of the features for designing and
using specs and generators. We expect to add some more advanced
generator techniques and help on testing in a future update.

*** More information

- [[#content/about/spec][spec Rationale]]
- [[https://clojure.github.io/spec.alpha][API Docs]]
- [[https://github.com/clojure/spec.alpha][Project]]
- [[resources#spec][spec Resources]]

** test.check
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/test_check_beginner.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/test_check_beginner
:CLOJURE_SITE_AUTHOR: Gary Fredericks
:CLOJURE_SITE_DATE: 2019-06-29
:CUSTOM_ID: content/guides/test_check_beginner
:END:
*** Introduction

test.check is a property-based testing library for clojure, inspired by
[[http://hackage.haskell.org/package/QuickCheck][QuickCheck]].

This guide, which is based on version ~0.10.0~, will briefly introduce
property-based testing using test.check examples, and then cover basic
usage of the different parts of the API.

*** Property-based testing

Property-based tests are often contrasted with "example-based tests",
which are tests which test a function by enumerating specific inputs and
the expected outputs (i.e., "examples"). This guide is written in terms
of testing pure functions, but for testing less pure systems you can
imagine a function that wraps the test, which uses the arguments to set
up the context for the system, runs the system, and then queries the
environment to measure the effects, and returns the result of those
queries.

Property-based testing, in contrast, describes properties that should be
true for all valid inputs. A property-based test consists of a method
for generating valid inputs (a "generator"), and a function which takes
a generated input and combines it with the function under test to decide
whether the property holds for that particular input.

A classic first example of a property is one that tests the ~sort~
function by checking that it's idempotent. In test.check, this could be
written like this:

<<test_check_beginner#quick-check-example>>

#+BEGIN_SRC clojure
(require '[clojure.test.check :as tc])
(require '[clojure.test.check.generators :as gen])
(require '[clojure.test.check.properties :as prop])

(def sort-idempotent-prop
  (prop/for-all [v (gen/vector gen/int)]
    (= (sort v) (sort (sort v)))))

(tc/quick-check 100 sort-idempotent-prop)
;; => {:result true,
;; =>  :pass? true,
;; =>  :num-tests 100,
;; =>  :time-elapsed-ms 28,
;; =>  :seed 1528580707376}
#+END_SRC

Here the ~(gen/vector gen/int)~ expression is the generator for inputs
to the ~sort~ function; it specifies that an input is a vector of
integers. In reality, ~sort~ can take any collection of compatibly
~Comparable~ objects; there's often a tradeoff between the simplicity of
a generator and the completeness with which it describes the actual
input space.

The name ~v~ is bound to a particular generated vector of integers, and
the expression in the body of the ~prop/for-all~ determines whether the
trial passes or fails.

The ~tc/quick-check~ call "runs the property" 100 times, meaning it
generates one hundred vectors of integers and evaluates
~(= (sort v) (sort (sort v)))~ for each of them; it reports success only
if each of those trials passes.

If any of the trials fails, then test.check attempts to "shrink" the
input to a minimal failing example, and then reports the original
failing example and the shrunk one. For example, this faulty property
claims that after sorting a vector of integers, the first element should
be less than the last element:

#+BEGIN_SRC clojure
(def prop-sorted-first-less-than-last
  (prop/for-all [v (gen/not-empty (gen/vector gen/int))]
    (let [s (sort v)]
      (< (first s) (last s)))))
#+END_SRC

If we run this property with ~tc/quick-check~, it returns something like
this:

#+BEGIN_SRC clojure
{:num-tests 5,
 :seed 1528580863556,
 :fail [[-3]],
 :failed-after-ms 1,
 :result false,
 :result-data nil,
 :failing-size 4,
 :pass? false,
 :shrunk
 {:total-nodes-visited 5,
  :depth 2,
  :pass? false,
  :result false,
  :result-data nil,
  :time-shrinking-ms 1,
  :smallest [[0]]}}
#+END_SRC

The original failing example ~[-3]~ (given at the ~:fail~ key) has been
shrunk to ~[0]~ (under ~[:shrunk :smallest]~), and a variety of other
data is provided as well.

*** Generators

The different parts of test.check are cleanly separated by namespace. We
will proceed from the bottom up, starting with generators, then
properties, and then two methods for running tests.

Generators are supported by the ~clojure.test.check.generators~
namespace.

The built-in generators fall into three categories: scalars (basic data
types), collections, and combinators.

- scalars (basic data types: numbers, strings, etc.)
- collections (lists, maps, sets, etc.)
- combinators

The combinators are general enough to support creating generators for
arbitrary custom types.

Additionally, there are several development functions for experimenting
with generators. We'll introduce those first so we can use them to
demonstrate the rest of the generator functionality.

**** Development Tools

The ~gen/sample~ function takes a generator and returns a collection of
small sample elements from that generator:

#+BEGIN_SRC clojure
user=> (gen/sample gen/boolean)
(true false true true true false true true false false)
#+END_SRC

The ~gen/generate~ function takes a generator and returns a single
generated element, and additionally allows specifying the ~size~ of the
element. ~size~ is an abstract parameter, that is generally an integer
ranging from 0 to 200.

#+BEGIN_SRC clojure
user=> (gen/generate gen/large-integer 50)
-165175
#+END_SRC

**** Scalar Generators

test.check comes with generators for booleans, numbers, characters,
strings, keywords, symbols, and UUIDs. E.g.:

#+BEGIN_SRC clojure
user=> (gen/sample gen/double)
(-0.5 ##Inf -2.0 -2.0 0.5 -3.875 -0.5625 -1.75 5.0 -2.0)

user=> (gen/sample gen/char-alphanumeric)
(\G \w \i \1 \V \U \8 \U \t \M)

user=> (gen/sample gen/string-alphanumeric)
("" "" "e" "Fh" "w46H" "z" "Y" "7" "NF4e" "b0")

user=> (gen/sample gen/keyword)
(:. :Lx :x :W :DR :*- :j :g :G :_)

user=> (gen/sample gen/symbol)
(+ kI G uw jw M9E ?23 T3 * .q)

user=> (gen/sample gen/uuid)
(#uuid "c4342745-9f71-42cb-b89e-e99651b9dd5f"
 #uuid "819c3d12-b45a-4373-a307-5943cf17d90b"
 #uuid "c72b5d34-255f-408f-8d16-4828ed740904"
 #uuid "d342d515-b297-4ed4-91cc-8cd55007e2c2"
 #uuid "6d09c6f3-12d4-4e5e-9de5-0ed32c9fef20"
 #uuid "a572178c-5460-44ee-b992-9d3d26daf8c0"
 #uuid "572cc48e-b3a8-40ca-9449-48af08c617d3"
 #uuid "5f6ed50b-adef-4e7f-90d0-44511900491e"
 #uuid "ddbbfd07-d580-4638-9858-57a469d91727"
 #uuid "c32b7788-70de-4bf5-b24f-1e7cb564a37d")
#+END_SRC

**** Collection Generators

The collection generators are generally functions with arguments for
generators of their elements.

For example:

#+BEGIN_SRC clojure
user=> (gen/generate (gen/vector gen/boolean) 5)
[false false false false]
#+END_SRC

(note that the second argument to ~gen/generate~ here is not specifying
the size of the collection, but the abstract ~size~ parameter mentioned
earlier; the default value for ~gen/generate~ is 30)

There are also generators for heterogeneous collections, the most
important of which is ~gen/tuple~:

#+BEGIN_SRC clojure
user=> (gen/generate (gen/tuple gen/boolean gen/keyword gen/large-integer))
[true :r -85718]
#+END_SRC

Some collection generators can also be customized further:

#+BEGIN_SRC clojure
user=> (gen/generate (gen/vector-distinct (gen/vector gen/boolean 3)
                                          {:min-elements 3 :max-elements 5}))
[[true  false false]
 [true  true  false]
 [false false true]
 [false true  true]]
#+END_SRC

**** Generator Combinators

The scalar and collection generators can generate a variety of
structures, but creating nontrivial custom generators requires using the
combinators.

***** ~gen/one-of~

~gen/one-of~ takes a collection of generators and returns a generator
that can generate values from any of them:

#+BEGIN_SRC clojure
user=> (gen/sample (gen/one-of [gen/boolean gen/double gen/large-integer]))
(-1.0 -1 true false 3 true true -24 -0.4296875 3)
#+END_SRC

There is also ~gen/frequency~, which is similar but allows specifying a
weight for each generator.

***** ~gen/such-that~

~gen/such-that~ restricts an existing generator to a subset of its
values, using a predicate:

#+BEGIN_SRC clojure
user=> (gen/sample (gen/such-that odd? gen/large-integer))
(3 -1 -1 -1 -3 5 -11 1 -1 -5)
#+END_SRC

However, there's no magic here: the only way to generate values that
match the predicate is to generate values repeatedly until one happens
to match. This means ~gen/such-that~ can randomly fail if the predicate
doesn't match too many times in a row:

#+BEGIN_SRC clojure
user=> (count (gen/sample (gen/such-that odd? gen/large-integer) 10000))
ExceptionInfo Couldn't satisfy such-that predicate after 10 tries.  clojure.core/ex-info (core.clj:4754)
#+END_SRC

This call to ~gen/sample~ (asking for 10000 odd numbers) fails because
~gen/large-integer~ returns even numbers about half the time, so seeing
ten even numbers in a row isn't extraordinarily unlikely.

~gen/such-that~ should be avoided unless the predicate is highly likely
to succeed. In other cases, there is often an alternative way to build
the generator, as we'll see with ~gen/fmap~.

***** ~gen/fmap~

~gen/fmap~ allows you to modify any generator by supplying a function to
modify the values it generates. You can use this to construct arbitrary
structures or custom objects by generating the pieces they need and then
combining them in the ~gen/fmap~ function:

#+BEGIN_SRC clojure
user=> (gen/generate (gen/fmap (fn [[name age]]
                                 {:type :humanoid
                                  :name name
                                  :age  age})
                               (gen/tuple gen/string-ascii
                                          (gen/large-integer* {:min 0}))))
{:type :humanoid, :name ".o]=w2hZ", :age 14}
#+END_SRC

Another use of ~gen/fmap~ is to restrict or skew the distribution of
another generator using targeted transformations. For example, to turn a
general integer generator into a generator of odd numbers, you could
either use the ~gen/fmap~ function ~#(+ 1 (* 2 %))~ (which also has the
effect of doubling the range of the distribution) or
~#(cond-> % (even? %) (+ 1))~ (which doesn't).

Here's a generator that only generates upper-case strings:

#+BEGIN_SRC clojure
user=> (gen/sample (gen/fmap #(.toUpperCase %) gen/string-ascii))
("" "" "JT" "" ">Y1@" "" "]-" "XCJ@C" "<ANF.\"|" "I@O\"M")
#+END_SRC

***** ~gen/bind~

The most advanced combinator allows generating things in multiple
stages, with the generators in later stages constructed using values
generated in earlier stages.

While this may sound complicated, the signature is hardly different from
~gen/fmap~: the argument order is reversed, and the function is expected
to return a generator instead of a value.

As an example, suppose you want to generate a random list of numbers in
two different orders (e.g., to test a function that should be agnostic
to collection ordering). This is hard to do using ~gen/fmap~ or any
other combinator, since generating two collections directly will
generally give you collections with different elements, and if you just
generate one you don't have the opportunity to use the generated list
with another generator (e.g. ~gen/shuffle~) that might be able to
reorder it.

~gen/bind~ gives us exactly the two-phase structure we need:

#+BEGIN_SRC clojure
user=> (gen/generate (gen/bind (gen/vector gen/large-integer)
                               (fn [xs]
                                 (gen/fmap (fn [ys] [xs ys])
                                           (gen/shuffle xs)))))
[[-5967 -9114 -2 -4 68583042 223266 540 3 -100]
 [223266 -9114 -2 -100 3 540 -5967 -4 68583042]]
#+END_SRC

The structure here is a bit obtuse, as the function we passed to
~gen/bind~ couldn't simply call ~(gen/shuffle xs)~ --- if it had, the
whole generator would have simply returned the one collection generated
by ~(gen/shuffle xs)~; in order to both generate a second collection
with ~gen/shuffle~ and also return the original collection, we use
~gen/fmap~ to combine the two into a vector.

Here's another structure that's a bit simpler at the expense of doing an
extra shuffle:

#+BEGIN_SRC clojure
user=> (gen/generate (gen/bind (gen/vector gen/large-integer)
                               (fn [xs] (gen/vector (gen/shuffle xs) 2))))
[[-4 254202577 -27512 1596863 0 6] [-4 6 254202577 1596863 -27512 0]]
#+END_SRC

However, an option with arguably even better readability is to use the
~gen/let~ macro, which uses a ~let~-like syntax to describe uses of
~gen/fmap~ and ~gen/bind~:

#+BEGIN_SRC clojure
user=> (gen/generate
        (gen/let [xs (gen/vector gen/large-integer)
                  ys (gen/shuffle xs)]
          [xs ys]))
[[0 47] [0 47]]
#+END_SRC

*** Properties

A property is an actual test — it combines a generator with a function
you want to test, and checks that the function behaves as expected given
the generated values.

Properties are created using the ~clojure.test.check.properties/for-all~
macro.

The property in [[test_check_beginner#quick-check-example][the first example]] generates a vector and then calls
the function being tested (~sort~) three times.

Properties can also combine several generators, for example:

#+BEGIN_SRC clojure
(def +-is-commutative
  (prop/for-all [a gen/large-integer
                 b gen/large-integer]
    (= (+ a b) (+ b a))))
#+END_SRC

There are two ways to actually run properties, which is what the next
two sections are about.

**** ~quick-check~

The standalone and functional method of running tests is via the
~quick-check~ function in the ~clojure.test.check~ namespace.

It takes a property and a number of trials, and runs the property up to
that many times, returning a map describing success or failure.

See [[test_check_beginner#quick-check-example][the examples above]].

**** ~defspec~

~defspec~ is a macro for writing property-based-tests that are
recognized and run by ~clojure.test~.

The difference from ~quick-check~ is partly just syntactic, and partly
that it /defines/ a test instead of running it.

For example, the [[test_check_beginner#quick-check-example][first ~quick-check~ example in this guide]] could also be
written like this:

#+BEGIN_SRC clojure
(require '[clojure.test.check.clojure-test :refer [defspec]])

(defspec sort-is-idempotent 100
  (prop/for-all [v (gen/vector gen/int)]
    (= (sort v) (sort (sort v)))))
#+END_SRC

Given this, calling ~(clojure.test/run-tests)~ in the same namespace
produces the following output:

#+BEGIN_EXAMPLE
Testing my.test.ns
{:result true, :num-tests 100, :seed 1536503193939, :test-var "sort-is-idempotent"}

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
#+END_EXAMPLE

*** Additional Documentation

For additional documentation, see the [[https://github.com/clojure/test.check/blob/master/README.md][test.check README]].

** Threading Macros Guide
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/threading_macros.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/threading_macros
:CLOJURE_SITE_AUTHOR: Paulus Esterhazy
:CLOJURE_SITE_DATE: 2016-02-21
:CUSTOM_ID: content/guides/threading_macros
:END:

Threading macros, also known as arrow macros, convert nested function
calls into a linear flow of function calls, improving readability.

*** The thread-first macro (->)

In idiomatic Clojure, pure functions transform immutable data structures
into a desired output format. Consider a function that applies two
transformations to a map:

#+BEGIN_SRC clojure
(defn transform [person]
   (update (assoc person :hair-color :gray) :age inc))

(transform {:name "Socrates", :age 39})
;; => {:name "Socrates", :age 40, :hair-color :gray}
#+END_SRC

~transform~ is an example of a common pattern: it takes a value and
applies multiple transformations with each step in the pipeline taking
the result of the previous step as its input. It is often possible to
improve code of this type by rewriting it to use the thread-first macro
~->~:

#+BEGIN_SRC clojure
(defn transform* [person]
   (-> person
      (assoc :hair-color :gray)
      (update :age inc)))
#+END_SRC

Taking an initial value as its first argument, [[clojure:core.clj::(defmacro ->][->]] threads it through
one or more expressions.

/Note: The word "thread" in this context (meaning passing a value
through a pipeline of functions) is unrelated to the concept of
concurrent threads of execution./

Starting with the second form, the macro inserts the first value as its
first argument. This is repeated at each subsequent step with the result
of the previous computation inserted as the first argument of the next
form. What looks like a function call with two arguments is in fact a
call with three arguments, as the threaded value is inserted just after
the function name. It may be helpful to mark the insertion point with
three commas for illustration:

#+BEGIN_SRC clojure
(defn transform* [person]
   (-> person
      (assoc ,,, :hair-color :gray)
      (update ,,, :age inc)))
#+END_SRC

Though not often seen in practice, this visual aid is valid Clojure
syntax, as commas are whitespace in Clojure.

Semantically, ~transform*~ is equivalent to ~transform~: the arrow macro
expands at compile time into the original code. In each case, the return
value of the function is the result of the last computation, the call to
~update~. The re-written function reads like a description of the
transformation: "Take a person, increase their age, give them gray hair,
and return the result". Of course in the context of immutable values, no
actual mutation takes place. Instead, the function simply returns a new
value with updated attributes.

Syntactically, the threading macro also allows the reader to read the
functions in left to right order of application, rather than reading
from the innermost expression out.

*** thread-last (->>) and thread-as (as->) macros

The ~->~ macro follows a purely syntactic transformation rule: for each
expression, insert the threaded value between the function name and the
first argument. Note that the threading expressions are function calls
of the form ~(f arg1 arg2 …​)~. A bare symbol or keyword without
parentheses is interpreted as a simple function invocation with a single
argument. This allows for a succinct chain of unary functions:

#+BEGIN_SRC clojure
(-> person :hair-color name clojure.string/upper-case)

;; equivalent to

(-> person (:hair-color) (name) (clojure.string/upper-case))
#+END_SRC

However, ~->~ is not universally applicable, as we do not always want to
insert the threaded argument in the initial position. Consider a
function that computes the sum of the squares of all odd positive
integers below ten:

#+BEGIN_SRC clojure
(defn calculate []
   (reduce + (map #(* % %) (filter odd? (range 10)))))
#+END_SRC

Like ~transform~, ~calculate~ is a pipeline of transformations, but unlike
the former, the threaded value appears in each function call in the
final position in the argument list. Instead of the thread-first macro
we need to use the thread-last macro [[clojure:core.clj::(defmacro ->>][->>]] instead:

#+BEGIN_SRC clojure
(defn calculate* []
   (->> (range 10)
        (filter odd? ,,,)
        (map #(* % %) ,,,)
        (reduce + ,,,)))
#+END_SRC

Again, though usually omitted, three commas mark the place where the
argument will be inserted. As you can see, in forms threaded using ~->>~
the threaded value is inserted at the end rather than the beginning of
the argument list.

Thread-first and thread-last are used in different circumstances. Which
one is appropriate depends on the signature of the transformation
functions. Ultimately you'll need to consult the documentation of the
functions used, but there are a few rules of thumb:

- By convention, core functions that operate on sequences expect the
  sequence as their last argument. Accordingly, pipelines containing
  ~map~, ~filter~, ~remove~, ~reduce~, ~into~, etc usually call for the
  ~->>~ macro.
- Core functions that operate on data structures, on the other hand,
  expect the value they work on as their first argument. These include
   [[clojure:core.clj::(fn ^:static
  assoc][assoc]], [[clojure:core.clj::6211][update]], [[clojure:core.clj::(defn dissoc][dissoc]], [[clojure:core.clj::(defn get][get]] and their [[clojure:core.clj::(defn assoc-in][-in]] variants. Pipelines that
  transform maps using these functions often require the ~->~ macro.
- When calling methods through [[#content/reference/java_interop][Java interop]], the Java object is passed
  in as the first argument. In such cases, ~->~ is useful, for example,
  to check a string for a prefix:

  #+BEGIN_SRC clojure
  (-> a-string clojure.string/lower-case (.startsWith "prefix"))
  #+END_SRC

Note also the more specialized interop macros [[clojure:core.clj::(defmacro ..][..]]  and [[clojure:core.clj::(defmacro doto][doto]].

Finally, there are cases where neither ~->~ nor ~->>~ are applicable. A
pipeline may consist of function calls with varying insertion
points. In these cases, you'll need to use [[clojure:core.clj::(defmacro as->][as->]], the more flexible
alternative. ~as->~ expects two fixed arguments and a variable number of
expressions. As with ~->~, the first argument is a value to be threaded
through the following forms. The second argument is the name of a
binding. In each of the subsequent forms, the bound name can be used
for the prior expression's result. This allows a value to thread into
any argument position, not just first or last.

#+BEGIN_SRC clojure
(as-> [:foo :bar] v
  (map name v)
  (first v)
  (.substring v 1))

;; => "oo"
#+END_SRC

*** some->, some->> and cond->

Two of Clojure's more specialized threading macros, [[clojure:core.clj::(defmacro some->][some->]] and [[clojure:core.clj::(defmacro
some->>][some->>]],
are used most commonly when interfacing with Java methods. ~some->~
resembles ~->~ in that it threads a value through a number of
expressions. However, it also short-circuits execution when an
expression evaluates as ~nil~ at any point in the chain. One common
problem with arrow macros in the context of [[#content/reference/java_interop][Java interop]] is that Java
methods do not expect to be passed ~nil~ (~null~). One way to avoid a
~NullPointerException~ in these cases is to add an explicit guard:

#+BEGIN_SRC clojure
(when-let [counter (:counter a-map)]
  (inc (Long/parseLong counter)))
#+END_SRC

~some->~ achieves the same effect more succinctly:

#+BEGIN_SRC clojure
(some-> a-map :counter Long/parseLong inc)
#+END_SRC

If ~a-map~ lacks the key ~:counter~, the entire expression will evaluate
to ~nil~ rather than raising an exception. In fact, this behavior is so
useful that it is common to see ~some->~ used when threading is not
required:

#+BEGIN_SRC clojure
(some-> (compute) Long/parseLong)

;; equivalent to

(when-let [a-str (compute)]
  (Long/parseLong a-str))
#+END_SRC

Like ~->~, the macro [[clojure:core.clj::(defmacro cond->][cond->]] takes an initial value, but unlike the
former, it interprets its argument list as a series of ~test, expr~
pairs. ~cond->~ threads a value through the expressions but skips those
with failing tests. For each pair, ~test~ is evaluated. If the result is
truthy, the expression is evaluated with the threaded value inserted
as its first argument; otherwise evaluation proceeds with the next
~test, expr~ pair. Note that unlike its relatives, [[clojure:core.clj::(defmacro some->][some->]] or [[clojure:core.clj::(defmacro cond][cond]],
~cond->~ never short-circuits evaluation, even if a test evaluates to
~false~ or ~nil~:

#+BEGIN_SRC clojure
(defn describe-number [n]
  (cond-> []
    (odd? n) (conj "odd")
    (even? n) (conj "even")
    (zero? n) (conj "zero")
    (pos? n) (conj "positive")))

(describe-number 3) ;; => ["odd" "positive"]
(describe-number 4) ;; => ["even" "positive"]
#+END_SRC

~cond->>~ inserts the threaded value as the last argument of each form
but works analogously otherwise.

** tools.build Guide
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/guides/tools_build.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/guides/tools_build
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-06-22
:CUSTOM_ID: content/guides/tools_build
:END:

[[https://github.com/clojure/tools.build][tools.build]] is a library of functions for building Clojure
projects. They are intended to be used in a build program to create
user-invokable target functions.

*** Builds are programs

The philosophy behind tools.build is that your project build is
inherently a program - a series of instructions to create one or more
project artifacts from your project source files. We want to write this
program with our favorite programming language, Clojure, and tools.build
is a library of functions commonly needed for builds that can be
connected together in flexible ways. Writing a build program does take a
bit more code than other declarative approaches, but can be easily
extended or customized far into the future, creating a build that grows
with your project.

To run your build programs, you will need two things - tools.build as a
dependency, and the source path that contains your program. Builds are
designed to be easily executed as a project "tool" in the Clojure CLI
(with -T). In the Clojure CLI, "tools" are programs that provide
functionality and do not use your project deps or classpath. Tools
executed with -T:an-alias remove all project deps and paths, add ~"."~
as a path, and include any other deps or paths as defined in
~:an-alias~.

As such, you will need an alias in your deps.edn that defines the build
classpath and includes the path to your build source, for example:

#+BEGIN_SRC clojure
{:paths ["src"]
 :deps {;; project deps
       }
 :aliases
 {:build {:deps {io.github.clojure/tools.build {:tag "TAG" :sha "SHA"}}
          :ns-default build}}}
#+END_SRC

#+BEGIN_QUOTE
*Note*

The git dep and Clojure CLI examples in this guide assume the use of
Clojure CLI 1.10.3.933 or higher. It is possible to use tools.build
with earlier versions of deps.edn/Clojure CLI but the deps.edn git
coordinates and Clojure CLI commands will vary.
#+END_QUOTE

As mentioned above, running a tool with -T removes the project :paths
and :deps. Using ~-T:build~ will use only the ~:paths~ and ~:deps~ from
the ~:build~ alias. The root deps.edn is still included, which will pull
in Clojure as well (but it would also come in as a dependency of
tools.build). The :paths are not specified here, so no additional paths
are added, however, ~-T~ includes the project root ~"."~ as a path by
default.

So executing ~clj -T:build jar~ will use an effective classpath here of:

- ~"."~
- clojure (from the root deps.edn)
- tools.build (from the ~:build~ alias ~:deps~)
- the transitive dependencies needed by clojure and tools.build

The ~:ns-default~ specifies the default Clojure namespace to find the
function specified on the classpath. Because the only local path is the
default ~"."~, we should expect to find the build program at ~build.clj~
in the root of our project. Note that the path roots (via the ~:build~
alias ~:paths~) and the namespace of the build program itself relative
to those paths roots are fully under your control. You may wish to put
them in a subdirectory of your project too.

And then finally, on the command line we specify the function to run in
the build, here ~jar~. That function will be executed in the ~build~
namespace, and uses the same arg passing style as execution with -X -
args are provided with alternating keys and values at the end.

The remainder of this guide demonstrates individual common use cases and
how to satisfy them with tools.build programs.

*** Source library jar build
:PROPERTIES:
:CUSTOM_ID: content/guides/tools_build#source-library-jar-build
:END:

The most common Clojure build creates a jar file containing Clojure
source code. To do this with tools.build we'll use the following tasks:

- ~create-basis~ - to create a project basis
- ~copy-dir~ - to copy Clojure source and resources into a working dir
- ~write-pom~ - to write a pom file in the working dir
- ~jar~ - to jar up the working dir into a jar file

The build.clj will look like this:

#+BEGIN_SRC clojure
(ns build
  (:require [clojure.tools.build.api :as b]))

(def lib 'my/lib1)
(def version (format "1.2.%s" (b/git-count-revs nil)))
(def class-dir "target/classes")
(def basis (b/create-basis {:project "deps.edn"}))
(def jar-file (format "target/%s-%s.jar" (name lib) version))

(defn clean [_]
  (b/delete {:path "target"}))

(defn jar [_]
  (b/write-pom {:class-dir class-dir
                :lib lib
                :version version
                :basis basis
                :src-dirs ["src"]})
  (b/copy-dir {:src-dirs ["src" "resources"]
               :target-dir class-dir})
  (b/jar {:class-dir class-dir
          :jar-file jar-file}))
#+END_SRC

Some things to notice:

- This is just normal Clojure code - you can load this namespace in
  your editor and develop it interactively at the REPL.
- As a single-purpose program, it's fine to build shared data in the
  set of vars at the top.
- We are choosing to build in the "target" directory and assemble the
  jar contents in "target/classes" but there is nothing special about
  these paths - it is fully in your control. Also, we've repeated those
  paths and others in multiple places here but you can remove that
  duplication to the extent that feels right.
- We've used the tools.build task functions to assemble larger
  functions like ~build/jar~ for the user to invoke. These functions
  take a parameter map and we've chosen not to provide any configurable
  parameters here, but you could!

The deps.edn file will look like this:

#+BEGIN_SRC clojure
{:paths ["src"]
 :aliases
 {:build {:deps {io.github.clojure/tools.build {:tag "TAG" :sha "SHA"}}
          :ns-default build}}}
#+END_SRC

And then you can run this build with:

#+BEGIN_EXAMPLE
clj -T:build clean
clj -T:build jar
#+END_EXAMPLE

We expect to be able to do these both together on the command line but
that is a work in progress.

*** Compiled uberjar application build

When preparing an application, it is common to compile the full app +
libs and assemble the entire thing as a single uberjar. An example build
for this might look like this:

#+BEGIN_SRC clojure
(ns build
  (:require [clojure.tools.build.api :as b]))

(def lib 'my/lib1)
(def version (format "1.2.%s" (b/git-count-revs nil)))
(def class-dir "target/classes")
(def basis (b/create-basis {:project "deps.edn"}))
(def uber-file (format "target/%s-%s-standalone.jar" (name lib) version))

(defn clean [_]
  (b/delete {:path "target"}))

(defn uber [_]
  (clean nil)
  (b/copy-dir {:src-dirs ["src" "resources"]
               :target-dir class-dir})
  (b/compile-clj {:basis basis
                  :src-dirs ["src"]
                  :class-dir class-dir})
  (b/uber {:class-dir class-dir
           :uber-file uber-file
           :basis basis
           :main my.lib.main}))
#+END_SRC

The deps.edn and build execution will look the same as the prior
example.

You can create the uber jar build with:

#+BEGIN_EXAMPLE
clj -T:build uber
#+END_EXAMPLE

The output of this build will be an uberjar at
~target/lib1-1.2.100-standalone.jar~. That jar contains both a compiled
version of this project and all of its dependencies. The uberjar will
have a manifest referring to the ~my.lib.main~ namespaces (which should
have a ~-main~ method) and can be invoked like this:

#+BEGIN_EXAMPLE
java -jar target/lib1-1.2.100-standalone.jar
#+END_EXAMPLE

*** Parameterized builds

In the builds above we did not parameterize any aspect of the build,
just chose which functions to call. You may find that it's useful to
parameterize your builds to differentiate dev/qa/prod, or version, or
some other factor. To account for function chaining at the command line,
it is advisable to establish the common set of parameters to use across
your build functions and have each function pass the parameters along.

For example, consider a parameterization that includes an extra set of
dev resources to set a local developer environment. We'll use a simple
~:env :dev~ kv pair to indicate this:

#+BEGIN_SRC clojure
(ns build
  (:require [clojure.tools.build.api :as b]))

(def lib 'my/lib1)
(def version (format "1.2.%s" (b/git-count-revs nil)))
(def class-dir "target/classes")
(def basis (b/create-basis {:project "deps.edn"}))
(def jar-file (format "target/%s-%s.jar" (name lib) version))
(def copy-srcs ["src" "resources"])

(defn clean [params]
  (b/delete {:path "target"})
  params)

(defn jar [{:keys [env] :as params}]
  (let [srcs (if (= env :dev) (cons "dev-resources" copy-srcs) copy-srcs)]
    (b/write-pom {:class-dir class-dir
                  :lib lib
                  :version version
                  :basis basis
                  :src-dirs ["src"]})
    (b/copy-dir {:src-dirs srcs
                 :target-dir class-dir})
    (b/jar {:class-dir class-dir
            :jar-file jar-file})
    params))
#+END_SRC

The other aspects of deps.edn and invocation remain the same.

Invocation that activates :dev environment will look like this:

#+BEGIN_EXAMPLE
clj -T:build jar :env :dev
#+END_EXAMPLE

The kv params are passed to the ~jar~ function.

*** Mixed Java / Clojure build

A common case that occurs is needing to introduce a Java implementation
class or two into a mostly Clojure project. In this case, you need to
compile the Java classes and include them with your Clojure source. In
this setup, we'll assume that your Clojure source is in ~src/~ and Java
source is in ~java/~ (where you actually put these is of course up to
you).

This build creates a jar with classes compiled from Java sources and
your Clojure sources.

#+BEGIN_SRC clojure
(ns build
  (:require [clojure.tools.build.api :as b]))

(def lib 'my/lib1)
(def version (format "1.2.%s" (b/git-count-revs nil)))
(def class-dir "target/classes")
(def basis (b/create-basis {:project "deps.edn"}))
(def jar-file (format "target/%s-%s.jar" (name lib) version))

(defn clean [_]
  (b/delete {:path "target"}))

(defn compile [_]
  (b/javac {:src-dirs ["java"]
            :class-dir class-dir
            :basis basis
            :javac-opts ["-source" "8" "-target" "8"]}))

(defn jar [_]
  (compile nil)
  (b/write-pom {:class-dir class-dir
                :lib lib
                :version version
                :basis basis
                :src-dirs ["src"]})
  (b/copy-dir {:src-dirs ["src" "resources"]
               :target-dir class-dir})
  (b/jar {:class-dir class-dir
          :jar-file jar-file}))
#+END_SRC

The ~compile~ task here can also be used as the prep task for this lib.

*** Task documentation

See the [[https://clojure.github.io/tools.build][API docs]] for detailed task documentation.

* News
** [2011-07-22] Introducing ClojureScript
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2011/07/22/introducing-clojurescript.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2011/07/22/introducing-clojurescript
:CLOJURE_SITE_AUTHOR: Stuart Sierra
:CLOJURE_SITE_DATE: 2011-07-22
:CUSTOM_ID: content/news/2011/07/22/introducing-clojurescript
:END:

The Clojure team is proud to introduce an important addition to the
Clojure language ecosystem.  [[https://github.com/clojure/clojurescript][ClojureScript]] is a new compiler for
Clojure that targets JavaScript.

A [[https://www.youtube.com/watch?v=tVooR-dF_Ag][video recording of the ClojureScript announcement]] is available,
along with [[http://cloud.github.com/downloads/clojure/clojurescript/clojurescript%20slides.pdf][slides (PDF) from the presentation]].

*** Why JavaScript

The Clojure language was first ([[#content/about/rationale][Rationale]]) because of its reach and
power on server platforms. For non-server platforms, nothing has
greater reach than JavaScript. It's been called the [[http://www.hanselman.com/blog/JavaScriptisAssemblyLanguagefortheWebPart2MadnessorjustInsanity.aspx][assembly language
of the Web]]. But beyond Web browsers, JavaScript can be found in [[http://arstechnica.com/apple/news/2011/06/ios-5-brings-nitro-speed-to-home-screen-web-apps.ars][mobile
devices]], [[http://developer.boxee.tv/JavaScript_API#Preface][set-top boxes]], and [[http://wiki.services.openoffice.org/wiki/Documentation/DevGuide/Scripting/Scripting_Framework][desktop applications]]. JavaScript has even
made inroads on the server in [[http://couchdb.apache.org/][databases]] and [[http://nodejs.org/][Web servers]]. As a result
of this reach, a lot of work has gone into making JavaScript engines
performant, including JIT-compilation into native code.


But JavaScript's weakness remains the language itself. Although it has
some powerful features such as first-class functions, JavaScript is
noted more for its flaws than for its strengths. It was never designed
to be a language for large applications.

What if we had a modern, robust, powerful language that could reach to
all the places that JavaScript does? This is the goal of ClojureScript.

*** Where We Are

Try it out! Follow the Quick Start instructions on the [[https://github.com/clojure/clojurescript/wiki][ClojureScript
wiki]].

Here's a partial list of what has been implemented so far:

- Protocols and ~deftype~
- Namespaces
- Functions: ~fn~, ~defn~, multiple-arities, variadics
- Destructuring
- Higher-order functions: ~map~, ~reduce~, ~filter~, ...
- Data structures: lists, maps, vectors, sets
- Data manipulation functions: ~conj~, ~assoc~, ~update-in~,...
- Sequences and sequence functions: ~first~, ~rest~, ...
- Macros: ~assert~, ~cond~, ~doto~, ~loop~, ~->~ and ~->>~, ...
- Metadata
- Reader in ClojureScript (think JSON but better)
- Regular expressions
- Atoms
- Core libraries: ~clojure.string~, ~clojure.set~, ~clojure.zip~, ...
- REPL using JDK-embedded JavaScript (Rhino)

ClojureScript is currently in Alpha status. The compiler and core
libraries are usable for developing applications, but expect to find
bugs and missing pieces of functionality. ClojureScript aims to be a
complete implementation of the Clojure language, but some parts aren't
finished yet.

Some parts of the Clojure language have no direct analog in
ClojureScript, in particular the concurrency primitives, since
JavaScript is single-threaded. There may also be edge cases where the
requirements of the JavaScript environment force ClojureScript to have
slightly different semantics from Clojure. We will document these
differences as we find them.

Obviously, any code making interop calls to Java, as most existing
Clojure libraries do, will not work in ClojureScript. Code written in
pure Clojure will *probably* work in ClojureScript with minor
adjustments. For example, [[https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj][clojure.zip in Clojure]] and [[https://github.com/clojure/clojurescript/blob/master/src/cljs/clojure/zip.cljs][clojure.zip in
ClojureScript]] are nearly identical. With a little effort, purely
algorithmic code can be made portable between
implementations. However, trying to abstract over all the differences
among host platforms has never been a goal of Clojure, nor will it be
a goal of ClojureScript.

We have a [[https://clojure.atlassian.net/projects/CLJS][ClojureScript JIRA instance]] set up to track bugs. As with
Clojure itself, submitting patches requires signing the [[#content/dev/contributor_agreement][Clojure
Contributor Agreement]]. We can only accept patches through JIRA, not
GitHub pull requests.

*** The Relationship to Google Closure

Google has led the way in developing rich client-side applications in
JavaScript. Because Google needs the Web to succeed as an
application-delivery platform, they have released some of their
JavaScript tools as open source under the name *Closure*. The homophonic
name clash is unfortunate, but not something we can do anything about.

[[http://code.google.com/closure/][Google Closure]] is a suite of tools for delivering complex JavaScript
applications to memory-constrained devices over slow connections. It
consists of three parts: a large library of JavaScript classes and
functions, a client-side templating system, and an optimizing
JavaScript compiler. These parts are designed to work in symbiosis.

The Google Closure compiler is a sophisticated JavaScript-to-JavaScript
compiler that performs whole-program analysis to inline and rearrange
code for optimal performance on modern JavaScript runtimes. Most
importantly, it eliminates unused or unreachable code. The Google
Closure compiler makes it possible to have a large library of JavaScript
functions written in a straightforward manner without concern for code
size, and to deliver minified versions of only the code your application
needs. However, taking full advantage of the Google Closure compiler
requires adherence to strict conventions for JavaScript source code.

The ClojureScript compiler emits JavaScript which follows Google
Closure's code conventions, and then invokes the Google Closure compiler
to generate compact, optimized JavaScript for delivery to clients.
ClojureScript also makes use of the Google Closure library for
capabilities such as event handling, DOM manipulation, and user
interface widgets.

It is possible to use ClojureScript with JavaScript libraries other than
Google Closure, but those libraries typically do not follow the
conventions of the Google Closure compiler and therefore will not be
able to take full advantage of its optimizations.

*** What ClojureScript is Not

*ClojureScript is not Clojure implemented in JavaScript.*

The Clojure community has tried various ways of generating JavaScript
from Clojure in the past. One [[https://github.com/clojure/clojure-contrib/tree/master/clojurescript][early attempt by Chris Houser]], also
called ClojureScript, used JavaScript as a implementation language for
the core data structures and compiler, the way the current version of
Clojure uses Java.

The new ClojureScript does not take this approach. Instead,
ClojureScript is written entirely in *Clojure*, as a compiler which
emits JavaScript and a large library of functions. Therefore,
ClojureScript does not aim to provide a complete development environment
in JavaScript. There is no ~eval~ and no runtime access to the
ClojureScript compiler from within ClojureScript.

*ClojureScript is not JavaScript with Clojure syntax.*

Another approach sometimes used to overcome JavaScript's syntactic
shortcomings is to layer another syntax on top of it while keeping all
of the JavaScript language semantics.  [[http://common-lisp.net/project/parenscript/][Parenscript]] and [[http://jashkenas.github.io/coffee-script/][CoffeeScript]]
are examples of this approach.

ClojureScript has the same language semantics as Clojure, not
JavaScript. The ClojureScript compiler emits JavaScript, similar to the
way the Clojure compiler emits Java bytecode.

*** How We Got Here

ClojureScript was initially developed by Rich Hickey, creator of
Clojure. Members of the Clojure/core team, along with others invited
from the Clojure community, have participated in the development of the
compiler.

*** Where to Learn More

- [[https://github.com/clojure/clojurescript/wiki][ClojureScript Wiki]]
- [[http://groups.google.com/group/clojure][Clojure Mailing List]]
- \#clojure IRC on [[http://freenode.net/][Freenode]]

** [2012-02-17] Clojure Governance and How It Got That Way
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2012/02/17/clojure-governance.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2012/02/17/clojure-governance
:CLOJURE_SITE_AUTHOR: Stuart Sierra
:CLOJURE_SITE_DATE: 2012-02-17
:CUSTOM_ID: content/news/2012/02/17/clojure-governance
:END:
*** Enter Rich, with Parentheses

In the beginning, there was a guy with an idea. That guy was Rich
Hickey, and his idea was to combine the power of Lisp with the reach
of a modern managed runtime. He started with [[http://jfli.sourceforge.net/][Jfli]], embedding a JVM in
Lispworks' Common Lisp implementation. When that proved inadequate, he
took a two-year sabbatical to write the compiler that would eventually
become [[https://clojure.org/][Clojure]]: a completely new Lisp for the JVM with language-level
concurrency support.

In late 2007, Rich Hickey presented Clojure at a meeting of the New
York Lisp users' group, [[http://lispnyc.org/][LispNYC]]. I was there, and I was so excited by
what I saw that I wrote one of the [[http://stuartsierra.com/2007/11/15/clojure-a-lisp-worth-talking-about][first blog articles about
Clojure]]. Three days later, I was asking questions about Java interop
on the [[http://groups.google.com/group/clojure][Clojure mailing list]].

Those early days were fun, participating in heady discussions about
fundamental language features like [[http://groups.google.com/group/clojure/browse_thread/thread/3a76a052b419d4d1/d57ae6ad6efb0d4e?#d57ae6ad6efb0d4e][nil vs. false]] and [[http://groups.google.com/group/clojure/browse_thread/thread/8b2c8dc96b39ddd7/5237b9d3ab300df8][argument
order]]. It felt like the beginning of something genuinely new. The
community was tiny, and Rich participated in almost every discussion
on the mailing list or IRC.

How times have changed. The Clojure mailing list has over five
thousand members, and we just wrapped up the [[http://clojure-conj.org/][second international
Clojure conference]] with nearly four hundred attendees.  Google Groups
tells me I've racked up over a thousand posts on the mailing list,
which is shocking to me. There are five books and counting about
Clojure. People are building businesses and careers on it. Who would
have guessed, in 2007, that we would be here in just four years?

*** Enter Second Stuart

(That was a cheap shot. Hi, Stu! :)

In the Summer of 2008, Stuart Halloway started [[http://thinkrelevance.com/blog/2008/07/30/clojure.html][blogging about
Clojure]]. With his co-founder Justin Gehtland, Stuart H. had already
[[http://thinkrelevance.com/][built a business]] helping big companies navigate from ponderous Java
development to more agile practices and more expressive languages like
Ruby. Stuart H. decided that Clojure was the [[http://thinkrelevance.com/blog/2009/10/19/the-case-for-clojure.html][next big thing]]. He wrote
the [[http://pragprog.com/book/shcloj/programming-clojure][first book about Clojure]] (soon to get a [[http://pragprog.com/book/shcloj2/programming-clojure][2nd edition]]).  When he and
Rich met at the 2008 JVM Language Summit, they started a long
conversation that would eventually become a partnership.

*** Clojure Contrib: The Beginning

Around the same mid-2008 time frame, "clojure-contrib" began its life as
a Subversion repository where community members could share code. There
were twelve committers and no rules, just a bunch of Clojure source
files containing code that we found useful. I contributed str-utils,
seq-utils, duck-streams, and later test-is.

The growth of contrib eventually led to the need for some kind of
library loading scheme more expressive than ~load-file~. I wrote a
primitive ~require~ function that took a file name argument and loaded
it from the classpath. Steve Gilardi modified ~require~ to take a
namespace symbol instead of a file. I suggested ~use~ as the shortcut
for the common case of ~require~ followed by ~refer~. This all happened
fairly quickly, without a lot of consideration or planning, culminating
in the ~ns~ macro. The peculiarities of the ~ns~ macro grew directly out
of this work, so you can blame us for that.

Clojure-contrib also prompted a question that every open-source
software project must grapple with: how to handle ownership. We'd
already [[http://groups.google.com/group/clojure/browse_thread/thread/4eea23108b2ed46e/e69c92cd7be8826a][gone through two licenses]]: the Common Public License and its
successor, the Eclipse Public License.

Rich [[http://groups.google.com/group/clojure/browse_thread/thread/6de5840e5ab9abdf/306f63a87d34e5f1][proposed a Clojure Contributor Agreement]] as a means to protect
Clojure's future. The motivation for the CA was to make sure Clojure
would always be open-source but never trapped by a particular
license. The Clojure CA is a covenant between the contributor and Rich
Hickey: the contributor assigns joint ownership of his contributions
to Rich. In return, Rich promises that Clojure will always be
available under an open-source license approved by the [[http://www.fsf.org/][FSF]] or the [[http://www.opensource.org/][OSI]].

Some open-source projects got stuck with the first license under which
contributions were made. Under the CA, if the license ever needs to
change again, there would be no obstacles and no need to get
permission from every past contributor. Agreements like this have
become standard practice for owners of large open-source projects like
[[http://www.eclipse.org/legal/committer_process/EclipseIndividualCommitterAgreementFinal.pdf][Eclipse]], [[http://www.apache.org/licenses/icla.txt][Apache]], and [[http://www.oracle.com/technetwork/community/oca-486395.html][Oracle]].

*** Clojure/core and "New Contrib"

In 2010 I left my cozy academic job and went to work for Relevance,
where Stuart Halloway and Rich were discussing a strategic partnership
that would eventually become [[http://clojure.com/][Clojure/core]]. So what is Clojure/core?
It's a business initiative of Relevance (though not an independent
business entity) to provide consulting, training, and
development-for-hire services around Clojure. Rich Hickey is an
advisor to Clojure/core, but not a Relevance employee.

Members of Clojure/core, of which I am one, have made a commitment to
spend their [[http://thinkrelevance.com/blog/2011/08/01/Friday-Update.html][20% time]] supporting the Clojure ecosystem. Although Rich
still personally reviews every patch for the language itself, the job
of answering questions and organizing contributions from a 5000-member
community is too big for one person, so Rich delegated that
responsibility to Clojure/core.

The first big issue Clojure/core had to confront was the distribution of
clojure-contrib. With sixty-plus libraries in one binary release, it was
already unwieldy. Since clojure-contrib releases were tied to Clojure
language releases, which happened infrequently, development had stalled.
There was also vast confusion about what, exactly, clojure-contrib was
meant to be. Was it an essential component of the language, a nascent
standard library, or a load of crap? (I was inclined to the latter view,
especially with regard to my own contributions.)

My attempts at [[https://github.com/clojure/clojure-contrib/commit/a6a92b9b3d2bfd9a56e1e5e9cfba706d1aeeaae5][modularizing clojure-contrib within a single Git
repository]] failed to improve the situation. Eventually, we settled on
the solution of separate Git repositories for each library. This was a
huge amount of work: dozens of repositories to create and hundreds of
files to move. Many of the contrib libraries were stagnant, their
original authors lacking time to continue working on them.

Finally, almost a year later, the situation has stabilized: [[#content/dev/contrib_libs][contrib
libraries]], each with its own Git repository, test suite, [[https://build.clojure.org/][continuous
integration]], and independent release cycle. The overall code quality
is higher and development is moving forward again.

It was a painful transition for everyone, not least for those of us
trying to manage it all and bear the brunt of the inevitable carping. On
top of everything else, the whole process overlapped with the release of
Clojure 1.3, the first release to break backwards-compatibility in
noticeable ways (non-dynamic Vars as a default, long/double as default
numeric types).

Our technology choices for Clojure and "new contrib" --- GitHub, JIRA,
Hudson, and Maven --- were driven by several concerns:

- to be first-class participants in the Java ecosystem
- to preserve the future-proof licensing structure of the CA
- to give library developers freedom to develop/release on their own
  schedule
- to ensure changes are made only after a thorough review process

The last point was particularly important for patches to the Clojure
language. Clojure is *very* stable: since its first public release,
implementation bugs have been rare and regressions almost nonexistent.
Most reported bugs are edge cases in Java interop. But stability has a
price: new features come more slowly. The majority of JIRA tickets on
Clojure are really feature requests. Rich is extremely conservative
about adding features to the language, and he has impressed this view on
Clojure/core for the purpose of screening tickets.

To take one prominent example, [[http://groups.google.com/group/clojure/browse_thread/thread/aa57ab265f7474a/51bb53ca077154f8][named arguments were discussed]] as far
back as January 2008. Community members developed the [[http://groups.google.com/group/clojure/browse_thread/thread/d4f5f04f6894c741/4d3051dc6604df5d][defnk macro]] to
facilitate writing functions with named arguments, and [[http://groups.google.com/group/clojure/browse_thread/thread/de791a1a28659ea/6020c7db6bb74844][lobbied to add
it]] to Clojure. Finally, in March 2010, Rich made a [[https://github.com/clojure/clojure/commit/29389970bcd41998359681d9a4a20ee391a1e07c][one-line commit]]
adding support for map destructuring from sequential collections. This
gave the benefit of keyword-style parameters everywhere destructuring
is supported, including function arguments. By waiting, and thinking,
we got something better than defnk. If defnk had been accepted
earlier, we might have been stuck with an inferior implementation.

Conversely, the decision to move some libraries into the language,
notably my testing library, was probably premature. (Stuart Halloway
accepts blame for that one. :) Some of the decisions I made in that
library could use revisiting, but now clojure.test is what we're stuck
with.

*** Clojure/dev and the Future

If there was one mistake that I personally made during the 1.3
migration, it was speaking as if Clojure/core *owned* Clojure and
clojure-contrib. We don't: Clojure is owned by Rich Hickey, and
clojure-contrib is owned jointly by Rich Hickey and contributors. But we
*are* the appointed stewards (and Stuarts!) of the open-source Clojure
ecosystem. In that role, we have to make decisions about what we choose
to invest time in supporting. Given limited time, and following Rich's
conservative position on new features, that decision is usually "no."

It's a difficult position to be in. Most of Clojure/core's members
come from the free-wheeling, fast-paced open-source world of Ruby on
Rails.  We really don't enjoy saying "no" all the time. But a
conservative attitude toward new features is exactly the reason
Clojure is so stable.  Patches don't get into the language until they
have been [[#content/dev/workflow][reviewed by at least three people]], one of them Rich
Hickey. New libraries don't get added to contrib without mailing-list
discussions. None of the new contrib libraries has reached the 1.0.0
milestone, and probably won't for some time. These hurdles are not
arbitrary; they are an attempt to guarantee that new additions to
Clojure reflect the same consideration and careful design that Rich
invested in the original implementation.

So what is clojure-contrib today? It's a curated set of libraries whose
ownership and licensing is governed by the Clojure Contributor
Agreement. It could also serve as a proving ground for new features in
the language, but this does not imply that every contrib library will
eventually make it into the language.

With the expansion of contrib, we've given name to another layer of
organization: *Clojure/dev*. Clojure/dev is the set of all people who
have signed the Clojure Contributor Agreement. This entitles them to
participate in discussions on the [[http://groups.google.com/group/clojure-dev][clojure-dev mailing list]], submit
patches on [[https://clojure.atlassian.net/projects/CLJ][JIRA]], and become committers on contrib libraries. Within
Clojure/dev is the smaller set of people who have been tasked with
screening Clojure language tickets.  Clojure/core overlaps with both
groups.

[[./assets/images/content/news/2012-02-17/clojure-community-layers.png]]

At the tail end of this year's [[http://clojure-conj.org/][Clojure/conj]], Stuart Halloway opened
the first face-to-face meeting of Clojure/dev with these words: "This
is the Clojure/dev meeting. It's a meeting of volunteers talking about
how they're going to spend their free time. The only thing we owe each
other is honest communication about when we're planning to do
something and when we're not. There is no obligation for anybody in
this room to build anything for anybody else."

One consensus that came out of the Clojure/dev meeting was that we need
to get better at using our tools, particularly JIRA. We would like to
streamline the processes of joining Clojure/dev, screening patches, and
creating new contrib libraries. We also need better integration testing
between Clojure and applications that use it. Application and library
developers can help by running their test suites against pre-release
versions of Clojure (alphas, betas, even SNAPSHOTs) and reporting
problems early.

But Stu's last point is an important one: no one in the Clojure
community owes anybody anything. If you want something, it's not enough
to ask for it, you need to be willing to do the work to make it happen.
At the same time, don't let a lukewarm response to ideas on the mailing
list dissuade you from implementing something you think is valuable. It
might just be that no one has time to think about it. Recall keyword
arguments: more than two years from inception to completion. We're in
this for the long haul. Join us, be patient, and let's see where we can
go.

** [2012-05-08] Reducers - A Library and Model for Collection Processing
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2012/05/08/reducers.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2012/05/08/reducers
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2012-05-08
:CUSTOM_ID: content/news/2012/05/08/reducers
:END:

I'm happy to have [[https://github.com/clojure/clojure/commit/89e5dce0fdfec4bc09fa956512af08d8b14004f6][pushed]] today the beginnings of a new Clojure library
for higher-order manipulation of collections, based upon /reduce/ and
/fold/. Of course, Clojure already has Lisp's ~reduce~, which corresponds
to the traditional ~foldl~ of functional programming. ~reduce~ is based
upon sequences, as are many of the core functions of Clojure, like
~map~, ~filter~ etc. So, what could be better? It's a long story, so
I'll give you the ending first:

- There is a new namespace: clojure.core.reducers
- It contains new versions of ~map~, ~filter~ etc based upon
  transforming reducing functions - reducers
- It contains a new function, ~fold~, which is a parallel
  reduce+combine
- ~fold~ uses fork/join when working with (the existing!) Clojure
  vectors and maps
- Your new parallel code has exactly the same shape as your existing
  seq-based code
- The reducers are composable
- Reducer implementations are primarily functional - no iterators
- The model uses regular data structures, not 'parallel collections' or
  other OO malarkey
- It's fast, and can become faster still
- This is work-in-progress

*** Basics

The story starts best at the bottom.

Clojure and other functional languages have a function called ~map~ that
takes a function and a collection/list.

- What does it mean to map a function on a collection?
- What are the common signatures?
- Do they [[http://www.infoq.com/presentations/Simple-Made-Easy][complect]] what to do with how to do it?

The classic recursive functional definition of ~map~ is to apply ~f~ to
the first thing in the collection, then ~cons~ the result onto the
result of mapping ~f~ on the /rest/ of the collection. This definition
includes plenty of 'how':

- How: mechanism - recursion
- How: order - sequentially
- How: laziness - (often) lazily
- How: representation - making a list/seq, or other concrete collection

Newer OO frameworks will often remove some of these problems by having
map be a function of ~fn * Coll → Coll~ for any type of Coll, removing
the sequentiality but also losing the laziness, and they still specify a
concrete collection result.

Semantically, and minimally, ~map~ means "apply-to-all" e.g.
~(map inc coll)~ means give me a (logical) collection where every item
is one greater than it was in ~coll~. But, ~map~ doesn't know how to
navigate around every collection - the use of
seqs/lists/iterators/streams etc forces a shared known representation.
Nor does ~inc~ (or any function) know how to apply itself to every
collection representation, else we could just say ~(inc coll)~.

The only thing that knows how to apply a function to a collection is the
collection itself.

What is the generic gateway to a collection applying things to itself?
In Clojure, it is (internal) ~reduce~.

We now have a new super-generalized and minimal abstraction for
collections - a collection is some set of things that, when given a
function to apply to its contents, can do so and give you the result,
i.e. /a collection is (at minimum) reducible/. In other words, you can
call ~reduce~ on it.

Thus, ~core.reducers/map~ is a function of ~fn * reducible → reducible~.
(Whereas ~core/map~ is a function of ~fn * seqable → seqable~.)

Now, how? If someone is going to ask the result of ~(map inc coll)~ to
reduce itself with some function ~f~, ~map~ must ultimately ask ~coll~
to do the job. Rather than pass ~coll f~, ~map~ passes ~coll~ a new,
transformed, reducing function that takes what ~coll~ supplies, calls
~inc~ on it, and then calls ~f~ on that.

#+BEGIN_SRC clojure
(reduce + (r/map inc [1 2 3])) ~=~ (reduce (fn [ret x] (+ ret (inc x))) (+) [1 2 3])
#+END_SRC

i.e. the core work of ~map f~ looks like this:

#+BEGIN_SRC clojure
(fn [f1]
  (fn [ret v]
    (f1 ret (f v))))
#+END_SRC

It takes a reducing function f1, and returns a new reducing function
that calls f1 after applying f to its input.

Thus you can define ~map~ as a function of ~fn * reducible → reducible~
by merely transforming the reducing function. Mapping is semantically a
function of the function of *one step* of a reduction. This
transformation is decomplected from both representation and order. We
call functions such as this ~map~, that take a reducible, and in turn
return something reducible via transformation of the reducing function,
reducers.

Now let's revisit the hows above...

- How: mechanism - functional transformation of reducing function
- How: order - doesn't know
- How: laziness - doesn't know
- How: representation - doesn't build anything

It is important to note that now, when ~(map f coll)~ is called nothing
happens except the creation of a recipe for a new collection, a recipe
that is itself reducible. No work is done yet to the contained elements
and no concrete collection is produced.

The beautiful thing is that this 'transformation of reducing function'
mechanism also works for many of the traditional seq functions, like
~filter~, ~take~, ~flatten~ etc. Note the fact that ~filter~ is
(potentially) contractive, and ~flatten~ is (potentially) expansive per
step - the mechanism is general and not limited to 1:1 transformations.
And other reducer definitions are as pretty as map's - none of the
imperativeness of iterators, or generators with yield.

*** Ok, So Where's My Cake?

If map doesn't do the work of mapping, but merely creates a recipe, when
does the work get done? When you reduce its result:

#+BEGIN_SRC clojure
(require '[clojure.core.reducers :as r])
(reduce + (r/filter even? (r/map inc [1 1 1 2])))
;=> 6
#+END_SRC

That should look familiar - it's the same named functions, applied in
the same order, with the same arguments, producing the same result as
the Clojure's seq-based fns. The difference is that, reduce being eager,
and these reducers fns being out of the seq game, there's no per-step
allocation overhead, so it's faster. Laziness is great when you need it,
but when you don't you shouldn't have to pay for it.

The reducer fns are curried, and they can be easily composed:

#+BEGIN_SRC clojure
;;red is a reducer awaiting a collection
(def red (comp (r/filter even?) (r/map inc)))
(reduce + (red [1 1 1 2]))
;=> 6
#+END_SRC

Thus reduction 'recipes' (reducers) are first class.

What if we /want/ a collection result? It's good to know that into uses
reduce:

#+BEGIN_SRC clojure
(into [] (r/filter even? (r/map inc [1 1 1 2])))
;=> [2 2 2]
#+END_SRC

Note there are no intermediate collections produced.

And, of course, you don't always want a result of the same collection
type:

#+BEGIN_SRC clojure
(into #{} (r/filter even? (r/map inc [1 1 1 2])))
;=> #{2}
#+END_SRC

*** Simplicity is Opportunity

Decomplecting the core operations from representation and laziness has
given us some speed, but what about the elimination of order? It
should open the door to parallelism, but we are stuck with the
semantics of ~reduce~ being ~foldl~, i.e. it uses an accumulator and is
[[http://vimeo.com/6624203][fundamentally serial]]. We can parallelize reduction by using
independent sub-reductions and combining their results, and the
library defines a function that does just that: ~fold~.

The primary signature of fold takes a combining function, a reducing
function, and a collection and returns the result of combining the
results of reducing subsegments of the collection, potentially in
parallel. Obviously if the work is to occur in parallel, the functions
must be associative, but they need not be commutative - ~fold~ preserves
order. Note that there is no initial 'seed' or 'accumulator' value, as
there may be with reduce and foldl. But, since the subsegments are
themselves reduced (with ~reduce~), it raises the question as to what
supplies the seed values for those reductions?

The combining function (an associative binary fn) must have some
'identity' value, a value that, when combined with some X, yields X. 0
is an identity value for +, as is 1 for *. The combining fn must supply
an identity value when called with no arguments (as do + and *). It will
be called with no arguments to supply a seed for each leaf reduction.
There is a fn (called /monoid/, shh!) to help you build such combining
functions.

If no combining fn is supplied, the reducing fn is used. Simple folds
look like reduces:

#+BEGIN_SRC clojure
(r/fold + [1 2 3 4])
;=> 10
#+END_SRC

But by promising less (i.e. not promising stepwise reduction from left
or right) ~fold~ can do more - run in parallel. It does this when the
collection is amenable to parallel subdivision. Ideal candidates are
data structures built from trees. Clojure vectors and maps are trees,
and have parallel implementations of ~fold~ based upon the [[https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html][ForkJoin
framework]].

What if the underlying collection is not amenable (e.g. is a sequence)?
~fold~ just devolves into ~reduce~, producing the same semantic, if not
physical, result.

There's a tremendous amount you can accomplish with this reduce+combine
strategy, especially when you consider that the map, filter etc reducers
will not constitute independent layers of parallel jobs - they just
transform the reducing fn working on the leaves.

You can have a look at the ~cat~ function included in the library for an
interesting example of a combining fn. cat quickly gathers up the fold
results, forming a binary tree with the reductions as leaves. It returns
a highly abstract, yet now quite useful 'collection' that is just
counted, reducible, foldable and seqable.

Oh yeah, perf. Don't be surprised to see things become 2-3X faster, or
more with more cores.

*** More Opportunity (i.e. Work)

As much fun as this is, there's still more fun to be had by those so
inclined:

- There are more seq fns that could become reducer fns
- Given multiple iterable sources, we should be able to build a
  multi-reducible, recovering the multi-input capabilities of map.
- Arrays, arraylists, strings etc are all amenable to parallel fold.
  - fork/join-based vector fold is 14 lines, so these are not
    difficult.
- Those IFn.LLL, DDD etc primitive-taking function interfaces can now
  spring to life.
  - We should be able to build primitive-transmitting reducer function
    pipelines.
  - We'd then need to look for and use them in the reductions of
    arrays and vectors of primitives
- Internal reduce solves the lazily dangling open resource problem, a
  problem solved similarly by [[http://www.haskell.org/haskellwiki/Enumerator_and_iteratee][Haskell's enumerators and
  iteratees]]. (Note that unlike iteratees, reducers do not allocate
  wrappers per step)

  - We need reducible I/O sources.

*** Summary

By adopting an alternative view of collections as reducible, rather
than seqable things, we can get a complementary set of fundamental
operations that tradeoff laziness for parallelism, while retaining the
same high-level, functional programming model. Because the two models
retain the same shape, we can easily choose whichever is appropriate
for the task at hand.

*** Follow Up

See the follow up [[#content/news/2012/05/15/anatomy-of-reducer][blog post]] for more details about what constitutes a
reducer, as well as some background about the library.

Rich

** [2012-05-15] Anatomy of a Reducer
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2012/05/15/anatomy-of-reducer.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2012/05/15/anatomy-of-reducer
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2012-05-15
:CUSTOM_ID: content/news/2012/05/15/anatomy-of-reducer
:END:

Last time, [[#content/news/2012/05/08/reducers][I blogged]] about Clojure's new [[https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj][reducers library]]. This time
I'd like to look at the details of what constitutes a reducer, as well
as some background about the library.

*** What's a Reducing Function?

The reducers library is built around transforming reducing functions. A
reducing function is simply a binary function, akin to the one you might
pass to ~reduce~. While the two arguments might be treated symmetrically
by the function, there is an implied semantic that distinguishes the
arguments: the first argument is a result or accumulator that is being
built up by the reduction, while the second is some new input value from
the source being reduced. While ~reduce~ works from the 'left', that is
neither a property nor promise of the reducing function, but one of
~reduce~ itself. So we'll say simply that a reducing fn has the shape:

#+BEGIN_SRC clojure
(f result input) -> new-result
#+END_SRC

In addition, a reducing fn may be called with no args, and should then
return an identity value for its operation.

*** Transforming Reducing Functions

A function that transforms a reducing fn simply takes one, and returns
another one:

#+BEGIN_SRC clojure
(xf reducing-fn) -> reducing-fn
#+END_SRC

Many of the core collection operations can be expressed in terms of such
a transformation. Imagine if we were to define the cores of ~map~,
~filter~ and ~mapcat~ in this way:

#+BEGIN_SRC clojure
(defn mapping [f]
  (fn [f1]
    (fn [result input]
      (f1 result (f input)))))

(defn filtering [pred]
  (fn [f1]
    (fn [result input]
      (if (pred input)
        (f1 result input)
        result))))

(defn mapcatting [f]
  (fn [f1]
    (fn [result input]
      (reduce f1 result (f input)))))
#+END_SRC

There are a few things to note:

- The functions consist only of the core logic of their operations
- That logic does not include any notion of collection, nor order
- filtering and kin can 'skip' inputs by simply returning the incoming
  result
- mapcatting and kin can produce more than one result per input by
  simply operating on result more than once

Using these directly is somewhat odd, because we are operating on the
reducing operation rather than the collection:

#+BEGIN_SRC clojure
(reduce + 0 (map inc [1 2 3 4]))
;;becomes
(reduce ((mapping inc) +) 0 [1 2 3 4])
#+END_SRC

*** Reducers

We expect map/filter etc to take and return logical collections. The
premise of the reducers library is that the minimum definition of
collection is something that is reducible. reduce ends up using a
protocol (CollReduce) to ask the collection to ~reduce~ itself, so we
can make reducible things by extending that protocol. Thus, given a
collection and a reducing function transformer like those above, we can
make a reducible with a function like this:

#+BEGIN_SRC clojure
(defn reducer
  ([coll xf]
   (reify
    clojure.core.protocols/CollReduce
    (coll-reduce [_ f1 init]
      (clojure.core.protocols/coll-reduce coll (xf f1) init)))))
#+END_SRC

Now:

#+BEGIN_SRC clojure
(reduce + 0 (map inc [1 2 3 4]))
;;becomes
(reduce + 0 (reducer [1 2 3 4] (mapping inc)))
#+END_SRC

That's better. It feels as if we have transformed the collection itself.
Note:

- reducer ultimately asks the source collection to reduce /itself/
- reducer will work with any reducing function transformer

Another objective of the library is to support reducer-based code with
the same shape as our current seq-based code. Getting there is easy:

#+BEGIN_SRC clojure
(defn rmap [f coll]
  (reducer coll (mapping f)))

(defn rfilter [pred coll]
  (reducer coll (filtering pred)))

(defn rmapcat [f coll]
  (reducer coll (mapcatting f)))

(reduce + 0 (rmap inc [1 2 3 4]))
;=> 14

(reduce + 0 (rfilter even? [1 2 3 4]))
;=> 6

(reduce + 0 (rmapcat range [1 2 3 4 5]))
;=> 20
#+END_SRC

*** From Reducible to (Parallel) Foldable

While it is an interesting exercise to find another fundamental way to
define the core collection operations, the end result is not much
different, just faster, certainly something [[http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.7401][a state-of-the-art
compilation and type system]] (had we one) might do for us given
sequence code. To stop here would be to completely miss the point of
the library. These operations have different, fundamentally simpler
semantics than their sequence-based counterparts.

How does one define parallel mapping/filtering/mapcatting etc? /We
already did!/ As long as the transformation itself doesn't care about
order (e.g. as ~take~ does), then a reducer is as foldable as its
source. As with ~reduce~, ~fold~ bottoms out on a protocol (CollFold),
and our reducer can extend that:

#+BEGIN_SRC clojure
(defn folder
  ([coll xf]
     (reify
      ;;extend CollReduce as before

      CollFold
      (coll-fold [_ n combinef reducef]
        (coll-fold coll n combinef (xf reducef))))))
#+END_SRC

Note that:

- ~folder~ has the same requirements as ~reducer~ - collection +
  reducing function transformer
- when ~fold~ is applied to something that can't fold, it devolves to
  ~reduce~

Thus the real definitions of reducers/map et al use ~folder~ (while take
uses ~reducer~):

#+BEGIN_SRC clojure
(defn rmap [f coll]
  (folder coll (mapping f)))

(defn rfilter [pred coll]
  (folder coll (filtering pred)))

(defn rmapcat [f coll]
  (folder coll (mapcatting f)))
#+END_SRC

Thus a wide variety of collection transformations can instead be
expressed as reducing function transformations, and applied in both
sequential and parallel contexts, across a wide variety of data
structures.

The library deals with several other details, such as:

- the transformers all need a nullary arity that just delegates to the
  transformed reducing function
- the transformers support a ternary arity where 2 inputs are supplied
  per step, as occurs with reduce-kv and map sources
- all of the reducers are curried

These additions are all mechanical, and are handled by macros. It is my
hope that the above will help illuminate the core logic underlying the
library.

*** Background

Much prior work highlights the value of fold as a primary mechanism for
collection manipulation, superior to iteration, although most of that
work was done in the context of recursively defined functions on lists
or sequences - i.e. fold implies foldl/foldr, and the results remain
inherently sequential.

The two primary motivators for this library were the Haskell Iteratee
library and Guy Steele's ICFP '09 talk.

**** Haskell Iteratees

The [[http://www.haskell.org/haskellwiki/Enumerator_and_iteratee][Haskell Enumerator/Iteratee library]] and its antecedents are an
inspiring effort to disentangle the source of data and the operations
that might apply to it, and one of the first I think to reify the role
of the 'iteratee'. An enumerator makes successive calls to the
iteratee to supply it items, decoupling the iteratee from the data
source. But the iteratee is still driving in some sense, as it is in
charge of signaling Done, and, it returns on each step the next
iteratee to use, effectively dictating a single thread of control. One
benefit is that even operations like ~take~ can be defined functionally,
as they can encode their internal state in the 'next' iteratee
returned. OTOH, and unlike reducers, the design wraps the result being
built up in a new iteratee each step, with potential allocation
overhead.

Being an automaton in a state, an iteratee is like a reified left fold,
and thus inherently serial. So, while they form quite a nice substrate
for the design of, e.g. parsers, iteratees are unsuitable for defining
things like map/filter etc if one intends to be able to parallelize
them.

**** Guy Steele's ICFP '09 talk

[[http://vimeo.com/6624203][Organizing Functional Code for Parallel Execution or, foldl and foldr
Considered Slightly Harmful]]

This talk boils down to - stop programming with streams, lists,
generators etc if you intend to exploit parallelism, as does the
reducers library.

Where reducers diverges from that talk is in the structure of the
fork/join parallel computation. Rather than map+reduce, reducers uses
reduce+combine. This reflects 2 considerations:

- It is accepted fork/join practice that at some point you stop
  splitting in half and handle the leaves 'sequentially'
  - if the best way to do that at the top is ~reduce~, why not at the
      bottom as well?
- ~map~ forces a result per input

You can see the awkwardness of the latter in the map/reduce-oriented
definition of parallel /filter/ in the talk, which must 'listify' items
or return empty lists, creating a bunch of concatenation busy-work for
the reducing step. Many other collection algorithms suffer similarly in
their map/reduce-oriented implementations, having greater internal
complexity and wrapping the results in collection representations, with
corresponding creation of more garbage and reduction busy-work etc vs
the reducing function transformer versions of same.

It is interesting that the accumulator style is not completely absent
from the reducers design, in fact it is important to the characteristics
just described. What has been abandoned are the /single initial value/
and /serial execution/ promises of foldl/r.

*** Summary

I hope this makes reducers easier to understand, use and define.

Rich

** [2013-06-28] Clojure core.async Channels
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2013/06/28/clojure-clore-async-channels.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2013/06/28/clojure-clore-async-channels
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2013-06-28
:CUSTOM_ID: content/news/2013/06/28/clojure-clore-async-channels
:END:

[[https://github.com/clojure/core.async][core.async]] is a new contrib library for Clojure that adds support for
asynchronous programming using channels.

*** Rationale

There comes a time in all good programs when components or subsystems
must stop communicating directly with one another. This is often
achieved via the introduction of queues between the producers of data
and the consumers/processors of that data. This architectural
indirection ensures that important decisions can be made with some
degree of independence, and leads to systems that are easier to
understand, manage, monitor and change, and make better use of
computational resources, etc.

On the JVM, the [[http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html][java.util.concurrent]] package provides some good
concurrent blocking queues, and they are a viable and popular choice
for Clojure programs. However, in order to use the queues one must
dedicate one or more actual threads to their consumption. Per-thread
stack allocation and task-switching overheads limit the number of
threads that can be used in practice. Another limitation of
j.u.c. queues is there is no way to block waiting on a set of
alternatives.

On JavaScript engines, there are no threads and no queues.

Thread overheads or lack of threads often cause people to move to
systems based upon events/callbacks, in the pursuit of greater
efficiency (often under the misnomer 'scalability', which doesn't apply
since you can't scale a single machine). Events complect communication
and flow of control. While there are various mechanisms to make
events/callbacks cleaner (FRP, Rx/Observables) they don't change their
fundamental nature, which is that upon an event an arbitrary amount of
other code is run, possibly on the same thread, leading to admonitions
such as "don't do too much work in your handler", and phrases like
"callback hell".

The objectives of core.async are:

- To provide facilities for independent threads of activity,
  communicating via queue-like /channels/
- To support both real threads and shared use of thread pools (in any
  combination), as well as ClojureScript on JS engines
- To build upon the work done on CSP and its derivatives

It is our hope that async channels will greatly simplify efficient
server-side Clojure programs, and offer simpler and more robust
techniques for front-end programming in ClojureScript.

*** History

The roots of this style go back at least as far as [[http://en.wikipedia.org/wiki/Communicating_sequential_processes][Hoare's
Communicating Sequential Processes (CSP)]], followed by realizations and
extensions in e.g.  [[http://en.wikipedia.org/wiki/Occam_programming_language][occam]], [[http://www.cs.kent.ac.uk/projects/ofa/jcsp/][Java CSP]] and the [[http://golang.org/][Go programming language]].

In modern incarnations, the notion of a channel becomes first class, and
in doing so provides us the indirection and independence we seek.

A key characteristic of channels is that they are blocking. In the most
primitive form, an unbuffered channel acts as a rendezvous, any reader
will await a writer and vice-versa. Buffering can be introduced, but
unbounded buffering is discouraged, as bounded buffering with blocking
can be an important tool coordinating pacing and back pressure, ensuring
a system doesn't take on more work than it can achieve.

*** Details
**** Just a library

~core.async~ is a library. It doesn't modify Clojure. It is designed to
support Clojure 1.5+.

**** Creating channels

You can create a channel with the [[core.async:clojure/core/async.clj::(defn chan][chan]] function. This will return a
channel that supports multiple writers and readers. By default, the
channel is unbuffered, but you can supply a number to indicate a
buffer size, or supply a buffer object created via [[core.async:clojure/core/async.clj::(defn buffer][buffer]],
[[core.async:clojure/core/async.clj::(defn
dropping-buffer][dropping-buffer]] or [[core.async:clojure/core/async.clj::(defn sliding-buffer][sliding-buffer]].

The fundamental operations on channels are putting and taking values.
Both of those operations potentially block, but the nature of the
blocking depends on the nature of the thread of control in which the
operation is performed. core.async supports two kinds of threads of
control - ordinary threads and IOC (inversion of control) 'threads'.
Ordinary threads can be created in any manner, but IOC threads are
created via [[core.async:clojure/core/async.clj::(defmacro go][go blocks]]. Because JS does not have threads, only ~go~
blocks and IOC threads are supported in ClojureScript.

**** go blocks and IOC 'threads'

~go~ is a macro that takes its body and examines it for any channel
operations. It will turn the body into a state machine. Upon reaching
any blocking operation, the state machine will be 'parked' and the
actual thread of control will be released. This approach is similar to
that used in [[http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx][C# async]]. When the blocking operation completes, the code
will be resumed (on a thread-pool thread, or the sole thread in a JS
VM). In this way the inversion of control that normally leaks into the
program itself with event/callback systems is encapsulated by the
mechanism, and you are left with straightforward sequential code. It
will also provide the illusion of threads, and more important,
separable sequential subsystems, to ClojureScript.

The primary channel operations within go blocks are [[core.async:clojure/core/async.clj::(defn >!][>!]]  (/put/) and [[core.async:clojure/core/async.clj::(defn <!][<!]]
(/take/). The go block itself immediately returns a channel, on which it
will eventually put the value of the last expression of the body (if
non-nil), and then close.

**** Channel on ordinary threads

There are analogous operations for use on ordinary threads - [[core.async:clojure/core/async.clj::(defblockingop >!!][>!!]]  (/put
blocking/) and [[core.async:clojure/core/async.clj::(defblockingop <!!][<!!]]  (/take blocking/), which will block the thread on
which they are called, until complete. While you can use these
operations on threads created with e.g. future, there is also a macro,
[[core.async:clojure/core/async.clj::(defmacro
thread][thread]], analogous to ~go~, that will launch a first-class thread and
similarly return a channel, and should be preferred over ~future~ for
channel work.

**** Mixing modes

You can put on a channel from either flavor of ~>!=/=>!!~ and similarly
take with either of ~<!=/=<<!~ in any combination, i.e. the channel is
oblivious to the nature of the threads which use it.

**** alt

It is often desirable to be able to wait for any one (and only one) of
a set of channel operations to complete. This powerful facility is
made available through the [[core.async:clojure/core/async.clj::(defn alts!][alts!]]  function (for use in ~go~ blocks), and
the analogous [[core.async:clojure/core/async.clj::(defblockingop alts!!][alts!!]]  (/alts blocking/). If more than one operation is
available to complete, one can be chosen at random or by priority
(i.e. in the order they are supplied). There are corresponding [[core.async:clojure/core/async.clj::385][alt!]]
and [[core.async:clojure/core/async.clj::(defmacro alt!!][alt!!]]  macros that combine the choice with conditional evaluation
of expressions.

**** Timeouts

Timeouts are just channels that automatically close after a period of
time. You can create one with the [[core.async:clojure/core/async.clj::(defn timeout][timeout]] function, then just include
the timeout in an ~alt~ variant. A nice aspect of this is that timeouts
can be shared between threads of control, e.g. in order to have a set
of activities share a bound.

**** The value of values

As with STM, the pervasive use of persistent data structures offers
particular benefits for CSP-style channels. In particular, it is always
safe and efficient to put a Clojure data structure on a channel, without
fear of its subsequent use by either the producer or consumer.

**** Contrasting Go language channels

core.async has obvious similarities to Go channels. Some differences
with Go are:

- All of the operations are expressions (not statements)
- This is a library, not syntax
- ~alts!~ is a function (and supports a runtime-variable number of
  operations)
- Priority is supported in ~alt~

Finally, Clojure is hosted, i.e. we are bringing these facilities to
existing platforms, not needing a custom runtime. The flip-side is we
don't have the underpinnings we would with a custom runtime. Reaching
existing platforms remains a core Clojure value proposition.

**** Whither actors?

I remain unenthusiastic about actors. They still couple the producer
with the consumer. Yes, one can emulate or implement certain kinds of
queues with actors (and, notably, people often do), but since any actor
mechanism already incorporates a queue, it seems evident that queues are
more primitive. It should be noted that Clojure's mechanisms for
concurrent use of state remain viable, and channels are oriented towards
the flow aspects of a system.

**** Deadlocks

Note that, unlike other Clojure concurrency constructs, channels, like
all communications, are subject to deadlocks, the simplest being waiting
for a message that will never arrive, which must be dealt with manually
via timeouts etc. CSP proper is amenable to certain kinds of automated
correctness analysis. No work has been done on that front for core.async
as yet.

Also note that async channels are not intended for fine-grained
computational parallelism, though you might see examples in that vein.

*** Future directions

Networks channels and distribution are interesting areas for attention.
We will also being doing performance tuning and refining the APIs.

**** Team

I'd like to thank the team that helped bring core.async to life:

- Timothy Baldridge
- Ghadi Shayban
- Alex Miller
- Alex Redington
- Sam Umbach

And once again, Tom Faulhaber for his work on autodoc.

**** Status

While the library is still in an early state , we are ready for people
to start trying it out and giving us feedback. The CLJS port is still
work in progress. Please have a look at the [[https://github.com/clojure/core.async/tree/master/examples][examples]], which we will
expand over time.

It should be noted that the protocols behind the implementation should
still be considered an implementation detail for the time being, until
we finish our exploratory work around network channels, which might
impact their design.

I hope that these async channels will help you build simpler and more
robust programs.

Rich

** [2014-08-06] Transducers are Coming
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2014/08/06/transducers-are-coming.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2014/08/06/transducers-are-coming
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2014-08-06
:CUSTOM_ID: content/news/2014/08/06/transducers-are-coming
:END:

Transducers are a powerful and composable way to build algorithmic
transformations that you can reuse in many contexts, and they're coming
to Clojure core and core.async.

Two years ago, in a [[https://clojure.org/news/2012/05/15/anatomy-of-reducer][blog post describing how reducers work]], I
described the reducing function transformers on which they were based,
and provided explicit examples like ~mapping~, ~filtering~ and
~mapcatting~. Because the reducers library intends to deliver an API
with the same 'shape' as existing sequence function APIs, these
transformers were never exposed a la carte, instead being encapsulated
by the macrology of reducers.

In working recently on providing algorithmic combinators for core.async,
I became more and more convinced of the superiority of reducing function
transformers over channel→channel functions for algorithmic
transformation. In fact, I think they are a better way to do many things
for which we normally create bespoke replicas of map, filter etc.

So, reducing function transformers are getting a name - *transducers*,
and first-class support in Clojure core and core.async.

*** What's a Transducer?

To recap that earlier post:

A reducing function is just the kind of function you'd pass to ~reduce~
- it takes a result so far and a new input and returns the next
result-so-far. In the context of transducers it's best to think about
this most generally:

#+BEGIN_EXAMPLE
;;reducing function signature
whatever, input -> whatever
#+END_EXAMPLE

and a transducer is a function that takes one reducing function and
returns another:

#+BEGIN_SRC clojure
;;transducer signature
(whatever, input -> whatever) -> (whatever, input -> whatever)
#+END_SRC

The primary power of transducers comes from their fundamental decoupling
- they don't care (or know about):
- the 'job' being done (what the reducing function does)
- the context of use (what 'whatever' is)
- the source of inputs (where input comes from).

The other source of power comes from the fact that transducers compose
using ordinary function composition.

The reducers library leverages transducers' decoupling from the job, the
representation, and the source of inputs to accomplish parallel
reduction. But transducers can also be used for:

- a la carte laziness
- transformations during collection building
- collection/iteration/laziness-free transforming reductions
- channel transformations, event notifications and more.

All of this is coming to Clojure core and core.async.

*** New stuff

Concretely, most of the core sequence functions are gaining a new arity,
one shorter than their current shortest, which elides the final
collection source argument. This arity will return a transducer that
represents the same logic, independent of lazy sequence processing.

Thus:

#+BEGIN_SRC clojure
;;look Ma, no collection!
(map f)
#+END_SRC

returns a 'mapping' transducer. filter et al get similar support.

You can build a 'stack' of transducers using ordinary function
composition (comp):

#+BEGIN_SRC clojure
(def xform (comp (map inc) (filter even?)))
#+END_SRC

You might notice the similarity between the above comp and a call to →>:

#+BEGIN_SRC clojure
(->> aseq (map inc) (filter even?))
#+END_SRC

One way to think of transducers is like →> but independent of the job
(lazy sequence creation) and the source of inputs (aseq).

*** Transducers in action

Once you've got a transducer, what can you do with it? *An open set of
things.*

For instance, given the above transducer and some data in a vector, you
can:

- lazily transform the data (one lazy sequence, not three as with
  composed sequence functions):

  #+BEGIN_EXAMPLE
  (sequence xform data)
  #+END_EXAMPLE

- reduce with a transformation (no laziness, just a loop):

  #+BEGIN_EXAMPLE
  (transduce xform + 0 data)
  #+END_EXAMPLE

- build one collection from a transformation of another, again no
  laziness:

  #+BEGIN_EXAMPLE
  (into [] xform data)
  #+END_EXAMPLE

- create a recipe for a transformation, which can be subsequently
  sequenced, iterated or reduced:

  #+BEGIN_EXAMPLE
  (iteration xform data)
  #+END_EXAMPLE

- or use the same transducer to transform everything that goes through
  a channel

  #+BEGIN_EXAMPLE
  (chan 1 xform)
  #+END_EXAMPLE

The latter demonstrates the corresponding new capability of core.async
channels - they can take transducers.

This post is just to serve as a heads up on what the ongoing work is
about. There will be more explanations, tutorials and derivations to
follow, here and elsewhere.

I'm excited about transducers and the power they bring, and I hope you
are too!

Rich

** [2015-06-30] Clojure 1.7 is now available
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2015/06/30/clojure-17.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2015/06/30/clojure-17
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2015-06-30
:CUSTOM_ID: content/news/2015/06/30/clojure-17
:END:

We are pleased to announce the release of Clojure 1.7. The two
headline features for 1.7 are transducers and reader
conditionals. Also see the [[https://github.com/clojure/clojure/blob/master/changes.md][complete list]] of all changes since Clojure
1.6 for more details.

*** Transducers

[[#content/reference/transducers][Transducers]] are composable algorithmic transformations. They are
independent from the context of their input and output sources and
specify only the essence of the transformation in terms of an
individual element. Because transducers are decoupled from input or
output sources, they can be used in many different processes -
collections, streams, channels, observables, etc. Transducers compose
directly, without awareness of input or creation of intermediate
aggregates.

Many existing sequence functions now have a new arity (one fewer
argument than before). This arity will return a transducer that
represents the same logic but is independent of lazy sequence
processing. Functions included are: map, mapcat, filter, remove, take,
take-while, drop, drop-while, take-nth, replace, partition-by,
partition-all, keep, keep-indexed, map-indexed, distinct, and interpose.
Additionally some new transducer functions have been added: cat, dedupe,
and random-sample.

Transducers can be used in several new or existing contexts:

- into - to collect the results of applying a transducer
- sequence - to incrementally compute the result of a transducer
- transduce - to immediately compute the result of a transducer
- eduction - to delay computation and recompute each time
- core.async - to apply a transducer while values traverse a channel

*** Portable Clojure and Reader Conditionals

It is now common to see a library or application targeting multiple
Clojure platforms with a single codebase. Clojure 1.7 introduces a new
extension (.cljc) for files that can be loaded by Clojure and
ClojureScript (and other Clojure platforms).

There will often be some parts of the code that vary between platforms.
The primary mechanism for dealing with platform-specific code is to
isolate that code into a minimal set of namespaces and then provide
platform-specific versions (.clj/.class or .cljs) of those namespaces.

To support cases where is not feasible to isolate the varying parts of
the code, or where the code is mostly portable with only small
platform-specific parts, 1.7 provides [[#content/reference/reader#reader-conditionals][Reader Conditionals]].

Reader conditionals are a new reader form that is only allowed in
portable cljc files. A reader conditional expression is similar to a
cond in that it specifies alternating platform identifiers and
expressions. Each platform is checked in turn until a match is found and
the expression is read. All expressions not selected are read but
skipped. A final :default fallthrough can be provided. If no expressions
are matched, the reader conditional will read nothing. The reader
conditional splicing form takes a sequential expression and splices the
result into the surrounding code.

*** Contributors

Thanks to all of those who contributed patches to Clojure 1.7:

- Timothy Baldridge
- Bozhidar Batsov
- Brandon Bloom
- Michael Blume
- Ambrose Bonnaire-Sergeant
- Aaron Cohen
- Pepijn de Vos
- Andy Fingerhut
- Gary Fredricks
- Daniel Solano Gómez
- Stuart Halloway
- Rich Hickey
- Immo Heikkinen
- Andrei Kleschinsky
- Howard Lewis Ship
- Alex Miller
- Steve Miner
- Nicola Mometto
- Tomasz Nurkiewicz
- Ghadi Shayban
- Paul Stadig
- Zach Tellman
- Luke VanderHart
- Jozef Wagner
- Devin Walters
- Jason Wolfe
- Steven Yi

Also, continued thanks to the total list of contributors from all
releases.

** [2016-01-14] Welcome to the new clojure.org!
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2016/01/14/clojure-org-live.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2016/01/14/clojure-org-live
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2016-01-14
:CUSTOM_ID: content/news/2016/01/14/clojure-org-live
:END:

You are reading this on the newly updated Clojure web site! The first
thing you will notice is that everything got a fresh coat of paint and
the design is a big step forward. Essentially all of the old page
content has been moved over to the new site, however some things are in
new locations - in virtually all of those cases, you should find
redirects taking you to the new location.

There are also several new things on the site:

- News - periodically we will post topical news here about new
  features, releases, or other things of note - these also appear as
  links on the home page
- [[#content/community/events][Events]] - there is now a page for each upcoming Clojure event, also
  with links on the home page
- [[#content/guides/guides][Guides]] - a new section for
  building out community guides and tutorials

Most importantly, all of the site content is stored in a [[https://github.com/clojure/clojure-site][repository]]
and open for pull requests from contributors with a signed contributor
agreement. If you are interested in adding or changing content, please
check out the page on [[#content/community/contributing_site][site contributions]] and the current [[https://github.com/clojure/clojure-site/issues][issues]] list.

** [2016-01-19] Clojure 1.8 is now available
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2016/01/19/clojure18.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2016/01/19/clojure18
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2016-01-19
:CUSTOM_ID: content/news/2016/01/19/clojure18
:END:

Some of the new features for 1.8 are:

- More string functions in [[clojure:string.clj][clojure.string]] (portable to ClojureScript):
  index-of, last-index-of, starts-with?, ends-with?, includes?
- Compiler [[#content/reference/compilation#direct-linking][direct linking]] - improves performance and startup time
- [[#content/reference/repl_and_main#launching-a-socket-server][Socket server]] and socket server REPL - adds the ability to allow
  remote Clojure REPL connections

For more information, see the [[https://github.com/clojure/clojure/blob/master/changes.md][complete list]] of all changes since
Clojure 1.7 for more details.

*** Contributors

Thanks to all of those who contributed to Clojure 1.8 (first time
contributors in bold):

- *Alexander Yakushev*
- Alex Miller
- Alex Redington
- Alf Kristian Stoyle
- Ambrose Bonnaire-Sergeant
- *Andrew Rosa*
- Andy Fingerhut
- *Andy Sheldon*
- *Aspasia Beneti*
- *Blake West*
- Bozhidar Batsov
- *Daniel Compton*
- *Erik Assum*
- Gary Fredericks
- Ghadi Shayban
- *Gordon Syme*
- Howard Lewis Ship
- *Jean Niklas L'orange*
- *Jeremy Heiler*
- *Jonas Enlund*
- Jozef Wagner
- Karsten Schmidt
- Kevin Downey
- *Mark Simpson*
- Michael Blume
- *Nahuel Greco*
- Nicola Mometto
- *Nikita Prokopov*
- *Nola Stowe*
- *Ragnar Dahlén*
- *Ralf Schmitt*
- Rich Hickey
- *Russ Olsen*
- *Shogo Ohta*
- Steve Miner
- Stuart Halloway
- Timothy Baldridge
- *Tsutomu Yano*
- *Yanxiang Lou*

** [2016-01-28] State of Clojure 2015 survey results
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2016/01/28/state-of-clojure-2015.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2016/01/28/state-of-clojure-2015
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2016-01-28
:CUSTOM_ID: content/news/2016/01/28/state-of-clojure-2015
:END:

Check out the State of Clojure 2015 survey results here:

[[http://blog.cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results]]

Thanks for responding - it's great to see the community growing and
doing great things!

** [2016-05-23] Introducing clojure.spec
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2016/05/23/introducing-clojure-spec.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2016/05/23/introducing-clojure-spec
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-05-23
:CUSTOM_ID: content/news/2016/05/23/introducing-clojure-spec
:END:

I'm happy to introduce today ~clojure.spec~, a new core library and
support for data and function specifications in Clojure.

*** Better Communication

Clojure is a dynamic language, and thus far we have relied on
documentation or external libraries to explain the use and behavior of
functions and libraries. But documentation is difficult to produce, is
frequently not maintained, cannot be automatically checked and varies
greatly in quality. Specs are expressive and precise. Including ~spec~
in Clojure creates a lingua franca with which we can state how our
programs work and how to use them.

*** More Leverage and Power

A key advantage of specifications over documentation is the leverage
they provide. In particular, specs can be utilized by programs in ways
that docs cannot. Defining specs takes effort, and ~spec~ aims to
maximize the return you get from making that effort. ~spec~ gives you
tools for leveraging specs in documentation, validation, error
reporting, destructuring, instrumentation, test-data generation and
generative testing.

*** Improved Developer Experience

Error messages from macros are a perennial challenge for new (and
experienced) users of Clojure. Specs can be used to conform data in
macros instead of using a custom parser. And Clojure's macro expansion
will automatically use specs, when present, to explain errors to users.
This should result in a greatly improved experience for users when
errors occur.

*** More Robust Software

Clojure has always been about simplifying the development of robust
software. In all languages, dynamic or not, tests are essential to
quality - too many critical properties are not captured by common type
systems. ~spec~ has been designed from the ground up to directly support
generative testing via [[https://github.com/clojure/test.check][test.check]]. When you use ~spec~ you get
generative tests for free.

Taken together, I think the features of ~spec~ demonstrate the ongoing
advantages of a powerful dynamic language like Clojure for building
robust software - superior expressivity, instrumentation-enhanced
REPL-driven development, sophisticated testing and more flexible
systems. I encourage you to read the ~spec~ [[https://clojure.org/about/spec][rationale and overview]]. Look
for spec's inclusion in the next alpha release of Clojure, within a
day or so.

I hope you find ~spec~ useful and powerful.

Rich

** [2017-01-31] State of Clojure 2016 Results
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2017/01/31/state-of-clojure-2016.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2017/01/31/state-of-clojure-2016
:CLOJURE_SITE_AUTHOR: Justin Gehtland
:CLOJURE_SITE_DATE: 2017-01-31
:CUSTOM_ID: content/news/2017/01/31/state-of-clojure-2016
:END:

Welcome back to the annual State of Clojure survey results. This year we
held steady in our response rate as 2,420 of you took the time and
effort to weigh in on your experience with Clojure - as always, we
appreciate that time and effort very much. And, as always, thanks to
Chas Emerick for starting this survey 7 years ago.

Clojure (and ClojureScript) were envisioned as tools that could make
programming simple, productive, and fun. They were always aimed squarely
at the working developer - someone being paid to solve complicated
problems who needed to focus more on the solution and less on the
unnecessary complexity surrounding it. While we love the academics, open
source developers, and hobbyists who have flocked to Clojure, we are
always happy to see signs of commercial adoption.

Last year, we had an outright majority of users (57%) using Clojure at
work. This year, that number accelerates up to 67%.

[[./assets/images/content/news/2017-01-31/use.jpg]]

Within this group of users, several interesting themes emerge:

- [[#content/news/2017/01/31/state-of-clojure-2016#products][commercial Clojure use is for products, not just internal tooling]]
- [[#content/news/2017/01/31/state-of-clojure-2016#cloud][Clojure users are adopting the public cloud]]
- [[#content/news/2017/01/31/state-of-clojure-2016#companies][Clojure has penetrated all kinds of companies, not just startups]]
- [[#content/news/2017/01/31/state-of-clojure-2016#adoption][one of the biggest barriers to adoption is corporate aversion to new technologies]]

In addition to these themes, we've included [[#content/news/2017/01/31/state-of-clojure-2016#details][detailed analysis]] of the
individual questions as well as links to the [[#content/news/2017/01/31/state-of-clojure-2016#data][raw data]].

*** Commercial Clojure use is for products, not just internal tools
:PROPERTIES:
:CUSTOM_ID: content/news/2017/01/31/state-of-clojure-2016#products
:END:

A whopping 60% of respondents who use Clojure at work are building
applications for people "outside my organization". We changed the
wording of the answers to this question from the 2015 survey, so a
direct head-to-head comparison isn't possible. However, in 2015, fully
70% of respondents said their use was for "personal" projects, while 42%
said "company-wide/enterprise". This year, only 5% answered "just me".
Even without the direct results comparison, the data shows a dramatic
shift towards building products.

[[./assets/images/content/news/2017-01-31/users.jpg]]

This year we also introduced a new question, asking what industry or
industries people develop for. For commercial users, "Enterprise
Software" was the leader (at 22%), followed by "Financial
services/fintech", "Retail/ecommerce", "Consumer software",
"Media/advertising", and "Healthcare". Everything else was at under 5%
reporting. When we dig deeper and look at each of those industries in
turn, we find that within each one, "outside my organization" is still
the most common answer. In fact, only in "Financial services/fintech" do
internal tools come within 15% of "outside my organization".

[[./assets/images/content/news/2017-01-31/industry.jpg]]

*** Clojure users are adopting the public cloud
:PROPERTIES:
:CUSTOM_ID: content/news/2017/01/31/state-of-clojure-2016#cloud
:END:

Last year, 51% of respondents said they were deploying into the public
cloud. This year, that number is up to 57%, coming almost entirely at
the expense of "traditional infrastructure" (private/hybrid cloud was
essentially unmoved). Recently, rescale released a report estimating
that "we are in fact only at about 6% enterprise cloud penetration
today" ([[https://blog.rescale.com/cloud-3-0-the-rise-of-big-compute/]]).
Clojurists in the workforce are considerably ahead of this curve, if
true.

[[./assets/images/content/news/2017-01-31/deploy.jpg]]

There is, unsurprisingly, a heavy correlation between use of the public
cloud and developing applications for use "outside my organization". The
use of the public cloud also skews heavily towards smaller organizations
(companies of fewer than 100 people make up 70% of the public cloud
group, while only 55% of the "traditional infrastructure" fell into that
category).

There were only two industries where traditional infrastructure
dramatically beat public cloud: Government/Military (which seems
obvious) and Academia (which seems sad, although it could be a
reflection of universities' sunk investment in infrastructure). And only
Telecom had a majority of respondents indicating "private/hybrid", which
is almost certainly a reflection of the fact that hybrid cloud offerings
are, by and large, products from the Telecom sector.

[[./assets/images/content/news/2017-01-31/deploy-private.jpg]]

*** Clojure has penetrated all kinds of companies, not just startups
:PROPERTIES:
:CUSTOM_ID: content/news/2017/01/31/state-of-clojure-2016#companies
:END:

If you look at the spread of response for size of organization, while
there is a clear winner (11-100), the split is fairly even otherwise. A
full 17% of responses were from companies of 1000+ people.

[[./assets/images/content/news/2017-01-31/size.jpg]]

Web development and open source development are the dominant two domains
regardless of company size, but coming in at a strong #3 is "building
and delivering commercial services", except when you look at responses
from 1000+ companies, in which case "enterprise apps" unsurprisingly
moves ahead.

[[./assets/images/content/news/2017-01-31/large-industry.jpg]]

"Enterprise software" is the #1 industry regardless of company size.
However, #2 is quite distinctly different across sizes — in smaller
companies (< 100 employees), "consumer software" is the strong #2,
whereas for companies > 100 employees, financial services is the
dominant #2.

(An interesting aside: most industries show a normal bell curve, with
most respondents coming from the middle two categories, 11-100 and
101-1000. For example:

[[./assets/images/content/news/2017-01-31/size-per-industry.jpg]]

Only two industries show the inverted bell curve, with the most
respondents at the edges — Academia, and Government/Military.

[[./assets/images/content/news/2017-01-31/size-per-industry-invert.jpg]]

You will note that these are the two industries where "traditional
infrastructure" also dominates, so the distribution of respondents
either being from the largest [most conservative] and smallest [most
disruptive] paints an interesting picture of how industries change.)

*** One of the biggest barriers to adoption is corporate aversion to new technologies
:PROPERTIES:
:CUSTOM_ID: content/news/2017/01/31/state-of-clojure-2016#adoption
:END:

As was true the last two years, error messages and "hiring and staffing"
are the top 2 reasons given for "What has been most frustrating or has
prevented you from using Clojure more than you do now?" though both have
fallen several percent since then. Interestingly, "Need docs/tutorials"
has jumped from #5 in 2015 to #3 now, which corresponds well with a
continuing growth of new entrants into the community.

[[./assets/images/content/news/2017-01-31/prevent.jpg]]

When you break down respondents by size, each category is relatively
uniform with one glaring exception: for some reason, companies of
100-1000+ people have a problem with the lack of static typing (it is a
strong #3 in that cohort). Everyone else has a carbon copy distribution
of the overall answers. When you look by industry, the "enterprise
software" crowd would clearly benefit from more tools and a better IDE
experience.

What we found fascinating was drilling through the free answer portion
of the responses to this question. Next year, we'll be adding a new
possible answer: "corporate aversion to new technologies". If it was
captured as one of the main responses, it would come in #2 or #3
overall. We clearly have work to do as a community to arm the
technologists who wish to adopt Clojure with the materials and support
they need to overcome internal inertia or resistance. That's an area
we'd love to both see more people contributing, but also letting us at
Cognitect know what else we could provide that would be useful.

*** Summary

When you dig into these numbers, you see a technology that has been
accepted as a viable tool for crafting solutions across industries,
company types and sizes, and target domains. As you might expect,
adoption of Clojure seems closely correlated with the adoption of other
new technologies, like the public cloud, and Clojure is beset with some
of the same headwinds, like corporate aversion to new things. We are
encouraged by the maturation of the community and of the ability of the
technology and its adherents to tackle the hard problems of commercial
software development.

*** Detailed Results
:PROPERTIES:
:CUSTOM_ID: content/news/2017/01/31/state-of-clojure-2016#details
:END:

In addition to the big themes above, this section highlights a few of
the more interesting results for specific questions in the survey. For
details on all questions, see the full results.

**** Which dialects of Clojure do you use?

The interesting detail here was that the percentage of respondents using
ClojureScript rose yet again, such that 2/3 of users are now using both
Clojure and ClojureScript together (this has continually risen from
about 1/2 3 years ago):

[[./assets/images/content/news/2017-01-31/dialect.jpg]]

Clojure increasingly delivers on the promise of a single unified
language stack that can be used to cover an entire application.

**** Prior to using Clojure, ClojureScript, or ClojureCLR, what was your primary development language?

We've changed the way this question is asked and the options provided
several times so it's difficult to assess trends. However, it's clear
that developers come to Clojure either from imperative/OO languages
(Java, C#, C/C++) or from dynamic languages (Ruby, Python, JavaScript,
etc) with only small numbers coming from functional programming
languages like Scala, Common Lisp, Haskell, Erlang, etc.

[[./assets/images/content/news/2017-01-31/prior-lang.jpg]]

**** What is your *primary* Clojure, ClojureScript, or ClojureCLR development environment?

Due to the general volatility of tools, it's interesting to see how this
changes year to year. However, this year things were mostly pretty
static with the three most common choices again Emacs/CIDER,
Cursive/IntelliJ, and Vim with no major changes in percent use. Sublime,
Light Table, and Eclipse/Counterclockwise all became a bit less common.
The most interesting development was the rise in the use of Atom which
was a new choice and selected by 6% of respondents.

[[./assets/images/content/news/2017-01-31/editor.jpg]]

**** What Clojure, ClojureScript, or ClojureCLR community forums have you used or attended in the last year?

This was a new question this year, trying to get a sense of how people
are interacting with other members of the community. The Clojurians
slack channel was the most frequently used - this is a great place to
connect with others and has taken the place of IRC for many. About half
of respondents are using the original language mailing lists, and almost
that many have looked at the Clojure subreddit.

[[./assets/images/content/news/2017-01-31/community.jpg]]

Interestingly, most respondents have not attended either local Clojure
meetups or Clojure conferences either in-person or remotely. There are
many active Clojure meetups and conferences in the world - if you'd like
to talk to other Clojurists, take a look and see if one is near you!

**** Which versions of Clojure do you currently use in development or production?

Library maintainers are often interested in how quickly users are
migrating to newer versions of Clojure as they decide whether they can
use new features. We can see in this year's survey that most users are
on the latest stable version (1.8.0) - 83%, with a third of respondents
already using the 1.9 prereleases prior to final release. Less than 5%
are using a Clojure version older than Clojure 1.7, which is good news
for those that wish to rely on 1.7 features like cljc files or
transducers.

[[./assets/images/content/news/2017-01-31/clojure-versions.jpg]]

**** What versions of the JDK do you target?

Similar to the prior question, it's useful to track what versions of the
JDK are in use in the community. We saw significant consolidation to
Java 1.8 over the past year (with Java 1.9 on the horizon) - 95% of
users are using it with only about 2% using a version older than Java
1.7. For the moment, Clojure is still supported on Java 1.6 but
eventually that support will be dropped.

[[./assets/images/content/news/2017-01-31/jdk-versions.jpg]]

**** What tools do you use to compile/package/deploy/release your Clojure projects?

While Leiningen continues to be ubiquitous, boot made significant
advances this year, moving from 13% usage to 22% usage.

[[./assets/images/content/news/2017-01-31/tools.jpg]]

**** What has been most frustrating or has prevented you from using Clojure more than you do now?

Error messages continued to be the top frustration for people and we
will continue to improve those with the integration of spec in Clojure
1.9. Interestingly, the majority of the other frustrations went down
this year compared to last year:

- Hiring/staffing - from 33% to 30%
- Scripting - from 33% to 18% (maybe due to the rise of Planck and
  Lumo)
- Docs - from 25% to 22% (hopefully the new Clojure and ClojureScript
  web sites have helped)
- Static typing - from 23% to 16% (maybe due to the release of spec)
- Long-term viability - from 20% to 10%
- Finding libraries - from 16% to 11%
- Portability - from 10% to 5% (continued uptake of cljc / reader
  conditionals)

[[./assets/images/content/news/2017-01-31/prevent-reason.jpg]]

**** Which JavaScript environments do you target?

The most interesting story here is the rise in three areas:

- React Native - 18% (new choice this year)
- Electron - 11% (new choice this year)
- AWS Lambda - 9% (vs 5% last year)

As JavaScript continues to seep into every area of computing,
ClojureScript is following along with it and seeing new and interesting
uses.

[[./assets/images/content/news/2017-01-31/js-env.jpg]]

**** Which tools do you use to compile/package/deploy/release your ClojureScript projects?

We saw a small increase in Figwheel this year (after a huge jump after
its release) with about 2/3 of ClojureScript users now using it. And as
we saw in the prior tools question, there is a big jump in the number of
ClojureScript developers using boot (from 15 to 23%).

[[./assets/images/content/news/2017-01-31/cljs-deploy.jpg]]

**** Which ClojureScript REPL do you use most often?

Again, even more usage of Figwheel here (76%, up from 71% last year). We
added Planck this year and it registered at 9%. The Lumo repl was not
listed as a choice but did make a showing in the comments.

[[./assets/images/content/news/2017-01-31/cljs-repl.jpg]]

**** How are you running your ClojureScript tests?

We added this question to gather some information on what seems like an
underserved area of the ecosystem. Of those who responded, we saw:

[[./assets/images/content/news/2017-01-31/cljs-test.jpg]]

However, there was a lot of information in the "Other" responses as
well. At least 60 people (more than replied for the Nashorn choice
above) responded that they were either not testing at all or were
relying on testing their ClojureScript via cljc tests that ran in
Clojure. This is a great area for future improvements with no real
consensus and a lot of developers not even doing it at all. Some other
choices seen in the comments were Devcards, Karma, Phantom, and doo.

**** What has been most frustrating or has prevented you from using ClojureScript more than you do now?

The top answer here was "Using JavaЅcript libs with ClojureScript /
Google Closure", which was a new choice we added this year. David Nolen
and the ClojureScript community have been working hard on some of the
biggest pain points in this area, which culminated in the recent release
of a new ClojureScript version with better support for externs and
modules.

[[./assets/images/content/news/2017-01-31/cljs-prevent.jpg]]

Some of the other choices fell in importance this year (similar to
Clojure):

- "Using ClojureScript REPLs" went from 45% to 34% (rise of Figwheel,
  Planck, Lumo)
- "Availability of docs" went from 39% to 31% (new ClojureScript web
  site)
- "Long-term viability" went from 15% to 10%

**** Here you can add any final comments or opinions...

The majority of responses (~62%) here either expressed sentiments of
happiness or gratitude (always good to see). Other categories centered
around expected themes (many are areas of current or future work):
docs/tutorials, error messages, tooling, startup time, etc. One
relatively stronger theme this year was the need for better marketing
for the purposes of expanding or introducing Clojure within
organizations, which is a great area for contribution from the entire
community.

*** The data
:PROPERTIES:
:CUSTOM_ID: content/news/2017/01/31/state-of-clojure-2016#data
:END:

If you'd like to dig into the results more deeply, you can find the
complete set of data from this and former years here:

- [[https://www.surveymonkey.com/results/SM-7K6NXJY3/][2016]]
- [[http://blog.cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results][2015]]
- [[http://blog.cognitect.com/blog/2014/10/20/results-of-2014-state-of-clojure-and-clojurescript-survey][2014]]
- [[http://cemerick.com/2013/11/18/results-of-the-2013-state-of-clojure-clojurescript-survey/][2013]]
- [[http://cemerick.com/2012/08/06/results-of-the-2012-state-of-clojure-survey/][2012]]
- [[http://cemerick.com/2011/07/11/results-of-the-2011-state-of-clojure-survey/][2011]]
- [[http://cemerick.com/2010/06/07/results-from-the-state-of-clojure-summer-2010-survey/][2010]]

Thanks again for providing your responses to help form this picture of
our growing community!

** [2017-12-08] Clojure 1.9 is now available
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2017/12/08/clojure19.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2017/12/08/clojure19
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-12-08
:CUSTOM_ID: content/news/2017/12/08/clojure19
:END:

Clojure 1.9 is now available!

Clojure 1.9 introduces two major new features: integration with spec and
command line tools.

spec ([[#content/about/spec][rationale]], [[#content/guides/spec][guide]]) is a library for describing the structure of
data and functions with support for:

- Validation
- Error reporting
- Destructuring
- Instrumentation
- Test-data generation
- Generative test generation
- Documentation

Clojure integrates spec via two new libraries (still in alpha):

- [[https://github.com/clojure/spec.alpha][spec.alpha]] - spec implementation
- [[https://github.com/clojure/core.specs.alpha][core.specs.alpha]] - specifications for Clojure itself

This modularization facilitates refinement of spec separate from the
Clojure release cycle.

The command line tools ([[#content/guides/getting_started][getting started]], [[#content/guides/deps_and_cli][guide]], [[#content/reference/deps_and_cli][reference]]) provide:

- Quick and easy install
- Clojure REPL and runner
- Use of Maven and local dependencies
- A functional API for classpath management ([[https://github.com/clojure/tools.deps.alpha][tools.deps.alpha]])

The installer is available for Mac developers in brew, for Linux users
in a script, and for more platforms in the future.

For more information, see the [[https://github.com/clojure/clojure/blob/master/changes.md][complete list of all changes]] in Clojure
1.9 for more details.

*** Contributors

Thanks to all of the community members who contributed to Clojure 1.9
(first time contributors in bold):

- *Adam Clements*
- Andy Fingerhut
- Brandon Bloom
- *Cameron Desautels*
- *Chad Taylor*
- Chris Houser
- *David Bürgin*
- *Eli Lindsey*
- *Gerrit Jansen Van Vuuren*
- Ghadi Shayban
- *Greg Leppert*
- *Jason Whitlark*
- *Johan Mena*
- Jozef Wagner
- *Lee Yen-Chin*
- *Matthew Boston*
- Michael Blume
- Michał Marczyk
- Nicola Mometto
- *Ruslan Al-Fakikh*
- *Steffen Dienst*
- Steve Miner
- *Yegor Timoshenko*
- *Zhuang XiaoDan*

** [2018-01-05] Git Deps for Clojure
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2018/01/05/git-deps.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2018/01/05/git-deps
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2018-01-05
:CUSTOM_ID: content/news/2018/01/05/git-deps
:END:

Clojure was designed to empower developers by enabling them to leverage
existing libraries. When Clojure was first released, this manifest
itself in strong interop support for Java. Eventually tooling (Leiningen
et al) arose around procuring Java libs from the Maven ecosystem, and
Clojure, its contribs, and the community also adopted the Maven approach
to /delivering/ libraries via artifacts hosted in well known
repositories like Maven Central and Clojars.

There were many benefits to this, but, like most things in programming,
there were attendant costs. Artifact based releases predate the
widespread adoption of content-based addressing systems like Git.
Without content-based addressing, they depend on conventions of release
naming and weak notions like semantic versioning. They also reflect the
nature of languages like Java and C that require a build step prior to
execution. Most Clojure libraries do not.

The modern reality of Clojure development is that (mostly) we use Git,
we use centralized Git repos like Github, Bitbucket et al, and code is
executable. Producing and consuming artifacts creates a lot of
unnecessary friction between creating code and using it. Let's get rid
of it when not needed!

Today we're happy to announce the availability of git deps support in
Clojure tools. It leverages the fact that tools.deps does not use the
Maven dependency resolver but instead resolves dependencies on its own.
This decouples dependency resolution and classpath creation from any
single library publishing/procurement mechanism. Git repos become a
source of libraries directly.

You can now specify git coordinates (in addition to mvn and local) in
deps.edn:

#+BEGIN_SRC clojure
{:deps
 {org.clojure/data.csv {:git/url "https://github.com/clojure/data.csv.git"
                        :sha "e5beccad0bafdb8e78f19cba481d4ecef5fabf36"}}}
#+END_SRC

The tools support (available as a library in tools.gitlibs) will:

- securely log into the git repository host and clone the repo (if
  needed)
- checkout and cache (per library+sha) the specified working tree (if
  needed)
- resolve transitive deps and incorporate the cached directory into the
  classpath

Of course, not every commit is stable, so one can designate stable
points using tags.

This greatly reduces the ceremony and tooling required to share and
consume libraries, facilitates parallel development of sibling
libraries, testing, speculative forks etc. and fosters a greater
connection to source truth while preserving the secure centralized
hosting, stable repeatability and caching one gets from e.g. Maven.

I am hopeful this git support will usher in a new level of agility for
Clojure development. Many thanks to Alex Miller for his tireless efforts
to convert these ideas into a working system.

For more information see:

- [[#content/guides/getting_started][Getting Started]] - to install or update the Clojure tools
- [[#content/guides/deps_and_cli][Deps and CLI Guide]] - on how to use the Clojure tools
- [[#content/reference/deps_and_cli][Deps and CLI Reference]] - complete reference info
- [[https://www.youtube.com/watch?v=oyLBGkS5ICk][Spec-ulation]] keynote - on growth versus breakage

** [2018-03-19] State of Clojure 2018 Results
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2018/03/19/state-of-clojure-2018.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2018/03/19/state-of-clojure-2018
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-03-19
:CUSTOM_ID: content/news/2018/03/19/state-of-clojure-2018
:END:

Welcome to the annual State of Clojure 2018 survey results! Thanks so
much for taking the time to check in and provide your feedback. We are
very fortunate to have data for some of these questions going all the
way back to 2010, giving us a long view on how the data is trending.
This year, we had 2325 respondents, about the same as last year.

*** Rapid Uptake of Clojure 1.9

With the release of Clojure 1.9 in December, we expected to see a shift
in version usage, and we did. 72% of developers are already using it
with about 60% still using Clojure 1.8 as well. Only a small (6%) number
of developers are still using versions 1.7 or older.

[[./assets/images/content/news/2018-03-19/clojure-use.png]]

We also keep an eye on JDK usage. Uptake of Java 1.9, released last
year, has been a bit slower with only 29% adopting Java 1.9 so far and
88% of developers using Java 1.8. Only 6% of developers are using Java
1.7 and less than 1% are still using Java 1.6.

In the editor/IDE world we saw some consolidation this year with both
Emacs (50%) and IntelliJ/Cursive (29%) making gains. All other editors
saw decreases, although there is still a lot of interesting innovation
happening around Atom and VS Code, which was not included but saw a lot
of mentions in the comments (~5% of total respondents) - will definitely
add next year!

[[./assets/images/content/news/2018-03-19/editor.png]]

In the ClojureScript world, Figwheel continues to dominate as a
critical part of most ClojureScript developer's REPL workflow (76%).
[[https://clojuriststogether.org/][Clojurists Together]] is a new community effort to support open source
projects in the community and they have been [[https://clojuriststogether.org/news/february-2018-monthly-update/][funding]] work on Figwheel
among other projects. Lumo was a new REPL option this year and made a
strong showing of 12%.

[[./assets/images/content/news/2018-03-19/repl.png]]

In CLJS target environments, we saw an increase of +6% targeting Node
(to 29%) and +4% targeting Lambda (to 13%) - both things to watch.

In the build tooling world, the entry of the [[https://clojure.org/guides/deps_and_cli][clj]] tool is driving a lot
of reevaluation and change right now. With so many things in flux,
this area is sure to evolve significantly in 2018 and it will be
interesting to see where we are in 2019. One important omission in the
choices this year was shadow-cljs. There were a lot of mentions in the
comments and it's clearly an important tool for many to build and
deploy - we'll be sure to add it next year.

*** Interest Surging from JavaScript Programmers

When we look at which language communities people are coming from, those
answers have been remarkably stable for years, but there was significant
movement this year for JavaScript (which vaulted over both Python and
Ruby). Clearly people are finding ClojureScript (and its strong
resonance with React) as an interesting and viable alternative to
JavaScript.

[[./assets/images/content/news/2018-03-19/prior-langs.png]]

As to where Clojurists hang out, we saw significant increases in use of
Reddit (+5%) and Slack (+4%) and some decreases in use of the Clojure
mailing lists, IRC, and attendance at both in-person and on-line
conferences. One new choice added this year was the ClojureVerse
Discourse server - it seems to be a useful midpoint between Slack (high
volume live chat) and mailing lists (low volume asynchronous
discussion). This was a new option yet 17% of respondents reported using
it.

[[./assets/images/content/news/2018-03-19/community-forums.png]]

*** Clojure and ClojureScript Used in Many Domains and Industries

One of the things we are always watching is the trend of people using
Clojure for their day-to-day work. This year, we continued to see about
2/3 of respondents using Clojure for work (compare that to the very
first survey back in 2010 when less than 1/3 were doing so). Web
development has always been the most dominant domain - in 2010, 53% were
doing web dev and these days fully 82% of Clojure devs are involved in
some kind of web development (not surprising given how many Clojure devs
are using both Clojure and ClojureScript together).

[[./assets/images/content/news/2018-03-19/domains.png]]

When looking at the industries using Clojure, we added a few choices
this year based on prominent results in last year's "Other" category -
entertainment (3%), energy/utility (2%), automotive/manufacturing (2%).
We also saw a noticeable increase (+3%) in Financial services. Perhaps
due to the new choices, we saw small decreases in the largest and most
generic categories, enterprise software and consumer software.

[[./assets/images/content/news/2018-03-19/industries.png]]

*** Interest in Hiring Stays Strong

There are several questions about how Clojure and ClojureScript should
change or be prioritized for improvement. The results are largely
similar to prior years, although the question format changed a little
making it hard to directly compare every detail. The top result is
clearly error messages though - while spec has started us down a road,
that is still a work in progress which will continue this year. Many
people have been using the Expound library for taking spec error output
and making the data easier to read.

Hiring and staffing is always an interesting one to watch and that
increased this year. We often see the seemingly contradictory dual
complaints of companies that need more people and developers that have a
hard time finding positions. To a large degree this is either a mismatch
in the geographic distribution of jobs and people and/or a mismatch in
needs and skill levels. It has been very encouraging to see so many
large teams growing and hiring of late though.

The need for more docs and tutorials is also one that has gone up and
down over the years and seems to be up again this year. While there are
a wealth of resources for new Clojure developers now in every format, it
is also sometimes difficult for people to find just the right resource
for their experience level and need. There have been many good
discussions lately about this and lots of active work in the community.

In general, there have been so many new tools, learning resources,
companies, etc of late that it's hard to keep up - 2018 is going to be a
great year for Clojure!

*** Check Out the Data

If you'd like to dig into the full results, you can find the complete
set of data from this and former years here:

- [[https://www.surveymonkey.com/results/SM-9BC5FNJ68/][2018]]
- [[https://www.surveymonkey.com/results/SM-7K6NXJY3/][2016]]
- [[http://blog.cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results][2015]]
- [[http://blog.cognitect.com/blog/2014/10/20/results-of-2014-state-of-clojure-and-clojurescript-survey][2014]]
- [[http://cemerick.com/2013/11/18/results-of-the-2013-state-of-clojure-clojurescript-survey/][2013]]
- [[http://cemerick.com/2012/08/06/results-of-the-2012-state-of-clojure-survey/][2012]]
- [[http://cemerick.com/2011/07/11/results-of-the-2011-state-of-clojure-survey/][2011]]
- [[http://cemerick.com/2010/06/07/results-from-the-state-of-clojure-summer-2010-survey/][2010]]

/Note that we are doing the survey about every 14 months so the last
survey occurred in late 2016 rather than 2017./

Thanks again for being part of the community!

** [2018-12-17] Clojure 1.10 release
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2018/12/17/clojure110.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2018/12/17/clojure110
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-12-17
:CUSTOM_ID: content/news/2018/12/17/clojure110
:END:

Clojure 1.10 focuses on two major areas: improved error reporting and
Java compatibility.

Error reporting at the REPL now
[[#content/reference/repl_and_main#error-printing][categorizes]]
errors based on their phase of execution (read, macroexpand, compile,
etc). Errors carry additional information about location and context as
data, and present phase-specific error messages with better location
reporting. This functionality is built into the clojure.main REPL, but
the functionality is also available to other REPLs and tools with the
ability to use and/or modify the data to produce better error messages.

Clojure 1.10 now requires Java 8 or above and has been updated
particularly for compatibility with Java 8 and Java 11. Changes included
bytecode-related bug fixes, removed use of deprecated APIs, and updates
related to the module system introduced in Java 9.

See the [[https://github.com/clojure/clojure/blob/master/changes.md#changes-to-clojure-in-version-110][change log]] for a complete list of all fixes, enhancements, and
new features in Clojure 1.10.

*** Contributors

Thanks to all of the community members who contributed patches to
Clojure 1.10 (first time contributors in bold):

- *Alexander Kiel*
- *Ben Bader*
- Bruce Adams
- *Cezary Kosko*
- Erik Assum
- *Eugene Kostenko*
- Ghadi Shayban
- *Gijs Stuurman*
- Jozef Wagner
- *Kwang Yul Seo*
- *Matthew Gilliard*
- Michał Marczyk
- Nicola Mometto
- Nikita Prokopov
- *Sean Corfield*
- *Sebastien Martel*
- Shogo Ohta
- Stuart Sierra

** [2019-01-07] State of Clojure 2019 Survey
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2019/01/07/clojure-2019-survey.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2019/01/07/clojure-2019-survey
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-01-07
:CUSTOM_ID: content/news/2019/01/07/clojure-2019-survey
:END:

It's time for the annual State of Clojure Community Survey!

If you are a user of Clojure or ClojureScript, we are greatly interested
in your responses to the following survey:

- [[https://www.surveymonkey.com/r/clojure2019][State of Clojure 2019]]

The survey contains four pages:

1. General questions applicable to any user of Clojure or ClojureScript
2. Questions specific to JVM Clojure (skip if not applicable)
3. Questions specific to ClojureScript (skip if not applicable)
4. Final comments

The survey will close January 22nd, after which all of the data will be
released with some analysis. We greatly appreciate your input!

** [2019-02-04] State of Clojure 2019 Results
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2019/02/04/state-of-clojure-2019.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2019/02/04/state-of-clojure-2019
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-02-04
:CUSTOM_ID: content/news/2019/02/04/state-of-clojure-2019
:END:

Welcome to the annual State of Clojure survey results! Every year we
survey Clojure and ClojureScript developers to evaluate the state of the
language and its users. Thank you to everyone that took the time to
complete the survey and provide your input. This year, we had 2461
respondents. Some highlights:

- Clojure is used by many [[#content/news/2019/02/04/state-of-clojure-2019#a-language-for-work][companies]] for web development,
  commercial services, and enterprise apps in a broad set of domains
  including financial services, enterprise software, retail,
  advertising, health care, and more.
- Clojure is [[#content/news/2019/02/04/state-of-clojure-2019#strengths-of-clojure][valued]] for its idiomatic support for functional
  programming, immutable data, interactive REPL, and ease of
  development.
- Clojure and its [[#content/news/2019/02/04/state-of-clojure-2019#vibrant-community][community]] are active and vibrant, as seen in the
  many thriving discussion forums, conferences, and user groups, with
  active involvement in community library development.

For more details and the [[https://www.surveymonkey.com/results/SM-S9JVNXNQV/][full results]], see below.

*** A Language for Work
:PROPERTIES:
:CUSTOM_ID: content/news/2019/02/04/state-of-clojure-2019#a-language-for-work
:END:

In the first Clojure survey in 2010, 27% of respondents reported using
Clojure for work and 33% for serious hobby projects. This number has
steadily grown over the years and we now see 66% using it at work and
54% using it for serious hobby projects.

Clojure is being used in a wide variety of domains - web development
(81%) and open source (48%) of course, but also building and delivering
commercial services (31%) and enterprise apps (22%). This work occurs in
a wide variety of industries - financial services, enterprise software,
consumer software, retail, media/advertising, healthcare, education, and
many more.

For the last four years, the percentage of Clojure developers in 1-10
person companies has fallen, this year to 35% (compared to 44% 3 years
ago). We saw increases in developers working at companies sized 1000+
and 11-100. We also saw the number of consumers of these Clojure
projects as less "in team" and more "outside team" or "outside the
organization".

We added a new question this year to gauge the general experience
level of Clojure developers. Almost half of Clojure users (49%) had 11
or more years of experience with 21% having 21 years or more. A recent
[[https://snyk.io/blog/jvm-ecosystem-report-2018-processes-you/][JVM ecosystem survey]] asked a similar question and for comparison saw
42% had 11 or more years of experience and only 3% had 21 or more
years.  Clojure developers tend to be more experienced on average than
other JVM developers.

Survey comments said:

- "Thanks to Clojure and ClojureScript I can make a living building and
  maintaining large systems and delivering complex solutions on time.
  Thank you!"
- "Clojure is thoughtfully designed and stable. It's a dynamic,
  functional lisp that can actually be sold to the bosses. (A sentence
  I never thought I would write)."
- "There is no way my team could pull all the rabbits out of hats that
  we do working in any other language. The only thing I ever seriously
  worry about, about Clojure, is how to ensure I get to work in Clojure
  and with Clojurists again should my current gig come to an end."

Hundreds of [[#content/community/companies][companies]] and tens of thousands of Clojure developers are
working in Clojure or ClojureScript every day, using it as the
foundation of their business.  The survey indicates that Clojure
developers are increasingly using it more for work, at bigger
companies, impacting ever larger groups of users.

*** Strengths of Clojure
:PROPERTIES:
:CUSTOM_ID: content/news/2019/02/04/state-of-clojure-2019#strengths-of-clojure
:END:

For years we have asked people what aspects of Clojure were most
important to them. These answers are remarkably consistent and this year
was no different. However it is good to reexamine these strengths to see
why developers value Clojure. The big four that are always at the top of
the list are: functional programming, immutability, the REPL, and ease
of development. These traits are interrelated. Language support for
immutable persistent data structures makes functional programming
idiomatic and effective. A REPL on a live, growing system, with data
loaded, is a great way for developers to try their new code in context
as it is written, improving quality.

Other important features include host compatibility / interop (allowing
us to take full advantage of the underlying platform and its libraries,
whether that's the JVM or JavaScript), the community, runtime
performance, expressive syntax, concurrency support, and a shared
language across tiers.

Some comments about the language:

- "Quality permeates Clojure. Language design, library design,
  interactive development, community architecture experience, all top
  notch."
- "Clojure/script is allowing me to create things that would be
  impossible in other languages."
- "Clojure is beautiful, functional and concise. It really rejuvenated
  my love for programming."
- "I really appreciate the well thought out design of Clojure. We feel
  that Clojure gives us distinct advantages while providing a language
  with minimum disruption."

*** Vibrant Community
:PROPERTIES:
:CUSTOM_ID: content/news/2019/02/04/state-of-clojure-2019#vibrant-community
:END:

The Clojure community is active, growing, and always helpful. Over the
years, the primary communication mechanisms have changed along with the
industry varying from IRC to the mailing lists to in recent years,
Slack. We've been tracking this for a couple years now. Slack continues
to be strong with 64% of respondents using it (note that this may be
biased by where we advertised the survey!). The Clojure subreddit
continued its strong rise to 55% use. ClojureTV on YouTube was a new
answer this year but almost half are using it to watch Clojure videos.
The official Clojure mailing lists had another drop this year as people
shift away from "old school" mailing lists. And the original place where
communication happened for Clojure is IRC which continued to fall out of
use, now at only 7%.

We also added a new question to gauge how users of Clojure interact with
the ecosystem. 96% reported being happy users of the language and
libraries, 65% were building services or products, 51% were advocating
for Clojure in their organization. More than a quarter (28%) were active
in helping new users (something very common to see on Slack, Reddit, or
the mailing lists). And 25% reported creating or maintaining open source
libraries, filing issues on libraries (17%), or providing pull requests
for fixes (15%).

Some quotes from users:

- "It's been great watching the ecosystem converge on excellence these
  past years, thanks so much for all the work and careful design!"
- "I love how the community continues to improve, and people generally
  are friendly."
- "Thanks for a great language, a steady hand at the wheel, and a
  passionate community!"

*** The Data

If you'd like to dig into the full results, you can find the complete
set of data from this and former years here:

- [[https://www.surveymonkey.com/results/SM-S9JVNXNQV/][2019]]
- [[https://www.surveymonkey.com/results/SM-9BC5FNJ68/][2018]]
- [[https://www.surveymonkey.com/results/SM-7K6NXJY3/][2016]]
- [[http://blog.cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results][2015]]
- [[http://blog.cognitect.com/blog/2014/10/20/results-of-2014-state-of-clojure-and-clojurescript-survey][2014]]
- [[http://cemerick.com/2013/11/18/results-of-the-2013-state-of-clojure-clojurescript-survey/][2013]]
- [[http://cemerick.com/2012/08/06/results-of-the-2012-state-of-clojure-survey/][2012]]
- [[http://cemerick.com/2011/07/11/results-of-the-2011-state-of-clojure-survey/][2011]]
- [[http://cemerick.com/2010/06/07/results-from-the-state-of-clojure-summer-2010-survey/][2010]]

Thanks again for using Clojure and ClojureScript and participating in
the survey!

** [2019-05-16] JIRA Migration
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2019/05/16/jira-migration.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2019/05/16/jira-migration
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-05-16
:CUSTOM_ID: content/news/2019/05/16/jira-migration
:END:

Clojure has been very fortunate to receive infrastructure support from
[[https://www.atlassian.com][Atlassian]] (for JIRA and Confluence) and [[https://www.contegix.com/][Contegix]] (for hosting) for
many years.  The Confluence and JIRA instances were not kept up to
date, and have grown increasingly hard to maintain. Recently, we
decided to shut down Confluence (content was either moved to
[[https://clojure.org][clojure.org]] or [[https://archive.clojure.org/design-wiki/display/design/Home.html][archived]]) and we are now preparing to migrate from our
old JIRA instance into a new cloud-hosted instance. Many thanks to
Atlassian again for supporting our efforts in this.

*** User migration

Due to the large number of users, it is not feasible for us to move
everyone, and we've decided to migrate all users that have edited
tickets in the past (changed a description, added a patch, etc) - this
will move user names and emails, not passwords. When the import happens,
email invites will go out for users in the new system based on the email
address in the old system. Initially these users will not have access to
projects.

Users that created or commented on tickets in the past (but did not
edit) will not automatically be migrated. We are planning to leverage
JIRA Service Desk to create a new path for language users to file
tickets without needing an account. These incoming tickets can be
triaged and turned into JIRA tickets as needed. We are also looking at a
new process to obtain a contributor account and gain access to the
system for commenting or other work. Stay tuned for more on that.

*** Backup and import

After users have been loaded, a backup of the old system and import into
the new system will occur. All projects, issues, attachments, comments,
etc will be preserved. This will be done on a per-project basis until
the migration is complete and might take a while to fully import and
verify.

After that, there will be some work to enable access for different
project administrators and users before the system is fully available.

We will put the old system into a read-only mode once the backup and
import has started. Once the import is complete, the old system will be
shut down. Redirect rules will be set up for the old Confluence and JIRA
urls to point to the new Confluence archive and new JIRA system so that
old links will continue to work.

Please be patient as we make the transition. Thanks!

** [2019-06-06] Clojure 1.10.1 release
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2019/06/06/clojure1-10-1.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2019/06/06/clojure1-10-1
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-06-06
:CUSTOM_ID: content/news/2019/06/06/clojure1-10-1
:END:

Clojure 1.10.1 is a small release focusing on two issues: working around
a Java performance regression and improving error reporting from
clojure.main.

*** Java performance regression

Recent builds of Java 8 (u202), 11 (11.0.2), 12, and 13 included some
changes that drastically affect optimization performance of calls from
static initializers to static fields. Clojure provides support for
loading code on startup from a user.clj file and this occurred in the
static initializer of the Clojure runtime (RT) class and was thus
affected.

This issue may eventually be resolved in Java, but in Clojure we have
modified runtime initialization to avoid loading user.clj in a static
initializer, which mitigates the case where this caused a performance
degradation.

*** clojure.main error reporting

clojure.main is frequently used as a Clojure program launcher by
external tools. Previously, uncaught exceptions would be automatically
printed by the JVM, which would also print the stack trace.

This release will now catch exceptions and use the same error triage
and printing functionality as the Clojure repl. The full stack trace,
ex-info, and other information will be printed to a target specified
by the configuration. See [[#content/reference/repl_and_main#as-launcher][clojure.main docs]] for configuration details.

*** Changelog

See the [[https://github.com/clojure/clojure/blob/master/changes.md#changes-to-clojure-in-version-1101][change log]] for a complete list of all changes in Clojure
1.10.1.

** [2019-07-25] Clojure Forum
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2019/07/25/clojure-forum.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2019/07/25/clojure-forum
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-07-25
:CUSTOM_ID: content/news/2019/07/25/clojure-forum
:END:

We are pleased to announce today a new forum for Clojure and
ClojureScript users: [[https://ask.clojure.org]]. You can ask questions,
discuss possible problems, request enhancements, and vote on questions
and answers.

The new forum was seeded with all of the open JIRA issues, one question
per issue with JIRA comments turned into answers. Over time, we expect
this site to serve as a persistent store of common questions, answers,
etc - it is open for web indexing and has both search and "similar
question" functionality to help you find previous related discussions.
This addresses one of the biggest issues with current places to ask
questions about Clojure - the ability to search and find similar prior
discussions.

For problems and enhancements, we have been using JIRA for years (and
will continue to do so). However, there are naturally two audiences for
issues, users and developers, who have different needs. The new forum
will serve as the primary place for users to ask questions about
potential problems or request possible enhancments. Authentication
occurs via GitHub (other auth providers may be added in the future). No
contributor agreement is needed.

Developers on Clojure, ClojureScript, etc will monitor these forums and
create JIRAs when necessary. Any user may vote on questions in the forum
and the dev teams can use this information when prioritizing fixes and
enhancements. This capability has been available in JIRA for many years,
but it was too much of a barrier to receive feedback from casual users.
The new forum greatly reduces this friction. JIRA will still be used by
developers submitting and working on patches, but not for initial
problem reporting.

For more information see the [[#content/community/ask][forum usage details]].

** [2020-01-07] State of Clojure 2020 Survey
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2020/01/07/clojure-2020-survey.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2020/01/07/clojure-2020-survey
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-01-07
:CUSTOM_ID: content/news/2020/01/07/clojure-2020-survey
:END:

It's time for the annual State of Clojure Community Survey!

If you are a user of Clojure or ClojureScript, we are greatly interested
in your responses to the following survey:

- [[https://www.surveymonkey.com/r/clojure2020][State of Clojure 2020]]

The survey contains five pages:

1. General info
2. Tool usage
3. Questions specific to JVM Clojure (skip if not applicable)
4. Questions specific to ClojureScript (skip if not applicable)
5. Final comments

The survey will close January 23rd, after which all of the data will be
released with some analysis. We greatly appreciate your input!

** [2020-02-20] State of Clojure 2020 Results
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2020/02/20/state-of-clojure-2020.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2020/02/20/state-of-clojure-2020
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-02-20
:CUSTOM_ID: content/news/2020/02/20/state-of-clojure-2020
:END:

Ten years ago, Chas Emerick ran the first State of Clojure survey. In
2010, most users had been using Clojure for just weeks or months, and
few were using it as a language for serious work.  [[https://www.surveymonkey.com/results/SM-CDBF7CYT7/][This year]], we see
consistent and growing use for [[#content/news/2020/02/20/state-of-clojure-2020#clojure-at-work][work]], steady interest in the key [[#content/news/2020/02/20/state-of-clojure-2020#values][value]]
propositions of Clojure, and an ever-evolving [[#content/news/2020/02/20/state-of-clojure-2020#community][community]] of users.

*** Clojure at Work
:PROPERTIES:
:CUSTOM_ID: content/news/2020/02/20/state-of-clojure-2020#clojure-at-work
:END:

One of the questions we have been asking since 2010 is whether
respondents are using Clojure for work, hobby projects, tinkering, or
studies. This year, we saw the highest percentage yet of Clojure use at
work:

[[./assets/images/content/news/2020-02-20/use.png]]

Additionally, we saw a small shift in company size to bigger companies -
an increase of 3% in companies of size 1000+ (and reduction in companies
size 1-10).

[[./assets/images/content/news/2020-02-20/org-size.png]]

We also asked respondents for the first time how many people were using
Clojure at their organization. As expected, many Clojure teams are
small. As a high-leverage tool, Clojure is a great fit for small
highly-productive teams. However, it was also great to see many
respondents at companies with 40 or even 100+ Clojure developers.

[[./assets/images/content/news/2020-02-20/at-org.png]]

A question we've been asking since 2010 (with some variation in wording
and choices), is in what domains Clojure is being used. The top results
have not changed too much over the years but we did see a noticeable
increase this year in "enterprise applications", to its highest level
ever.

[[./assets/images/content/news/2020-02-20/domains.png]]

Feedback comments indicate Clojure is a tool yielding high leverage for
both companies and teams:

- "Clojure continues to be a force multiplier and a vital enabler for
  our production system."
- "Clojure enables our small team to do more with less."
- "Clojure is by far the best language I have to use at work, and it is
  a pleasure to solve problems using it. It is almost perfect."
- "Clojure is powering our data driven insurance ERP. I cannot think of
  a better approach. Many thanks!"
- "Hard to find too many complaints about Clojure: it's a wonderful
  language with a great community. I plan to stay with this language +
  community for a long time. We have basically bet the company's
  technical strategy on it."
- "I love using Clojure and ClojureScript and have moved all our
  development projects using various different languages (PHP, Python,
  C#, Javascript) to only using Clojure and ClojureScript"
- "Our startup is built solely on Clojure and Clojurescript and we are
  very happy with it."

Clojure's use continues to grow at hundreds of [[#content/community/companies][companies]], with an ever
higher percentage of developers using it at work for their core
business.

*** Values
:PROPERTIES:
:CUSTOM_ID: content/news/2020/02/20/state-of-clojure-2020#values
:END:

Since 2015, we have asked a question about which aspects of Clojure
users valued the most. The weighted ranking of those answers has
remained virtually identical since 2015. The most important things to
Clojure users are: functional programming, the REPL, immutable data,
ease of development, and host interop. Indeed these are all things
intrinsic to the Clojure experience and align strongly with the reasons
Clojure exists.

The open feedback comments often praised the steady arc of Clojure's
development and tradition for growing without breaking:

- "Clojure is an awesome lisp, lovingly created with taste and
  refinement. It is a pleasure to think and implement in the
  abstractions provided."
- "Great work, team! This is the most stable technology I've used in my
  many years doing software development."
- "I love what you are doing with the language and community. In the
  world of churn and constantly pumping changes just to create 'buzz'
  clojure is like a safe zone where my sanity is kept alive."
- "I really like the simplicity of Clojure and the functional nature of
  it. I also like the fact that the team doesn't slap on a ton of
  features like every other language out there."
- "Thanks for sticking to the principles: lean, conservative,
  essential, no frills, production grade software that brought back
  Lisp to the mainstream."

*** Community
:PROPERTIES:
:CUSTOM_ID: content/news/2020/02/20/state-of-clojure-2020#community
:END:

Again this year we surveyed the most popular forums where Clojurists
interact with each other. Some new and/or rising entries included
in-person Clojure conferences (we saw many new ones this year!), the
new [[https://ask.clojure.org][Ask Clojure]] site, Telegram chats, and Discord.

[[./assets/images/content/news/2020-02-20/forums.png]]

We also collect information on how users are involved in the Clojure
ecosystem. The response this year were very similar to last year but we
did see mild upticks in helping new Clojure users, advocating for
Clojure in their organization, and maintaining open source libraries,
all great contributions!

[[./assets/images/content/news/2020-02-20/ecosystem.png]]

In feedback comments, many people enjoyed the kind and responsive
Clojure community:

- "The Clojure community is absolutely fantastic. Being able to post a
  question and get thoughtful & insightful answers quickly is immensely
  valuable. Thank you for fostering such an incredible community."
- "Clojure (Script) is a great, well-thought out language that has
  helped me tremendously in my work. However, it also exposed me to a
  wonderful community of thoughtful developers who have given me
  wonderful new insights, while remaining a friendly and welcoming
  community"
- "Wonderful language and a uniquely insightful community. It has
  helped me rediscover my love for programming."

*** Deep Dives

Clojure developers will be particularly interested in the version and
tooling related questions in the survey.

One new question we asked this year was about the primary developer
operating system to give us better guidance about tool-related work. As
expected, MacOS was the leader (55%), followed by Linux (35%) and
Windows (9%):

[[./assets/images/content/news/2020-02-20/os.png]]

For primary development tool, there were only minor updates this year.
Emacs dropped slightly to 43%, IntelliJ/Cursive rose slightly to 32%,
and VS Code with Calva had the biggest increase to 10%.

[[./assets/images/content/news/2020-02-20/tool.png]]

Clojure users have a wealth of fine development environments, each
suited to different communities and tastes, and we're glad to see them
all getting better day by day.

For many years, the survey has included a question about "build tools",
but this idea of a single monolithic tool has become increasingly less
reflective of how people are managing Clojure projects, where they may
use multiple tools for different parts of their process, particularly in
mixed Clojure/ClojureScript projects. In response to this, we tailored
this question more tightly to dependency management and made it
multi-select this year:

[[./assets/images/content/news/2020-02-20/deps.png]]

Looking at previous years, we continue to see strong (but slightly
reduced) use of Leiningen, and a steady increase in use of clj/deps.edn.
For ClojureScript work, shadow-cljs has made big strides over the last
couple years, with big support from Clojurists Together.

In the greater world of Java and the JVM, Java has migrated to a new
release strategy where releases come out every spring and fall, and
every 3 years there is a "long term support" (LTS) release - 8, 11, and
(presumably) 17. Java 9 introduced a major change with the module system
and in all JVM communities this has caused a significant user base to
remain on Java 8. Clojure reflects this as well (although probably shows
more shift to Java 11 than other language communities):

[[./assets/images/content/news/2020-02-20/java.png]]

Releases like Java 9, 10, 12, and soon 13 are effectively dead when the
next release comes out and we would recommend sticking primarily to the
LTS releases and maybe the latest release, if it's not an LTS release.

One aspect of Java 11 that is underappreciated is significant work to
make Java work better in containers like Docker. If you are deploying in
containerized environments with Java 8, you should really be looking
closely at the changes in Java 11 and considering an upgrade.

Clojure itself has been using Java 8 as the baseline JVM for a couple
years and will continue to do so (while also supporting newer versions
of Java). When running Clojure, we recommend Java 8 or 11 right now.

Since last year, we've seen strong uptake of Clojure 1.10.0 and 1.10.1.
The latter was a maintenance release this year with error handling
improvements building on the changes in Clojure 1.10.0 and mitigations
for some Java performance regressions in their service releases after
Java 8u201. Use of Clojure 1.8 and earlier continues to dwindle:

[[./assets/images/content/news/2020-02-20/clojure.png]]

In addition to the prior dependency management question, we also added a
new question on how respondents are starting their apps in production.
Based on feedback, it's likely the wording and answer choices will need
some fine-tuning next year, but there is some interesting feedback in
the results:

[[./assets/images/content/news/2020-02-20/run-app.png]]

The majority of users are using launchers like Leiningen or clj to start
their production apps, more so than by building jars or uberjars and
launching them directly with Java. We do see a small group also
experimenting with Graal native images (particularly common with smaller
scripting apps).

*** Full Results

If you'd like to dig into the full results, you can find the complete
set of data from this and former years here:

- [[https://www.surveymonkey.com/results/SM-CDBF7CYT7/][2020]]
- [[https://www.surveymonkey.com/results/SM-S9JVNXNQV/][2019]]
- [[https://www.surveymonkey.com/results/SM-9BC5FNJ68/][2018]]
- [[https://www.surveymonkey.com/results/SM-7K6NXJY3/][2016]]
- [[http://blog.cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results][2015]]
- [[http://blog.cognitect.com/blog/2014/10/20/results-of-2014-state-of-clojure-and-clojurescript-survey][2014]]
- [[http://cemerick.com/2013/11/18/results-of-the-2013-state-of-clojure-clojurescript-survey/][2013]]
- [[http://cemerick.com/2012/08/06/results-of-the-2012-state-of-clojure-survey/][2012]]
- [[http://cemerick.com/2011/07/11/results-of-the-2011-state-of-clojure-survey/][2011]]
- [[http://cemerick.com/2010/06/07/results-from-the-state-of-clojure-summer-2010-survey/][2010]]

Thanks again for using Clojure and ClojureScript and participating in
the survey!

** [2020-02-28] Clojure Homebrew Tap
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2020/02/28/clojure-tap.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2020/02/28/clojure-tap
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-02-28
:CUSTOM_ID: content/news/2020/02/28/clojure-tap
:END:

For Mac or Linux users using Homebrew, Clojure now has its own
[[https://github.com/clojure/homebrew-tools][Homebrew tap]], ~clojure/tools~. Creating an official Clojure tap has the
following advantages:

1. Clojure team controls formula contents
2. Clojure team controls release timing
3. Freedom to keep an archive of older versioned releases that would
   be too much for the core tap
4. Easier to automate releases

*** Dependencies

Clojure requires Java. Clojure officially supports Java LTS releases
(currently Java 8 and Java 11), but also tries to ensure interim
versions work as well. You can use any Java installation, whether it's
a commercial release from Oracle or an open source version based on
OpenJDK (like adoptopenjdk).

The Clojure tools require that either the ~java~ command is on the path
or that the ~JAVA_HOME~ environment variable is set.

*** How do I use it?

Using an external homebrew tap just requires combining the tap location
and the formula name:

#+BEGIN_EXAMPLE
brew install clojure/tools/clojure
#+END_EXAMPLE

for a new install or:

#+BEGIN_EXAMPLE
brew upgrade clojure/tools/clojure
#+END_EXAMPLE

to upgrade your current install. For more detailed information, see
the [[https://github.com/clojure/homebrew-tools/blob/master/README.md][docs at the tap]]. Other pages on the Clojure site have been updated
appropriately.

*** Development, stable, and archived releases

As those docs describe, there are now three flavors of release
available:

1. Stable releases (obtained with the commands above) - this is what
   most people should use and we expect to update these on the frequency
   of every 1-3 months.
2. Development releases (using the --devel flag) - the latest bits,
   probably best for tools developers and those evaluating new bug fixes
   or functionality. New development releases may come out as frequently
   as multiple times per week during active periods.
3. Archived version releases - occasionally, it may be useful to install
   a specific older release, and there will now be an archive of these
   release formulas available. See the tap docs for how to use.

*** What about the core tap?

The Homebrew core tap still has a clojure formula for the Clojure tools.
You should now consider that unofficial and likely to lag behind the
Clojure tap, which should be preferred. Anyone can update it, or we may
periodically bump it for big releases, but we will not be actively
updating it as of now.

** [2020-07-23] Cognitect Joins Nubank!
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2020/07/23/cognitect-joins-nubank.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2020/07/23/cognitect-joins-nubank
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2020-07-23
:CUSTOM_ID: content/news/2020/07/23/cognitect-joins-nubank
:END:

We are thrilled to announce that Cognitect is joining the Nubank
family of companies. This is the next step in a long relationship, and
opens new opportunities for Clojure worldwide. Please read the full
story over on the [[https://cognitect.com/blog/2020/07/23/Cognitect-Joins-Nubank][Cognitect blog]].

** [2021-01-14] State of Clojure 2021 Survey
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/01/14/clojure-2021-survey.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/01/14/clojure-2021-survey
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-01-14
:CUSTOM_ID: content/news/2021/01/14/clojure-2021-survey
:END:

It's time for the annual State of Clojure Community Survey!

If you are a user of Clojure or ClojureScript, we are greatly interested
in your responses to the following survey:

- [[https://www.surveymonkey.com/r/clojure2021][State of Clojure 2021]]

The survey contains five pages:

1. General info
2. Tool usage
3. Questions specific to JVM Clojure (skip if not applicable)
4. Questions specific to ClojureScript (skip if not applicable)
5. Final comments

Only the first two questions are required, please skip any questions
that are not applicable.

The survey will close January 29th, after which all of the data will be
released with some analysis. We greatly appreciate your input!

** [2021-01-26] Clojure 1.10.2 release
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/01/26/clojure1-10-2.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/01/26/clojure1-10-2
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-01-26
:CUSTOM_ID: content/news/2021/01/26/clojure1-10-2
:END:

Clojure 1.10.2 includes a number of improvements for Java
interop/compatibility:

- Fixes an issue in the ~locking~ macro to satisfy more stringent Java
  verifiers (particularly, Graal)
- Fix for invocation of static interface methods with primitives
- ~proxy~ was incorrectly emitting Java 5 bytecode, now will be Java 8
  to match all other code gen
- Spec now compiled to Java 8 bytecode instead of Java 5 bytecode
- Many fixes for reflection, javadoc urls, Java deprecation warnings,
  etc

Other important Clojure fixes:

- Fix ~case~ expression branch analysis resulting in compilation error
- Fix ~nth~ with not-found value on regex matcher
- Improve ~vector-of~ impls with equals, hashing, metadata support to
  match other colls
- Fix printing of some maps with namespace syntax
- Various doc string and error message fixes
- Perf improvement - use transients in ~zipmap~

*** Detailed changelog

See the [[https://github.com/clojure/clojure/blob/master/changes.md#changes-to-clojure-in-version-1102][change log]] for a complete list of all changes in Clojure
1.10.2.

** [2021-03-04] Clojure 1.10.3 release
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/03/04/clojure1-10-3.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/03/04/clojure1-10-3
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-03-04
:CUSTOM_ID: content/news/2021/03/04/clojure1-10-3
:END:

Clojure 1.10.3 is a small release with the following changes:

- Reverted the case error message change from 1.10.2 due to backwards
  compatibility concerns
- Added prepl support for reader conditionals

*** Detailed changelog

See the [[https://github.com/clojure/clojure/blob/master/changes.md#changes-to-clojure-in-version-1103][change log]] for a complete list of all changes in Clojure
1.10.3.

** [2021-03-18] Keyword argument functions now also accept maps
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/03/18/apis-serving-people-and-programs.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/03/18/apis-serving-people-and-programs
:CLOJURE_SITE_AUTHOR: Fogus
:CLOJURE_SITE_DATE: 2021-03-18
:CUSTOM_ID: content/news/2021/03/18/apis-serving-people-and-programs
:END:

To date, Clojure's support for keyword arguments forces programmers to
choose between creating APIs that better support people (accepting
keyword args) or APIs that better support programs (by taking a map of
those args).

Introduced in Clojure 1.11, a function specified to take keyword
arguments may be passed a single map instead of or in addition to (and
following) the key/value pairs. When a lone map is passed, it is used
outright for destructuring, else a trailing map is added to the map
built from the preceding key/values via ~conj~. For example, a function
that takes a sequence of optional keyword arguments and returns a vector
containing the values is defined as:

#+BEGIN_SRC clojure
(defn destr [& {:keys [a b] :as opts}]
  [a b opts])

(destr :a 1)
->[1 nil {:a 1}]

(destr {:a 1 :b 2})
->[1 2 {:a 1 :b 2}]
#+END_SRC

In Clojure 1.11 the call to ~destr~ accepts a mixture of key/value pairs
and/or a lone (or trailing) map benefitting both programmer and program.

This enhancement is available now in
~org.clojure/clojure "1.11.0-alpha1"~.

** [2021-04-06] State of Clojure 2021 Results
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/04/06/state-of-clojure-2021.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/04/06/state-of-clojure-2021
:CLOJURE_SITE_AUTHOR: Fogus
:CLOJURE_SITE_DATE: 2021-04-06
:CUSTOM_ID: content/news/2021/04/06/state-of-clojure-2021
:END:

While a challenging year overall, 2020 was another good year for
Clojure and its ecosystem. One big newsworthy item was that [[https://building.nubank.com.br/nubank-acquires-cognitect-press-release][Cognitect
joined Nubank]], the world's largest independent digital bank, to
/reinvent financial services across Latin America/. The news was well
received, and the general sentiment is summarized by a comment left by
one of the survey respondents:

#+BEGIN_QUOTE
Great to see the Nubank acquisition of Cognitect. I think this has
done wonders to bolster confidence in Clojure and Datomic for the long
term. Also the subsequent support of open source developers sends a
very positive message, and directly supports a healthy and robust
ecosystem.

---  anonymous survey respondent
#+END_QUOTE

Indeed Ed Wible, the co-founder of Nubank [[https://building.nubank.com.br/welcoming-cognitect-nubank][talked about Nubank's
commitment to supporting and growing Clojure]] (and Datomic) into the
future.

In this post I'll outline a few of the more salient points shown in
the [[https://www.surveymonkey.com/results/SM-S2L8NR6K9][2021 survey]].  Specifically, I'll touch on the use of Clojure in
production, the use of Clojure for start-ups, and how Clojure helps
programmers and organizations to move quickly and confidently. As an
added bonus I'll highlight some of the amazing projects and people
making the Clojure community strong.

*** Clojure in Production

Continuing the trend from last year, Clojure has seen growth in large
companies (i.e. those having 100-1000 employees).

[[./assets/images/content/news/2021-03-15/sizes.png]]

Nubank currently employs approximately 700 (at the time of writing)
Clojure programmers, and Nubank is just one prominent example of the
many banks, mortgage companies, and financial services companies using
Clojure today, accounting for 22% (and growing) of the Clojure job
market as reported by survey respondents. The survey shows healthy gains
in the healthcare and retail markets as well.

[[./assets/images/content/news/2021-03-15/industries.png]]

Having said all of that, just where are Clojure projects deployed in
production systems? Interestingly, the survey shows some nice growth
in the way of public cloud and serverless deployments. The [[https://www.investopedia.com/how-amazon-makes-money-4587523][trends for
AWS]] indicate that the cloud market is booming and so it's natural that
the general increase for that segment would show specifically for
Clojure deployments as well.

*** Clojure (still) for Start-ups

While more large companies are adopting Clojure than ever, the sweet
spot is still the smaller companies of less than 100 employees.

[[./assets/images/content/news/2021-03-15/lgvssmall.png]]

The reasons that start-ups choose Clojure are many and variegated:

- Leverage - small effort, big result
- Ready access to large existing ecosystems - Java, JavaScript, .NET
- Scalable base - grow from PoC, to MVP, to production systems at scale
- Moving fast - discussed in the next section

One exciting start-up of note in the Clojure ecosystem is [[https://roamresearch.com][Roam
Research]]. Roam's flagship product is an online note-taking tool that
is designed to augment the human mind in building a set of notes that
allow deep connectivity and discoverability. The [[https://www.theinformation.com/articles/a-200-million-seed-valuation-for-roam-shows-investor-frenzy-for-note-taking-apps][enthusiasm for Roam
is palpable]] and it'll be fun to watch them grow.

*** Clojure for Moving Fast

Most survey respondents reported that they came to Clojure from the Java
programming language. The fact that both languages run on the same
virtual machine certainly helps smooth the path from Java to Clojure.
However, many other advantages allow Clojure programmers a greater
flexibility and agility in their day to day work lives using Clojure.

[[./assets/images/content/news/2021-03-15/features.png]]

First, Clojure programmers value a *functional style of programming*
facilitating a separation of data and process. Coupled with its suite of
immutable data structures, Clojure applications are often built as
pipelines of data transformation functions that can be composed to
implement higher-level business concepts in software. As a *dialect of
Lisp*, Clojure provides an interactive programming environment called
the REPL (Read, Eval, Print, Loop). The REPL fosters exploratory
programming, allowing Clojure programmers to interactively develop
solutions to sticky programming problems using a tight feedback loop.
Indeed, the confluence of the REPL, immutable data structures, and
functional programming allows for a development process light on
ceremony, allowing programmers to focus on the problem at hand rather
than the complexities foisted on them by their programming language.

*** The Clojure Ecosystem

Finally, Clojure would have never grown to its current size without
the help of countless developers, technical writers, and big thinkers
along the way. The appreciation for the amazing Clojure community is
palpable within Nubank and this appreciation is increasingly being
expressed as [[https://github.com/orgs/nubank/sponsoring][open source project funding]]. I'd like to close this
year's post by highlighting a number of the community leaders
mentioned in the survey responses.

- [[https://github.com/bbatsov][Bozhidar Batsov]] /for continuing to improve Clojure tooling ecosystem./
- Arne Brasseur - /[[https://github.com/lambdaisland/kaocha][Kaocha]] is superb and his educational skills fantastic./
- /Everything [[https://github.com/borkdude][Michiel Borkent]] aka borkdude touches is awesome!/
- [[https://github.com/seancorfield][Sean Corfield]] /because he is always helpful and polite, and writes
  excellent documentation for important libraries./
- [[https://github.com/mfikes][Michael Fikes]] /for being enthusiastic, engaging, and inspirational,
  and approachable./
- [[https://github.com/thheller][Thomas Heller]] /has made an amazing tool in [[https://github.com/thheller/shadow-cljs][shadow-cljs]]./
- (Daniel) Higginbotham, /because he made me laugh hundreds of times
  while [[https://www.braveclojure.com][introducing me to Clojure]]./
- [[https://github.com/awkay][Tony Kay]] /and contributors of [[https://github.com/fulcrologic/fulcro][Fulcro]] for providing a comprehensive
  solution to client-server state management./
- [[http://www.realgenekim.me][Gene Kim]] /for ... unabashed love of the language, and for helping
  spread the good word./
- [[https://www.londonclojurians.org][London Clojurians]] - /the online talks in the past year have been
  amazing./
- Tiago Luchini, /[[https://github.com/hodur-org][Hodur]] creator./
- [[https://github.com/gigasquid][Carin Meier]] /for her progressiveness: for advancing the state of the
  art in machine learning, and her contributions to visibility and
  representation in the community./
- [[https://github.com/swannodette][David Nolen]] /is generous with explanations, direct, genuine, and
  never condescending or judgmental./
- [[https://lispcast.com][Eric Normand]], /as he provides great content for beginners./
- [[https://www.michaelnygard.com][Michael Nygard]] /for architecture insights./
- [[https://github.com/yogthos][Dmitri Sotnikov]] /for making web dev in Clojure accessible to the
  masses./
- [[https://github.com/ptaoussanis][Peter Taoussanis]] - /Nice, simple and complete libraries./

There are so many more who deserve praise and recognition so in the
words of one of the survey respondents:

#+BEGIN_QUOTE
Clojure literally changed my life for the better. I am eternally
grateful for the humans behind it.

---  anonymous respondent
#+END_QUOTE

We too are grateful for everyone involved in the Clojure community and
we hope to see a continuance and growth in support for those members of
the community who work so hard and devote their valuable time to help
Clojure and its ecosystem thrive.

*** Full Results

If you'd like to dig into the full results, you can find the complete
set of data from this and former years here:

- [[https://www.surveymonkey.com/results/SM-S2L8NR6K9][2021]]
- [[https://www.surveymonkey.com/results/SM-CDBF7CYT7/][2020]]
- [[https://www.surveymonkey.com/results/SM-S9JVNXNQV/][2019]]
- [[https://www.surveymonkey.com/results/SM-9BC5FNJ68/][2018]]
- [[https://www.surveymonkey.com/results/SM-7K6NXJY3/][2016]]
- [[http://blog.cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results][2015]]
- [[http://blog.cognitect.com/blog/2014/10/20/results-of-2014-state-of-clojure-and-clojurescript-survey][2014]]
- [[https://cemerick.com/blog/2013/11/18/results-of-the-2013-state-of-clojure-clojurescript-survey.html][2013]]
- [[https://cemerick.com/blog/2012/08/06/results-of-the-2012-state-of-clojure-survey.html][2012]]
- [[https://cemerick.com/blog/2011/07/11/results-of-the-2011-state-of-clojure-survey.html][2011]]
- [[https://cemerick.com/blog/2010/06/07/results-from-the-state-of-clojure-summer-2010-survey.html][2010]]

Thanks again for using Clojure and ClojureScript and participating in
the survey!

** [2021-06-04] Clojure Deref (June 4, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/06/04/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/06/04/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-06-04
:CUSTOM_ID: content/news/2021/06/04/deref
:END:

Welcome to the Clojure Deref! This is a new periodic (thinking
bi-weekly) link/news roundup for the Clojure ecosystem. We'll be
including links to Clojure articles, Clojure libraries, and when
relevant, what's happening in the Clojure core team.

*** Highlights

[[https://clojurescript.org/][ClojureScript]] turns 10 this week! Happy birthday ClojureScript! :cake:
We mark this from the [[https://github.com/clojure/clojurescript/commit/515900f9762102987bda7d53b919dafc0b6c0580][first commit]] by Rich Hickey in the repo. Several
thousand commits later things are still going strong and David Nolen
and Mike Fikes continue to lead the project. ClojureScript recently
released version [[https://github.com/clojure/clojurescript/blob/master/changes.md#110866][1.10.866]].

The [[https://stackoverflow.com/dev-survey/start][StackOverflow developer's survey]] for 2021 just opened. Last year
they removed Clojure from the survey because they were scared we were
growing too powerful (I assume). But this year's survey includes
Clojure as an option again, so let them know you're out there! (It
also seems a lot shorter this year.)

The [[https://clojured.de/][:clojureD Conference]] is just hours away!
Ticket sales have ended but presumably talks will be made available
afterwards. If you're going, we'll see you there!

*** Experience reports

This week we saw several interesting Clojure experience reports worth
mentioning:

- Red Planet Labs [[https://tech.redplanetlabs.com/2021/06/03/tour-of-our-250k-line-clojure-codebase/][gave an overview]] of their codebase and some of the
  techniques they use pervasively - using Schema, monorepo, Specter
  for polymorphic data, Component, with-redefs for testing, macros and
  more.
- Jakub Holý at Telia talked about the importance of
  [[https://engineering.telia.no/blog/slow-restarts-rescued-by-clojure][interactive development with Clojure]].
- Crossbeam did a talk at Philly Tech Week about [[https://technical.ly/philly/2021/06/04/crossbeam-clojure/][why they bet on
  Clojure]] and their experience with hiring.
- Shivek Khurana talked about [[https://shivekkhurana.medium.com/mysterious-clojure-jobs-and-where-to-find-them-f784ebab4dea][how to find a job using Clojure]]. There
  are now many companies using and hiring for Clojure, although
  sometimes it's challenging to find a Clojure job that is a good
  match for your location and/or experience - these are some great
  tips!

*** Libraries

Some interesting library updates and posts this week:

- [[https://github.com/threatgrid/asami][Asami]] - Paula Gearon wrote a [[https://github.com/threatgrid/asami/wiki/Introduction][nice overivew of querying graph dbs]]
- Joe Littlejohn at Juxt wrote an overview of the [[https://www.juxt.pro/blog/json-in-clojure][Clojure JSON
  ecosystem]] covering many popular libraries and their tradeoffs
- [[https://github.com/oakes/odoyle-rules][odoyle-rules]] - Zach Oakes added a new section on [[https://github.com/oakes/odoyle-rules#defining-rules-dynamically][defining rules
  dynamically]]
- [[https://vlaaad.github.io/reveal/][Reveal]] - Vlad wrote about viewing Vega charts in Reveal
- [[https://github.com/wilkerlucio/pathom][Pathom]] - Wilker Lucio gives some [[https://blog.wsscode.com/pathom-updates-10/][updates on many features]]

*** Art

- As always Jack Rusher has been up to making beautiful art with
  Clojure, in particular exploring 3D rendered attractors like the
  [[https://twitter.com/jackrusher/status/1398336040260231171][Golden Aizwa Attractor]] (the [[https://twitter.com/jackrusher/status/1398368701058011141][Clojure code]]) and [[https://twitter.com/jackrusher/status/1398573268894900227][Three-Scroll Uunified
  Attractor]], and [[https://twitter.com/jackrusher/status/1398674759110561798][one made in bone]]. Hit his [[https://twitter.com/jackrusher][feed]] for lots more cool
  projects, often made with Clojure.

*** Feedback

You can find future episodes on the [[https://clojure.org/feed.xml][RSS feed]] for this blog. Should it
be an email newsletter too?

Let us know!

** [2021-06-11] Clojure Deref (June 11, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/06/11/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/06/11/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-06-11
:CUSTOM_ID: content/news/2021/06/11/deref
:END:

Welcome to the Clojure Deref! This is a periodic link/news roundup for
the Clojure ecosystem. ([[https://clojure.org/feed.xml][RSS feed]])

*** Highlights

This week [[https://www.reuters.com/article/us-nubank-funding-berkshire-idUSKCN2DK1FI][Nubank announced]] a new $750M investment, led by $500M from
Berkshire Hathaway at a $30B valuation. Nubank is the largest user of
Clojure and Datomic in the world and a great example of the benefits
of Clojure's approach to managing complexity at scale.

Chris Nuernberger [[https://www.youtube.com/watch?v=5mUGu4RlwKE][presented a great talk]] this week for London
Clojurians about his work on high performance data processing with the
[[https://github.com/cnuernber/dtype-next][dtype-next]] and [[https://github.com/techascent/tech.ml.dataset][tech.ml.dataset]] libraries.

The [[https://clojured.de/][ClojureD conference]] last weekend was great with lots of
interesting Clojure (and some non-Clojure) talks! Keep an eye out for
videos soon.

*** Podcasts

We have a bumper crop of Clojure-related podcast episodes this week, put
these in your ears...

- [[https://www.cognitect.com/cognicast/160][Cognicast]] - Christian Romney interviews Jarrod Taylor from the
  Datomic team
- [[https://getsmarterandmakestuff.com/2021/06/06/podcast-episode-005-michael-fogus/][Get Smarter and Make Stuff]] - Craig Andera interviews Michael Fogus
  from the Clojure core team
- [[https://anchor.fm/lostinlambduhhs/episodes/puredanger-Alex-Miller—​Clojures-Cool-dad-e12botj][Lost in Lambduhhs]] - Jordan Miller interviews Alex Miller from the
  Clojure core team
- [[https://clojurescriptpodcast.com/][ClojureScript Podcast]] - Jacek Schae interviews Tommi Reiman about
  Malli
- [[https://soundcloud.com/defn-771544745/72-chris-badahdah-from-phoenix][defn]] - Vijay Kiran and Ray McDermott interview Chris Badahdah about Portal

*** Libraries and Databases

Some interesting library updates and posts this week:

- [[https://github.com/mcorbin/mirabelle][Mirabelle]] - 0.1.0 of this stream processing tool inspired by
  Riemann - check out the [[https://www.mirabelle.mcorbin.fr/][docs]] and a [[https://www.mcorbin.fr/posts/2021-06-07-mirabelle-cabourotte-blackbox/][use case]]
- [[https://github.com/sicmutils/sicmutils][sicmutils]] - Sam Ritchie
  released version 0.19.0 of this math and physics based library
  (based on the books by Sussman and Wisdom)
- [[https://github.com/kiranshila/cybermonday][Cybermonday]] - Kiran Shila releases the first release of this Clojure
  data interface to Markdown (like Hiccup for Markdown)
- [[https://github.com/graphqlize/honeyeql/][HoneyEQL]] - Tamizhvendan S introduced [[https://cljdoc.org/d/org.graphqlize/honeyeql/0.1.0-alpha36/doc/readme][0.1.0-alpha36]] for EQL queries
  to relational databases
- [[https://github.com/clojure-expectations/clojure-test][Expectations]] - Sean Corfield released [[https://cljdoc.org/d/com.github.seancorfield/expectations/2.0.0-alpha2/doc/readme][2.0.0-alpha2]] of this
  clojure.test-compatible implementation of Expectations
- [[https://github.com/CrypticButter/snoop][Snoop]] - Luis Thiam-Nye announced the initial release of a library
  for runtime function validation using Malli
- [[https://clojurelog.github.io/][OSS Clojure DBs]] - a summary and comparison of open-source Clojure
  databases (but don't forget [[https://www.datomic.com][Datomic]]! :)

*** Blogs, discussions, tutorials

- [[https://shaunlebron.github.io/t3tr0s-slides/#0][Tetris in ClojureScript]] - by Shaun Lebron
- [[http://hariomgaur.in/2021/06/06/consume-from-kafka.html][Apache Kafka & Ziggurat]] - Ziggurat is an event stream processing
  tool written in Clojure and this article shows how to use it to
  consume events from Kafka
- [[https://lambdaisland.com/blog/2021-06-04-clojure-beginners-just-like-vegans-searching-for-good-cheese][Why are Clojure beginners just like vegans searching for good
  cheese?]] - on Lambda Island
- [[https://github.com/prestancedesign/pingcrm-clojure][Ping CRM on Clojure]] - a demo of implementing Ping CRM on
  Clojure+ClojureScript
- [[https://clojureverse.org/t/organizing-clojure-code-a-real-problem/7567][Organizing Clojure code]] - a discussion from Clojureverse
- [[https://markm208.github.io/cljbook/][An Animated Introduction to Clojure]] - by Mark Mahoney

*** Throwback Friday (I know, I'm doing it wrong)

In this recurring segment, we harken back to a talk from an older time
to a favorite talk of yore. This week, we're featuring:

- [[https://www.youtube.com/watch?v=ShEez0JkOFw][Clojure: Programming with Hand Tools]] by Tim Ewald

Is it about woodworking? Is it about Clojure? Is it about how to work?
Yes.

** [2021-06-18] Clojure Deref (June 18, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/06/18/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/06/18/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-06-18
:CUSTOM_ID: content/news/2021/06/18/deref
:END:

Welcome to the Clojure Deref! This is a periodic link/news roundup for
the Clojure ecosystem.  ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

- [[https://hopl4.sigplan.org/][HOPL IV]] (History of Programming Languages) at [[https://conf.researchr.org/home/pldi-2021][PLDI 2021]] is happening
  on Monday and Tuesday and includes a talk from Rich Hickey about the
  [[https://clojure.org/about/history][History of Clojure]] paper. Registration is still available and the
  conference is online and features many other fine language
  developers!
- The results are out from the [[https://snyk.io/jvm-ecosystem-report-2021/][JVM Ecosystem Report 2021]] and Clojure
  continues to make a strong showing as one of the most popular JVM
  languages (other than Java), rising from 2.9% last year to 8.4% this
  year. Lots of other interesting tidbits in there as well.

*** Sponsorship Spotlight

Lately [[https://twitter.com/cgrand][Christophe Grand]] and [[https://twitter.com/BaptisteDupuch][Baptiste Dupuch]] have been [[https://twitter.com/cgrand/status/1404446965778292736][teasing]] their
work on a new ClojureDart runtime with Flutter support. You can
support their work on GitHub: [[https://github.com/sponsors/cgrand][cgrand]] [[https://github.com/sponsors/dupuchba][dupuchba]].  [[https://github.com/nubank][Nubank]] (users of both
Clojure and Flutter) are now supporting both!

*** Podcasts and videos

- [[https://lispcast.com/what-is-missing-from-stratified-design/][LispCast]] - Eric Normand talks about stratified design
- [[https://soundcloud.com/defn-771544745/73-paula-gearon][defn]] - Vijay Kiran and Ray McDermott interview Paula Gearon
- [[https://www.youtube.com/watch?v=oTy4JYY3CoQ][REPL-driven development]] - demo from Jakub Holý
- [[https://www.youtube.com/watch?v=hSqpJpowazg][FizzBuzz in Clojure]]

*** Blogs, discussions, tutorials

- [[https://joannecheng.me/2021/06/11/transducers.html][Clojure Transducers]] - Joanne Cheng explains transducers
- [[https://danielgregoire.dev/posts/2021-06-13-code-observation-clojure-destructuring/][Clojure's Destructuring]] - Daniel Gregoire dives into destructuring
- [[https://dawranliou.com/blog/better-performance-with-java-arrays-in-clojure/][Better performance with Java arrays in Clojure]] - Daw-Ran Liou on
  using Java arrays in Clojure
- [[https://tilton.medium.com/backpressure-99501f23881f][Backpressure]] - Kenny Tilton talks about core.async and ETL
- [[https://sidesteps.github.io/posts/fun-of-clojure.html][Fun of clojure - wrap some code around data]] - [[https://twitter.com/Sharas_][@Sharas_]] on the data
  ethos of Clojure
- [[https://lambdaisland.com/blog/2021-06-17-lambdaisland-is-changing][Lambda Island is Changing]] - Arne Brasseur and his merry band of
  Clojurists at Gaiwan are changing directions a bit
- [[https://shivekkhurana.medium.com/should-you-adopt-clojure-at-your-company-6e10c92be154][Should you adopt Clojure at your company?]] - Shivek Khurana, TLDR:
  yes! :)

*** Libraries and Tools

Some interesting library updates and posts this week:

- [[https://github.com/nubank/ordnungsamt][ordnungsamt]] - a tool for running ad-hoc migrations over a code
  repository
- [[https://github.com/nubank/clj-github][clj-github]] - a library for working with the GitHub developer API
- [[https://github.com/nubank/umschreiben-clj][umschreiben-clj]] - extensions to [[https://github.com/clj-commons/rewrite-clj][rewrite-clj]]
- [[https://www.fulcrologic.com/copilot][Copilot]] - Tony Kay teased a new upcoming code analysis tool for
  Clojure and ClojureScript
- [[https://github.com/borkdude/scittle][scittle]] - Michiel Borkent did the [[https://github.com/borkdude/scittle/releases/tag/v0.0.1][first release]] of the SCI
  interpreter for [[https://borkdude.github.io/scittle/][use in script tags]]
- [[https://github.com/clojure-lsp/clojure-lsp/][clojure-lsp]] - Eric Dallo [[https://clojure-lsp.github.io/clojure-lsp/CHANGELOG/#20210614-170047][released]] a new version with enhanced path
  support for deps.edn projects
- [[https://github.com/FieryCod/holy-lambda][holy-lambda]] - Karol Wójcik [[https://github.com/FieryCod/holy-lambda/blob/master/CHANGELOG.md#021-10-06-2021][released]] a new version
- [[https://github.com/seancorfield/honeysql][honeysql]] - Sean Corfield [[https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc3/doc/readme][added]] :distinct syntax and some other
  features and fixes
- [[https://github.com/fulcrologic/fulcro][Fulcro]] - Tony Kay released 3.5.0-RC1 with more support for non-React
  apps
- [[https://github.com/seancorfield/next.jdbc][next.jdbc]] - Sean Corfield [[https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.2.674/doc/readme][released]] 1.2.674
- [[https://github.com/borkdude/refl][refl]] - Michiel Borkent released a new example project to clean up
  reflection configs for GraalVM for Clojure projects


*** Fun and Games

- [[https://tylerxhobbs.com/fidenza][Fidenza]] - Tyler Hobbs has a long history of doing interesting
  generative art with Clojure and he has published a rundown of his
  newest generative algorithm. Not explicitly Clojure but fascinating
  to read.
- [[https://ertugrulcetin.github.io/racing-game-cljs/][ClojureScript racing game]] - Ertuğrul Çetin published this game this
  week

*** Throwback Friday (I know, I'm doing it wrong)

In this recurring segment, we harken back to a talk from an older time
to a favorite talk of yore. This week, we're featuring:

- [[https://www.youtube.com/watch?v=xmCrMUhhg9c][Why is a Monad Like a Writing Desk?]] by Carin Meier from Clojure/West
  2012

In this lovely story from 2012, Carin Meier talks about monads through
the lens of Clojure and Alice in Wonderland.

** [2021-06-25] Clojure Deref (June 25, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/06/25/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/06/25/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-06-25
:CUSTOM_ID: content/news/2021/06/25/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

It is common to see complaints that both Clojure jobs and Clojure
developers are hard to find. The real truth is: both exist, but there is
sometimes a mismatch in either experience or geographic distribution. We
don't typically highlight jobs in the Deref but here are some great
places to find Clojure jobs:

- [[https://jobs.braveclojure.com/][Brave Clojure]] - job board
- [[https://functional.works-hub.com/functional-programming-jobs][Functional Works]] - job board
- [[http://clojurians.net][Clojurians slack]] - #jobs and #remote-jobs channel
- [[https://clojureverse.org/c/community-center/jobs/52][Clojureverse]]
- [[https://www.reddit.com/r/Clojure/comments/npeien/who_is_hiring_may_31_2021/][Clojure subreddit]] - monthly thread
- [[https://kennytilton.github.io/whoishiring/][Who is hiring]] - search at HackerNews
- [[https://twitter.com/search?q=clojure%20job&src=spelling_expansion_revert_click&f=live][Twitter search]]

Also, I want to highlight that [[https://www.youtube.com/playlist?list=PLaSn8eiZ631nON7le-wdZxTR0c5bxqPYi][clojureD 2021 conference]] videos are
coming out now, about one per day, check them out!

*** Sponsorship spotlight

Over the last couple years, the [[https://calva.io/][Calva]] team has
been putting a ton of effort into making VS Code a great place to
Clojure. If you enjoy the fruits of that effort, consider supporting one
of these fine folks working in this area:

- [[https://github.com/PEZ][Peter Strömberg]] - [[https://github.com/sponsors/PEZ][sponsor]] for Calva
- [[https://github.com/bpringe][Brandon Ringe]] - [[https://github.com/sponsors/bpringe][sponsor]] for Calva
- [[https://github.com/ericdallo][Eric Dallo]] - [[https://www.patreon.com/ericdallo][sponsor]] for clojure-lsp

*** Podcasts and videos

- [[https://www.case-podcast.org/45-eric-normand-on-functional-thinking][CaSE]] - Conversations about Software Engineering talks with Eric
  Normand
- [[https://podcasts.apple.com/us/podcast/s4-e32-lacinia-with-howard-lewis-ship/id1461500416?i=1000526576095][ClojureScript podcast]] - Jacek Schae interviews Howard Lewis Ship
- [[https://www.youtube.com/watch?v=CR1faH3S1pA][Apropos]] - Mia, Mike, Ray, Eric chat plus special guest Martin
  Kavalar

*** Blogs, discussions, tutorials

- [[https://danielgregoire.dev/posts/2021-06-18-open-closed-systems-clojure/][Open and Closed Systems with Clojure]] - Daniel Gregoire
- [[https://blog.jakubholy.net/2021/simplicity/][What is simplicity in programming and why does it matter?]] - Jakub
  Holý
- [[https://www.michaelnygard.com/blog/2021/06/counterfactuals-are-not-causality/][Counterfactuals are not Causality]] - Michael Nygard - not about
  Clojure but worth a read!
- [[https://robhaisfield.com/notes/how-i’m-learning-clojure][How I'm learning Clojure]] - Rob Haisfield
- [[https://ostash.dev/posts/2021-06-18-clojure-metadata/][Clojure metadata]] - Roman Ostash
- [[https://ostash.dev/posts/2021-06-24-edn-data-notation/][Data notation in Clojure]] - Roman Ostash
- [[https://blog.jakubholy.net/2021/specific-vs-general-cryogen/][Specific vs. general: Which is better?]] - Jakub Holý

*** Libraries

Some interesting library updates and posts this week:

- [[https://github.com/mauricioszabo/spock/][spock]] 0.1.1 - a Prolog in Clojure
- [[https://github.com/pfeodrippe/recife][recife]] 0.3.0 - model checker library in Clojure
- [[https://github.com/tonsky/datascript][datascript]] 1.2.1 - immutable in-memory database and Datalog query
  engine
- [[https://github.com/ont-app/sparql-endpoint][sparql-endpoint]] 0.1.2 - utilities for interfacing with SPARQL 1.1
  endpoints
- [[https://github.com/modern-energy/pulumi-cljs][pulumi-cljs]] - ClojureScript wrapper for Pulumi's infrastructure as
  code Node API
- [[https://gitlab.com/domaindrivenarchitecture/c4k-keycloak][c4k-keycloak]] - k8s deployment for keycloak
- [[https://github.com/lucywang000/clj-statecharts][clj-statecharts]] 0.1.0 - State Machine and StateCharts for
  Clojure(Script)
- [[https://github.com/clojure-lsp/clojure-lsp][clojure-lsp]] 2021.06.24-14.24.11 - Language Server (LSP) for Clojure
- [[https://github.com/juxt/tick][tick]] 0.4.32 - Time as a value
- [[https://github.com/cognitect-labs/aws-api][aws-api]] 0.8.515 - programmatic access to AWS services from Clojure

*** Tools

- [[https://www.libhunt.com/l/clojure][Clojure LibHunt]] - find Clojure open source projects!
- [[https://github.com/Tyruiop/syncretism][syncretism]] - options search engine based on Yahoo! Finance market
  data
- [[https://gitlab.com/yogthos/mastodon-bot][mastodon-bot]] - bot for mirroring Twitter/Tumblr accounts and RSS
  feeds on Mastodon

*** Fun and Games

Chris Ford did a [[https://www.youtube.com/watch?v=BRBR45k2Yw4][live coding performance]] (on keytar!) - see the [[https://github.com/ctford/tin-ear][code]]

*** Throwback Friday (I know, I'm doing it wrong)

In this recurring segment, we harken back to talks from an older time of
yore. This week, we're featuring:

- [[https://www.youtube.com/watch?v=dPK6t7echuA][How to Think about Parallel Programming: Not!]] by Guy L. Steele Jr
  from Strange Loop 2010 - it's a decade+ old but still worth watching
  for how we think about what languages should provide, and a
  particular inspiration to the later design of Clojure reducers
- [[https://www.youtube.com/watch?v=lU3awBr5C7E][Advent of Code 2020, Day 17]] by Zach Tellman - a wonderful example of
  how to work in Clojure. write code in your editor, eval small exprs
  to your REPL, building iteratively up to a final solution

** [2021-07-02] Clojure Deref (July 2, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/07/02/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/07/02/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-07-02
:CUSTOM_ID: content/news/2021/07/02/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

Clojurists Together [[https://www.clojuriststogether.org/news/the-next-phase-of-clojurists-together/][announced]] a more varied set of funding models
moving forward to better match what projects have been seeking.

All of the [[http://clojured.de/][clojureD]] [[https://www.youtube.com/playlist?list=PLaSn8eiZ631nON7le-wdZxTR0c5bxqPYi][2021 videos]] are now available, including [[https://www.youtube.com/watch?v=BTAx-gFz6Ks][my video]]
discussing a set of new Clojure CLI features and the tools.build
library. We have been hard at work polishing documentation and
finalizing a last few bits of the source prep functionality and we
expect it will be available soon for you to work with! For now, the
video is a good overview of what's coming: expanded source for
source-based libs, a new tools.build library, and some extensions to
tool support in the Clojure CLI.

*** In the core

We have mostly been working on Clojure CLI and tools.build lately but
these items went by this week, maybe of interest:

- [[https://clojureverse.org/t/do-clojure-still-have-rooms-to-improve-at-compiler-level][Does Clojure still have rooms to improve at compiler level?]] - some
  discussion at ClojureVerse
- [[https://clojure.atlassian.net/browse/CLJ-2637][CLJ-2637 - Automatic argument conversion to Functional Interface
  (Lambda) from Clojure fn]] - this patch was proposed to do automatic
  SAM conversion for Clojure functions in the compiler.

This is an area we've actually spent a lot of time thinking about for
Clojure 1.11, (tracking under [[https://clojure.atlassian.net/browse/CLJ-2365][CLJ-2365]] although most of the work has
happened off ticket). In particular we have talked about a long list
of possible use cases for functional interop and also a long list of
ideas for making functional interop less cumbersome, both syntax and
implementation. The examples given in CLJ-2637 are primarily about the
Java Stream API but we don't think that's particularly high on the
list of what's interesting (if you're in Clojure, just use Clojure's
apis!). But there are cases where you have Java APIs in the JDK or
elsewhere that now take one of the SAM-style interfaces, or a
java.function interface and it would be nice to reduce the friction in
passing a Clojure function without needing to reify - either by
automatic detection and conversion, or helper fns, or even new syntax
and compiler support. No conclusions yet.

*** Podcasts and videos

- [[https://www.youtube.com/watch?v=URR6iu6l3fc][Apropos]] - Mia, Mike, Ray, and Eric chat about Clojure

*** Blogs, discussions, tutorials

- [[https://www.clojuremorsels.com/][Clojure Morsels]] - a new biweekly mailing list for Clojure news
  starting soon
- [[https://vlaaad.github.io/clj-vs-cli][REPL vs CLI: IDE wars]] - Vlad thinks about REPLs vs the command line
  for dev
- [[https://gustavosantos.dev/a/clojure-building-blocks][Clojure Building Blocks]] - Gustavo Santos
- [[https://gustavosantos.dev/a/getting-started-with-clojure][Getting Started with Clojure]] - Gustavo Santos
- [[https://betweentwoparens.com/blog/rich-comment-blocks/][Rich Comment Blocks]] - Thomas Mattacchione

*** Training and hiring

- [[https://learndatomic.com/][Learn Datomic]] - is a new course for learning Datomic and Datalog by
  Jacek Schae, coming soon!
- [[https://www.reddit.com/r/Clojure/comments/ob7nkk/who_is_hiring_june_30_2021/][Who's Hiring]] - monthly hiring thread on Clojure subreddit

*** Libraries and tools

Some interesting library and tool updates and posts this week:

- [[https://github.com/alekcz/pcp][PCP]] - Clojure replacement for PHP
- [[https://github.com/FieryCod/holy-lambda][holy-lambda]] [[https://github.com/FieryCod/holy-lambda/blob/master/CHANGELOG.md#022-01-07-2021][0.2.2]] - A micro-framework that integrates Clojure with
  AWS Lambda on either Java, Clojure Native, or Babashka runtime
- [[https://github.com/clojure-lsp/clojure-lsp][clojure-lsp]] [[https://github.com/clojure-lsp/clojure-lsp/releases/tag/2021.07.01-13.46.18][2021.07.01-13.46.18]] - Language Server (LSP) for Clojure,
  this release with new API/CLI support!
- [[https://github.com/sauercrowd/clojureflare][clojureflare]] - a new ClojureScript lib for using Cloudflare workers
- [[https://github.com/BetterThanTomorrow/calva][Calva]] 2.0.202 - Clojure & ClojureScript in Visual Studio Code

** [2021-07-09] Clojure Deref (July 9, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/07/09/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/07/09/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-07-09
:CUSTOM_ID: content/news/2021/07/09/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

Rich Hickey [[https://clojure.org/about/history][wrote a paper]] "A History of Clojure" for the [[https://hopl4.sigplan.org/][HOPL IV]]
(History of Programming Languages) conference. This week [[https://www.pldi21.org/prerecorded_hopl.11.html][the video]] for
the conference was made available along with the Q&A hosted by Guy
Steele.  Certainly worth watching/reading if you want to know more
about how and why Clojure came to be!

We got the sad news this week that the beloved [[https://groups.google.com/g/clojure/c/ZWmDEzvn-Js/m/ad4gKdLEAgAJ][4Clojure site is
shutting down]]. For a long, long time [[https://github.com/4clojure/4clojure][4Clojure]] has been an early stop
for many developers learning Clojure, as a source of programming
problems, and perhaps more importantly as a font for answer
comparisons.  Many hearty thanks to David Byrne, Alan Malloy, and
everyone that [[https://github.com/4clojure/4clojure#contributors][contributed]] to it over a [[https://github.com/4clojure/4clojure/commit/ff457d0b3b5f5e5a74316a1747809c25b84b3b5e][decade]] of use. There are
already a couple nascent efforts to bring it back to life in [[https://github.com/oxalorg/4ever-clojure][other]]
[[https://github.com/porkostomus/4bb][forms]] if you want to help.

*** In the core

Today we put out a pre-release of the Clojure CLI and a new
tools.build library covering many enhancements and new features for
working with source libraries (particularly those from git), project
builds, and CLI tools. Check out [[https://clojure.org/news/2021/07/09/source-libs-builds][Source Libs and Builds]] for an
overview and links to new docs! Feedback is welcome at
[[https://ask.clojure.org]] or in the #tools-deps channel on Clojurians
slack.

*** Podcasts and videos

- [[https://clojurescriptpodcast.com/][ClojureScript Podcast]] - Jacek Schae has a new episode about
  Component with Stuart Sierra
- [[https://www.youtube.com/watch?v=vE8d-tXOuXo][FSet]] - Renzo Borgatti talked about a faster set library at London
  Clojurians

*** Blogs, discussions, tutorials

- [[https://blog.davemartin.me/posts/debugging-in-clojure/][Debugging in Clojure]] by Dave Martin
- [[http://ingesolvoll.github.io/posts/2021-07-05-specced-re-frame/][A la carte specs for your re-frame subs and events]] by Inge Solvoll
- [[https://www.works-hub.com/learn/why-and-how-to-learn-clojure-developers-insights-de445][Functional Workplaces: Freshcode - Why and How to Learn Clojure]] by
  Artem Barmin
- [[https://ostash.dev/posts/2021-07-08-transient-data-structures/][Transient Data Structures in Clojure]] by Roman Ostash
- [[https://clj-br.github.io/]] - also check out the new self-editable
  user group page for Clojure Brasil! Fascinante!

*** Libraries and tools

Some interesting library and tool updates and posts this week:

- [[https://github.com/clojure/tools.build][tools.build]] 0.1.2 - first release, functions for writing build
  programs
- [[https://github.com/wilkerlucio/transito][transito]] 2021.07.04 - helpers for common Clojure transit operations
- [[https://github.com/borkdude/deps.clj][deps.clj]] [[https://github.com/borkdude/deps.clj/releases/tag/v0.0.16][0.0.16]] - port of the clojure CLI bash script to Clojure
- [[https://github.com/wilkerlucio/pathom][Pathom]] 2.4.0 - Pathom is a Clojure(script) engine for processing EQL
  requests
- [[https://github.com/fulcrologic/fulcro][Fulcro]] 3.5 - A library for development of single-page full-stack web
  applications in clj/cljs
- [[https://github.com/oliyh/carmine-streams][carmine-streams]] 0.1.3 - Utility functions for working with Redis
  streams in carmine
- [[https://github.com/clojure-lsp/clojure-lsp][clojure-lsp]] [[https://github.com/clojure-lsp/clojure-lsp/releases/tag/2021.07.05-15.12.14][2021.07.05-15.12.14]] - Language Server (LSP) for Clojure
- [[https://github.com/walmartlabs/lacinia-pedestal][lacinia-pedestal]] 0.16.1 - Expose Lacinia GraphQL as Pedestal
  endpoints
- [[https://github.com/henryw374/tools.jvm][tools.jvm]] - new library for getting information about the JVM
  runtime
- [[https://github.com/alekcz/pcp][PCP]] 0.0.1 - Clojure replacement for PHP
- [[https://github.com/borkdude/sci][sci]] [[https://github.com/borkdude/sci/blob/master/CHANGELOG.md#v026][0.2.6]] - Clojure(Script) interpreter suitable for scripting and
  Clojure DSLs
- [[https://github.com/prestancedesign/inertia-clojure][inertia-clojure]] 0.2.3 - Clojure adapter for inertia.js (SPAs with no
  API)
- [[https://github.com/vlaaad/remote-repl/][remote-repl]] 1.2.9 - REPL client for remote REPLs, now with [[https://github.com/vlaaad/remote-repl/#reconnecting][automatic
  reconnect]]
- [[https://github.com/BrunoBonacci/mulog][μ/log]] 0.8.0 - micro-logging library that logs events and data, not
  words
- [[https://gitlab.com/yogthos/mastodon-bot][mastodon-bot]] 1.13.6 - a bot for mirroring Twitter/Tumblr accounts
  and RSS feeds on Mastodon
- [[https://github.com/helins/maestro.clj][maestro.clj]] - a new tool for managing a monorepo with deps.edn and
  babashka
- [[https://github.com/liquidz/vim-iced][vim-iced]] 3.5.2 - Clojure Interactive Development Environment for
  Vim8/Neovim
- [[https://github.com/borkdude/specter-cli][specter-cli]] - A new native Specter CLI using GraalVM native-image
  and SCI
- [[https://calva.io/][Calva]] 2.0.203 - Clojure & ClojureScript in Visual Studio Code

*** Fun

If you like Minecraft and Clojure, check out [[https://www.youtube.com/watch?v=qgQwhc_DDSY][Witchcraft]] to do your
crafting from a REPL!

** [2021-07-09] Source Libs and Builds
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/07/09/source-libs-builds.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/07/09/source-libs-builds
:CLOJURE_SITE_AUTHOR: Fogus
:CLOJURE_SITE_DATE: 2021-07-09
:CUSTOM_ID: content/news/2021/07/09/source-libs-builds
:END:

Several years ago, Clojure introduced [[#content/reference/deps_and_cli#deps.edn][deps.edn]] (a data definition for
dependencies), [[https://github.com/clojure/tools.deps.alpha/][tools.deps]] (a library for computing classpaths), and
the [[#content/reference/deps_and_cli][Clojure CLI]] to run programs. The Clojure community has widely
adopted these and we are excited today to provide a clear path for
users looking to use these same tools to build their projects:

- [[https://github.com/clojure/tools.build/][tools.build]] - a library for building artifacts
- CLI updates to make working with source repos as libs easier
- CLI updates for installing, introspecting, and using custom tools

Builds are processes and are best represented as programs. The
tools.build library provides building blocks to write build programs -
this is a modular and compositional approach to artifact building,
making the best use of Clojure itself as the language.

We take advantage of Clojure's dynamic nature to use source repositories
directly as libraries, avoiding the overhead of building, deploying, and
consuming artifacts. While most Clojure libraries can be consumed
directly as source, sometimes they require a preparation step (like
compiling Java in mixed source projects). We've added support for this
as well.

Finally, we've enhanced making, installing, and running custom tools
that run independently of the project classpath. Tools embrace all of
the ideas above and require only a git repository for others to install
and run.

*** Builds are Programs

The new [[https://github.com/clojure/tools.build][tools.build]] library is a set of helper functions for writing
build programs. To add a build for your deps.edn project, you will:

- Write a Clojure program that uses tools.build to build your project
- Provide function entry points in your program for whatever targets
  make sense (things like ~clean~, ~compile~ or ~jar~)
- Add an alias to your deps.edn that invokes your build program and
  includes tools.build as a dependency
- Invoke the build as a tool using ~-T~. ~-T~ is similar to ~-X~ but
  omits the project classpath and includes the root of the project as
  one of the ~:paths~.

For more details and full examples, see the following:

- [[https://clojure.github.io/tools.build][tools.build API]]
- [[#content/guides/tools_build#source-library-jar-build][tools.build guide]]

*** Source Repos as Libs

Due to Clojure's dynamic nature, we can directly use source
repositories as libraries without the overhead of making,
distributing, and consuming artifacts. This release provides some
[[#content/reference/deps_and_cli#git][updates for git libraries]]:

- Git repository urls are now optional and inferred if the library name
  follows a naming convention
- Git tag and short git sha prefix are now sufficient to identify a git
  lib version. The prefix is included to verify that the tag has not
  moved (both must point to the same commit).

Occasionally, source dependencies will require preparation (e.g.
compilation, resource text replacement, code gen, etc.) to use them on
the classpath. A common case is needing to compile Java source in a
mixed source library. A source-based lib declares how it should be
prepped in its deps.edn:

#+BEGIN_SRC clojure
{:deps/prep-lib {:alias :build
                 :fn compile
                 :ensure "target/classes"}}
#+END_SRC

The Clojure CLI library checks that the ~:ensure~ directory exists and
if it's not found, program execution will not proceed. To tell the CLI
to prepare this (and any other libraries), you can run the command:

#+BEGIN_EXAMPLE
clj -X:deps prep
#+END_EXAMPLE

This command will find the unprepped libs, and run the ~compile~
function using the ~:build~ alias, presumably filling the ~target/classes~
directory with necessary classes to put on the classpath
(~"target/classes"~ should be in the project ~:paths~). More information
on supporting unprepped dependencies is available in the [[#content/reference/deps_and_cli#prep-libs][Clojure CLI
reference]].

*** Tools

We have also enhanced the Clojure CLI to explore, install, invoke, and
introspect tools based on a set of conventions for tool creators.
Installing a new tool such as [[https://github.com/clojure/tools.deps.graph][tools.deps.graph]] can be done as follows:

#+BEGIN_EXAMPLE
clj -Ttools install io.github.clojure/tools.deps.graph '{:git/tag "v1.0.63"}' :as graph
#+END_EXAMPLE

The use of a Git library name ~io.github.clojure/tools.deps.graph~ and
the git tag ~v1.0.63~ allows the CLI to find and install the tool as
~graph~, which is the name that used for invocation, a la
~clj -Tgraph <function> <args>~. In this one case, a ~:sha~ is not
required (but it will be resolved and recorded to check for a match in
the future).

The command above uses ~-Ttools~ which is invoking the ~tools~ tool,
which is automatically installed by the Clojure CLI.

The CLI also provides a way to explore the available versions of tools
with the ~clj -X:deps find-versions~ command to list the tags available
for a tool (also works for Maven versions).

Finally, there are new ~help/doc~ and ~help/dir~ functions available in
the ~:deps~ alias for introspecting what functions are available and how
to use them. For example, you can run:

#+BEGIN_EXAMPLE
clj -X:deps help/doc :ns help
#+END_EXAMPLE

To look at the documentation for the ~clojure.tools.cli.help~ namespace.

More information on the new [[#content/reference/deps_and_cli#tool-installation-and-invocation][tools support in the CLI]] is available in
the reference docs.

*** Installation

A prerelease version of the CLI is now available: 1.10.3.905.

On Mac or Linux, you can install the prerelease [[https://github.com/clojure/homebrew-tools#version-archive-tool-releases][using brew]]. On Linux
or Windows you can use the installer per the instructions in [[#content/guides/getting_started][Getting
Started]] to install the specific version above.

*** What's New

All items below are additive updates, there should be no changes
required for existing deps.edn projects or CLI usage.

- [[https://github.com/clojure/tools.build][tools.build]] - a new library for builds
  - [[https://clojure.github.io/tools.build][API]] - what's available
  - [[#content/guides/tools_build][Guide]] - how to use it
- deps.edn:
  - [[#content/reference/deps_and_cli#git][git deps]]
    - If a git library name follows the repo convention names, the
      ~:git/url~ can now be inferred (~:git/url~ can also be specified
      explicitly and takes precedence)
    - ~:git/tag~ and short ~:git/sha~ can now be specified instead of
      the full sha. Both must point to the same commit.
    - ~:sha~ has been renamed to ~:git/sha~ but the original is still
      supported for backwards compatibility
  - A new ~:deps/prep-lib~ top-level key is used to say how a lib is
    prepared with the following keys: ~:alias~, ~:fn~, and ~:ensures~.
    See [[#content/reference/deps_and_cli#prep-libs][prep]] docs for more.
  - A new ~:tools/usage~ top-level key is used to provide the
    ~:ns-default~ and ~:ns-aliases~ context for a tool
- [[#content/reference/deps_and_cli][Clojure CLI]]
  - New ~-T~ switch is like ~-X~ (invokes a function) but omits the
    project ~:paths~ and ~:deps~ and adds ~:paths ["."]~ to provide a
    clean tool classpath. ~-T:aliases~ is same as -X, ~-Ttoolname~ -
    resolves and uses tool context.
  - New API [[#content/reference/deps_and_cli#other-programs][help functions]] available via the built-in ~:deps~ alias: ~help/doc~
    and ~help/dir~
  - New API function ~basis~ that can be used to provide a custom
    basis to use, in combination with other tools that take a basis
  - New API program ~prep~ that is used to [[#content/reference/deps_and_cli#prep-libs][prep]] source libs
- [[https://github.com/clojure/tools.deps.alpha][tools.deps.alpha]]
  - New library API: ~create-basis~ (also available in tools.build -
    use that one if writing a build program)
- [[https://github.com/clojure/tools.tools][tools.tools]] - a tool library for managing tools
  - [[https://clojure.github.io/tools.tools][API]]
  - [[#content/reference/deps_and_cli#tool-installation-and-invocation][Reference]]
  - tools.tools is auto-installed by the Clojure CLI as a tool named
    ~tools~ (invoke with ~-Ttools~)

You may also want to check out [[https://www.youtube.com/watch?v=BTAx-gFz6Ks][Alex Miller's talk]] about this release
at clojureD.

Issues and bugs can be reported on [[https://ask.clojure.org]] or in
Clojurians Slack in #tools-deps.

** [2021-07-16] Clojure Deref (July 16, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/07/16/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/07/16/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-07-16
:CUSTOM_ID: content/news/2021/07/16/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

Big congrats to [[https://amperity.com/][Amperity]] on their [[https://amperity.com/blog/amped-up-announcing-amperitys-usd100m-series-d-financing][Series D financing]] and valuation of
$1B, making them another "unicorn" built substantially on Clojure and
ClojureScript, approaching 100 Clojure developers. It is great to see
these Clojure success stories at scale!  Amperity has also been a
great contributor to the Clojure ecosystem, so many thanks to them.

*** Podcasts and videos

- [[https://lispcast.com/why-is-data-so-powerful/][LispCast]] - Eric Normand on the power of data
- [[https://www.youtube.com/watch?v=DaVrEYIhRFA][clojure-lsp]] - Eric Dallo showcases clojure-lsp
- [[https://www.youtube.com/watch?v=KOzi-YBq3aI][sudoku solver]] - Dutch Clojure Meetup #133

*** Blogs, discussions, tutorials

- [[https://tonsky.me/blog/icfpc-2021/][Zig, Skia, Clojure, Geometry and the Japanese TV Show: ICFP Contest
  2021]] by Nikita Prokopov
- [[https://www.juxt.pro/blog/maven-central][How-to: Clojure libraries on Maven Central]] by Juxt
- [[https://www.notamonadtutorial.com/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/][BEAM all the things! ClojErl, an implementation of Clojure on the
  Erlang Virtual Machine]] - an interview with Juan Facorro, it's
  creator
- [[https://geokon-gh.github.io/literate-clojure.html][Projectless literate Clojure with embedded SVG]] by George Kontsevich

*** Libraries and tools

Some interesting library and tool updates and posts this week:

- [[https://blog.datomic.com/2021/07/Datomic-Cloud-884-9095-New-tiers-and-internet-access.html][Datomic Cloud]] 884-9095 - new lower pricing tiers, API Gateway
  automation, and simplified operation
- [[https://github.com/clojure/data.json][data.json]] 2.4.0 - no dependency JSON parser/writer in Clojure
- [[https://github.com/clojure/tools.reader][tools.reader]] 1.3.6 - Clojure reader in Clojure
- [[https://github.com/clojure/tools.build][tools.build]] 0.1.3 - Building artifacts in Clojure
- [[https://github.com/FieryCod/holy-lambda][holy-lambda]] 0.2.3 - micro-framework that integrates Clojure with AWS
  Lambda
- [[https://github.com/hyperfiddle/rcf][rcf]] - (NEW) turn your Rich Comment Forms into tests
- [[https://github.com/juji-io/datalevin][datalevin]] 0.4.40 - simple, fast and durable Datalog database
- [[https://github.com/retrogradeorbit/bootleg][bootleg]] 0.1.9 - simple template processing command line tool to help
  build static websites
- [[https://github.com/seancorfield/depstar][depstar]] 2.1.267 - builds JARs, uberjars, does AOT, manifest
  generation, etc for deps.edn projects
- [[https://pathom3.wsscode.com/][pathom]] 2021.07.10-alpha - logic programming through attribute
  relationships.
- [[https://github.com/wilkerlucio/pathom-viz][pathom-viz]] 2021.7.11 - visualization tools for Pathom
- [[https://github.com/wilkerlucio/pathom-viz-connector][pathom-viz-connector]] 2021.07.15-1 - connect Pathom parsers with the
  Pathom Viz Electron standalone tool
- [[https://www.mirabelle.mcorbin.fr/][mirabelle]] 0.3.0 - stream processing engine for monitoring
- [[https://github.com/clojure-lsp/clojure-lsp][clojure-lsp]] 2021.07.12-12.30.59 - Language Server (LSP) for Clojure
- [[https://calva.io/][Calva]] 2.0.204 - Clojure for VS Code
- [[https://github.com/babashka/babashka][babashka]] 0.5.0 - native, fast starting Clojure interpreter for
  scripting
- [[https://github.com/jonase/eastwood][eastwood]] 0.8.1 - Clojure lint tool
- [[https://github.com/liquidz/antq][antq]] 0.16.0 - point out your outdated dependencies

*** Video throwback

If you haven't seen it, the classic [[https://www.youtube.com/watch?v=jlPaby7suOc][Every Clojure Talk Ever]] by Alex
Engelberg and Derek Slager does a pretty good job of lovingly
capturing the foibles and curiosities of the Clojure community. Enjoy!

** [2021-07-23] Clojure Deref (July 23, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/07/23/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/07/23/deref
:CLOJURE_SITE_AUTHOR: Fogus
:CLOJURE_SITE_DATE: 2021-07-23
:CUSTOM_ID: content/news/2021/07/23/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

I started the week by writing a [[http://blog.fogus.me/2021/07/20/clojure-builds-as-an-amalgamation-of-orthogonal-parts/][post about the new Clojure library
tools.build]] and how to add support for building artifacts using this
new tool in our collective Clojure utility belt. The discussion is
framed around moving from a small Leiningen project.clj file to a
build.clj that uses tools.build and the Clojure CLI to do its thing.

*** Podcasts and videos

- [[https://soundcloud.com/defn-771544745/74-will-acton-and-the-greatest-clojure-podcast-crossover][defn]] - defn podcast with Will Acton under the microscope and [[https://anchor.fm/lostinlambduhhs/episodes/lilactown-Will-Acton-X-DEFN-e14olt3][Jordan
  Miller]] as guest host. Good fun!
- [[https://clojurescriptpodcast.com/][ClojureScript Podcast]] - Anatoly talking about mount
- [[https://www.youtube.com/watch?v=b6LHzZogIbA&t=5s][Fred Overflow]] - State and Concurrency in Clojure vs Java
- [[https://www.youtube.com/watch?v=481UBX-5eY4][Los Angeles Clojure Users Group]] - Learning Crux Datalog
- [[https://www.youtube.com/watch?v=u5ECoR7KT1Y][London Clojurians]] - Babashka tasks

*** Blogs, discussions, tutorials

- [[https://www.alexthinks.com/2021/07/making-a-mobile-app-with-clojurescript-in-2021][Making an app with Clojurescript]] by Alex Davis
- [[https://medium.com/@markcwoodworth/restructuring-destructuring-20f79ef41963][Restructuring Destructuring]] by Mark Woodworth - A post that's right
  up my alley.  A walk-through of how destructuring work by
  implementing your own along the way.

*** Libraries and tools

Some interesting library and tool updates and posts this week:

- [[https://twitter.com/bbatsov/status/1417072603458588674][Cider]] 9 - Cider turned 9 years old! A fantastic tool from Bozhidar
  Batsov and his team of contributors. Thank you!
- [[https://lambdaisland.com/blog/2021-06-29-lioss-update-june-2021][Lambda Island]] - An overview of some of the great tools and libraries
  coming from Lambda Island in July.
- [[https://github.com/cognitect-labs/test-runner][test-runner]] 0.4.0 - Cognitect-Labs test-runner gets a bump.
- [[https://github.com/clojure/tools.build][tools.build]] 0.1.6 - Building artifacts in Clojure

*** Training and hiring

- [[https://jobs-staging.braveclojure.com/][Brave Clojure Jobs]] - A redesign is underway and in beta for this
  great jobs resource for the Clojure community and it looks great!

*** Video throwback

Rich Hickey's 2016 Clojure/conj keynote entitled [[https://www.youtube.com/watch?v=oyLBGkS5ICk][Spec-ulation]] is a
deep discussion on growth versus breakage in software and well worth
another look.

** [2021-07-30] Clojure Deref (July 30, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/07/30/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/07/30/deref
:CLOJURE_SITE_AUTHOR: Fogus
:CLOJURE_SITE_DATE: 2021-07-30
:CUSTOM_ID: content/news/2021/07/30/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

Erez Rabih wrote a good blog [[https://engineering.nanit.com/6-years-of-professional-clojure-2b61cb6c1983][post that covers a lot of the high and
low points of working in the tech industry as a Clojure
programmer]]. It's a fair and balanced assessment.

*** In the core

Last week [[https://twitter.com/fogus/status/1420478116481409029][I posed a question in a tweet]] asking:

#+BEGIN_QUOTE
As a Clojure programmer, what about JDK interop do you wish was
cleaner, easier to express, and/or unnecessary altogether (e.g.
reified in clojure.core)?
#+END_QUOTE

We've been thinking about this question a lot lately and had an idea how
the answers would fall and were not surprised when they all mostly fell
into the following categories.

- Cleaner Java variadic method calls (i.e. building an array
  explicitly)
- Methods as first-class functions
- Extending abstract base-class dynamically (i.e. ~reify-class~)
- Applicative functions do not work with Java Streams
- Cleaner array type hints
- String/parseTYPE use
- Math/xxx use
- Inner class auto-require

Most of these items have related tickets and those that don't are quite
well-known in the Clojure community. Now we're not entirely sure if all
of these are worth pursuing but we are thinking about them all and
trying to identify ways that we can smooth the sharp edges of JDK
interop. Stay tuned.

If we've missed anything from the list above then feel free to reach
out to [[https://www.twitter.com/puredanger][Alex]] or [[https://www.twitter.com/fogus][myself]] on Twitter.

*** Libraries and tools

Some interesting library and tool updates and posts this week:

- [[https://github.com/clj-kondo/clj-kondo/blob/master/doc/hooks.md#macroexpand][clj-kondo]] - adds macroexpand hooks in version 2021.07.28
- [[https://github.com/cnuernber/tmdjs][tmdjs]] - DataFrame and Numerics for ClojureScript version
  1.000-beta-2
- [[https://github.com/clojure/tools.build][tools.build]] - version 0.1.7 fixes a problem where an unneeded
  resources file was overriding the tools.deps dependency
- [[https://clojure.org/releases/tools#v1.10.3.933][Clojure Tools]] - release notes for the Clojure command line tools
  version 1.10.3.933

*** Video Throwback

Flashback to Lambda Days 2017 when [[https://www.kent.ac.uk/computing/people/3686/turner-david][David Turner]] (SASL, KRC, Miranda,
Haskell) gave a talk titled /[[https://www.youtube.com/watch?v=QVwm9jlBTik][Some History of Functional Programming
Languages]]/ from his fascinating and unique perspective.

** [2021-08-13] Clojure Deref (Aug 13, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/08/13/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/08/13/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-08-13
:CUSTOM_ID: content/news/2021/08/13/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

This seems like a good week to highlight some more Clojure unicorns
(private companies with valuations of at least 1 billion USD). One of
the largest unicorns in the world is of course Nubank($30B). A few
weeks ago we highlighted Amperity ($1B), which reached this level with
their latest round and back in January AppsFlyer ($1B) became a
unicorn. This week we have two new Clojure-built/friendly companies
joining the list - [[https://www.reifyhealth.com/][Reify Health]] ([[https://blog.reifyhealth.com/reify-health-raises-millions-eliminate-waiting-clinical-trials][$2.2B]]) and [[https://taxbit.com/][TaxBit]] ([[https://techcrunch.com/2021/08/12/crypto-tax-software-provider-taxbit-raises-130m-at-a-1-33b-valuation/][$1.5B]]).  It's
great to see people build growing and successful companies with
Clojure. Are there other Clojure unicorns? Who is missing from this
list?

The Deref was on vacation last week but we saw the results of the 2021
Stackoverflow survey. In 2020, Stackoverflow failed to include Clojure
as an option so we were glad to see its return this week. Notably,
Clojure again topped the list as the [[https://insights.stackoverflow.com/survey/2021#section-top-paying-technologies-top-paying-technologies][top paying technology]] (as it did
in 2019). Additionally, Clojure was the 2nd [[https://insights.stackoverflow.com/survey/2021#technology-most-loved-dreaded-and-wanted][most loved programming
language]]. For those that filled out the survey, thanks for sharing
your info!

Finally, shout out to Dmitri Sotnikov for the release of the 3rd
edition of [[https://www.pragprog.com/titles/dswdcloj3/web-development-with-clojure-third-edition/][Web Development with Clojure]]!

*** In the core

This week, I've been working with Rich on exploring several different
options for [[https://ask.clojure.org/index.php/2817/lighter-weight-aliasing-for-keywords][lightweight keyword aliases]] (the most highly ranked
request in [[https://ask.clojure.org]]). We've now explored several
possible options for this - changing the semantics of alias, creating
a new kind of symbolic only alias, adding a new clause to ~ns~, and
currently we are looking at modifying ~:require~ itself, which is
currently looking the most promising. More to come as we make some
more syntax decisions and hopefully move this towards the 1.11 stream!

Fogus has been working lately on new ~update-keys~ and ~update-vals~
functions, also one of the top rated [[https://ask.clojure.org/index.php/1926/adding-functions-map-vals-and-map-keys][requests]] on Ask Clojure. He's
been working with Rich to refine the docstrings and semantics, and
also benchmarking a variety of implementation options.

*** Videos and podcasts

Lots of great media in the last couple week:

- [[https://www.youtube.com/watch?v=3HxVMGaiZbc][ClojureScript in the Age of TypeScript]] --- David Nolen from the
  Emerging Tech for the Enterprise Conference
- [[https://www.youtube.com/watch?v=85xtUwRQRy8][Atoms make up EVERYTHING]] - from Jordan Miller looking at reactive
  atoms in CLJS
- [[https://lispcast.com/the-humble-programmer/][The Humble Programmer]] - Eric Normand on Dijkstra's 1972 Turing Award
  lecture
- [[https://vimeo.com/585335551][Apropos 2021-07-24]] - developing mobile native apps
- [[https://soundcloud.com/defn-771544745/75-philippa-markovics][defn podcast]] - with Philippa Markovics
- [[https://clojurescriptpodcast.com/][ClojureScript podcast]] - lvh interviewed by Jacek Schae on security
- [[https://www.cognitect.com/cognicast/161][Cognitect podcast]] - Mike Fikes interviewed by Ghadi Shayban about
  maintaining ClojureScript using CLJS in web browsers and
  microcontrollers

*** Blogs

- [[https://corfield.org/blog/2021/08/02/tools-build/][tools.build]] - Sean Corfield
- [[https://opencrux.com/blog/dev-diary-aug-21.html][Crux Development Diary #6]]
- [[https://metaredux.com/posts/2021/08/01/meta-reduce-2021-1-summer-time.html][Meta Reduce 2021.1: Summer Time]] - Bozhidar Batsov
- [[https://javahippie.net/clojure/camunda/2021/08/07/calling-clojure-from-camunda.html][Calling Clojure code from Camunda]]
- [[https://otavio.dev/2021/08/12/clojure-journey-ix-destructuring][Clojure Journey IX - Destructuring]] - O. Valadares
- [[https://camdez.com/blog/2021/08/08/clojure-indentation-commas][Clojure Indentation Commas]] - Cameron Desautels
- [[https://functional.works-hub.com/learn/feature-of-app-development-in-clojure-55184][Feature of App Development in Clojure]]

*** Libraries and Tools

- [[https://github.com/polyfy/polylith][polylith]] [[https://github.com/polyfy/polylith/releases/tag/v0.2.0-alpha10][v0.2.0-alpha10]] - framework for building Clojure applications
- [[https://github.com/clojure/core.cache][core.cache]] [[https://github.com/clojure/core.cache/releases/tag/v1.0.217][1.0.217]] - caching library for Clojure
- [[https://github.com/clojure/core.memoize][memoize]] 1.0.250 - memoization library for Clojure
- [[https://github.com/kwladyka/consistency-clj][consistency-clj]] - NEW - consistency helpers
- [[https://github.com/viesti/nrepl-cljs-sci][nrepl-cljs-sci]] 0.0.11 - nrepl server for nodejs
- [[https://github.com/clojure-lsp/clojure-lsp][clojure-lsp]] [[https://github.com/clojure-lsp/clojure-lsp/releases/tag/2021.08.03-13.33.03][2021.08.03-13.33.03]] - Language Server (LSP) for
  Clojure - now supports babashka, can find public unused vars
- [[https://github.com/lispyclouds/contajners][contajners]] - NEW idiomatic, data-driven, REPL friendly clojure
  client for OCI container engines
- [[https://github.com/uncomplicate/neanderthal][neanderthal]] 0.43.0 - fast Clojure matrix library
- [[https://github.com/metosin/malli][malli]] [[https://github.com/metosin/malli/blob/master/CHANGELOG.md#060-2021-08-08][0.6.0]] - Data-Driven Schemas for Clojure/Script
- [[https://github.com/cognitect-labs/aws-api][aws-api]] - new services released: Route53 Recovery Cluster, AWS
  Route53 Recovery Control Config, AWS Route53 Recovery Readiness,
  Amazon Chime SDK Identity, and Amazon Chime SDK Messaging services
- [[https://github.com/lambdaschmiede/camunda-clojure-plugin][camunda-clojure-plugin]] - NEW Camunda Process Engine Plugin to
  execute Clojure Functions from Activities
- [[https://github.com/fulcrologic/datomic-cloud-backup][datomic-cloud-backup]] - NEW library for creating and restoring
  backups of databases in Datomic Cloud
- [[https://github.com/clj-commons/manifold][manifold]] 0.1.9-alpha5 - a compatibility layer for event-driven
  abstractions
- [[https://github.com/clj-kondo/clj-kondo][clj-kondo]] 2021.08.06 - a linter for Clojure code that sparks joy
- [[https://github.com/lilactown/autonormal][autonormal]] v2.0.0 - library for storing and querying graph data in a
  Clojure map
- [[https://github.com/babashka/babashka][babashka]] 0.5.1 - Native, fast starting Clojure interpreter for
  scripting
- [[https://github.com/seancorfield/clj-new][clj-new]] 1.1.331 - generate new projects based on clj, Boot, or
  Leiningen Templates
- [[https://github.com/ruedigergad/cli4clj][cli4clj]] 1.7.9 - Create simple interactive CLIs for Clojure
  applications
- [[https://calva.io][Calva]] v2.0.206 - Calva is an integrated REPL powered environment for
  enjoyable and productive Clojure and ClojureScript development in
  Visual Studio Code - perf improvements
- [[http://djblue.github.io/portal][portal]] 0.13.0 - A clojure tool to navigate through your data - perf
- [[https://github.com/camsaul/whitespace-linter][whitespace-linter]] - NEW extensible whitespace linter
- [[https://gitlab.com/yogthos/mastodon-bot][mastodon-bot]] - a bot for mirroring Twitter/Tumblr accounts and RSS
  feeds on Mastodon, reimplementing on clojure/jvm

** [2021-08-20] Clojure Deref (Aug 20, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/08/20/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/08/20/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-08-20
:CUSTOM_ID: content/news/2021/08/20/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

Peter Strömberg spent the week working on a very cool zero-install
[[https://calva.io/get-started-with-clojure/]["learn Clojure"]] story using Gitpod and Calva. He's looking for
feedback - check it out, particularly if you are early in your Clojure
journey!

In business news, Adam Renklint from Pitch [[https://pitch.com/blog/every-week][had a nice write up]] about
how they leverage Clojure as a tool for releasing every week. And
congrats to Metabase for their [[https://techcrunch.com/2021/08/19/insight-partners-leads-30m-round-into-metabase-developing-enterprise-business-intelligence-tools/][$30M round]] this week!

*** In the core

I mentioned last week that I was working on [[https://ask.clojure.org/index.php/2817/lighter-weight-aliasing-for-keywords][lightweight keyword
aliases]] and I've summarized what we've looked at, the final proposal,
and patches at [[https://clojure.atlassian.net/browse/CLJ-2123][CLJ-2123]]. I also spent some "quality" time this week
updating all of the tools.deps dependencies. The latest Maven core
release bumps some transitive deps with security reports and also
fixes a number of concurrency issues we've been seeing through the
Clojure CLI. Unfortunately, I also detected a regression in some of
the Maven model building code and spent some time filing tickets and
working with Maven folks on that (will probably lead to a new Maven
release). For now I have worked around the regression so
tools.deps/Clojure CLI users won't be impacted.

Fogus has continued work on new [[https://ask.clojure.org/index.php/1926/adding-functions-map-vals-and-map-keys][update-keys and update-vals functions]]
and a related [[https://clojure.atlassian.net/browse/CLJ-1879][older problem]] that affects the benchmarking of
those. He's also been doing some work on the Cognitect aws-api.

*** Podcasts and videos

- [[https://www.infoq.com/podcasts/lucas-cavalcanti-nubank-fintech-clojure/][Info interview]] - Lucas Cavalcanti from Nubank
- [[https://clojurescriptpodcast.com/][S4 E 36]] - Jacek Schae on ClojureScript podcast with lvh (part 2)
- [[https://www.youtube.com/watch?v=cGeWBJtOz2Y][Introduction to Protojure]] - Greg Haskins at Boston Clojure Group
- [[https://www.youtube.com/watch?v=Ufyqwzn1RDs][Scicloj status report: Notespace, 2021-08-19]] - Daniel Slutsky

*** Blogs

- [[https://cuddly-octo-palm-tree.com/posts/2021-03-07-review-whyfp/][Review: Why FP Matters (Hughes)]] - Gary Verhaegen
- [[https://lambdaisland.com/blog/2021-08-18-a-tale-of-three-clojures][A Tale of Three Clojures]] - Alys Brooks
- [[https://www.juxt.pro/blog/radar-2021][JUXT Clojure Radar 2021]]
- [[http://allentiak.github.io/posts-output/2021-08-13-gsoc-partial-evaluation-report/][GSoC 2021 Partial Evaluation Report]] - Leandro Doctors
- [[https://camdez.com/blog/2021/08/14/regex-optimization-in-clojure/][Regex Optimization in Clojure]] - Cameron Desautels
- [[https://widdindustries.com/clojurescript-datetime-lib-comparison/][Performance comparison of Clojurescript date/time libraries]] - Henry
  Widd
- [[https://metaredux.com/posts/2021/08/17/introducing-incomplete-a-simple-clojure-code-completion-library.html][Introducing incomplete: A Simple Clojure Code Completion Library]] -
  Bozhidar Batsov
- [[https://freshcodeit.com/freshcode-post/how-javascript-developer-first-met-clojure][My story of how I first met Clojure]] - Pavel from Freshcode
- [[https://martinklepsch.org/100/the-cljdoc-contributions-strategy.html][The cljdoc contributions strategy]] - Martin Klepsch

*** Libraries and Tools

New releases and tools this week:

- Clojure CLI [[https://clojure.org/releases/tools#v1.10.3.943][1.10.3.943]] - many perf improvements
- [[https://github.com/clojure/tools.build][tools.build]] v0.1.8 - Library of functions for building Clojure
  projects
- [[https://github.com/seancorfield/deps-new][deps-new]] - NEW - A new, simpler alternative to clj-new
- [[https://github.com/javahippie/clj-test-containers][clj-test-containers]] 0.5.0 - A lightweight, unofficial wrapper around
  the Testcontainers Java library
- [[https://github.com/clojure-lsp/clojure-lsp][clojure-lsp]] [[https://github.com/clojure-lsp/clojure-lsp/releases/tag/2021.08.16-19.02.30][2021.08.16-19.02.30]]
- [[https://github.com/clojure-lsp/lein-clojure-lsp][lein-clojure-lsp]] - NEW - Language Server (LSP) for Clojure
- [[https://github.com/fulcrologic/datomic-cloud-backup][datomic-cloud-backup]] 0.0.5 - A library for creating and restoring
  backups of databases in Datomic Cloud
- [[https://github.com/seancorfield/honeysql][honeysql]] [[https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/readme][2.0.783]] - Turn Clojure data structures into SQL
- [[https://github.com/wilkerlucio/pathom3][pathom3]] 2021.08.14-alpha - Logic programming via attribute
  relationships
- [[https://github.com/babashka/pod-babashka-etaoin][pod-babashka-etaoin]] - now available for windows - pure Clojure
  webdriver protocol implementation
- [[https://github.com/liquidz/vim-iced][vim-iced]] 3.6.0 - Clojure Interactive Development Environment for
  Vim8/Neovim
- [[https://github.com/djblue/portal][portal]] [[https://github.com/djblue/portal/blob/master/CHANGELOG.md#0140---2021-08-15][0.14.0]] - A clojure tool to navigate through your data
- [[https://github.com/athos/trenchman][trenchman]] - NEW Trenchman is a standalone nREPL/prepl client written
  in Go and heavily inspired by Grenchman. It connects to a running
  nREPL/prepl server and starts up a REPL session instantly.

*** Video Throwback

The Calva getting started work reminded me of Felienne Hermans'
excellent Strange Loop 2019 keynote [[https://www.youtube.com/watch?v=g1ib43q3uXQ]["How to teach programming (and
other things)?"]]. If you're interested in this area, also check out her
upcoming book (available in large part in early release now) [[https://www.manning.com/books/the-programmers-brain][The
Programmer's Brain]] based on her research. It's a great read and I
think every programmer will learn some interesting things from it.

** [2021-08-27] Clojure Deref (Aug 27, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/08/27/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/08/27/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-08-27
:CUSTOM_ID: content/news/2021/08/27/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

I'd like to highlight the SciCloj community this week. This recent
[[https://www.youtube.com/watch?v=Qa89bqEqA8k][video]] is a great overview of what's going on. They are working on a
[[https://scicloj.github.io/landing-page/][brand new web page]] which will be getting improved in the coming weeks.

So many people doing great work in this area and I appreciate the
continued time and attention here. This is an area where Clojure can
(and does!) shine but people are not as familiar with it as an option.
Check it out and get involved if you're interested.

*** In the core

This week I made another pass on the patch for [[https://ask.clojure.org/index.php/2817/lighter-weight-aliasing-for-keywords][lightweight keyword
aliases]] based on Rich's feedback and updated the patch on
[[https://clojure.atlassian.net/browse/CLJ-2123][CLJ-2123]]. I've also been looking at the idea of providing some wrapper
functions in Clojure core for commonly used Java functions and we're
investigating what would be most useful there - early leading
candidates are number parsing, math functions, and uuid stuff. As
always, this is investigative work that may or may not actually result
in something.

Fogus has continued to work on [[https://ask.clojure.org/index.php/1926/adding-functions-map-vals-and-map-keys][update-keys and update-vals functions]],
the protocol preference issue in [[https://clojure.atlassian.net/browse/CLJ-1879][CLJ-1879]], and several things for the
Cognitect [[https://github.com/cognitect-labs/aws-api][aws-api]].

*** Blogs

- [[https://www.clojuriststogether.org/news/long-term-funding-selections/][Long-term funding selections]] - Daniel Compton
- [[https://cuddly-octo-palm-tree.com/posts/2021-08-22-cwafi-10/][Cheap interpreter, part 10: fastest one yet, then a hundred times
  faster]] - Gary Verhaegen
- [[https://dev.to/hlship/down-the-rabbit-hole-with-clojure-defrecord-and-macros-3aal][Down the rabbit hole with Clojure, defrecord, and macros]] - Howard
  Lewis Ship
- [[https://lambdaisland.com/blog/2021-08-25-classpath-is-a-lie][The Classpath is a Lie]] - Lambda Island
- [[https://corfield.org/blog/2021/08/25/deps-edn-monorepo-5/][deps.edn and monorepos V (Polylith)]] - Sean Corfield
- [[https://otavio.dev/2021/08/26/clojure-journey-x-namespaces/][Clojure Journey X -- Namespaces]] - Otavio Valadares
- [[https://flexiana.com/2021/08/on-the-nature-of-clojure-protocols][On the Nature of Clojure Protocols]] - Rok Lenarčič
- [[https://kaygun.tumblr.com/post/660171148494028800/multinomial-regression-in-clojure][Multinomial Regression in Clojure]] - Atabey Kaygun
- [[https://medium.com/helpshift-engineering/hacking-with-handlebars-in-java-and-clojure-part-ii-c4de51f49815][Hacking with Handlebars in Java and Clojure: Part II]] - Pranav
  Gajjewar
- [[https://consistent.fit/posts/founder-diaries/][Founder Diaries: Clojure Hackers and a Fitness Startup]] - Stepan
  Parunashvili
- [[https://clojureverse.org/t/clojureverse-report-august-22-downtime-planned-changes-to-infra/8083][ClojureVerse Report: August 22 downtime / Planned changes to infra]]

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/clojure/tools.build][tools.build]] v0.1.9 - Library of functions for building Clojure
  projects
- [[https://github.com/lread/test-doc-blocks][test-doc-blocks]] [[https://github.com/lread/test-doc-blocks/blob/main/CHANGELOG.adoc#v10137-alpha][v1.0.137-alpha]] - Test AsciiDoc and CommonMark code
  blocks found in articles and docstrings
- [[https://github.com/eerohele/Tutkain][Tutkain]] [[https://github.com/eerohele/Tutkain/blob/fcfd3c10a064d8d164f8da6b9c25cd51cf2790c4/CHANGELOG.md][0.9.0 (alpha)]] - Sublime Text 4 package for interactive
  Clojure development
- [[https://github.com/clj-commons/rewrite-clj][rewrite-clj]] [[https://github.com/clj-commons/rewrite-clj/blob/main/CHANGELOG.adoc#v10682-alpha][v1.0.682-alpha]] - Rewrite Clojure Code and EDN
- [[https://github.com/athos/trenchman][trenchman]] [[https://github.com/athos/trenchman/blob/main/CHANGELOG.md#v020---2021-08-24][v0.2.0]] - A standalone nREPL/prepl client written in Go
- [[https://calva.io][Calva]] 2.0.210 - REPL powered environment for enjoyable and
  productive Clojure and ClojureScript development in Visual Studio
  Code
- [[https://github.com/clojure-lsp/clojure-lsp][clojure-lsp]] [[https://github.com/clojure-lsp/clojure-lsp/releases/tag/2021.08.24-14.41.56][2021.08.24-14.41.56]] - Language Server (LSP) for Clojure
- [[https://github.com/IGJoshua/americano][americano]] 1.2.0 - A simple tool for compiling Java from the Clojure
  CLI

*** Video Throwback

Many, many years ago Aaron Bedra did a talk at Clojure/conj
highlighting the (at the time) poor default state of web app security
in Clojure.  Because the Clojure community is awesome, that quickly
resulted in a lot of changes to the defaults in Ring, Compojure, etc
and fixed many of the problems.

Several years later, Joy Clark did a talk called [[https://www.youtube.com/watch?v=lRHPZXKQVLk][Simple AND Secure?]] at
EuroClojure 2017. This talk goes through the OWASP Top 10 areas (for
2017) and looks at what Clojure provides for web apps in those areas. I
think most of it is still relevant and worth watching (but keep in mind
this is 4 years old).

I think now is a good time for an update, both on the threats and the
state of Clojure with respect to them. If you're pitching things to a
Clojure conference in the next year, I think this would be a great
topic!

** [2021-09-03] Clojure Deref (Sept 3, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/09/03/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/09/03/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-09-03
:CUSTOM_ID: content/news/2021/09/03/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

[[https://www.clojuriststogether.org][Clojurists Together]] announced their [[https://www.clojuriststogether.org/news/q3-2021-funding-announcement/][Q3 funding projects]] - congrats to
all receiving funding and thanks to Clojurists Together for
facilitating the funding of open source! I don't know of any other
language community that does as much as the Clojure community to
support sustainable open source.

If you like learning things, two things to mention this week - Jacek
Schae opened the [[https://learndatomic.com][Learn Datomic]] course for enrollment and Deep Learning
for Programmers by Dragan Djuric finally hit [[https://aiprobook.com/deep-learning-for-programmers/?release=1.0.0][1.0.0]]!  Dig in and learn
something new!

*** In the core

I think both Fogus and I continued working on the same things we've been
working on the last couple weeks but moving asymptotically closer to
"finished". We also did a lot of updates on various Clojure JIRA
tickets, preparing things for Rich to look at. We are expecting to move
some of this work (lightweight keyword aliasing, update-keys,
update-vals, bunch of jiras) over the line and into a Clojure
1.11.0-alpha2 over the next week. Not sure yet exactly what that will
include, depends what makes it through review, some may slip out of
alpha2, but I think we will have enough to get an alpha2 out regardless.
A lot of what we have been working on is really revising how we work so
that we can more regularly deliver new Clojure goodness to you!

This week also saw the release of a new Clojure CLI version, which is
largely the same but bumps all of the transitive deps (importantly
including some transitive dep security updates and Maven download
concurrency improvements), and replaces our build process for the CLI
itself with tools.build, so we are eating our dogfood there (and it
tastes pretty good!). I did fix a few minor issues in tools.deps and
tools.build through that process, but things went surprisingly smoothly.

*** Videos and podcasts

- [[https://www.youtube.com/watch?v=asnh6KXoidA][Betting your company on Lisp: 5 years with Clojure in production]] -
  Adam Tornhill
- [[https://www.therepl.net/episodes/38/][Banking and Clojure with Allen Rohner]] - Daniel Compton's The REPL
  podcast returns!
- [[https://clojurescriptpodcast.com/][ClojureScript podcast]] - Part 3 of Jacek Schae's talk with lvh

*** Blogs

- [[https://slipset.github.io/posts/config][Dependency injection, perhaps? Part 2]] - Erik Assum
- [[https://slipset.github.io/posts/dependency-injection-perhaps][Dependency injection, perhaps? Part 1]] - Erik Assum
- [[https://www.git-tower.com/blog/developing-for-the-desktop-pitch/][Pitch --- Developing a Collaborative Presentation Tool for Modern
  Teams]] - Adam Renklint
- [[https://davidvujic.blogspot.com/2021/09/material-design-in-a-functional-world.html][Material Design in a Functional World]] - David Vujic
- [[https://davidvujic.blogspot.com/2021/08/hey-webpack-hey-clojurescript.html][Hey Webpack, Hey ClojureScript]] - David Vujic

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/wilkerlucio/pathom3][Pathom 3]] [[https://blog.wsscode.com/pathom-updates-11/][3 alpha]] - Logic programming via attribute relationships
- [[https://calva.io][Calva]] 2.0.211 - Calva is an integrated REPL powered environment for
  enjoyable and productive Clojure and ClojureScript development in
  Visual Studio Code.
- [[https://github.com/babashka/babashka][babashka]] [[https://github.com/babashka/babashka/blob/master/CHANGELOG.md#060][0.6.0]] - Fast-starting native scripting runtime for Clojure
- [[https://github.com/clojure/tools.build][tools.build]] v0.2.0 - Library of functions for building Clojure
  projects
- [[https://github.com/IGJoshua/farolero][farolero]] 1.3.0 - Thread-safe Common Lisp style conditions and
  restarts for Clojure(Script).
- [[https://github.com/jonase/eastwood][eastwood]] [[https://github.com/jonase/eastwood/blob/Release-0.9.9/changes.md#changes-from-097-to-098][0.9.9]] - Clojure lint tool
- [[https://github.com/lambdaisland/classpath][classpath]] - Classpath/classloader/deps.edn related utilities
- [[https://github.com/polyfy/polylith][polylith]] [[https://github.com/polyfy/polylith/releases/tag/v0.2.12-alpha][0.2.12-alpha]] - A tool used to develop Polylith based
  architectures in Clojure
- [[https://github.com/seancorfield/build-clj][build-clj]] v0.1.2 - Common build tasks abstracted into a library
- [[https://github.com/tolitius/obiwan][obiwan]] 0.1.472 - redis/search clojure client based on jedis
- [[https://clojure.org/reference/deps_and_cli][Clojure CLI]] [[https://clojure.org/releases/tools#v1.10.3.967][1.10.3.967]] - Clojure CLI
- [[https://github.com/PEZ/rn-rf-shadow][rn-rf-shadow]] - An example project to get you started with React
  Native using shadow-cljs
- [[https://github.com/carocad/frechet][frechet]] 0.13.0 - Discrete Fréchet distance
- [[https://github.com/fulcrologic/fulcro][fulcro]] 3.5.3 - A library for development of single-page full-stack
  web applications in clj/cljs
- [[https://clojure-lsp.io/][clojure-lsp]] [[https://github.com/clojure-lsp/clojure-lsp/releases/tag/2021.09.03-00.42.46][2021.09.03-00.42.46]] - A Language Server for
  Clojure(script).
- [[https://github.com/borkdude/deps.clj][deps.clj]] 0.0.17 - A faithful port of the clojure CLI bash script to
  Clojure.
- [[https://github.com/IGJoshua/farolero][farolero]] 1.3.0 - Thread-safe Common Lisp style conditions and
  restarts for Clojure(Script).
- [[https://github.com/seancorfield/next-jdbc][next-jdbc]] [[https://github.com/seancorfield/next-jdbc/releases/tag/v1.2.709][1.2.709]] - A modern low-level Clojure wrapper for
  JDBC-based access to databases
- [[https://github.com/viesti/timbre-json-appender][timbre-json-appender]] 0.2.3 - JSON appender for Timbre
- [[https://github.com/schmee/java-http-clj][java-http-clj]] 0.4.3 - Clojure wrapper for java.net.http with async,
  HTTP/2 and WebSockets
- [[https://github.com/lread/test-doc-blocks][test-doc-blocks]] [[https://github.com/lread/test-doc-blocks/blob/main/CHANGELOG.adoc#v10146-alpha][1.0.146-alpha]] - Test AsciiDoc and CommonMark code
  blocks found in articles and docstrings
- [[https://github.com/clj-commons/manifold][manifold]] [[https://github.com/clj-commons/manifold][0.1.9-alpha6]] - A compatibility layer for event-driven
  abstractions

*** Video Throwback

I'm very happy this week to release a new edit of [[https://youtu.be/LKtk3HCgTa8]["Simple Made Easy"
by Rich Hickey]], which was first given as the closing keynote at
Strange Loop 2011, 10 years ago. To make this edit, I used the
original HD video and Rich's original slides with all the bullet/slide
transitions and animations, so this is as close as you'll get to how
it was originally given in the room. Enjoy this classic!

** [2021-09-10] Clojure Deref (Sept 10, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/09/10/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/09/10/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-09-10
:CUSTOM_ID: content/news/2021/09/10/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

The Call for Papers is now open for [[https://www.reclojure.org/][re:Clojure]], a virtual Clojure
conference on Dec 3-4, and the inimitable Professor Sussman will be
doing the keynote! Looking forward to attending!

[[https://exercism.org][Exercism]] has a brand new [[https://exercism.org/tracks/clojure/concepts][Clojure course]] (shoutout to Bobby Towers and
everyone that contributed). They are interested in feedback, so give
it a look!

*** In the core

Fogus's work on update-keys, update-vals, and reduce-kv nondeterminism
all went through a couple review cycles and is waiting for Rich,
hopefully headed towards 1.11. He has also been looking at how the
trailing map support added to Clojure 1.11.0-alpha1 affects specs using
~keys*~ and we're trying to decide on what needs to be done there.

I've been looking at a variety of things this week related to ease of
use around static methods in the JDK and whether any contrib libs should
be more readily available to Clojure users. The focus of this
conversation has moved all over the place as we analyze various things
and I'm not sure where it's all going yet!

*** Videos and podcasts

- [[https://www.therepl.net/episodes/39/][Clojure Goes Fast with Alexander Yakushev]] - on The REPL with Daniel
  Compton
- [[https://www.youtube.com/watch?v=6jvG3XbSeos][Wire up ClojureScript SPA to Clojure backend (part 1)]] - Daniel Amber

*** Blogs

- [[https://xtdb.com/blog/crux-to-xtdb-rename.html][Crux is evolving into XTDB]] - Jeremy Taylor
- [[https://tonsky.me/blog/clojure-ui/][Thoughts on Clojure UI framework]] - Nikita Prokopov
- [[https://www.jocas.lt/blog/post/deftype-unsynchronized-mutable/][Clojure deftype with =unsynchronized-mutable=]] - Dainius Jocas
- [[https://www.metosin.fi/blog/my-first-project-at-metosin/][My First Project at Metosin!]] - Kari Marttila

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/cognitect-labs/test-runner][test-runner]] v0.5.0 - Clojure test runner
- [[https://github.com/liquidz/antq][antq]] 1.0.0 - Point out your outdated dependencies.
- [[https://github.com/DomainDrivenArchitecture/dda-k8s-crate][dda-k8s-crate]] [[https://github.com/DomainDrivenArchitecture/dda-k8s-crate/releases/tag/1.2.0][1.2.0]] - dda-k8s-crate installs & configures all in one
  server k8s on a ubuntu system
- [[https://github.com/henryw374/js-literal][js-literal]] - like inbuild cljs #js literal, but recursive
- [[https://github.com/juji-io/datalevin][datalevin]] 0.5.8 - A simple, fast and durable Datalog database
- [[https://github.com/lambdaisland/fetch][fetch]] 1.0.41 - ClojureScript wrapper for the JavaScript fetch API
- [[https://github.com/lambdaisland/witchcraft-plugin][witchcraft-plugin]] - Add Clojure support (and an nREPL) to any
  Bukkit-based Minecraft server
- [[https://github.com/clj-commons/manifold][manifold]] 0.1.9 - A compatibility layer for event-driven abstractions

*** Art

First, I wanted to point to some more [[https://twitter.com/jackrusher/status/1187703042143150081][art from Jack Rusher]], who makes
heavy use of Clojure in the making. Follow for a stream of cool stuff.

And second I wanted to highlight the latest essay, [[https://tylerxhobbs.com/essays/2021/the-rise-of-long-form-generative-art]["The Rise of
Long-Form Generative Art"]] by Tyler Hobbs. It is not about Clojure, but
Tyler uses Clojure a lot and always has interesting thoughts in this
area.

** [2021-09-17] Clojure Deref (Sept 17, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/09/17/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/09/17/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-09-17
:CUSTOM_ID: content/news/2021/09/17/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

This week we released [[https://clojure.org/releases/devchangelog#v1.11.0-alpha2][Clojure 1.11.0-alpha2]] which pulls together
several things the core team has been working on plus a variety of
older bug fixes. I wanted to expand a bit more on some of the items in
the release. In general, it's worth digging into these jira tickets as
we expend a fair amount of effort trying to making them good records
of problem/alternatives/solution and I'm going to be heavily mining
them here.

*[[https://clojure.atlassian.net/browse/CLJ-2123][Add :as-alias option to require like :as but not load]]*

This was the [[https://ask.clojure.org/index.php/questions/clojure?sort=votes][most voted]] open request on Ask Clojure and really stemmed
from the big increase in qualified keyword usage from spec. In spec
you might name a spec ~:my.cool.domain/account~ where "my.cool.domain"
is not a "real" namespace that can be loaded, it's just a useful
qualifier. You can of course use the full qualifier every time but
that can be tedious.

Clojure has long had namespace aliases, most commonly defined using the
~:require~ or ~:use~ clause of ~ns~. However, both ~require~ and ~use~
bottom out in ~load-file~, which loads the needed namespace before
creating the alias. You can alternately use ~create-ns~ to create a
runtime Namespace without loading, and then use ~alias~ to alias to it,
and this has been the most common workaround (sometimes with some macro
goo around it to make it easier).

We explored several different options for this, and they're enumerated
in CLJ-2123. We looked at changing ~alias~ to automatically create a
runtime namespace, but this would change ~alias~ semantics, possibly in
ways that would impact existing users. We looked at creating a new kind
of keyword-only alias (I prototyped this - it was a terrible mess to
retain backward portability). We looked at expanding ~ns~ to include a
variant of ~alias~, but this one would have been a breaking change for
the spec (this is kind of a tangent) and we think would have been a bit
harder to cover for existing ns analyzers than where we ended up, which
was to add a new ~:as-alias~ clause to ~require~, that is essentially
like :as, but does not require a loaded namespace.

So you can then do:

#+BEGIN_SRC clojure
(ns foo
  (:require [my.cool.domain :as-alias d])) ;; works! (doesn't load)

::d/account ;; valid
#+END_SRC

The core.specs.alpha spec has been updated to include ~:as-alias~ and a
new version of that library was built and is depended on by
1.11.0-alpha2. Important to note is that this was an additive (via
~keys*~), not breaking, change.

*[[https://clojure.atlassian.net/browse/CLJ-1959][update-keys]] and [[https://clojure.atlassian.net/browse/CLJ-2651][update-vals]]*

Also, a highly voted old request, ~update-keys~ and ~update-vals~ are
functions that have been rewritten many, many times in Clojure code
bases and utility libraries (also often called ~map-keys=/=map-vals~).
When we look at stuff like this, we try to be clear about what
challenges we believe are in or out of scope, how generic to make the
implementation, what promises we should make in the docstring, and how
to achieve the best performance given that. Other impls may make
different choices than we did here, which is fine. For example, should
this work on all associative types (like vectors?) or just maps? We
decided covering the map case well was more important. There was a lot
of perf testing done on implementation choices - that's not all covered
in the tickets.

*[[https://clojure.atlassian.net/browse/CLJ-1879][IKVReduce - make old slow path (IPersistentMap) faster and extend to
Object, removing impl ambiguity]]*

This is kind of an old ticket, but had a direct impact on testing for
update-keys and update-vals, which rely on the IKVReduce protocol.
Protocols are an open extension mechanism where choices are made based
on type matching (including Java inheritance). The IKVReduce protocol
also has an associated Java interface IKVReduce which can be used by
Java implementation classes needing to hook into the protocol (similar
pattern is used in other places as well inside Clojure's impl). To cover
this, the IKVReduce protocol is extended to both the IKVReduce interface
(fast impl) and to the IPersistentMap interface (slow impl). If a
concrete impl (like PersistentHashMap) matches multiple types, the
"closest" one will match. However, PHM implements both of these and it's
essentially a "tie". What we've seen over the years is that based on the
ordering of things returned from reflection, it's possible for PHM to
route to either of the two protocol extensions, sometimes leading to
much slower results for reduce-kv.

We looked at a bunch of ways to resolve this - tweaks to reduce-kv,
special cases for the built-in impls (PHM, PAM), adding a protocol
preference system like multimethods have, etc. There are tradeoffs in
all these approaches, some pretty significant. In the end we decided
that another way to remove the ambiguity is to define the "slow
fallback" implementation on Object, rather than on
IPersistentMap. This widens the scope of what reduce-kv can be applied
to, essentially changing it from "maps" to "colls that seq to map
entries". The Object case is always a last resort case, so there is no
longer any ambiguity - PHM will always take the "fast" through
IKVReduce interface (self reduction). Also, this means that ~reduce-kv~
now works on java.util.Maps (another very old jira request) and
potentially other useful things. Needless to say, there was a lot of
perf testing done on this and several of the alternatives. Along the
way, it seemed clear that the "slow" path fallback was a lot slower
than it needed to be, so that was also rewritten for better
performance. The major tradeoff in the solution we landed on is that
~(satisfies? IKVReduce x)~ is now true for everything. As an internal
protocol rarely used directly, there is very little code in the wild
doing anything like this ([[https://github.com/cgrand/xforms][xforms]] is the most notable example we found
and we've been consulting with Christophe about that one).

The end result of all this is that ~reduce-kv~ is faster in the "slow"
case, will predictably use the "fast" case when it can, and can be
applied to more types of colls.

*Other enhancements and bug fixes*

- [[https://clojure.atlassian.net/browse/CLJ-1908][CLJ-1908]] Add clojure.test api run-test and run-test-var to run
  single test with fixtures and report
- [[https://clojure.atlassian.net/browse/CLJ-2600][CLJ-2600]] Don't block realized? of delay on pending result
- [[https://clojure.atlassian.net/browse/CLJ-2649][CLJ-2649]] Fix order of checks in some-fn and every-pred for 3
  predicate case to match other unrollings
- [[https://clojure.atlassian.net/browse/CLJ-2636][CLJ-2636]] Get rid of reflection on java.util.Properties when defining
  *clojure-version*
- [[https://clojure.atlassian.net/browse/CLJ-2350][CLJ-2350]] Improve keyword arity exception message
- [[https://clojure.atlassian.net/browse/CLJ-2444][CLJ-2444]] Fix typo in test-vars docstring
- [[https://clojure.atlassian.net/browse/CLJ-1509][CLJ-1509]] AOT compile more Clojure namespaces
- [[https://clojure.atlassian.net/browse/CLJ-2387][CLJ-2387]] Fix off-by-one in socket server port validation

We've been working on creating some new internal processes for working
through jiras, and this is the first chunk of those. We're hoping to
get a mixture of highly voted (important to the community), important
from core team perspective, and low-hanging fruit into each 1.11
alpha/beta.  I don't have a prediction for when we will "finish" 1.11
as it depends a lot on what we decide to include, and that is an
ongoing discussion.

As always, it's a huge help to us if you can swap it into your build and
just run your test suite to see if anything breaks (or is faster!). We'd
love to hear that feedback, even if it's "all good".

*** Videos and podcasts

- [[https://www.youtube.com/watch?v=grL3DQyvneI][Turning your editor into a Clojure IDE with clojure-lsp]] - Eric Dallo
- [[https://www.therepl.net/episodes/40/][The REPL]] - Daniel Compton interviews Paulus Esterhazy
- [[https://clojurescriptpodcast.com/][ClojureScript Podcast]] - Jacek Schae's final part of the interview
  with lvh
- [[https://soundcloud.com/defn-771544745/76-the-desi-episode-with-kartik-gupta-and-hariom-gaur][defnpodcast]] - The Desi Episode with Kartik Gupta and HariOm Gaur

*** Blogs

- [[https://davidvujic.blogspot.com/2021/09/clojurescript-amplified.html][ClojureScript.  Amplified.]] - David Vujic
- [[https://slipset.github.io/posts/all-your-base][Dependency injection, perhaps? Part 3]] - Erik Assum
- [[https://arthurbarroso.github.io/testing-the-dom-using-shadow-and-reagent.html][Testing the DOM using shadow-cljs and Reagent]] - Arthur Barroso

*** Libraries and Tools

New releases and tools this week:

- [[https://vlaaad.github.io/reveal-pro][Reveal Pro]] - Read Eval Visualize Loop for Clojure, Supercharged
- [[https://github.com/lk-geimfari/secrets.clj][secrets.clj]] 1.0.0 - A Clojure library designed to generate
  cryptographically strong random numbers.
- [[https://github.com/seancorfield/build-uber-log4j2-handler][build-uber-log4j2-handler]] v0.1.0 - A conflict handler for log4j2
  plugins cache files for the tools.build uber task.
- [[https://github.com/seancorfield/build-clj][build-clj]] v0.3.0 - Common build tasks abstracted into a library
- [[https://github.com/clojure/tools.build][tools.build]] v0.5.0 - Library of functions to make Clojure builds
- [[https://github.com/oliyh/martian][martian]] v0.1.18 - The HTTP abstraction library for Clojure/script,
  supporting Swagger, Schema, re-frame and more
- [[https://github.com/clj-kondo/clj-kondo][clj-kondo]] [[https://github.com/clj-kondo/clj-kondo/blob/master/CHANGELOG.md#20210914][2021.09.15]] - A linter for Clojure code that sparks joy
- [[https://github.com/johanthoren/julian][julian]] 1.0.0 - A Clojure(Script) library to convert between Julian
  Day Number and common time
- [[https://github.com/erp12/fijit][fijit]] 1.0.7 - A Clojure library for Scala interop
- [[https://github.com/FieryCod/holy-lambda][holy-lambda]] 0.5.0 - The extraordinary simple, performant, and
  extensible custom AWS Lambda runtime for Clojure
- [[https://github.com/PEZ/clojure-exercism-template][clojure-exercism-template]] - Learn more Clojure and Interactive
  Programming with Exercism in the browser
- [[https://github.com/clojure-lsp/clojure-lsp][clojure-lsp]] [[https://github.com/clojure-lsp/clojure-lsp/releases/tag/2021.09.13-19.32.00][2021.09.13-19.32.00]] - Language Server (LSP) for Clojure
- [[https://github.com/clj-easy/graal-build-time][graal-build-time]] 0.0.11 - Library to initialize Clojure packages at
  build time with GraalVM native-image
- [[https://convex.world/]] - Convex is an open, decentralised, and
  efficient technology platform built in the spirit of the original
  Internet
- [[https://github.com/eerohele/Tutkain][Tutkain]] [[https://github.com/eerohele/Tutkain/blob/3700db4e194aeb9cc1f5b74aafe4ccd1588353e6/CHANGELOG.md#0100-alpha---2021-09-15][0.10.0]] - A Sublime Text package for interactive Clojure
  development
- [[https://github.com/juji-io/datalevin][datalevin]] 0.5.13 - A simple, fast and versatile Datalog database
- [[https://github.com/babashka/babashka][babashka]] [[https://github.com/babashka/babashka/blob/master/CHANGELOG.md#061][0.6.1]] - Native, fast starting Clojure interpreter for
  scripting
- [[https://github.com/athos/trenchman][trenchman]] v0.3.0 - A standalone nREPL/prepl client written in Go and
  heavily inspired by Grenchman

** [2021-09-24] Clojure Deref (Sept 24, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/09/24/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/09/24/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-09-24
:CUSTOM_ID: content/news/2021/09/24/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Videos and podcasts

- [[https://www.youtube.com/watch?v=zK9y1nvmft8][Changing to Clojure mid-flight]] - Marcus Rydberg from Func Prog
  Sweden
- [[https://www.youtube.com/watch?v=1OcAUhe3E1E][Vlojure - A New Way to Write ClojureScript]] - Ella Hoeppner
- [[https://www.therepl.net/episodes/41/][The REPL]] - podcast with guest Chris Houser
- [[https://getsmarterandmakestuff.com/2021/09/18/podcast-episode-009-carin-meier/][Get Smarter and Make Stuff]] - podcast with guest Carin Meier
- [[https://anchor.fm/recursive-house/episodes/Episode-2---Dmitri-Sotnikov---Engineering-for-Scale-in-Clojure-e17ka83][RH Podcast]] - Dmitri Sotnikov - Engineering for Scale in Clojure

*** Blogs

- [[https://convexhuman.com/graalvm-clojure.html][Native Clojure with GraalVM]] - Mohammed Amarnah
- [[https://jobs-blog.braveclojure.com/2021/09/20/a-better-clojure-job-board.html][A Better Clojure Job Board]] - Daniel Higginbotham
- [[https://hyperfiddle.notion.site/Reactive-Clojure-You-don-t-need-a-web-framework-you-need-a-web-language-44b5bfa526be4af282863f34fa1cfffc][Reactive Clojure: You don't need a web framework, you need a web
  language]] - Dustin Getz

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/ivarref/yoltq][yoltq]] 0.2.33 - An opinionated Datomic queue for building (more)
  reliable systems. Supports retries, backoff, ordering and more
- [[https://github.com/clj-easy/graal-config][graal-config]] - GraalVM native-image configurations distribution for
  Clojure libraries
- [[https://github.com/pfeodrippe/pitoco][pitoco]] - Check your endpoint schemas (using spec-provider, Malli and
  Pathom)
- [[https://github.com/clojure/brew-install][brew-install]] [[https://clojure.org/releases/tools#v1.10.3.986][1.10.3.986]] - Clojure CLI
- [[https://github.com/oliyh/cljs-http-promise][cljs-http-promise]] 0.1.47-SNAPSHOT - A ClojureScript HTTP library
- [[https://github.com/behrica/clj-py-r-template][clj-py-r-template]] - Clojure polyglot clj-template
- [[https://github.com/djblue/portal][portal]] [[https://github.com/djblue/portal/releases/tag/0.15.1][0.15.1]] - A clojure tool to navigate through your data
- [[https://github.com/seancorfield/deps-new][deps-new]] 0.3.1 - A new, simpler alternative to clj-new
- [[https://github.com/bsless/stress-server][stress-server]] - Stress your Clojure servers until they sweat
- [[https://github.com/ribelo/doxa][doxa]] - A simple in-memory database
- [[https://github.com/seancorfield/clj-new][clj-new]] v1.2.359 - Generate new projects based on clj, Boot, or
  Leiningen Templates
- [[https://github.com/liquidz/antq][antq]] 1.1.0 - Point out your outdated dependencies
- [[https://github.com/cognitect-labs/aws-api][aws-api]] 0.8.524 - AWS, data driven
- [[https://github.com/borkdude/scittle][scittle]] 0.0.4 - The Small Clojure Interpreter exposed for usage in
  script tags
- [[https://github.com/borkdude/nbb][nbb]] 0.0.76 - Ad-hoc CLJS scripting on Node.js
- [[https://github.com/borkdude/deps.clj][deps.clj]] [[https://github.com/borkdude/deps.clj/blob/master/CHANGELOG.md#v0018][0.0.18]] - A faithful port of the clojure CLI bash script to
  Clojure
- [[https://github.com/benedekfazekas/morpheus][morpheus]] - Generate dependency graphs for variables in
  Clojure(Script) namespaces
- [[https://github.com/lilactown/helix][helix]] 0.1.3 - A simple, easy to use library for React development in
  ClojureScript
- [[https://github.com/skinkade/uniformity][uniformity]] - Clojure(Script) library for cryptographically random
  data with uniform behavior between JVM and JS usage

*** Art

Lots of people using Clojure to make art these days, here's a few I
saw go by on Twitter this week:

- [[https://twitter.com/sakalli/status/1439926455249539075][@sakalli]]
- [[https://twitter.com/generateme_blog/status/1440578677574569986][@generateme_blog]]
- [[https://twitter.com/RustyVermeer/status/1441182689957085184][@RustyVermeer]]

** [2021-10-08] Clojure Deref (Oct 8, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/10/08/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/10/08/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-10-08
:CUSTOM_ID: content/news/2021/10/08/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

Last week was a bit of a Deref holiday as your host was otherwise
occupied running the Strange Loop conference (in-person)! It was really
great to see so many familiar friends and (masked) faces at a conference
again. As I said during the opener, turns out it actually is the people
you meet along the way that make it all worthwhile. :) Can't wait to see
you all at a Clojure conference in the future.

*** In the core

Fogus has been working through the spec-related updates for the change
in 1.11.0-alpha1 to support a trailing map in calls to kwarg functions
(typically spec'ed with keys* specs). This was not something we were
that worried about initially, but it has turned out to be a far more
intricate puzzle than we imagined.

For example, you might have a function and a spec:

#+BEGIN_SRC clojure
;; opts can be kwarg :a or :b
(defn config [name & opts] ...)
;; (config "a-name" :a 100 :b 200)

;; spec options with keys*
(s/def ::a int?)
(s/def ::b int?)
(s/fdef config
  :args (s/cat :name string? :opts (s/keys* :opt-un [::a ::b])))

;; now a valid call, but fails the spec when instrumented
(stest/instrument `config)
(config "a-name" {:a 100 :b 200})
Execution error - invalid arguments to user/config at (REPL:1).
{:a 100, :b 200} - failed: keyword? at: [:opts :clojure.spec.alpha/k]
#+END_SRC

The initial thought was just to make keys* spec smarter, but really on
close examination this is problematic. keys* can be used in multiple
contexts - in a custom data structure with its own syntax, in macro
definitions, or in function definitions. In the first couple cases, this
is effectively language created by a designer and adding newly allowed
cases is probably wrong (some good examples can be built from the ~ns~
specs). On the other side, we could leave keys* alone and add a new spec
that you could "opt into" when you want this (but then everyone has to
update their function specs). But we're trying to find a middle path by
hooking instrument for functions to transform the input before it is
checked with keys*, so that particular case continues to work
automatically in 1.11 with existing specs (and other uses are not
affected). Anyhow, that work is getting close.

I've been working on several things, but one ongoing thing we're
exploring is some way to surface some of the static methods in
java.lang.Math etc so that they are both fast and more "visible". At the
moment I'm going down the path of generating a namespace by reflecting
Math - originally as a dynamic thing, now looking more at code gen pre
build. Still not sure exactly where this will end up. I also spent a lot
of time in the last couple weeks diving into a new batch of jiras and
each of those is its own little world and I will talk more about some of
those as they move through the pipeline.

*** Videos and podcasts

- [[https://www.cognitect.com/cognicast/162][Cognicast]] - Craig Andera
- [[https://www.therepl.net/episodes/42/][The REPL]] - Faster JSON parsing with Erik Assum
- [[https://anchor.fm/lostinlambduhhs/episodes/lambduhh—​Jordan-Miller-I-e185vtp][:lambduhh (= Jordan Miller "I" )]] - Jordan Miller
- [[https://clojurescriptpodcast.com/][ClojureScript podcast]] - Config with Alexander Yakushev
- [[https://lispcast.com/the-humble-programmer/][The Humble Programmer]] - Eric Normand
- [[https://lispcast.com/programmer-as-navigator/][Programmer as Navigator]] - Eric Normand
- [[https://www.youtube.com/watch?v=04NfYSLQfY8][Use RabbitMQ with Clojure]] - Daniel Amber
- [[https://www.youtube.com/watch?v=_8z1r8KV9uk][Spock - Prolog in Clojure, logically]] - Mauricio Szabo from London
  Clojurians

*** Blogs

- [[https://noahtheduke.github.io/posts/2021-10-02-from-elegance-to-speed-with-clojure/][From Elegance to Speed, with Clojure]] - Noah Bogart
- [[https://corfield.org/blog/2021/10/01/deps-edn-monorepo-6/][deps.edn and monorepos VI (Polylith)]] - Sean Corfield
- [[https://cuddly-octo-palm-tree.com/posts/2021-10-03-monads-clojure/][Monads for Clojure programmers]] - Gary Verhaegen
- [[https://nextjournal.com/mk/clerk-preview][Clerk - Local-First Notebooks for Clojure]] - Martin Kavalar

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/lambdaisland/deja-fu][deja-fu]] - Lightweight ClojureScript local time/date library
- [[https://github.com/babashka/neil][neil]] - A CLI which adds common features to your #clojure deps.edn
  projects.
- [[https://github.com/yetanalytics/lrsql][lrsql]] - A SQL-based Learning Record Store
- [[https://github.com/yetanalytics/colossal-squuid][colossal-squuid]] - Library for generating sequential UUIDs, or
  SQUUIDs
- [[https://github.com/rm-hull/nvd-clojure][nvd-clojure]] [[https://github.com/rm-hull/nvd-clojure/blob/1.7.0/CHANGELOG.md][1.7.0]] - National Vulnerability Database
  dependency-checker plugin for Leiningen
- [[https://github.com/borkdude/sci][sci]] [[https://github.com/borkdude/sci/blob/master/CHANGELOG.md#v027][0.2.7]] - Configurable Clojure interpreter suitable for scripting
  and Clojure DSLs
- [[https://clojure-lsp.io/][clojure-lsp]] 2021.09.30-15.28.01 - A Language Server for
  Clojure(script)
- [[https://calva.io][Calva]] 2.0.214 - Calva is an integrated REPL powered environment for
  enjoyable and productive Clojure and ClojureScript development in
  Visual Studio Code.
- [[https://github.com/sultanov-team/secret-keeper][secret-keeper]] [[https://github.com/sultanov-team/secret-keeper/tree/0.3.61][0.3.61]] - A Clojure(Script) library for keeping your
  secrets under control
- [[https://github.com/borkdude/api-diff][api-diff]] - Compare two mvn libraries or two directories for breaking
  API changes and deprecations.
- [[https://github.com/askonomm/ruuter][ruuter]] - A tiny, zero-dependency HTTP router
- [[https://github.com/liquidz/vim-iced][vim-iced]] 3.7.0 - Clojure Interactive Development Environment for
  Vim8/Neovim
- [[https://github.com/borkdude/deps.clj][deps.clj]] v0.0.19 - A faithful port of the clojure CLI bash script to
  Clojure.
- [[https://github.com/clj-kondo/clj-kondo][clj-kondo]] [[https://github.com/clj-kondo/clj-kondo/blob/master/CHANGELOG.md#20210925][2021.09.25]] - A linter for Clojure code that sparks joy
- [[https://github.com/babashka/babashka][babashka]] [[https://github.com/babashka/babashka/blob/master/CHANGELOG.md#062][0.6.2]] - Native, fast starting Clojure interpreter for
  scripting
- [[https://gitlab.com/domaindrivenarchitecture/c4k-jira][c4k-jira]] - c4k-jira provides a k8s deployment for jira
- [[https://github.com/liquidz/vim-iced][vim-iced]] 3.7.0 - Clojure Interactive Development Environment for
  Vim8/Neovim
- [[https://github.com/seancorfield/next-jdbc][next-jdbc]] 1.2.731 - A modern low-level Clojure wrapper for
  JDBC-based access to databases
- [[https://github.com/seancorfield/honeysql][honeysql]] 2.1.818 - Turn Clojure data structures into SQL

** [2021-10-14] Clojure Deref (Oct 14, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/10/14/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/10/14/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-10-14
:CUSTOM_ID: content/news/2021/10/14/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Videos and podcasts

- [[https://youtu.be/-XegX_K6w-o][Asami: Turn your JSON into a Graph in 2 Lines]] - Paula Gearon, from
  Strange Loop 2021
- [[https://www.youtube.com/watch?v=U-BzDXTTRCo][Compiling Probabilistic Programs with Daphne]] - Christian Weilbach
  from London Clojurians
- [[https://vimeo.com/343941372][Clojure Macros "No more copypasta! Use mac'roni!"]] - Eric Loren

*** Blogs

- [[https://dev.solita.fi/2021/10/14/grokking-clojure-transducers.html][Grokking Clojure transducers]] - Eero Helenius
- [[https://bsless.github.io/fast-and-elegant-clojure/][Fast and Elegant Clojure]] - Ben Sless
- [[https://corfield.org/blog/2021/10/13/deps-edn-monorepo-7/][deps.edn and monorepos VII (Polylith)]] - Sean Corfield
- [[https://thomas-sojka.tech/real-life-use-cases-for-cljs-macros.html][Real-life use cases for CLJS macros]] - Thomas Sojka

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/walmartlabs/lacinia][lacinia]] 1.0 - GraphQL implementation in pure Clojure
- [[https://github.com/walmartlabs/lacinia-pedestal][lacinia-pedestal]] 1.0 - Expose Lacinia GraphQL as Pedestal endpoints
- [[https://gitlab.com/glossa/weave][weave]] 0.1.120 - Clojure data format and tools for weaving documents
- [[https://github.com/paketo-buildpacks/clojure-tools][clojure-tools]] - A Cloud Native Buildpack that builds Clojure-based
  applications from source
- [[https://github.com/askonomm/shh][shh]] - A CLI password manager designed for efficiency
- [[https://github.com/polyfy/polylith][polylith]] [[https://github.com/polyfy/polylith/releases/tag/v0.2.13-alpha][0.2.13-alpha]] - A tool used to develop Polylith based
  architectures in Clojure
- [[https://gitlab.com/mauricioszabo/clojuby][clojuby]] - Ruby on Clojure
- [[https://github.com/ingesolvoll/glimt][glimt]] - HTTP FSM for re-frame
- [[https://github.com/clj-commons/ordered][ordered]] 1.15.10 - Ordered sets and maps, implemented in pure clojure
- [[https://github.com/clojure/tools.build][tools.build]] v0.6.2 - Library of functions for building Clojure projects
- [[https://github.com/clojure/tools.deps.alpha][tools.deps.alpha]] 0.12.1053 - Dependency resolution and classpaths
- [[https://github.com/clj-commons/rewrite-clj][rewrite-clj]] [[https://github.com/clj-commons/rewrite-clj/blob/main/CHANGELOG.adoc#v10699-alpha][1.0.699-alpha]] - Rewrite Clojure code and edn
- [[https://github.com/johanthoren/bibcal][bibcal]] [[https://github.com/johanthoren/bibcal/releases/tag/1.0.0][1.0.0]] - Calculate dates based on the Bible and the 1st Book
  of Enoch
- [[https://calva.io][Calva]] 2.0.16 - Calva is an integrated REPL powered environment for
  enjoyable and productive Clojure and ClojureScript development in
  Visual Studio Code.
- [[https://github.com/ingesolvoll/kee-frame][kee-frame]] 1.2.0 - re-frame with batteries included
- [[https://github.com/seancorfield/build-clj][build-clj]] 0.5.2 - Common build tasks abstracted into a library.
- [[https://github.com/clj-commons/digest][digest]] [[https://cljdoc.org/d/org.clj-commons/digest/1.4.93/api/clj-commons.digest][1.4.93]] - Digest algorithms (md5, sha1 ...​) for Clojure

*** Art

Once again, some really nice work from Jack Rusher - [[https://twitter.com/jackrusher/status/1447950443137613828][this tweet]]
highlights a nice function and the Clojure code that made it, and [[https://twitter.com/jackrusher/status/1447879286262743040][this
tweet]] credits [[https://thi.ng][Karsten Schmidt's]] excellent thi.ng geom libraries! We
are fortunate to have such great tools to work with in Clojure.

** [2021-10-22] Clojure Deref (Oct 22, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/10/22/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/10/22/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-10-22
:CUSTOM_ID: content/news/2021/10/22/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

The Clojure community has a long and friendly relationship with our
cousins in the Racket/Scheme community and we've often had speakers at
Clojure conference from that world. I wanted to call your attention to
the recent Strange Loop keynote from Will Byrd, [[https://www.youtube.com/watch?v=AffW-7ika0E]["Strange Dreams of
Stranger Loops"]] which takes his prior investigations into generating
quines (programs that produce themselves) with miniKanren into further
territories of twines (twin quines) and quine relays and many other
interesting digressions.

Near the end of the talk, Will announced two "competitions", each for
$1000, the [[http://webyrd.net/quips.html][QuiPS Prize]] for the best "small" strange loop along the
order of quines and quine relays, self-reproducing behavior, and the
[[http://webyrd.net/mant.html][Mant Prize]] - for the best "large" strange loop, and you'll need to
watch the video to get the full sense of the intent here. I've linked
his pages for these prizes, which are as yet unpublished. Feel free to
pester [[https://twitter.com/webyrd][Will]] to fill those out more completely. :)

I'm highlighting these here both to give them some more circulation and
because I think there are many smart and curious minds in the Clojure
community that would enjoy working on things like this to spur the Quine
Industrial Complex.

*** In the core

Lots of things in mid-flight right now, some getting near the "done"
end. [[https://clojure.atlassian.net/browse/CLJ-2664][CLJ-2664]] is a new Clojure namespace clojure.java.math wrapping
java.lang.Math. There are a couple related pieces of work for adding
numeric parsing functions and uuid constructors. All of those are
coming out of a survey of which JDK static methods were in common use
and trying to cover a bit more of that surface area in the Clojure API
directly. All of that is 1.11 scope. Additionally, I think we're near
the end of the spec updates for trailing map support, which is being
done in [[https://clojure.atlassian.net/browse/CLJ-2606][CLJ-2606]] and that will end up in new versions of spec (both
old and new). You can also find a variety of other tickets ready for
Rich's review in the [[https://clojure.atlassian.net/issues/?filter=10010][Screened]] list (see [[https://clojure.org/dev/workflow][workflow]] page for more
details).

In addition to all that, we've been doing a lot of thinking and planning
for future directions of the Clojure team, nothing I can share on that
right now but it's been fun to talk about ways we can grow.

*** Videos and podcasts

- [[https://clojurescriptpodcast.com/][ClojureScript podcast]] - OSS with Michiel Borkent
- [[https://soundcloud.com/defn-771544745/77-michelle-lim][defn podcast]] - Michelle Lim (and some special guests!)
- [[https://pod.link/1471141263/episode/10a363f4e62eb8ca37120468d752c99b][re:Clojure Interviews 1]] - Jeremy Taylor, product lead XTDB
- [[https://pod.link/1471141263/episode/6c1b3b75294f84291809fa01595dbcf4][re:Clojure Interviews 2]] - Alex Oloo, Head of Design ABSA Bank
- [[https://www.youtube.com/watch?v=Rdk5r1bjBoc][Clojure REPLs Deep Dive]] - Nikita Prokopov
- [[https://www.youtube.com/watch?v=4UvT0yqBDw8][How to hack on clojure-lsp the Clojure Way]] - Peter Strömberg

*** Blogs

- [[https://javahippie.net/clojure/2021/10/18/finding-my-inner-wes-anderson.html][Finding my inner Wes Anderson with Babashka]] - Tim Zöller
- [[https://www.juxt.pro/blog/clojurescript-app-performance][Speed up your ClojureScript Webapp]] - Lucio D'Alessandro

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/IGJoshua/coffi][coffi]] 0.2.259 - A Foreign Function Interface in Clojure for JDK 17
- [[https://github.com/logicblocks/salutem][salutem]] - A health check library for sync / async health checks
- [[https://github.com/clj-kondo/clj-kondo][clj-kondo]] [[https://github.com/clj-kondo/clj-kondo/blob/master/CHANGELOG.md#20211019][2021.10.19]] - A linter for Clojure code that sparks joy
- [[https://github.com/phronmophobic/clj-media][clj-media]] - View or create videos and gifs with clojure
- [[https://github.com/fluent-development/heroicons-clojure][heroicons-clojure]] - heroicons for Fulcro and Reagent
- [[https://github.com/tatut/xtdb-inspector][xtdb-inspector]] - Web UI for inspecting XTDB database
- [[https://github.com/askonomm/shh][shh]] 2021.10.20 - A CLI password manager designed for efficiency
- [[https://clojure-lsp.io/][clojure-lsp]] [[https://clojure-lsp.io/CHANGELOG/#20211020-164947][20211020-164947]] - A Language Server for Clojure(script)
- [[https://github.com/borkdude/nbb][nbb]] v0.0.107 - Ad-hoc CLJS scripting on Node.js
- [[https://github.com/dainiusjocas/clj-jq][clj-jq]] [[https://github.com/dainiusjocas/clj-jq/releases/tag/v1.1.3][1.1.3]] - Clojure wrapper for jackson-jq
- [[https://calva.io][Calva]] 2.0.220 - Calva is an integrated REPL powered environment for
  enjoyable and productive Clojure and ClojureScript development in
  Visual Studio Code
- [[https://github.com/wilkerlucio/pathom3][pathom3]] 2021.07.10-alpha - A library for navigating data
- [[https://github.com/AbhinavOmprakash/luna][luna]] 0.1.0-SNAPSHOT - A Domain Specific Language (DSL) that
  translates to regex.Pattern
- [[https://github.com/cognitect-labs/aws-api][aws-api]] - AWS, data driven
- [[https://github.com/clojure/java.data][java.data]] 1.0.92 - Functions for recursively converting Java beans
  to Clojure and vice versa
- [[https://github.com/oliyh/re-graph][re-graph]] 0.1.16 - A graphql client for clojurescript and clojure
- [[https://github.com/ingesolvoll/glimt][glimt]] 0.2.1 - HTTP FSM for re-frame

** [2021-10-29] Clojure Deref (Oct 29, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/10/29/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/10/29/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-10-29
:CUSTOM_ID: content/news/2021/10/29/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

Looks like [[https://www.reclojure.org/][re:Clojure]] on Dec 3-4 is shaping up to be a great online
event! Keynotes will be Gerald Sussman and Stephen Wolfram and other
speakers being announced, so keep that on your calendar!

*** In the core

Have you ever worked on one thing that highlighted another problem, and
then you started working on that, and then that highlighted another
problem? Well, it was that kind of week. I'm not ready to talk about all
that stuff yet, maybe next week.

In our overall ticket [[https://clojure.org/dev/workflow][workflow]], "vetting" is the step where Rich
agrees something is worth working on, "release assignment" is where we
decide something is in scope for the current release, and "screening"
is where someone on the core team (usually me or Fogus, occasionally
others) believes a patch is ready for Rich's final review. We've been
trying to surface a list of new tickets for Rich to vet about once a
month, and that's pulled from what we are seeing out in the community,
looking at votes on ask.clojure, and our own sense of what's
important.

One ticket that Rich reviewed and ok'ed from the [[https://clojure.atlassian.net/issues/?filter=10010][Screened]] list this
week was [[https://clojure.atlassian.net/browse/CLJ-2065][CLJ-2065]] "reduce-kv fails on subvec", an old and annoying
issue. Feel free to look at these various queues to see what's in
process, but keep in mind that things move both forward AND backward
through these queues based on review!

*** Videos and podcasts

- [[https://www.youtube.com/watch?v=L0af0bc5Jec][RCF TDD usage]]
- [[https://thattech.show/episodes/37-zombies-emacs-and-getting-clojure-with-magnar-sveen][That Tech Show]] - Zombies, Emacs and Getting Clojure with Magnar
  Sveen
- [[https://clojurescriptpodcast.com/][ClojureScript podcast]] - Eric Dallo
- [[https://open.spotify.com/episode/7xphsYemKzUfMihjcLleRR][re:Clojure Interviews 3]] - Jakub Holy, Clojure(Script) developer
- [[https://open.spotify.com/episode/3ALvdU4liAaoRP3DkTskPb][re:Clojure Interviews 4]] - Kathi Fisler, Research Professor of
  Computer Science at Brown University
- [[https://www.youtube.com/watch?v=YaHiff2vZ_o][Data Navigation with Pathom 3]] - Wilker Lucio from London Clojurians
- [[https://www.youtube.com/watch?v=fJpDztSR53E][Start 3D modeling in Clojure with scad-clj and Calva]] - Peter
  Strömberg
- [[https://www.youtube.com/watch?v=oXU17qZjtWM][Quick Demo: Calva for Clojure GUI app dev in the browser]] - Peter
  Strömberg

*** Blogs

- [[https://www.quantisan.com/orchestrating-pizza-making-a-tutorial-for-aws-step-functions-with-stepwise/][Orchestrating Pizza-Making: A Tutorial for AWS Step Functions with
  Stepwise]] - Paul Lam
- [[https://lambdaland.org/posts/2021-09-25_models_of_programming_draft2/][Models of Programming]] - Ashton Wiersdorf
- [[https://gist.github.com/didibus/6e5ff960b25fdc1a5f8f97acede614b0][When is Clojure "the right tool for the job"?]] - didibus

*** Bork Watch

Michiel Borkent, the man, the myth, the legend is getting his own
section this week as he attempts to take over the Deref...​.

- [[https://blog.michielborkent.nl/migrating-octopress-to-babashka.html][Replacing my Octopress blog with 200 lines of Babashka]] - Michiel
  Borkent
- [[https://github.com/babashka/babashka][babashka]] [[https://github.com/babashka/babashka/blob/master/CHANGELOG.md#064][0.6.4]] - Native, fast starting Clojure interpreter for
  scripting
- [[https://github.com/borkdude/jet][jet]] [[https://github.com/borkdude/jet/releases/tag/v0.1.0][0.1.0]] - CLI to transform between JSON, EDN and Transit, powered
  with a minimal query language.
- [[https://github.com/borkdude/deps.clj][deps.clj]] [[https://github.com/borkdude/deps.clj/blob/master/CHANGELOG.md#v0020][0.0.20]] - A faithful port of the clojure CLI bash script to
  Clojure. Used as native CLI, deps resolver in babashka and getting
  started REPL in Calva
- [[https://github.com/borkdude/rewrite-edn][rewrite-edn]] 0.1.0 - Utility lib on top of rewrite-clj with common
  operations to update EDN while preserving whitespace and comments

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/lucywang000/clj-statecharts][clj-statecharts]] 0.1.1 - State Machine and StateCharts for
  Clojure(Script)
- [[https://vlaaad.github.io/reveal-pro][Reveal Pro]] 1.3.265 - Reveal is a Read Eval Visualize Loop for
  Clojure
- [[https://clojure.org/reference/deps_and_cli][Clojure CLI]] [[https://clojure.org/releases/tools#v1.10.3.998][1.10.3.998]] - Clojure CLI
- [[https://github.com/leafclick/pgmig][pgmig]] [[https://github.com/leafclick/pgmig/releases/tag/v0.7.1][0.7.1]] - Standalone PostgreSQL Migration Runner
- [[https://github.com/magnetcoop/esignatures.docusign][esignatures.docusign]] - A Library for interacting with DocuSign
  eSignature API which optionally provides Integrant initialization
  keys for Duct framework.
- [[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor.el]] [[https://metaredux.com/posts/2021/10/26/clj-refactor-3-0.html][3.0]] - A collection of Clojure refactoring functions
  for Emacs
- [[https://github.com/phronmophobic/membrane.term][membrane.term]] - A simple terminal emulator in clojure
- [[https://github.com/tristanstraub/thecreeps-godotclj][Clojure implementation of Godot engine tutorial]]
- [[https://github.com/behrica/opencpu-clj][opencpu-clj]] 0.3.0 - Clojure client for opencpu
- [[https://github.com/AbhinavOmprakash/sisyphus][sisyphus]] 0.1.1 - sisyphus can schedule multiple tasks and will do
  them happily for you
- [[https://calva.io][Calva]] 2.0.222 - Calva is an integrated REPL powered environment for
  enjoyable and productive Clojure and ClojureScript development in
  Visual Studio Code
- [[https://github.com/clj-commons/byte-streams][byte-streams]] 0.2.9 - a rosetta stone for jvm byte representations
- [[https://github.com/IGJoshua/coffi][coffi]] 0.2.277 - A Foreign Function Interface in Clojure for JDK 17

** [2021-11-05] Clojure Deref (Nov 5, 2021)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/news/2021/11/5/deref.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/news/2021/11/5/deref
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2021-11-05
:CUSTOM_ID: content/news/2021/11/5/deref
:END:

Welcome to the Clojure Deref! This is a weekly link/news roundup for
the Clojure ecosystem. ([[https://twitter.com/ClojureDeref][@ClojureDeref]] [[https://clojure.org/feed.xml][RSS]])

*** Highlights

This week brings a new version of [[https://github.com/clojure/clojurescript][ClojureScript]] - read the release
notes for [[https://clojurescript.org/news/2021-11-04-release][ClojureScript 1.10.891]]!

*** Videos and podcasts

- [[https://anchor.fm/lostinlambduhhs/episodes/ericnormand-e19f4j7][Lost in Lambduhhs podcast]] - Eric Normand
- [[https://lispcast.com/what-is-domain-modeling/][What is domain modeling?]] - Eric Normand
- [[https://www.youtube.com/watch?v=a4sm_B_mqhs][ClojureDocs Rich Comments Surfing in Calva]] - Peter Strömberg
- [[https://www.youtube.com/watch?v=TaazvSJvBaw][Clojure Transducers from the ground up]] - Fred Overflow

*** Blogs

- [[https://blogit.michelin.io/clojure-programming/][Bringing Clojure programming to Enterprise]] - Fabien Alberi
- [[https://lambdaisland.com/blog/2021-11-03-making-nrepl-cider-more-dynamic-1][Making nREPL and CIDER More Dynamic (part 1)]] - Arne Brasseur
- [[https://metaredux.com/posts/2021/11/02/everything-is-wrong.html][Everything is Wrong]] - Bozhidar Batsov
- [[https://www.slideshare.net/pjschwarz/the-functional-programming-triad-of-map-filter-and-fold][The Functional Programming Triad of Map, Filter and Fold]] - Philip
  Schwarz
- [[https://blog.michielborkent.nl/better-clojure-highlighting.html][Better Clojure highlighting with nextjournal/clojure-mode]] - Michiel
  Borkent

*** Libraries and Tools

New releases and tools this week:

- [[https://github.com/nextjournal/clerk][clerk]] - Local-First Notebooks for Clojure
- [[https://github.com/clojure/core.async][core.async]] 1.4.627 - Facilities for async programming and
  communication in Clojure
- [[https://github.com/chr15m/sitefox][sitefox]] 0.0.2 - Node + cljs backend web framework
- [[https://github.com/hyperfiddle/rcf][rcf]] - RCF -- a REPL-first, async test macro for Clojure/Script
- [[https://github.com/m1kal/charbel][charbel]] - Write synthesizable FPGA code with Clojure syntax
- [[https://github.com/mcorbin/mirabelle][mirabelle]] [[https://www.mirabelle.mcorbin.fr/changelog/#v070][0.7.0]] - A stream processing engine for monitoring
- [[https://github.com/IGJoshua/farolero][farolero]] 1.4.0 - Thread-safe Common Lisp style conditions and
  restarts for Clojure(Script)
- [[https://github.com/pfeodrippe/recife][recife]] [[https://github.com/pfeodrippe/recife/commit/09e11f2f172b684af466c645208adf7f2ebc0654][0.4.0]] - A Clojure model checker
- [[https://github.com/scicloj/sklearn-clj][sklearn-clj]] 0.3.6 - Use sklearn estimators from Clojure
- [[https://github.com/exoscale/deps-modules][deps-modules]] - Multi-module projects with deps.edn
- [[https://github.com/scicloj/scicloj.ml][scicloj.ml]] 0.1.1 - A Clojure machine learning library
- [[https://clojure-lsp.io/][clojure-lsp]] [[https://github.com/clojure-lsp/clojure-lsp/releases/tag/2021.11.02-15.24.47][2021.11.02-15.24.47]] - A Language Server for
  Clojure(script).
- [[https://calva.io][Calva]] [[https://github.com/BetterThanTomorrow/calva/releases/tag/v2.0.223][2.0.223]] - Calva is an integrated REPL powered environment for
  enjoyable and productive Clojure and ClojureScript development in
  Visual Studio Code
- [[https://github.com/FieryCod/holy-lambda-ring-adapter][holy-lambda-ring-adapter]] 0.1.0 - An adapter between Ring core
  request/response model and Holy Lambda
- [[https://github.com/lispyclouds/contajners][contajners]] 0.0.2 - An idiomatic, data-driven, REPL friendly clojure
  client for OCI container engines
- [[https://github.com/weavejester/ragtime][ragtime]] 0.9.0 - Database-independent migration library
- [[https://github.com/vharmain/nbb-lambda-adapter][nbb-lambda-adapter]] - NPM package to enable running Clojurescript
  code on AWS Lambda NodeJS runtime
- [[https://github.com/helins/binf.cljc][binf.cljc]] 1.1.0 - Handling binary formats in all shapes and forms
- [[https://github.com/FieryCod/holy-lambda][holy-lambda]] 0.6.2 - The extraordinary simple, performant, and
  extensible custom AWS Lambda runtime for Clojure
- [[https://github.com/clj-commons/aleph][aleph]] 0.4.7-alpha10 - asynchronous communication for clojure
- [[https://github.com/clj-commons/byte-streams][byte-streams]] 0.2.10 - A Rosetta stone for JVM byte representations

* Privacy
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/privacy.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/privacy
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2021-08-25
:CUSTOM_ID: content/privacy
:END:
** PRIVACY POLICY

Cognitect, Inc. ("*Cognitect,*" "*we,*" or "*us*") provides the website
located at www.clojure.org (the "*Website*"). We value and respect your
privacy. This "*Privacy Policy*" demonstrates our commitment to your
right of privacy and explains how we use, disclose and protect the
Personal Information (as defined below) of users ("*you,*" "*User,*" or
"*your*") of the Website. By visiting the Website, you expressly consent
to the use and disclosure of your Personal Information as described
below. If you do not agree with the terms set out in this Privacy
Policy, please do not visit the Website.

** WHAT INFORMATION DO WE COLLECT?

Personal information is data that can be used to identify or contact a
single person ("*Personal Information*"). We generally collect or
receive Personal Information when you visit the ask.clojure.org domain
on the Website in the following ways: - when you voluntarily provide
information to us, such as when you post questions, answers, or content
on our forum or knowledgebase, or contact us; - we collect information
automatically through use of our Website; and - other parties, such as
GitHub, may provide information to us or grant us access to information
which can be reasonably linked to you.

Each of these methods is described in more detail below: - Information
You Voluntarily Choose to Provide - The Personal Information we collect
from you will vary depending on the services you are using, parts of the
Website you are visiting, and how you access those services and/or
Website. The Personal Information you provide to us may include any
information you submit to us through email and post on our knowledgebase
and forum. - You agree not to submit information that contain or
reference, and understand and agree we have no obligations or liability
with respect to: (i) information that can identify an individual in
relation to any past, present, or future physical or mental health or
condition, provision of health care, or payment for the provision of
health care, including, but not limited to, diagnoses, treatment
information, medical test results, and prescription information; and/or
(ii) an individual's race, ethnic origin, political opinions, religious
or philosophical beliefs, genetic data, biometric data, sex life or
sexual orientation. Without limiting the generality of the foregoing,
you acknowledge in no event will Cognitect be liable to you or any third
party for any direct, indirect, incidental, lost profits, remote, cover,
exemplary, consequential, special, or punitive damages, regardless of
the foreseeability of such damages resulting from your submission of any
such information. - Information Collected Automatically When You Use the
Website Like most websites, we collect basic web traffic information
(such as IP addresses) to monitor overall usage of our Website,
understand Website traffic patterns, and identify if there are problems
on the Website. - Information We Receive from Others In some cases,
other parties provide us with Personal Information about you, or allow
us to collect Personal Information about you. Although we cannot control
your privacy settings at those websites or how those other parties
protect your privacy, once we receive information about you through
those websites, we will treat it in accordance with this Privacy Policy.
- You may also be able to link an account from third-party websites,
such as GitHub, to our Website. This may allow you to use your
credentials from the other site or service to sign in to certain
features on our Website. If you link your account from a third-party
site or service, we may collect information from those third-party
accounts, and any information that we collect will be governed by this
Privacy Policy.

** HOW DO WE USE YOUR PERSONAL INFORMATION?

We use your Personal Information: - to provide the services or
information you request; - to develop, deliver, and improve our
services, user experience and other offerings; - to communicate with you
regarding your use of the Website and/or Product; - to measure the
effectiveness of our content; - to monitor performance of the Websites;
- to monitor and moderate online community interactions on the Website
(for example, questions, answers and posts on our knowledgebase and
forum); - to protect our rights and the rights of our Website visitors;
- to protect the vital interests of the Company, you, or our other
Website visitors (for example, in the event of an emergency); and - for
internal auditing purposes. We also collect information in an aggregated
form that does not, on its own, permit direct association with any
specific individual. We may collect, use, transfer, and disclose
aggregated or otherwise non-personal information for any purpose.

** HOW DO WE USE COOKIES?

We do not use cookies on the Website.

** WHEN MAY A THIRD PARTY RECEIVE ACCESS TO YOUR PERSONAL INFORMATION?

Cognitect will not disclose your Personal Information to any third
parties except: - to our professional advisers, accountants, insurers,
lawyers and auditors on a confidential basis; - if Cognitect or its
assets are or may be acquired by a third party, the information may be
provided to that third party and its advisors; - in exceptional
circumstances, Cognitect may be required or permitted by law to disclose
Personal Information, for example where such disclosure is necessary to
meet any applicable law, regulation, legal process or other legal
obligation; detect, investigate and help prevent security, fraud or
technical issues; and/or protect the rights, property or safety of
Cognitect, our employees or other users of the Website.; or - otherwise
with your consent.

Cognitect does not sell your Personal Information.

Cognitect may disclose your Personal Information to Cognitect's parent
company, affiliated legal entities, subsidiaries and any other
businesses with whom we are under common corporate control (collectively
the "*Affiliates*"). All of our Affiliates that receive your information
from us will comply with the terms of this Privacy Policy with respect
to their use and disclosure of such information.

** HOW DOES COGNITECT KEEP YOUR INFORMATION SECURE?

Cognitect is committed to keeping your information secure. We endeavor
to take all reasonable steps to keep secure any information that we hold
about you, and to keep this information accurate and up to date. Your
information is stored on secure servers that are protected in controlled
facilities. Other than the sharing of information outlined in this
Privacy Policy, personally identifiable information is not accessible by
the public, and we require our employees and data processors to respect
the confidentiality of any Personal Information. Any personally
identifiable information on user profiles is private.

** CHILDREN'S PRIVACY

We do not direct our Website to children (usually considered to be under
the age of 13, depending on the country where you reside). We also do
not intentionally collect Personal Information from children through our
Website. If you are the parent or guardian of a child and you believe
that we have inadvertently received Personal Information about that
child, please contact us as described in the Contact Us section of this
Privacy Policy and we will take reasonable steps to remove the
information from our records.

** GAINING ACCESS TO, UPDATING DELETING YOUR INFORMATION OR WITHDRAWING
CONSENT

If at any time you want to request, update, correct or remove Personal
Information, you are welcome to submit a request to
[[mailto:support@cognitect.com][support@cognitect.com]]. We may ask you to verify your identity before
we can act on your request. If you are aware of changes or
inaccuracies in your Personal Information, you should inform us of
such changes so that our records may be updated or corrected.

We may reject requests that are unreasonably repetitive, require
disproportionate technical effort (for example, developing a new system
or fundamentally changing an existing practice), risk the privacy of
others, or would be extremely impractical (for instance, requests
concerning information residing on backup systems).

Where we can provide information access and correction, we will do so,
except where it would require a disproportionate effort. We aim to
maintain our services in a manner that protects information from
accidental or malicious destruction. Because of this, after you delete
information from our services, we may not immediately delete residual
copies from our active servers and may not remove information from our
backup systems.

Where consent is required for our use of your Personal Information as
described herein, you have the right to withdraw or decline your consent
and cease your use of the Website. If you decide to withdraw your
consent, such withdrawal will not affect the lawfulness of processing
based on consent before such withdrawal.

** CALIFORNIA PRIVACY RIGHTS

California Civil Code Sec. 1798.100, et seq. (also known as the
California Consumer Privacy Act of 2018) ("*CCPA*") provides certain
rights to California residents regarding their Personal Information. A
California resident has the right to request that we disclose certain
information, including: (1) the categories of Personal Information we
have collected about that California resident, (2) the categories of
sources from which the Personal Information is collected, (3) the
business or commercial purpose for collecting or selling the Personal
Information, (4) the categories of third parties with whom Cognitect
shares Personal Information, and (5) the specific pieces of Personal
Information we have collected about the resident. A California resident
has the right to request that we delete his/her Personal Information.
Finally, a California resident has the right not to be discriminated
against for exercising his/her privacy rights under the CCPA. You can
request such Personal Information and change your Personal Information
by emailing us at
[[mailto:support@cognitect.com][support@cognitect.com]].

Pursuant to California Civil Code Section 1789.3, California users are
entitled to the following consumer rights notice: California residents
may reach the Compliant Assistance Unit of the Division of Consumer
Services for the California Department of Consumer Affairs by mail at
1625 North Market Blvd., Sacramento, CA 95834, or by telephone at (916)
445-1254 or (800) 952-5210.

** LINKS TO OTHER WEBSITES

The Website contains links to other websites. These third-party websites
have separate and independent privacy policies. The privacy policies and
applicable terms of use of the third-party websites will govern your
interaction with such third-party websites. We encourage you to review
the privacy policy of linked sites, as Cognitect is not responsible or
liable for the practices, content, and/or privacy policies of those
third-party websites. Nonetheless, we seek to protect the integrity of
our Website and welcome any feedback about these third-party websites.

** DATA RETENTION

We will retain your Personal Information only for as long as reasonably
necessary for the purposes set out above, considering criteria such as
applicable rules on statute of limitations, legal requirements and the
duration of your use of the Website and receipt of our services.

** INTERNATIONAL USERS & USERS FROM THE EUROPEAN UNION

This section of the Privacy Policy applies only if you use the Website
or services covered by this Privacy Policy from a country that is a
Member State of the European Union and supplements the information in
this Privacy Policy.

We process information defined as personal data under applicable data
protection law ("*Personal Data*") for the purposes set out in this
Privacy Policy, as described above. - Legal Basis for Processing
Personal Data: Our legal basis to process Personal Data, such as for
the purposes listed above in the "How Do We Use Your Personal
Information?"  section, includes processing that is: - necessary to
comply with legal requirements (for example, to comply with applicable
accounting rules and to make mandatory disclosures to law
enforcement); - protection of the vital interests of a natural person
(for example, in the event of an emergency); - necessary for our
legitimate interests (for example, to manage our relationship with you
and to improve the Website and our services); and - based on your
consent (for example, to communicate with you about the Website and
services), which may subsequently be withdrawn at any time (by
contacting us at [[mailto:support@cognitect.com][support@cognitect.com]]) without affecting the
lawfulness of processing based on consent before its withdrawal. - In
some instances, you may be required to provide us with Personal Data
for processing as described above, in order for us to be able to
provide you all of our services, and for you to use all the features
of the Website. - Please be aware your Personal Data may be collected,
managed, transferred to, processed, and stored or accessed in a
country different other than your country of residence. In addition,
we may make other disclosures of your Personal Data outside of your
country of residence, for example, in the event we receive a legal or
regulatory request from a foreign law enforcement body. We will always
take steps designed to ensure any transfer of such information outside
your country of residence is carefully managed to protect your rights
and interests by implementing appropriate safeguards to protect your
Personal Data. Data protection laws in any such country may be
different from those laws of your country of residence. By visiting
the Website and accepting this Privacy Policy, you consent to the
transfer of your information, including Personal Data, to such
country(ies) as set forth in this Privacy Policy.

- From time to time, Personal Information we collect from data subjects
  in the European Economic Area or Switzerland ("EEA or Switzerland")
  may be transferred to, stored, processed or accessed by us outside of
  the EEA or Switzerland, for example, the United States. We will
  always take steps to ensure any transfer of such information outside
  the EEA or Switzerland is carefully managed to protect your rights
  and interests by implementing appropriate safeguards to protect your
  Personal Data.
- If you would like to find out more about these safeguards in respect
  of processing your Personal Data and the means by which you can
  obtain a copy of them, please contact us at
  [[mailto:support@cognitect.com][support@cognitect.com]].
- Your Rights: In addition to the rights to access, amend or delete
  your Personal Data as set out above, you may be entitled, in
  accordance with applicable law, to object to or request the
  restriction of processing of your Personal Data, and to request
  portability of your own Personal Data. Requests should be submitted
  to [[mailto:support@cognitect.com][support@cognitect.com]].
- If you consider that our processing of your Personal Data infringes
  applicable law, you may lodge a complaint with a competent
  supervisory authority, which may be the authority in your Member
  State of residence or work.

** FUTURE REVISIONS

Cognitect's Website and activities may continue to grow and change.
Because of this, from time to time, our Privacy Policy will be reviewed
and revised. You should check this page occasionally to ensure you are
familiar with those changes. Whenever we change our Privacy Policy we
will post an updated version on our Website, including the last date of
revision.

This Privacy Policy was last revised on August 25, 2021.

** CONTACT US

If you have any questions about how we handle your Personal
Information and protect your privacy, please feel free to contact us
at [[mailto:support@cognitect.com][support@cognitect.com]] or call us at 919.283.2748. You may also mail
requests to:

Cognitect

101 W. Chapel Hill Street., Suite 300

Durham, NC 27701

USA

* Reference
** The Reader
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/reader.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/reader
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-02-15
:NEXTPAGE_CUSTOM_ID: content/reference/repl_and_main
:CUSTOM_ID: content/reference/reader
:END:

Clojure is a [[https://en.wikipedia.org/wiki/Homoiconicity][homoiconic]] language, which is a fancy term describing the
fact that Clojure programs are represented by Clojure data
structures. This is a very important difference between Clojure (and
Common Lisp) and most other programming languages - Clojure is defined
in terms of the evaluation of data structures and *not* in terms of the
syntax of character streams/files. It is quite common, and easy, for
Clojure programs to manipulate, transform and produce other Clojure
programs.

That said, most Clojure programs begin life as text files, and it is the
task of the /reader/ to parse the text and produce the data structure
the compiler will see. This is not merely a phase of the compiler. The
reader, and the Clojure data representations, have utility on their own
in many of the same contexts one might use XML or JSON etc.

One might say the reader has syntax defined in terms of characters,
and the Clojure language has syntax defined in terms of symbols,
lists, vectors, maps etc. The reader is represented by the function
[[clojure:core.clj::(defn
read][read]], which reads the next form (not character) from a stream, and
returns the object represented by that form.

Since we have to start somewhere, this reference starts where evaluation
starts, with the reader forms. This will inevitably entail talking about
data structures whose descriptive details, and interpretation by the
compiler, will follow.

*** Reader forms
**** Symbols

- Symbols begin with a non-numeric character and can contain
  alphanumeric characters and *, +, !, -, _, ', ?, <, > and = (other
  characters may be allowed eventually).
- '/' has special meaning, it can be used once in the middle of a
  symbol to separate the namespace from the name, e.g.
  ~my-namespace/foo~. '/' by itself names the division function.
- '.' has special meaning - it can be used one or more times in the
  middle of a symbol to designate a fully-qualified class name, e.g.
  ~java.util.BitSet~, or in namespace names. Symbols beginning or
  ending with '.' are reserved by Clojure. Symbols containing / or .
  are said to be 'qualified'.
- Symbols beginning or ending with ':' are reserved by Clojure. A
  symbol can contain one or more non-repeating ':'s.

**** Literals
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#literals
:END:

- Strings - Enclosed in "double quotes". May span multiple lines.
  Standard Java escape characters are supported.
- Numbers - generally represented as per Java
  - Integers can be indefinitely long and will be read as Longs when
    in range and clojure.lang.BigInts otherwise. Integers with an N
    suffix are always read as BigInts. Octal notation is allowed with
    a ~0~ prefix, and hexadecimal notation is allowed with a ~0x~
    prefix. When possible, they can be specified in any base with
    radix from 2 to 36 (see
    [[https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#parseLong(java.lang.String,%20int)][Long.parseLong()]]);
    for example ~2r101010~, ~052~, ~8r52~, ~0x2a~, ~36r16~, and ~42~
    are all the same Long.
  - Floating point numbers are read as Doubles; with M suffix they are
    read as BigDecimals.
  - Ratios are supported, e.g. ~22/7~.
- Characters - preceded by a backslash: ~\c~. ~\newline~, ~\space~,
  ~\tab~, ~\formfeed~, ~\backspace~, and ~\return~ yield the
  corresponding characters. Unicode characters are represented with
  ~\uNNNN~ as in Java. Octals are represented with ~\oNNN~.
- ~nil~ Means 'nothing/no-value'- represents Java null and tests
  logical false
- Booleans - ~true~ and ~false~
- Symbolic values - ~##Inf~, ~##-Inf~, and ~##NaN~
- Keywords - Keywords are like symbols, except:
  - They can and must begin with a colon, e.g. :fred.
  - They cannot contain '.' in the name part, or name classes.
  - Like symbols, they can contain a namespace, ~:person/name~, which
    may contain '.'s.
  - A keyword that begins with two colons is auto-resolved in the
    current namespace to a qualified keyword:
    - If the keyword is unqualified, the namespace will be the
      current namespace. In ~user~, ~::rect~ is read as ~:user/rect~.
    - If the keyword is qualified, the namespace will be resolved
      using aliases in the current namespace. In a namespace where
      ~x~ is aliased to ~example~, ~::x/foo~ resolves to
      ~:example/foo~.

**** Lists

Lists are zero or more forms enclosed in parentheses: ~(a b c)~

**** Vectors

Vectors are zero or more forms enclosed in square brackets: ~[1 2 3]~

**** Maps

- Maps are zero or more key/value pairs enclosed in braces:
  ~{:a 1 :b 2}~
- Commas are considered whitespace, and can be used to organize the
  pairs: ~{:a 1, :b 2}~
- Keys and values can be any forms.

***** Map namespace syntax
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#map-namespace-syntax
:END:

/Added in Clojure 1.9/

Map literals can optionally specify a default namespace context for keys
in the map using a ~#:ns~ prefix, where /ns/ is the name of a namespace
and the prefix precedes the opening brace ~{~ of the map. Additionally,
~#::~ can be used to auto-resolve namespaces with the same semantics as
auto-resolved keywords.

A map literal with namespace syntax is read with the following
differences from a map without:

- Keys
  - Keys that are keywords or symbols without a namespace are read
    with the default namespace.
  - Keys that are keywords or symbols with a namespace are not
    affected *except* for the special namespace ~_~, which is removed
    during read. This allows for the specification of keywords or
    symbols without namespaces as keys in a map literal with namespace
    syntax.
  - Keys that are not symbols or keywords are not affected.
- Values
  - Values are not affected.
  - Nested map literal keys are not affected.

For example, the following map literal with namespace syntax:

#+BEGIN_SRC clojure
#:person{:first "Han"
         :last "Solo"
         :ship #:ship{:name "Millennium Falcon"
                      :model "YT-1300f light freighter"}}
#+END_SRC

is read as:

#+BEGIN_SRC clojure
{:person/first "Han"
 :person/last "Solo"
 :person/ship {:ship/name "Millennium Falcon"
               :ship/model "YT-1300f light freighter"}}
#+END_SRC

**** Sets

Sets are zero or more forms enclosed in braces preceded by ~#~:
~#{:a :b :c}~

**** deftype, defrecord, and constructor calls (version 1.3 and later):

- Calls to Java class, deftype, and defrecord constructors can be
  called using their fully qualified class name preceded by # and
  followed by a vector: ~#my.klass_or_type_or_record[:a :b :c]~
- The elements in the vector part are passed *unevaluated* to the
  relevant constructor. defrecord instances can also be created with a
  similar form that takes a map instead: ~#my.record{:a 1, :b 2}~
- The keyed values in the map are assigned *unevaluated* to the
  relevant fields in the defrecord. Any defrecord fields without
  corresponding entries in the literal map are assigned nil as their
  value. Any extra keyed values in the map literal are added to the
  resulting defrecord instance.

*** Macro characters
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#macro-characters
:END:

The behavior of the reader is driven by a combination of built-in
constructs and an extension system called the read table. Entries in the
read table provide mappings from certain characters, called macro
characters, to specific reading behavior, called reader macros. Unless
indicated otherwise, macro characters cannot be used in user symbols.

**** Quote (')
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#quote
:END:

~'form~ ⇒ ~(quote form)~

**** Character (\)

As per above, yields a character literal. Example character literals
are: ~\a \b \c~.

The following special character literals can be used for common
characters: ~\newline~, ~\space~, ~\tab~, ~\formfeed~, ~\backspace~, and
~\return~.

Unicode support follows Java conventions with support corresponding to
the underlying Java version. A Unicode literal is of the form ~\uNNNN~,
for example ~\u03A9~ is the literal for Ω.

**** Comment (;)

Single-line comment, causes the reader to ignore everything from the
semicolon to the end-of-line.

**** Deref (@)

~@form ⇒ (deref form)~

**** Metadata (\^)
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#metadata
:END:

Metadata is a map associated with some kinds of objects: Symbols, Lists,
Vector, Sets, Maps, tagged literals returning an IMeta, and record,
type, and constructor calls. The metadata reader macro first reads the
metadata and attaches it to the next form read (see
[[clojure:core.clj::with-meta (fn ^:static with-meta][with-meta]]
to attach meta to an object):

~^{:a 1 :b 2} [1 2 3]~ yields the vector ~[1 2 3]~ with a metadata map
of ~{:a 1 :b 2}~.

A shorthand version allows the metadata to be a simple symbol or string,
in which case it is treated as a single entry map with a key of :tag and
a value of the (resolved) symbol or string, e.g.:

~^String x~ is the same as ~^{:tag java.lang.String} x~

Such tags can be used to convey type information to the compiler.

Another shorthand version allows the metadata to be a keyword, in which
case it is treated as a single entry map with a key of the keyword and a
value of true, e.g.:

~^:dynamic x~ is the same as ~^{:dynamic true} x~

Metadata can be chained in which case they are merged from right to
left.

**** Dispatch (#)
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#dispatch
:END:

The dispatch macro causes the reader to use a reader macro from another
table, indexed by the character following

- ~#{}~ - see Sets above
- Regex patterns (~#"pattern"~)
  A regex pattern is read and /compiled at read time/. The resulting
  object is of type java.util.regex.Pattern. Regex strings do not
  follow the same escape character rules as strings. Specifically,
  backslashes in the pattern are treated as themselves (and do not
  need to be escaped with an additional backslash). For example,
  ~(re-pattern "\\s*\\d+")~ can be written more concisely as
  ~#"\s*\d+"~.
- Var-quote (#'):
  ~#'x~ ⇒ ~(var x)~
- Anonymous function literal (#()):
  ~#(…​)~ ⇒ ~(fn [args] (…​))~ where args are determined by the presence of
  argument literals taking the form ~%~, ~%n~ or ~%&~. ~%~ is a synonym for
  ~%1~, ~%n~ designates the nth arg (1-based), and ~%&~ designates a rest
  arg. This is not a replacement for [[clojure:core.clj::fn (fn* fn ][fn]] - idiomatic use would be for
  very short one-off mapping/filter fns and the like. ~#()~ forms cannot
  be nested.
- Ignore next form (~#_~) The form following ~#_~ is completely skipped by
  the reader. (This is a more complete removal than the [[clojure:core.clj::(defmacro comment][comment]] macro
  which yields nil).

**** Syntax-quote (`, note, the "backquote" character), Unquote (~) and Unquote-splicing (~@)
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#syntax-quote
:END:

For all forms other than Symbols, Lists, Vectors, Sets and Maps, ~`x~ is
the same as ~'x~.

For Symbols, syntax-quote /resolves/ the symbol in the current context,
yielding a fully-qualified symbol (i.e. namespace/name or
fully.qualified.Classname). If a symbol is non-namespace-qualified and
ends with '#', it is resolved to a generated symbol with the same name
to which '_' and a unique id have been appended. e.g. x# will resolve
to x_123. All references to that symbol within a syntax-quoted
expression resolve to the same generated symbol.

For Lists/Vectors/Sets/Maps, syntax-quote establishes a template of the
corresponding data structure. Within the template, unqualified forms
behave as if recursively syntax-quoted, but forms can be exempted from
such recursive quoting by qualifying them with unquote or
unquote-splicing, in which case they will be treated as expressions and
be replaced in the template by their value, or sequence of values,
respectively.

For example:

#+BEGIN_SRC clojure
user=> (def x 5)
user=> (def lst '(a b c))
user=> `(fred x ~x lst ~@lst 7 8 :nine)
(user/fred user/x 5 user/lst a b c 7 8 :nine)
#+END_SRC

The read table is currently not accessible to user programs.

*** extensible data notation (edn)

Clojure's reader supports a superset of [[https://github.com/edn-format/edn][extensible data notation
(edn)]].  The edn specification is under active development, and
complements this document by defining a subset of Clojure data syntax
in a language-neutral way.

*** Tagged Literals
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#tagged-literals
:END:

Tagged literals are Clojure's implementation of edn [[https://github.com/edn-format/edn#tagged-elements][tagged elements]].

When Clojure starts, it searches for files named ~data_readers.clj~ or
~data_readers.cljc~ at the root of the classpath. Each such file must
contain a Clojure map of symbols, like this:

#+BEGIN_SRC clojure
{foo/bar my.project.foo/bar
 foo/baz my.project/baz}
#+END_SRC

The key in each pair is a tag that will be recognized by the Clojure
reader. The value in the pair is the fully-qualified name of a
[[#content/reference/vars][Var]] which will be invoked by the reader to parse the
form following the tag. For example, given the ~data_readers.clj~ file
above, the Clojure reader would parse this form:

#+BEGIN_SRC clojure
#foo/bar [1 2 3]
#+END_SRC

by invoking the Var ~#'my.project.foo/bar~ on the vector ~[1 2 3]~. The
data reader function is invoked on the form AFTER it has been read as a
normal Clojure data structure by the reader.

Reader tags without namespace qualifiers are reserved for Clojure.
Default reader tags are defined in [[clojure:core.clj::(def ^{:added "1.4"} default-data-readers][default-data-readers]] but may be
overridden in ~data_readers.clj~ / ~data_readers.cljc~ or by rebinding
[[clojure:core.clj::(def ^{:added "1.4" :dynamic true}
*data-readers*][*data-readers*]].  If no data reader is found for a tag, the function
bound in [[clojure:core.clj::(def ^{:added "1.5" :dynamic true} *default-data-reader-fn*][*default-data-reader-fn*]] will be invoked with the tag and
value to produce a value. If ~default-data-reader-fn~ is nil (the
default), a RuntimeException will be thrown.

If a ~data_readers.cljc~ is provided, it is read with the same semantics
as any other cljc source file with reader conditionals.

**** Built-in tagged literals

Clojure 1.4 introduced the /instant/ and /UUID/ tagged literals.
Instants have the format ~#inst "yyyy-mm-ddThh:mm:ss.fff+hh:mm"~. NOTE:
Some of the elements of this format are optional. See the code for
details. The default reader will parse the supplied string into a
~java.util.Date~ by default. For example:

#+BEGIN_SRC clojure
(def instant #inst "2018-03-28T10:48:00.000")
(= java.util.Date (class instant))
;=> true
#+END_SRC

Since [[clojure:core.clj::(def ^{:added "1.4" :dynamic true} *data-readers*][*data-readers*]] is a dynamic var that can be bound, you can
replace the default reader with a different one. For example,
~clojure.instant/read-instant-calendar~ will parse the literal into a
~java.util.Calendar~, while ~clojure.instant/read-instant-timestamp~ will
parse it into a ~java.util.Timestamp~:

#+BEGIN_SRC clojure
(binding [*data-readers* {'inst read-instant-calendar}]
  (= java.util.Calendar (class (read-string (pr-str instant)))))
;=> true

(binding [*data-readers* {'inst read-instant-timestamp}]
  (= java.util.Timestamp (class (read-string (pr-str instant)))))
;=> true
#+END_SRC

The ~#uuid~ tagged literal will be parsed into a ~java.util.UUID~:

#+BEGIN_SRC clojure
(= java.util.UUID (class (read-string "#uuid \"3b8a31ed-fd89-4f1b-a00f-42e3d60cf5ce\"")))
;=> true
#+END_SRC

**** Default data reader function

If no data reader is found when reading a tagged literal, the
[[clojure:core.clj::(def ^{:added "1.5" :dynamic true}
*default-data-reader-fn*][*default-data-reader-fn*]] is invoked. You can set your own default data
reader function and the provided [[clojure:core.clj::7767][tagged-literal]] function can be used
to build an object that can store an unhandled literal. The object
returned by ~tagged-literal~ supports keyword lookup of the ~:tag~ and
~:form~:

#+BEGIN_SRC clojure
(set! *default-data-reader-fn* tagged-literal)

;; read #object as a generic TaggedLiteral object
(def x #object[clojure.lang.Namespace 0x23bff419 "user"])

[(:tag x) (:form x)]
;=> [object [clojure.lang.Namespace 599782425 "user"]]
#+END_SRC

*** Reader Conditionals
:PROPERTIES:
:CUSTOM_ID: content/reference/reader#reader-conditionals
:END:

Clojure 1.7 introduced a new extension (.cljc) for portable files that
can be loaded by multiple Clojure platforms. The primary mechanism for
managing platform-specific code is to isolate that code into a minimal
set of namespaces, and then provide platform-specific versions
(.clj/.class or .cljs) of those namespaces.

In cases where is not feasible to isolate the varying parts of the code,
or where the code is mostly portable with only small platform-specific
parts, 1.7 also introduced /reader conditionals/, which are supported
only in cljc files and at the default REPL. Reader conditionals should
be used sparingly and only when necessary.

Reader conditionals are a new reader dispatch form starting with ~#?~ or
~#?@~. Both consist of a series of alternating features and expressions,
similar to ~cond~. Every Clojure platform has a well-known "platform
feature" - ~:clj~, ~:cljs~, ~:cljr~. Each condition in a reader
conditional is checked in order until a feature matching the platform
feature is found. The reader conditional will read and return that
feature's expression. The expression on each non-selected branch will be
read but skipped. A well-known ~:default~ feature will always match and
can be used to provide a default. If no branches match, no form will be
read (as if no reader conditional expression was present).

#+BEGIN_QUOTE
*Note*

Implementors of non-official Clojure platforms should use a qualified
keyword for their platform feature to avoid name collisions.
Unqualified platform features are reserved for official platforms.
#+END_QUOTE

The following example will read as Double/NaN in Clojure, js/NaN in
ClojureScript, and nil in any other platform:

#+BEGIN_SRC clojure
#?(:clj     Double/NaN
   :cljs    js/NaN
   :default nil)
#+END_SRC

The syntax for ~#?@~ is exactly the same but the expression is expected
to return a collection that can be spliced into the surrounding context,
similar to unquote-splicing in syntax quote. Use of reader conditional
splicing at the top level is not supported and will throw an exception.
An example:

#+BEGIN_SRC clojure
[1 2 #?@(:clj [3 4] :cljs [5 6])]
;; in clj =>        [1 2 3 4]
;; in cljs =>       [1 2 5 6]
;; anywhere else => [1 2]
#+END_SRC

The [[clojure:core.clj::(defn read][read]] and [[clojure:core.clj::(defn read-string][read-string]] functions optionally take a map of options as
a first argument. The current feature set and reader conditional
behavior can be set in the options map with these keys and values:

#+BEGIN_SRC clojure
:read-cond - :allow to process reader conditionals, or
             :preserve to keep all branches
:features - persistent set of feature keywords that are active
#+END_SRC

An example of how to test ClojureScript reader conditionals from
Clojure:

#+BEGIN_SRC clojure
(read-string
  {:read-cond :allow
   :features #{:cljs}}
  "#?(:cljs :works! :default :boo)")
;; :works!
#+END_SRC

However, note that the Clojure reader will /always/ inject the platform
feature :clj as well. For platform-agnostic reading, see
[[https://github.com/clojure/tools.reader][tools.reader]].

If the reader is invoked with ~{:read-cond :preserve}~, the reader
conditional and non-executed branches will be preserved, as data, in the
returned form. The reader-conditional will be returned as a type that
supports keyword retrieval for keys with ~:form~ and a ~:splicing?~
flag. Read but skipped tagged literals will be returned as a type that
supports keyword retrieval for keys with ~:form~ and ~:tag~ keys.

#+BEGIN_SRC clojure
(read-string
  {:read-cond :preserve}
  "[1 2 #?@(:clj [3 4] :cljs [5 6])]")
;; [1 2 #?@(:clj [3 4] :cljs [5 6])]
#+END_SRC

The following functions can also be used as predicates or constructors
for these types:

[[clojure:core.clj::(defn reader-conditional?][reader-conditional?]], [[clojure:core.clj::7780][reader-conditional]], [[clojure:core.clj::(defn tagged-literal?][tagged-literal?]], [[clojure:core.clj::7767][tagged-literal]].

** The REPL and main entry points
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/repl_and_main.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/repl_and_main
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/reader
:NEXTPAGE_CUSTOM_ID: content/reference/evaluation
:CUSTOM_ID: content/reference/repl_and_main
:END:
*** The clojure.main namespace

The ~clojure.main~ namespace provides functions that allow Clojure
programs and interactive sessions to be launched via Java's application
launcher tool ~java~.

*** clojure.main --help

The ~clojure.main/main~ entry point accepts a variety of arguments and
flags.

- With no options or args, runs an interactive Read-Eval-Print Loop
- init options:
  - -i, --init path Load a file or resource
  - -e, --eval string Evaluate expressions in string; print non-nil
    values
  - --report target Report uncaught exception to "file" (default),
    "stderr", or "none", overrides System property clojure.main.report
    (added in 1.10.1)
- main options:
  - -r, --repl Run a repl
  - path Run a script from a file or resource
  - - Run a script from standard input
  - -m, --main A namespace to find a -main function for execution
  - -h, -?, --help Print this help message and exit
- operation:
  - Establishes thread-local bindings for commonly set!-able vars
  - Enters the user namespace
  - Binds ~*command-line-args*~ to a seq of strings containing command
    line args that appear after any main option
  - Runs all init options in order
  - Runs a repl or script if requested

The init options may be repeated and mixed freely, but must appear
before any main option. The appearance of any eval option before running
a repl suppresses the usual repl greeting message: "Clojure
~(clojure-version)".

Paths may be absolute or relative in the filesystem or relative to
classpath. Classpath-relative paths have prefix of @ or @/

*** Launching a REPL

The simplest way to launch a Clojure /repl/ is to use the [[#content/guides/getting_started][clj]] command
tool, which invokes clojure.main:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.0
user=>
#+END_EXAMPLE

The REPL prompt shows the name of the current namespace (~*ns*~), which
defaults to /user/.

Several special vars are available when using the REPL:

- *1, *2, *3 - hold the result of the last three expressions that were
  evaluated
- *e - holds the result of the last exception.

The [[clojure:repl.clj][clojure.repl]] namespace has a number of useful functions for
inspecting the source and documentation of available functions:

- [[clojure:repl.clj::(defmacro doc][doc]] - prints the docstring for a var given its name
- [[clojure:repl.clj::(defn find-doc][find-doc]] - prints the docstring for any var whose doc or name
  matches the pattern
- [[clojure:repl.clj::(defn apropos][apropos]] - returns a seq of definitions matching a regex
- [[clojure:repl.clj::(defmacro source][source]] - prints the source for a symbol
- [[clojure:repl.clj::(defn pst][pst]] - Print Stack Trace for a given exception or *e by default

*** Launching a Script

To run a file full of Clojure code as a script, pass the path to the
script to ~clojure.main~ as an argument:

#+BEGIN_EXAMPLE
clj -M /path/to/myscript.clj
#+END_EXAMPLE

*** Passing arguments to a Script

To pass in arguments to a script, pass them in as further arguments when
launching ~clojure.main~:

#+BEGIN_EXAMPLE
clj -M /path/to/myscript.clj arg1 arg2 arg3
#+END_EXAMPLE

The arguments will be provided to your program as a seq of strings bound
to the var ~*command-line-args*~:

#+BEGIN_EXAMPLE
*command-line-args* => ("arg1" "arg2" "arg3")
#+END_EXAMPLE

*** Error printing
:PROPERTIES:
:CUSTOM_ID: content/reference/repl_and_main#error-printing
:END:
**** At REPL

As of Clojure 1.10, Clojure errors categorized into one of several
phases:

- ~:read-source~ - an error thrown while reading characters at the REPL
  or from a source file.
- ~:macro-syntax-check~ - a syntax error found in the syntax of a macro
  call, either from spec or from a macro throwing
  IllegalArgumentException, IllegalStateException, or ExceptionInfo.
- ~:macroexpansion~ - all other errors thrown during macro evaluation
  are categorized as macroexpansion errors.
- ~:compile-syntax-check~ - a syntax error caught during compilation.
- ~:compilation~ - non-syntax errors caught during compilation.
- ~:execution~ - any errors thrown at execution time.
- ~:read-eval-result~ - any error thrown while reading the result of
  execution (only applicable for REPLs that read the result).
- ~:print-eval-result~ - any error thrown while printing the result of
  execution.

Exceptions thrown during all phases (exception ~:execution~) will have
ex-data attached with one or more of the following keys:

- ~:clojure.error/phase~ - phase indicator
- ~:clojure.error/source~ - file name (no path)
- ~:clojure.error/line~ - integer line number
- ~:clojure.error/column~ - integer column number
- ~:clojure.error/symbol~ - symbol being expanded/compiled/invoked
- ~:clojure.error/class~ - cause exception class symbol
- ~:clojure.error/cause~ - cause exception message
- ~:clojure.error/spec~ - explain-data for a spec error

The clojure.main REPL includes the categorization and printing of errors
by default, but the individual steps of this process are exposed as well
for other REPLs to use, specifically the functions:

- [[clojure:core_print.clj::(defn Throwable->map][Throwable->map]]
  - converts an Exception chain into Clojure data
- [[clojure:main.clj::(defn ex-triage][ex-triage]]
  - analyzes Clojure exception data to pull relevant information from
  the top and bottom of the exception chain into a map describing just
  the set of data needed to format an exception string
- [[clojure:main.clj::(defn ex-str][ex-str]]
  - produces a phase-appropriate message given a set of exception data

The clojure.main REPL combines these functions in a pipeline to produce
the printed exception message:
~(-> ex Throwable->map clojure.main/ex-triage clojure.main/ex-str)~.
Other REPLs can use one or more pieces of this pipeline as necessary
when building or customizing their exception printing.

**** As launcher
:PROPERTIES:
:CUSTOM_ID: content/reference/repl_and_main#as-launcher
:END:

Up to Clojure 1.10.0, clojure.main when used as a program launcher (with
-m, -e, or with a script), uncaught exceptions would be automatically
printed along with the full nested stack trace. In this case, the error
triage and printing process above was not applied.

As of Clojure 1.10.1, uncaught exceptions will now be caught and printed
according to the same error triage and printing functionality as the
Clojure REPL. The full stack trace, ex-info, and other information will
be printed to a target specified by the configuration.

The three available error targets are:

- ~file~ - write to a temp file (default, falls back to ~stderr~)
- ~stderr~ - write to stderr stream
- ~none~ - don't write

These error targets can be specified either as options to clojure.main,
or as Java system properties (flags take precedence). When invoking
clojure.main (or using the clj tool), use ~--report <target>~. For Java
system property, use ~-Dclojure.main.report=<target>~.

Other programs may wish to take advantage of this functionality, and
it is available in [[clojure:main.clj::(defn report-error][report-error]], which takes a Throwable and
optionally the :target.

*** tap

tap is a shared, globally accessible system for distributing a series of
informational or diagnostic values to a set of (presumably effectful)
handler functions. It can be used as a better debug ~prn~, or for
facilities like logging etc.

[[clojure:core.clj::(defn tap>][tap>]] sends a value to the set of taps. Taps can be added with [[clojure:core.clj::(defn add-tap][add-tap]]
and will be called with any value sent to tap>. The tap function may
(briefly) block (e.g. for streams) and will never impede calls to
tap>, but blocking indefinitely may cause tap values to be dropped. If
no taps are registered, tap> discards. Remove taps with [[clojure:core.clj::(defn remove-tap][remove-tap]].

*** Launching a Socket Server
:PROPERTIES:
:CUSTOM_ID: content/reference/repl_and_main#launching-a-socket-server
:END:

The Clojure runtime now has the ability to start a socket server at
initialization based on system properties. One expected use for this is
serving a socket-based REPL, but it also has many other potential uses
for dynamically adding server capability to existing programs without
code changes.

A socket server will be started for each JVM system property like
"clojure.server.<server-name>". The value for this property is an edn
map representing the configuration of the socket server with the
following properties:

- ~server-daemon~ - defaults to true, socket server thread doesn't
  block exit
- ~address~ - host or address, defaults to loopback
- ~port~ - positive integer, required
- ~accept~ - namespaced symbol of function to invoke on socket accept,
  required
- ~args~ - sequential collection of args to pass to accept
- ~bind-err~ - defaults to true, binds ~*err*~ to socket out stream
- ~client-daemon~ - defaults to true, socket client thread doesn't
  block exit

Additionally, there is a repl function provided that is slightly
customized for use with the socket server in [[clojure:core/server.clj::180][clojure.core.server/repl]].

Following is an example of starting a socket server with a repl
listener. This can be added to any existing Clojure program to allow it
to accept external REPL clients via a local connection to port 5555.

#+BEGIN_EXAMPLE
-Dclojure.server.repl="{:port 5555 :accept clojure.core.server/repl}"
#+END_EXAMPLE

An example client you can use to connect to this repl remotely is
telnet:

#+BEGIN_EXAMPLE
$ telnet 127.0.0.1 5555
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
user=> (println "hello")
hello
#+END_EXAMPLE

You can instruct the server to close the client repl session by using
the special command ~:repl/quit~:

#+BEGIN_EXAMPLE
user=> :repl/quit
Connection closed by foreign host.
#+END_EXAMPLE

Also see:

- [[https://clojure.atlassian.net/browse/CLJ-1671][CLJ-1671]]
- [[https://archive.clojure.org/design-wiki/display/design/Socket%2BServer%2BREPL.html][Socket Server and REPL design page]]

*** Related functions

Main entry point: ~clojure.main/main~

Reusable REPL: ~clojure.main/repl~

Error handling: ~clojure.main/ex-triage~ ~clojure.main/ex-str~

Allowing set! for the customary REPL vars: ~clojure.main/with-bindings~

Socket server control: ~clojure.core.server/start-server~
~clojure.core.server/stop-server~ ~clojure.core.server/stop-servers~

Socket repl: ~clojure.core.server/repl~

** Evaluation
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/evaluation.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/evaluation
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/repl_and_main
:NEXTPAGE_CUSTOM_ID: content/reference/special_forms
:CUSTOM_ID: content/reference/evaluation
:END:

Evaluation can occur in many contexts:

- Interactively, in the REPL
- On a sequence of forms read from a stream, via ~load~ / ~load-file~ /
  ~load-reader~ / ~load-string~
- Programmatically, via ~eval~

Clojure programs are composed of expressions. Every form not handled
specially by a special form or macro is considered by the compiler to be
an expression, which is evaluated to yield a value. There are no
declarations or statements, although sometimes expressions may be
evaluated for their side-effects and their values ignored. In all cases,
evaluation is the same - a single object is considered by the compiler,
evaluated, and its result returned. If an expression needs to be
compiled, it will be. There is no separate compilation step, nor any
need to worry that a function you have defined is being interpreted.
/Clojure has no interpreter/.

Strings, numbers, characters, ~true~, ~false~, ~nil~ and keywords
evaluate to themselves.

A Symbol is /resolved/:

- If it is namespace-qualified, the value is the value of the binding
  of the global var named by the symbol. It is an error if there is no
  global var named by the symbol, or if the reference is to a
  non-public var in a different namespace.
- If it is package-qualified, the value is the Java class named by the
  symbol. It is an error if there is no Class named by the symbol.
- Else, it is not qualified and the first of the following applies:

  1. If it names a special form it is considered a special form, and
     must be utilized accordingly.
  2. If in a local scope (e.g. in a function definition or a let form),
     a lookup is done to see if it names a local binding (e.g. a
     function argument or let-bound name). If so, the value is the
     value of the local binding.
  3. A lookup is done in the current namespace to see if there is a
     mapping from the symbol to a class. If so, the symbol is
     considered to name a Java class object. Note that class names
     normally denote class objects, but are treated specially in
     certain special forms, e.g. ~.~ and ~new~.
  4. A lookup is done in the current namespace to see if there is a
     mapping from the symbol to a var. If so, the value is the value of
     the binding of the var referred-to by the symbol.
  5. It is an error.

If a Symbol has metadata, it may be used by the compiler, but will not
be part of the resulting value.

Vectors, Sets and Maps yield vectors and (hash) sets and maps whose
contents are the /evaluated values/ of the objects they contain. Vector
elements are evaluated left to right, Sets and Maps are evaluated in an
undefined order. The same is true of metadata maps. If the vector or map
has metadata, the /evaluated/ metadata map will become the metadata of
the resulting value.

#+BEGIN_EXAMPLE
user=> (def x 1)
user=> (def y 2)
user=> ^{:x x} [x y 3]
^{:x 1} [1 2 3]
#+END_EXAMPLE

An empty list ~()~ evaluates to an empty list.

Non-empty Lists are considered /calls/ to either special forms, macros,
or functions. A call has the form (operator operands*).

Special forms are primitives built-in to Clojure that perform core
operations. If the operator of a call is a symbol that resolves to the
name of a special form, the call is to that special form. Each form
discussed individually under [[#content/reference/special_forms][Special Forms]].

[[#content/reference/macros][Macros]] are functions that manipulate forms, allowing for syntactic
abstraction. If the operator of a call is a symbol that names a global
var that is a macro function, that macro function is called and is
passed the /unevaluated/ operand forms. The return value of the macro is
then evaluated in its place.

If the operator is not a special form or macro, the call is considered
a function call. Both the operator and the operands (if any) are
evaluated, from left to right. The result of the evaluation of the
operator is cast to IFn (the interface representing Clojure
functions), and invoke() is called on it, passing the evaluated
arguments. The return value of invoke() is the value of the call
expression. If the function call form has metadata, it may be used by
the compiler, but will not be part of the resulting value. Note that
special forms and macros might have other-than-normal evaluation of
their arguments, as described in their entries under [[#content/reference/special_forms][Special Forms]].

Any object other than those discussed above will evaluate to itself.

- ~(load classpath-resource ...​)~
- ~(load-file filename)~
- ~(load-reader reader)~
- ~(load-string string)~

The above describes the evaluation of a single form. The various load
forms will sequentially read and evaluate the set of forms contained in
the source. Such sets of forms usually have side effects, often on the
global environment, defining functions etc.

The loading functions occur in a temporary context, in which ~*ns*~ has
a fresh binding. That means that, should any form have an effect on that
var (e.g. in-namespace), the effect will unwind at the completion of the
load. load et al return the value produced by the last expression.

- ~(eval form)~

Evaluates the form /data structure/ (not text!) and returns the result.

#+BEGIN_SRC clojure
(eval (list + 1 2 3))
-> 6
#+END_SRC

** Special Forms
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/special_forms.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/special_forms
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-02-09
:PREVPAGE_CUSTOM_ID: content/reference/evaluation
:NEXTPAGE_CUSTOM_ID: content/reference/macros
:CUSTOM_ID: content/reference/special_forms
:END:

Special forms have evaluation rules that differ from standard Clojure
evaluation rules and are understood directly by the Clojure compiler.

Headings for the special forms informally describe the special form
grammar using regular expression syntax: ? (optional), * (0 or more),
and + (1 or more). Non-terminals are denoted by /italics/.

*** (~def~ /symbol/ /doc-string/? /init/?)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#def
:END:

Creates and interns or locates a global [[https://clojure.org/reference/vars][var]] with the name of ~symbol~
and a namespace of the value of the current namespace (~*ns*~). If ~init~
is supplied, it is evaluated, and the root binding of the var is set
to the resulting value. If ~init~ is not supplied, the root binding of
the var is unaffected. ~def~ always applies to the root binding, even if
the var is thread-bound at the point where ~def~ is called. ~def~ yields
the var itself (not its value). Throws an exception if ~symbol~ is
already in the namespace and not mapped to an interned var. Support
for ~doc-string~ was added in Clojure 1.3.

Any metadata on the ~symbol~ will be evaluated, and become metadata on
the var itself. There are several metadata keys that have special
interpretation:

- ~:private~
  a boolean indicating the access control for the var. If this key is
  not present, the default access is public (e.g. as if
  ~:private false~).
- ~:doc~
  a string containing short (1-3 line) documentation for the var
  contents
- ~:test~
  a fn of no args that uses ~assert~ to check various operations. The
  var itself will be accessible during evaluation of a literal fn in
  the metadata map.
- ~:tag~
  a symbol naming a class or a Class object that indicates the Java
  type of the object in the var, or its return value if the object is a
  fn.

In addition the compiler will place the following metadata keys on the
var:

- ~:file~ string
- ~:line~ int
- ~:name~ simple symbol
- ~:ns~ namespace in which var is interned
- ~:macro~ ~true~ if var names a macro
- ~:arglists~ a list of vector(s) of argument forms, as were supplied
  to ~defn~

The var metadata can be used for application-specific purposes as well.
Consider using namespace-qualified keys (e.g. ~:myns/foo~) to avoid
clashes.

#+BEGIN_SRC clojure
(defn
 ^{:doc "mymax [xs+] gets the maximum value in xs using > "
   :test (fn []
             (assert (= 42  (mymax 2 42 5 4))))
   :user/comment "this is the best fn ever!"}
  mymax
  ([x] x)
  ([x y] (if (> x y) x y))
  ([x y & more]
   (reduce mymax (mymax x y) more)))

user=> (meta #'mymax)
  {:name mymax,
   :user/comment "this is the best fn ever!",
   :doc "mymax [xs+] gets the maximum value in xs using > ",
   :arglists ([x] [x y] [x y & more])
   :file "repl-1",
   :line 126,
   :ns #<Namespace user >,
   :test #<user$fn__289 user$fn__289@20f443 >}
#+END_SRC

Many macros expand into ~def~ (e.g. ~defn~, ~defmacro~), and thus also
convey metadata for the resulting var from the ~symbol~ used as the
name.

Using ~def~ to modify the root value of a var at other than the top
level is usually an indication that you are using the var as a mutable
global, and is considered bad style. Consider either using binding to
provide a thread-local value for the var, or putting a [[https://clojure.org/reference/refs][ref]] or [[https://clojure.org/reference/agents][agent]] in
the var and using transactions or actions for mutation.

*** (~if~ /test/ /then/ /else/?)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#if
:END:

Evaluates ~test~. If not the singular values ~nil~ or ~false~, evaluates
and yields ~then~, otherwise, evaluates and yields ~else~. If ~else~ is
not supplied it defaults to ~nil~. All of the other conditionals in
Clojure are based upon the same logic, that is, ~nil~ and ~false~
constitute logical falsity, and everything else constitutes logical
truth, and those meanings apply throughout. ~if~ performs conditional
tests of boolean Java method return values without conversion to
Boolean. Note that ~if~ does not test for arbitrary values of
java.lang.Boolean, only the singular value ~false~ (Java's
~Boolean.FALSE~), so if you are creating your own boxed Booleans make
sure to use ~Boolean/valueOf~ and not the Boolean constructors.

*** (~do~ /expr/*)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#do
:END:

Evaluates the expressions /expr/s in order and returns the value of the
last. If no expressions are supplied, returns ~nil~.

*** (~let~ [ /binding/* ] /expr/*)

/binding/ ⇒ /binding-form/ /init-expr/

Evaluates the expressions /expr/s in a lexical context in which the
symbols in the /binding-form/s are bound to their respective
/init-expr/s or parts therein. The bindings are sequential, so each
/binding/ can see the prior bindings. The /expr/s are contained in an
implicit ~do~. If a /binding/ symbol is annotated with a metadata tag,
the compiler will try to resolve the tag to a class name and presume
that type in subsequent references to the /binding/. The simplest
/binding-form/ is a symbol, which is bound to the entire /init-expr/:

#+BEGIN_SRC clojure
(let [x 1
      y x]
  y)
-> 1
#+END_SRC

See [[#content/reference/special_forms#binding-forms][Binding Forms]] for more information about binding
forms.

*Locals created with ~let~ are not variables. Once created their values
never change!*

*** (~quote~ /form/)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#quote
:END:

Yields the unevaluated /form/.

#+BEGIN_EXAMPLE
user=> '(a b c)
(a b c)
#+END_EXAMPLE

Note there is no attempt made to call the function ~a~. The return value
is a list of 3 symbols.

*** (~var~ /symbol/)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#var
:END:

The ~symbol~ must resolve to a var, and the Var object itself /(not its
value)/ is returned. The reader macro ~#'x~ expands to ~(var x)~.

*** (~fn~ /name/? [/params/* ] /expr/*), (~fn~ /name/? ([/params/* ] /expr/*)+)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#fn
:END:

- /params/ ⇒ /positional-param/* , or /positional-param/* & /rest-param/
- /positional-param/ ⇒ /binding-form/
- /rest-param/ ⇒ /binding-form/
- /name/ ⇒ /symbol/

Defines a function (fn). Fns are first-class objects that implement
the [[https://clojure.github.io/clojure/javadoc/clojure/lang/IFn.html][IFn interface]]. The ~IFn~ interface defines an ~invoke()~ function that
is overloaded with arity ranging from 0-20. A single fn object can
implement one or more invoke methods, and thus be overloaded on arity.
One and only one overload can itself be variadic, by specifying the
ampersand followed by a single /rest-param/. Such a variadic entry
point, when called with arguments that exceed the positional params,
collects them in a seq which is bound to, or destructured by, the rest
param. If the supplied args do not exceed the positional params, the
rest param will be ~nil~.

The first form defines a fn with a single invoke method. The second
defines a fn with one or more overloaded invoke methods. The arities of
the overloads must be distinct. In either case, the result of the
expression is a single fn object.

The expressions /expr/s are compiled in an environment in which the
/params/ are bound to the actual arguments. The /expr/s are enclosed in
an implicit ~do~. If a name /symbol/ is provided, it is bound within the
function definition to the function object itself, allowing for
self-calling, even in anonymous functions. If a /param/ symbol is
annotated with a metadata tag, the compiler will try to resolve the tag
to a class name and presume that type in subsequent references to the
binding.

#+BEGIN_SRC clojure
(def mult
  (fn this
      ([] 1)
      ([x] x)
      ([x y] (* x y))
      ([x y & more]
          (apply this (this x y) more))))
#+END_SRC

Note that named fns such as ~mult~ are normally defined with ~defn~,
which expands into something such as the above.

A fn (overload) defines a recursion point at the top of the function,
with arity equal to the number of /param/s /including the rest param, if
present/. See [[#content/reference/special_forms#recur][recur]].

fns implement the Java ~Callable~, ~Runnable~ and ~Comparator~
interfaces.

*Since 1.1*

Functions support specifying runtime pre- and post-conditions.

The syntax for function definitions becomes the following:

*** (~fn~ /name/? [/param/* ] /condition-map/? /expr/*), (~fn~ name? ([/param/* ] /condition-map/? /expr/*)+)

The syntax extension also applies to ~defn~ and other macros which
expand to ~fn~ forms.

Note: If the sole form following the parameter vector is a map, it is
treated as the function body, and not the condition map.

The /condition-map/ parameter may be used to specify pre- and
post-conditions for a function. It is of the following form:

#+BEGIN_EXAMPLE
{:pre [pre-expr*]
 :post [post-expr*]}
#+END_EXAMPLE

where either key is optional. The condition map may also be provided as
metadata of the arglist.

/pre-expr/ and /post-expr/ are boolean expressions that may refer to the
parameters of the function. In addition, ~%~ may be used in a
/post-expr/ to refer to the function's return value. If any of the
conditions evaluate to ~false~ and ~*assert*~ is true, a
~java.lang.AssertionError~ exception is thrown.

Example:

#+BEGIN_SRC clojure
(defn constrained-sqr [x]
    {:pre  [(pos? x)]
     :post [(> % 16), (< % 225)]}
    (* x x))
#+END_SRC

See [[#content/reference/special_forms#binding-forms][Binding Forms]] for more information about binding
forms.

*** (~loop~ [/binding/* ] /expr/*)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#loop
:END:

~loop~ is exactly like ~let~, except that it establishes a recursion
point at the top of the loop, with arity equal to the number of
bindings. See [[#content/reference/special_forms#recur][recur]].

*** (~recur~ /expr/*)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#recur
:END:

Evaluates the expressions /expr/s in order, then, in parallel, rebinds
the bindings of the recursion point to the values of the /expr/s. If
the recursion point was a ~fn~ method, then it rebinds the params. If
the recursion point was a [[#content/reference/special_forms#loop][loop]], then it rebinds the ~loop~
bindings. Execution then jumps back to the recursion point. The ~recur~
expression must match the arity of the recursion point exactly. In
particular, if the recursion point was the top of a variadic fn
method, there is no gathering of ~rest~ args - a single seq (or null)
should be passed. ~recur~ in other than a tail position is an error.

Note that ~recur~ is the only non-stack-consuming looping construct in
Clojure. There is no tail-call optimization and the use of self-calls
for looping of unknown bounds is discouraged. ~recur~ is functional and
its use in tail-position is verified by the compiler.

#+BEGIN_SRC clojure
(def factorial
  (fn [n]
    (loop [cnt n acc 1]
       (if (zero? cnt)
            acc
          (recur (dec cnt) (* acc cnt))))))
#+END_SRC

*** (~throw~ /expr/)

The /expr/ is evaluated and thrown, therefore it should yield an
instance of some derivee of ~Throwable~.

*** (~try~ /expr/* /catch-clause/* /finally-clause/?)

- /catch-clause/ → (catch /classname/ /name/ /expr/*)
- /finally-clause/ → (finally /expr/*)

The /expr/s are evaluated and, if no exceptions occur, the value of the
last expression is returned. If an exception occurs and /catch-clause/s
are provided, each is examined in turn and the first for which the
thrown exception is an instance of the /classname/ is considered a
matching /catch-clause/. If there is a matching /catch-clause/, its
/expr/s are evaluated in a context in which /name/ is bound to the
thrown exception, and the value of the last is the return value of the
function. If there is no matching /catch-clause/, the exception
propagates out of the function. Before returning, normally or
abnormally, any /finally-clause/ /expr/s will be evaluated for their
side effects.

*** (~monitor-enter~ /expr/), (~monitor-exit~ /expr/)

These are synchronization primitives that should be avoided in user
code. Use the ~locking~ macro.

*** Other Special Forms

The special forms [[#content/reference/java_interop#dot][dot ('.')]], [[java_interop#new][new]], and [[java_interop#set!][set!]] of fields are described in
the [[#content/reference/java_interop][Java Interop]] section of the reference.

[[#content/reference/vars#set!][set!]] of vars is described in the [[#content/reference/vars][Vars]] section of the reference.

*** Binding Forms (Destructuring)
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#binding-forms
:END:

The simplest /binding-form/ in Clojure is a symbol. However, Clojure
also supports abstract structural binding called destructuring in ~let~
binding lists, ~fn~ parameter lists, and by extension any macro that
expands into a ~let~ or ~fn~. Destructuring is a way to create a set of
bindings to values within a collection by using an analogous collection
as a binding form. A vector form specifies bindings by position in a
sequential collection, a map form by key in an associative collection.
Destructuring forms can appear anywhere /binding-form/s can, and thus
nest, yielding code that is clearer than using collection accessors.

/Binding-form/s that don't match their respective part due to an absence
of data (i.e. too few elements in a sequential structure, no key in an
associative structure, etc) bind to ~nil~.

**** Sequential destructuring

Vector /binding_form/s sequentially bind values in collections like
vectors, lists, seqs, strings, arrays, and anything that supports [[clojure:core.clj::(defn nth][nth]].
The sequential destructuring form is a vector of /binding-form/s, which
will be bound to successive elements from the /init-expr/, looked up via
~nth~. In addition, and optionally, a /binding-form/ following a ~&~ will be
bound to the remainder of the sequence, i.e. that part not yet bound,
and looked up via [[clojure:core.clj::(defn nthnext][nthnext]].

Finally, also optionally, ~:as~ followed by a symbol binds that symbol
to the entire /init-expr/:

#+BEGIN_SRC clojure
(let [[a b c & d :as e] [1 2 3 4 5 6 7]]
  [a b c d e])

->[1 2 3 (4 5 6 7) [1 2 3 4 5 6 7]]
#+END_SRC

These forms can nest:

#+BEGIN_SRC clojure
(let [[[x1 y1][x2 y2]] [[1 2] [3 4]]]
  [x1 y1 x2 y2])

->[1 2 3 4]
#+END_SRC

In all of the sequential cases the /binding-form/s in the destructure
binding will match the places in the target data structure where the
desired values reside.

**** Associative destructuring
:PROPERTIES:
:CUSTOM_ID: content/reference/special_forms#associative-destructuring
:END:

Map /binding-form/s create bindings by looking up values in collections
like maps, sets, vectors, strings, and arrays (the latter three have
integer keys). It consists of a map of /binding-form→key/ pairs, each
/binding-form/ bound to the value in the /init-expr/ at the key
provided. In addition, and optionally, an ~:as~ key in the binding form
followed by a symbol binds that symbol to the entire /init-expr/. Also
optionally, an ~:or~ key in the binding form followed by another map may
be used to supply default values for some or all of the keys if they are
not found in the /init-expr/:

#+BEGIN_SRC clojure
(let [{a :a, b :b, c :c, :as m :or {a 2 b 3}}  {:a 5 :c 6}]
  [a b c m])

->[5 3 6 {:c 6, :a 5}]
#+END_SRC

It is often the case that you will want to bind symbols with the same
name as the corresponding map keys. The ~:keys~ directive addresses the
redundancy often found in the binding /binding-form→key/ pairs:

#+BEGIN_SRC clojure
(let [{fred :fred ethel :ethel lucy :lucy} m] ...
#+END_SRC

can be written:

#+BEGIN_SRC clojure
(let [{:keys [fred ethel lucy]} m] ...
#+END_SRC

As of Clojure 1.6, you can also use prefixed map keys in the map
destructuring form:

#+BEGIN_SRC clojure
(let [m {:x/a 1, :y/b 2}
      {:keys [x/a y/b]} m]
  (+ a b))

-> 3
#+END_SRC

In the case of using prefixed keys, the bound symbol name is the same as
the right-hand side of the prefixed key. You can also use auto-resolved
keyword forms in the ~:keys~ directive:

#+BEGIN_SRC clojure
(let [m {::x 42}
      {:keys [::x]} m]
  x)

-> 42
#+END_SRC

There are similar ~:strs~ and ~:syms~ directives for matching string and
symbol keys, the latter also allowing prefixed symbol keys since Clojure
1.6.

Clojure 1.9 adds support for directly destructuring many keys (or
symbols) that share the same namespace using the following destructuring
key forms:

- ~:ns/keys~ - ~ns~ specifies the default namespace for the key to look
  up in the input
  - keys elements should not specify a namespace
  - keys elements also define new local symbols, as with ~:keys~
- ~:ns/syms~ - ~ns~ specifies the default namespace for the symbol to
  look up in the input
  - syms elements should not specify a namespace
  - syms elements also define new local symbols, as with ~:syms~

#+BEGIN_SRC clojure
(let [m #:domain{:a 1, :b 2}
      {:domain/keys [a b]} m]
  [a b])

-> [1 2]
#+END_SRC

**** Keyword Arguments

Keyword arguments are optional trailing variadic arguments of the form
~akey aval bkey bval​~ that can be accessed in the function body via
associative destructuring. Also, introduced in Clojure 1.11, a function
specified to take kwargs may be passed a single map instead of or in
addition to (and following) the key/value pairs. When a lone map is
passed, it is used outright for destructuring, else a trailing map is
added to the map built from the preceding key/values via ~conj~. To
define a function that accepts keyword arguments you supply a map
destructuring form in the /rest-param/ declaration position. For
example, a function that takes a sequence and optional keyword arguments
and returns a vector containing the values is defined as:

#+BEGIN_SRC clojure
(defn destr [& {:keys [a b] :as opts}]
  [a b opts])

(destr :a 1)
->[1 nil {:a 1}]

(destr {:a 1 :b 2})
->[1 2 {:a 1 :b 2}]
#+END_SRC

The map /binding-form/ to the right of the ~&~ in ~destr~ is an associative
destructuring /binding-form/ [[#content/reference/special_forms#associative-destructuring][detailed above]].

The two declarations of ~foo~ below are equivalent, demonstrating
associative destructuring's interpretation of seqs:

#+BEGIN_SRC clojure
(defn foo [& {:keys [quux]}] ...)

(defn foo [& opts]
  (let [{:keys [quux]} opts] ...))
#+END_SRC

**** Nested destructuring

Since binding forms can be nested within one another arbitrarily, you
can pull apart just about anything:

#+BEGIN_SRC clojure
(let [m {:j 15 :k 16 :ivec [22 23 24 25]}
      {j :j, k :k, i :i, [r s & t :as v] :ivec, :or {i 12 j 13}} m]
  [i j k r s t v])

-> [12 15 16 22 23 (24 25) [22 23 24 25]]
#+END_SRC

** Macros
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/macros.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/macros
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/special_forms
:NEXTPAGE_CUSTOM_ID: content/reference/other_functions
:CUSTOM_ID: content/reference/macros
:END:

Clojure has a programmatic macro system which allows the compiler to be
extended by user code. Macros can be used to define syntactic constructs
which would require primitives or built-in support in other languages.
Many core constructs of Clojure are not, in fact, primitives, but are
normal macros.

Some macros produce simple combinations of primitive forms. For
example, [[clojure:core.clj::(defmacro when][when]] combines [[#content/reference/special_forms#if][if]] and [[#content/reference/special_forms#do][do]]:

#+BEGIN_EXAMPLE
user=> (macroexpand '(when (pos? a) (println "positive") (/ b a)))
(if (pos? a) (do (println "positive") (/ b a)))
#+END_EXAMPLE

Other macros re-arrange forms in useful ways, like the ~->~ macro, which
recursively inserts each expression as the first argument of the next
expression:

#+BEGIN_EXAMPLE
user=> (-> {} (assoc :a 1) (assoc :b 2))
{:b 2, :a 1}
user=> (macroexpand '(-> {} (assoc :a 1) (assoc :b 2)))
(assoc (clojure.core/-> {} (assoc :a 1)) :b 2)
#+END_EXAMPLE

*** Special variables

Two special variables are available inside defmacro for more advanced
usages:

- ~&form~ - the actual form (as data) that is being invoked
- ~&env~ - a map of local bindings at the point of macro expansion. The
  env map is from symbols to objects holding compiler information about
  that binding.

All of the following macros are documented on the [[https://clojure.github.io/clojure/][API]] page. Many are
also discussed on topic pages as noted:

Creating macros: [[clojure:core.clj::defmacro (fn][defmacro]], [[clojure:core.clj::(defmacro definline][definline]], [[clojure:core.clj::(defn macroexpand-1][macroexpand-1]], [[clojure:core.clj::4014][macroexpand]].

Branching: [[clojure:core.clj::(defmacro and][and]], [[clojure:core.clj::(defmacro or][or]], [[clojure:core.clj::(defmacro when][when]], [[clojure:core.clj::(defmacro when-not][when-not]], [[clojure:core.clj::(defmacro when-let][when-let]], [[clojure:core.clj::(defmacro when-first][when-first]], [[clojure:core.clj::(defmacro if-not][if-not]],
[[clojure:core.clj::(defmacro if-let][if-let]], [[clojure:core.clj::(defmacro cond][cond]], [[clojure:core.clj::(defmacro condp][condp]].

Looping (see also [[#content/reference/sequences][Sequences]]): [[clojure:core.clj::(defmacro for][for]], [[clojure:core.clj::(defmacro doseq][doseq]], [[clojure:core.clj::(defmacro dotimes][dotimes]], [[clojure:core.clj::(defmacro while][while]].

Working with vars (see also [[#content/reference/vars][Vars and Environment]]): [[clojure:core.clj::(defmacro ns][ns]], [[clojure:core.clj::(declare][declare]], [[clojure:core.clj::defn (fn defn][defn]],
[[clojure:core.clj::defmacro
(fn][defmacro]], [[clojure:core.clj::(defmacro definline][definline]], [[clojure:core.clj::(defmacro defmethod][defmethod]], [[clojure:core.clj::(defmacro defmulti][defmulti]], [[clojure:core.clj::(defn-][defn-]], [[clojure:core.clj::(defmacro defonce][defonce]], [[clojure:core.clj::(defmacro defstruct][defstruct]].

Arranging code differently: [[clojure:core.clj::(defmacro ..][..]], [[clojure:core.clj::(defmacro doto][doto]], [[clojure:core.clj::(defmacro ->][->]].

Dynamic scopes (see also [[#content/reference/vars][Vars and Environment]]): [[clojure:core.clj::(defmacro binding][binding]], [[clojure:core.clj::(defmacro locking][locking]],
[[clojure:core.clj::(defmacro
time][time]], [[clojure:core.clj::(defmacro with-in-str][with-in-str]], [[clojure:core.clj::(defmacro with-local-vars][with-local-vars]], [[clojure:core.clj::(defmacro with-open][with-open]], [[clojure:core.clj::(defmacro with-out-str][with-out-str]],
[[clojure:core.clj::(defmacro
with-precision][with-precision]].

Creating lazy things (see also [[#content/reference/sequences][Sequences]]): [[clojure:core.clj::(defmacro lazy-cat][lazy-cat]], [[clojure:core.clj::(defmacro delay][delay]]
# FIXME: don't know how lazy-cons defined [[clojure:core.clj::(lazy-cons][lazy-cons]]

[[#content/reference/java_interop][Java interop]] macros: [[clojure:core.clj::(defmacro ..][..]], [[clojure:core.clj::(defmacro amap][amap]], [[clojure:core.clj::(defmacro areduce][areduce]], [[clojure:genclass.clj::(defmacro gen-class][gen-class]], [[clojure:genclass.clj::(defmacro gen-interface][gen-interface]],
[[clojure:core_proxy.clj::(defmacro
proxy][proxy]], [[clojure:core_proxy.clj::(defmacro proxy-super][proxy-super]], [[clojure:core.clj::(defmacro memfn][memfn]].

Documenting code: [[clojure:core.clj::(defmacro assert][assert]], [[clojure:core.clj::(defmacro comment][comment]], [[clojure:repl.clj::(defmacro doc][doc]].

Transactions: [[clojure:core.clj::(defmacro dosync][dosync]], [[clojure:core.clj::(defmacro io!][io!]].

A few [[#content/reference/special_forms][special forms]] are actually implemented as macros, primarily to
provide destructuring: fn let loop.

** Other Useful Functions and Macros
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/other_functions.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/other_functions
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/macros
:NEXTPAGE_CUSTOM_ID: content/reference/data_structures
:CUSTOM_ID: content/reference/other_functions
:END:

Boolean and comparison functions: [[clojure:core.clj::(defn =][=]], [[clojure:core.clj::(defn ==][==]], [[clojure:core.clj::(defn identical?][identical?]], [[clojure:core.clj::(defn not=][not=]], [[clojure:core.clj::(defn not][not]], [[clojure:core.clj::(defn true?][true?]],
[[clojure:core.clj::(defn
false?][false?]], [[clojure:core.clj::(defn nil?][nil?]].

Miscellaneous: [[clojure:core.clj::(defn identity][identity]], [[clojure:core.clj::(defmacro dotimes][dotimes]], [[clojure:core.clj::(defmacro time][time]], [[clojure:core.clj::(defmacro assert][assert]], [[clojure:core.clj::(defmacro with-open][with-open]].

*** Creating functions

| Function         | Example expression                 | Return value           |
|------------------+------------------------------------+------------------------|
| [[#content/reference/special_forms#fn][fn]]               | ~(map (fn [x] (+ 2 x)) [1 2 3])~     | ~(3 4 5)~                |
| #() [[#content/reference/reader][reader]] macro | ~(map #(+ 2 %) [1 2 3])~             | ~(3 4 5)~                |
| [[clojure:core.clj::(defn partial][partial]]          | ~(map (partial + 2) [1 2 3])~        | ~(3 4 5)~                |
| [[clojure:core.clj::2561][comp]]             | ~(map (comp - *) [2 4 6] [1 2 3])~   | ~(-2 -8 -18)~            |
| [[clojure:core.clj::(defn complement][complement]]       | ~(map (complement zero?) [3 2 1 0])~ | ~(true true true false)~ |
| [[clojure:core.clj::(defn constantly][constantly]]       | ~(map (constantly 9) [1 2 3])~       | ~(9 9 9)~                |

*** Printing
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/other_functions.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/other_functions
:CUSTOM_ID: content/reference/other_functions#printing
:END:

Several functions are provided to print objects to the output stream
that is the current value of ~*out*~. The -str versions bind ~*out*~ to a
StringWriter, print to that, and return the resulting string.  [[clojure:core.clj::3665][pr]]
prints the object(s), separated by spaces if there is more than one.
[[clojure:core.clj::(defn
prn][prn]] does the same and follows it with a [[clojure:core.clj::(defn newline][newline]].  [[clojure:core.clj::(defn print][print]] and [[clojure:core.clj::(defn println][println]]
call [[clojure:core.clj::3665][pr]] and [[clojure:core.clj::(defn prn][prn]] respectively, with ~*print-readably*~ (which defaults to
true) bound to nil, which causes strings to print without surrounding
quotes or any escape character encoding, and characters to print
without the leading '\', or any escape character encoding. By default,
[[clojure:core.clj::3665][pr]] and [[clojure:core.clj::(defn prn][prn]] print in a way that objects can be read by the reader,
while [[clojure:core.clj::(defn print][print]] and [[clojure:core.clj::(defn println][println]] produce output for human consumption. When
~*print-readably*~ is non-nil, the printing of metadata is toggled by
~*print-meta*~, which defaults to nil.

**** Related functions

Print to ~*out*~: [[clojure:core.clj::3665][pr]], [[clojure:core.clj::(defn prn][prn]], [[clojure:core.clj::(defn print][print]], [[clojure:core.clj::(defn println][println]], [[clojure:core.clj::(defn newline][newline]].

Print to string: [[clojure:core.clj::(defn pr-str][pr-str]], [[clojure:core.clj::(defn prn-str][prn-str]], [[clojure:core.clj::(defn print-str][print-str]], [[clojure:core.clj::(defn println-str][println-str]],
[[clojure:core.clj::(defmacro
with-out-str][with-out-str]].

*** Regex Support
:PROPERTIES:
:CUSTOM_ID: content/reference/other_functions#regex-support
:END:

Regex patterns can be compiled at read-time via the ~#"pattern"~ reader
macro, or at run time with [[clojure:core.clj::(defn re-pattern][re-pattern]].  Both forms produce
[[https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html][java.util.regex.Pattern]] objects.

#+BEGIN_EXAMPLE
user=> (re-seq #"[0-9]+" "abs123def345ghi567")
("123" "345" "567")
user=> (re-find #"([-+]?[0-9]+)/([0-9]+)" "22/7")
["22/7" "22" "7"]
user=> (let [[a b c] (re-matches #"([-+]?[0-9]+)/([0-9]+)" "22/7")]
         [a b c])
["22/7" "22" "7"]
user=> (re-seq #"(?i)[fq].." "foo bar BAZ QUX quux")
("foo" "QUX" "quu")
#+END_EXAMPLE

**** Related functions

[[clojure:core.clj::(defn re-matcher][re-matcher]], [[clojure:core.clj::(defn re-find][re-find]], [[clojure:core.clj::(defn re-matches][re-matches]], [[clojure:core.clj::(defn re-groups][re-groups]], [[clojure:core.clj::(defn re-seq][re-seq]].

** Data Structures
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/data_structures.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/data_structures
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/other_functions
:NEXTPAGE_CUSTOM_ID: content/reference/datatypes
:CUSTOM_ID: content/reference/data_structures
:END:

Clojure has a rich set of data structures. They share a set of
properties:

- They are immutable
- They are read-able
- They support proper value equality semantics in their implementation
  of equals
- They provide good hash values
- In addition, the collections:
  - Are manipulated via interfaces.
  - Support sequencing
  - Support persistent manipulation.
  - Support metadata
  - Implement java.lang.Iterable
  - Implement the non-optional (read-only) portion of
      java.util.Collection or java.util.Map

*** nil

nil is a possible value of any data type in Clojure. nil has the same
value as Java null. The Clojure conditional system is based around nil
and false, with nil and false representing the values of logical falsity
in conditional tests - anything else is logical truth. In addition, nil
is used as the end-of-sequence sentinel value in the sequence protocol.

*** Numbers

Clojure provides full support for JVM primitive values by default,
allowing high performance, idiomatic Clojure code for numeric
applications.

Clojure also supports the Java boxed number types derived from
java.lang.Number, including BigInteger and BigDecimal, plus its own
Ratio type. There is some special handling:

**** Longs

By default Clojure operates with natural numbers as instances of Java's
long primitive type. When a primitive integer operation results in a
value that too large to be contained in a primitive value, a
java.lang.ArithmeticException is thrown. Clojure provides a set of
alternative math operators suffixed with an apostrophe: +', -', *',
inc', and dec'. These operators auto-promote to BigInt upon overflow,
but are less efficient than the regular math operators.

**** Ratio

Represents a ratio between integers. Division of integers that can't be
reduced to an integer yields a ratio, i.e. 22/7 = 22/7, rather than a
floating point or truncated value.

**** Contagion

BigInts and floating point types are "contagious" across operations.
That is, any integer operation involving a BigInt will result in a
BigInt, and any operation involving a double or float will result in a
double.

**** BigInt and BigDecimal literals

Numeric literals for BigInt and BigDecimal are specified using a postfix
N and M respectively.

| Example expression               | Return value         |
|----------------------------------+----------------------|
| ~(= 1 1.0 1M)~                     | ~true~                 |
| ~(/ 2 3)~                          | ~2/3~                  |
| ~(/ 2.0 3)~                        | ~0.6666666666666666~   |
| ~(map #(Math/abs %) (range -3 3))~ | ~(3 2 1 0 1 2)~        |
| ~(class 36786883868216818816N)~    | ~clojure.lang.BigInt~  |
| ~(class 3.14159265358M)~           | ~java.math.BigDecimal~ |

**** Related functions

Computation: [[clojure:core.clj::986][+]], [[clojure:core.clj::1045][-]], [[clojure:core.clj::1010][*]], [[clojure:core.clj::(defn /][/]], [[clojure:core.clj::924][inc]], [[clojure:core.clj::1144][dec]], [[clojure:core.clj::(defn quot][quot]], [[clojure:core.clj::(defn rem][rem]], [[clojure:core.clj::(defn min][min]], [[clojure:core.clj::(defn max][max]].

Auto-promoting computation: [[clojure:core.clj::(defn +'][+']], [[clojure:core.clj::(defn -'][-']], [[clojure:core.clj::(defn *'][*']], [[clojure:core.clj::(defn inc'][inc']], [[clojure:core.clj::(defn dec'][dec']].

Comparison: [[clojure:core.clj::(defn ==][==]], [[clojure:core.clj::(defn <][<]], [[clojure:core.clj::(defn <=][<=]], [[clojure:core.clj::(defn >][>]], [[clojure:core.clj::(defn >=][>=]], [[clojure:core.clj::(defn zero?][zero?]], [[clojure:core.clj::(defn pos?][pos?]], [[clojure:core.clj::(defn neg?][neg?]].

Bitwise operations: [[clojure:core.clj::(defn bit-and][bit-and]], [[clojure:core.clj::(defn bit-or][bit-or]], [[clojure:core.clj::(defn bit-xor][bit-xor]], [[clojure:core.clj::(defn bit-not][bit-not]],
[[clojure:core.clj::(defn
bit-shift-right][bit-shift-right]], [[clojure:core.clj::(defn bit-shift-left][bit-shift-left]].

Ratios: [[clojure:core.clj::(defn numerator][numerator]], [[clojure:core.clj::(defn denominator][denominator]].

Coercions: [[clojure:core.clj::(defn int][int]], [[clojure:core.clj::(defn bigdec][bigdec]], [[clojure:core.clj::(defn bigint][bigint]], [[clojure:core.clj:: double][double]], [[clojure:core.clj::(defn float][float]], [[clojure:core.clj::(defn long][long]], [[clojure:core.clj::(defn num][num]], [[clojure:core.clj::(defn short][short]].

*** Strings

Clojure strings are Java Strings. See also [[#content/reference/other_functions#printing][Printing]].

#+BEGIN_EXAMPLE
user=> (map (fn [x] (.toUpperCase x)) (.split "Dasher Dancer Prancer" " "))
("DASHER" "DANCER" "PRANCER")
#+END_EXAMPLE

**** Related functions

[[clojure:core.clj::(defn str][str]], [[clojure:core.clj::string? (fn ^:static string?][string?]], [[clojure:core.clj::(defn pr-str][pr-str]], [[clojure:core.clj::(defn prn-str][prn-str]], [[clojure:core.clj::(defn print-str][print-str]], [[clojure:core.clj::(defn println-str][println-str]], [[clojure:core.clj::(defmacro with-out-str][with-out-str]].

*** Characters

Clojure characters are Java Characters.

**** Related functions

[[clojure:core.clj::(defn char][char]], [[clojure:core_print.clj::char-name-string][char-name-string]], [[clojure:core_print.clj::char-escape-string][char-escape-string]].

*** Keywords
:PROPERTIES:
:CUSTOM_ID: content/reference/data_structures#keywords
:END:

Keywords are symbolic identifiers that evaluate to themselves. They
provide very fast equality tests. Like Symbols, they have names and
optional [[#content/reference/namespaces][namespaces]], both of which are strings.
The leading ':' is not part of the namespace or name.

Keywords implement IFn for invoke() of one argument (a map) with an
optional second argument (a default value). For example ~(:mykey
my-hash-map :none)~ means the same as ~(get my-hash-map :mykey
:none)~. See [[clojure:core.clj::(defn get][get]].

**** Related functions

[[clojure:core.clj::616][keyword]], [[clojure:core.clj::(defn keyword?][keyword?]]

*** Symbols

Symbols are identifiers that are normally used to refer to something
else. They can be used in program forms to refer to function
parameters, let bindings, class names and global vars. They have names
and optional [[#content/reference/namespaces][namespaces]], both of which are strings. Symbols can have
metadata (see [[clojure:core.clj::with-meta (fn ^:static with-meta][with-meta]]).

Symbols, just like Keywords, implement IFn for invoke() of one
argument (a map) with an optional second argument (a default
value). For example ~('mysym my-hash-map :none)~ means the same as ~(get
my-hash-map 'mysym :none)~. See [[clojure:core.clj::(defn get][get]].

**** Related functions

[[clojure:core.clj::591][symbol]], [[clojure:core.clj::(defn symbol?][symbol?]], [[clojure:core.clj::(defn gensym][gensym]], (see also the #-suffix [[#content/reference/reader][reader]] macro)

*** Collections

All of the Clojure collections are immutable and [[https://en.wikipedia.org/wiki/Persistent_data_structure][persistent]].  In
particular, the Clojure collections support efficient creation of
'modified' versions, by utilizing structural sharing, and make all of
their performance bound guarantees for persistent use. The collections
are efficient and inherently thread-safe. Collections are represented
by abstractions, and there may be one or more concrete
realizations. In particular, since 'modification' operations yield new
collections, the new collection might not have the same concrete type
as the source collection, but will have the same logical (interface)
type.

All the collections support [[clojure:core.clj::(defn count][count]] for getting the size of the
collection, [[clojure:core.clj::conj (fn ^:static conj][conj]] for 'adding' to the collection, and [[clojure:core.clj::seq (fn ^:static seq][seq]] to get a
sequence that can walk the entire collection, though their specific
behavior is slightly different for different types of collections.

Because collections support the [[clojure:core.clj::seq (fn ^:static seq][seq]] function, all of the [[#content/reference/sequences][sequence
functions]] can be used with any collection.

**** Java collection hashes

The Java collection interfaces specify algorithms for [[https://docs.oracle.com/javase/8/docs/api/java/util/List.html#hashCode()][Lists]], [[https://docs.oracle.com/javase/8/docs/api/java/util/Set.html#hashCode()][Sets]], and
[[https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#hashCode()][Maps]] in calculating hashCode() values. All Clojure collections conform
to these specifications in their hashCode() implementations.

**** Clojure collection hashes

Clojure provides its own hash computations that provide better hash
properties for collections (and other types), known as the ~hasheq~
value.

The ~IHashEq~ interface marks collections that provide the ~hasheq()~
function to obtain the hasheq value. In Clojure, the [[clojure:core.clj::5177][hash]] function can
be used to compute the hasheq value.

Ordered collections (vector, list, seq, etc) must use the following
algorithm for calculating hasheq (where hash computes hasheq). Note that
unchecked-add-int and unchecked-multiply-int are used to get integer
overflow calculations.

#+BEGIN_SRC clojure
(defn hash-ordered [collection]
  (-> (reduce (fn [acc e] (unchecked-add-int
                            (unchecked-multiply-int 31 acc)
                            (hash e)))
              1
              collection)
      (mix-collection-hash (count collection))))
#+END_SRC

Unordered collections (maps, sets) must use the following algorithm for
calculating hasheq. A map entry is treated as an ordered collection of
key and value. Note that unchecked-add-int is used to get integer
overflow calculations.

#+BEGIN_SRC clojure
(defn hash-unordered [collection]
  (-> (reduce unchecked-add-int 0 (map hash collection))
      (mix-collection-hash (count collection))))
#+END_SRC

The [[clojure:core.clj::(defn mix-collection-hash][mix-collection-hash]] algorithm is an implementation detail subject
to change.

*** Lists (IPersistentList)
:PROPERTIES:
:CUSTOM_ID: content/reference/data_structures#lists
:END:

Lists are collections. They implement the ISeq interface
directly. (Note that the empty list implements ISeq as well, however
the ~seq~ function will always return ~nil~ for an empty sequence.)  [[clojure:core.clj::(defn count][count]]
is O(1).  [[clojure:core.clj::conj (fn ^:static conj][conj]] puts the item at the front of the list.

**** Related functions

Create a list: [[clojure:core.clj::list (. clojure.lang.PersistentList][list]], [[clojure:core.clj::(defn list*][list*]].

Treat a list like a stack: [[clojure:core.clj::(defn peek][peek]], [[clojure:core.clj::(defn pop][pop]].

Examine a list: [[clojure:core.clj::(defn list?][list?]].

*** Vectors (IPersistentVector)
:PROPERTIES:
:CUSTOM_ID: content/reference/data_structures#vectors
:END:

A Vector is a collection of values indexed by contiguous integers.
Vectors support access to items by index in log32N hops.  [[clojure:core.clj::(defn count][count]] is
O(1).  [[clojure:core.clj::conj (fn ^:static conj][conj]] puts the item at the end of the vector. Vectors also
support [[clojure:core.clj::(defn rseq][rseq]], which returns the items in reverse order. Vectors
implement IFn, for invoke() of one argument, which they presume is an
index and look up in themselves as if by nth, i.e. vectors are
functions of their indices.  Vectors are compared first by length,
then each element is compared in order.

**** Related functions

Create a vector: [[clojure:core.clj::(defn vector][vector]], [[clojure:core.clj::369][vec]], [[clojure:gvec.clj::(defn vector-of][vector-of]].

Examine a vector: [[clojure:core.clj::(defn get][get]], [[clojure:core.clj::(defn nth][nth]], [[clojure:core.clj::(defn peek][peek]], [[clojure:core.clj::(defn rseq][rseq]], [[clojure:core.clj::vector? (fn ^:static vector?][vector?]].

'change' a vector: [[clojure:core.clj::(fn ^:static assoc][assoc]], [[clojure:core.clj::(defn pop][pop]], [[clojure:core.clj::(defn subvec][subvec]], [[clojure:core.clj::(defn replace][replace]].

See also [[#content/reference/other_libraries][zippers]]

*** Maps (IPersistentMap)
:PROPERTIES:
:CUSTOM_ID: content/reference/data_structures#maps
:END:

A Map is a collection that maps keys to values. Two different map
types are provided - hashed and sorted. Hash maps require keys that
correctly support hashCode and equals. Sorted maps require keys that
implement Comparable, or an instance of Comparator. Hash maps provide
faster access (log32N hops) vs (logN hops), but sorted maps are, well,
sorted.  [[clojure:core.clj::(defn count][count]] is O(1).  [[clojure:core.clj::conj (fn ^:static conj][conj]] expects another (possibly single entry)
map as the item, and returns a new map which is the old map plus the
entries from the new, which may overwrite entries of the old.  [[clojure:core.clj::conj (fn ^:static conj][conj]]
also accepts a MapEntry or a vector of two items (key and value).  [[clojure:core.clj::seq (fn ^:static seq][seq]]
returns a sequence of map entries, which are key/value pairs. Sorted
map also supports [[clojure:core.clj::(defn rseq][rseq]], which returns the entries in reverse
order. Maps implement IFn, for invoke() of one argument (a key) with
an optional second argument (a default value), i.e. maps are functions
of their keys. nil keys and values are ok.

**** Related functions

Create a new map: [[clojure:core.clj::(defn hash-map][hash-map]], [[clojure:core.clj::(defn sorted-map][sorted-map]], [[clojure:core.clj::(defn sorted-map-by][sorted-map-by]].

'change' a map: [[clojure:core.clj::(fn ^:static assoc][assoc]], [[clojure:core.clj::(defn dissoc][dissoc]], [[clojure:core.clj::(defn select-keys][select-keys]], [[clojure:core.clj::(defn merge][merge]], [[clojure:core.clj::(defn merge-with][merge-with]], [[clojure:core.clj::(defn
zipmap][zipmap]].

Examine a map: [[clojure:core.clj::(defn get][get]], [[clojure:core.clj::(defn contains?][contains?]], [[clojure:core.clj::(defn find][find]], [[clojure:core.clj::(defn keys][keys]], [[clojure:core.clj::(defn vals][vals]], [[clojure:core.clj::map? (fn ^:static map?][map?]].

Examine a map entry: [[clojure:core.clj::1569][key]], [[clojure:core.clj::1576][val]].

*** StructMaps

#+BEGIN_QUOTE
*Note*

Most uses of StructMaps would now be better served by [[#content/reference/datatypes][records]].
#+END_QUOTE

Often many map instances have the same base set of keys, for instance
when maps are used as structs or objects would be in other languages.
StructMaps support this use case by efficiently sharing the key
information, while also providing optional enhanced-performance
accessors to those keys. StructMaps are in all ways maps, supporting the
same set of functions, are interoperable with all other maps, and are
persistently extensible (i.e. struct maps are not limited to their base
keys). The only restriction is that you cannot dissociate a struct map
from one of its base keys. A struct map will retain its base keys in
order.

StructMaps are created by first creating a structure basis object
using [[clojure:core.clj::(defn create-struct][create-struct]] or [[clojure:core.clj::(defmacro defstruct][defstruct]], then creating instances with
[[clojure:core.clj::(defn
struct-map][struct-map]] or [[clojure:core.clj::4050][struct]].

#+BEGIN_SRC clojure
(defstruct desilu :fred :ricky)
(def x (map (fn [n]
              (struct-map desilu
                :fred n
                :ricky 2
                :lucy 3
                :ethel 4))
             (range 100000)))
(def fred (accessor desilu :fred))
(reduce (fn [n y] (+ n (:fred y))) 0 x)
 -> 4999950000
(reduce (fn [n y] (+ n (fred y))) 0 x)
 -> 4999950000
#+END_SRC

**** Related functions

StructMap setup: [[clojure:core.clj::(defn create-struct][create-struct]], [[clojure:core.clj::(defmacro defstruct][defstruct]], [[clojure:core.clj::(defn accessor][accessor]].

Create individual struct: [[clojure:core.clj::(defn struct-map][struct-map]], [[clojure:core.clj::4050][struct]].

*** ArrayMaps

When doing code form manipulation it is often desirable to have a map
which maintains key order. An array map is such a map - it is simply
implemented as an array of key val key val...​ As such, it has linear
lookup performance, and is only suitable for /very small/ maps. It
implements the full map interface. New ArrayMaps can be created with
the [[clojure:core.clj::(defn array-map][array-map]] function. Note that an array map will only maintain sort
order when un-'modified'. Subsequent assoc-ing will eventually cause
it to 'become' a hash-map.

*** Sets
:PROPERTIES:
:CUSTOM_ID: content/reference/data_structures#sets
:END:

Sets are collections of unique values.

There is literal support for hash-sets:

#+BEGIN_SRC clojure
#{:a :b :c :d}
-> #{:d :a :b :c}
#+END_SRC

You can create sets with the [[clojure:core.clj::(defn hash-set][hash-set]] and [[clojure:core.clj::(defn sorted-set][sorted-set]] functions:

#+BEGIN_SRC clojure
(hash-set :a :b :c :d)
-> #{:d :a :b :c}

(sorted-set :a :b :c :d)
-> #{:a :b :c :d}
#+END_SRC

You can also get a set of the values in a collection using the [[clojure:core.clj::4093][set]]
function:

#+BEGIN_SRC clojure
(set [1 2 3 2 1 2 3])
-> #{1 2 3}
#+END_SRC

Sets are collections:

#+BEGIN_SRC clojure
(def s #{:a :b :c :d})
(conj s :e)
-> #{:d :a :b :e :c}

(count s)
-> 4

(seq s)
-> (:d :a :b :c)

(= (conj s :e) #{:a :b :c :d :e})
-> true
#+END_SRC

Sets support 'removal' with [[clojure:core.clj::(defn disj][disj]], as well as ~contains?~ and ~get~, the
latter returning the object that is held in the set which compares
equal to the key, if found:

#+BEGIN_SRC clojure
(disj s :d)
-> #{:a :b :c}

(contains? s :b)
-> true

(get s :a)
-> :a
#+END_SRC

Sets are functions of their members, using ~get~:

#+BEGIN_SRC clojure
(s :b)
-> :b

(s :k)
-> nil
#+END_SRC

Clojure provides basic set operations like [[clojure:set.clj::(defn union][union]] / [[clojure:set.clj::(defn difference][difference]] /
[[clojure:set.clj::(defn
intersection][intersection]], as well as some pseudo-relational algebra support for
'relations', which are simply sets of maps - [[clojure:set.clj::(defn select][select]] / [[clojure:set.clj::(defn index][index]] / [[clojure:set.clj::89][rename]] / [[clojure:set.clj::(defn
join][join]].

** Datatypes
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/datatypes.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/datatypes
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/data_structures
:NEXTPAGE_CUSTOM_ID: content/reference/sequences
:CUSTOM_ID: content/reference/datatypes
:END:
*** Motivation

Clojure is written in terms of abstractions. There are abstractions
for sequences, collections, callability, etc. In addition, Clojure
supplies many implementations of these abstractions. The abstractions
are specified by host interfaces, and the implementations by host
classes.  While this was sufficient for bootstrapping the language, it
left Clojure without similar abstraction and low-level implementation
facilities. The [[#content/reference/protocols][protocols]] and [[#][datatypes]] features add powerful and
flexible mechanisms for abstraction and data structure definition with
no compromises vs the facilities of the host platform.

*** Basics

The datatype features - [[clojure:core_deftype.clj::(defmacro deftype][deftype]] , [[clojure:core_deftype.clj::(defmacro defrecord][defrecord]] and [[clojure:core_deftype.clj::(defmacro reify][reify]] , provide the
mechanism for defining implementations of abstractions, and in the
case of reify, instances of those implementations. The abstractions
themselves are defined by either [[#content/reference/protocols][protocols]] or interfaces. A datatype
provides a host type, (named in the case of deftype and defrecord,
anonymous in the case of reify), with some structure (explicit fields
in the case of deftype and defrecord, implicit closure in the case of
reify), and optional in-type implementations of abstraction
methods. They support, in a relatively clean manner, access to the
highest-performance primitive representation and polymorphism
mechanisms of the host. N.B.  that they are not merely host-in-parens
constructs. They support only a circumscribed subset of the host
facilities, often with more dynamism than the host itself. The intent
is that, unless interop forces one to go beyond their circumscribed
scope, one need not leave Clojure to get the highest-performing data
structures possible on the platform.

*** deftype and defrecord

[[clojure:core_deftype.clj::(defmacro deftype][deftype]] and [[clojure:core_deftype.clj::(defmacro defrecord][defrecord]] dynamically generate compiled bytecode for a
named class with a set of given fields, and, optionally, methods for
one or more protocols and/or interfaces. They are suitable for dynamic
and interactive development, need not be AOT compiled, and can be
re-evaluated in the course of a single session. They are similar to
defstruct in generating data structures with named fields, but differ
from defstruct in that:

- They generate a unique class, with fields corresponding to the given
  names.
- the resulting class has a proper type, unlike conventions for
  encoding type for structs in metadata
- because they generate a named class, it has an accessible constructor
- fields can have type hints, and can be primitive
  - note that currently a type hint of a non-primitive type will not
    be used to constrain the field type nor the constructor arg, but
    will be used to optimize its use in the class methods
  - constraining the field type and constructor arg is planned
- a deftype/defrecord can implement one or more protocols and/or
  interfaces
- deftype/defrecord can be written with a special reader syntax
  #my.thing[1 2 3] where:
  - each element in the vector form is passed to the
    deftype/defrecord's constructor un-evaluated
  - the deftype/defrecord name must be fully qualified
  - only available in Clojure versions later than 1.3
- when a deftype/defrecord Foo is defined a corresponding function
  ~->Foo~ is defined that passes its arguments to the constructor
  (versions 1.3 and later only)

[[clojure:core_deftype.clj::(defmacro deftype][deftype]] and [[clojure:core_deftype.clj::(defmacro defrecord][defrecord]] differ in the following ways:

- deftype provides no functionality not specified by the user, other
  than a constructor
- defrecord provides a complete implementation of a persistent map,
  including:
  - value-based equality and hashCode
  - metadata support
  - associative support
  - keyword accessors for fields
  - extensible fields (you can assoc keys not supplied with the
    defrecord definition)
  - etc
- deftype supports mutable fields, defrecord does not
- defrecord supports an additional reader form of #my.record{:a 1, :b
  2} taking a map that initializes a defrecord according to:
  - the defrecord name must be fully qualified
  - the elements in the map are un-evaluated
  - existing defrecord fields take the keyed values
  - defrecord fields without keyed values in the literal map are
    initialized to nil
  - additional keyed values are allowed and added to the defrecord
  - only available in Clojure versions later than 1.3
- when a defrecord Bar is defined a corresponding function ~map->Bar~
  is defined that takes a map and initializes a new record instance
  with its contents (versions 1.3 and later only)

*** Why have both deftype and defrecord?

It ends up that classes in most OO programs fall into two distinct
categories: those classes that are artifacts of the
implementation/programming domain, e.g. String or collection classes, or
Clojure's reference types; and classes that represent application domain
information, e.g. Employee, PurchaseOrder etc. It has always been an
unfortunate characteristic of using classes for application domain
information that it resulted in information being hidden behind
class-specific micro-languages, e.g. even the seemingly harmless
employee.getName() is a custom interface to data. Putting information in
such classes is a problem, much like having every book being written in
a different language would be a problem. You can no longer take a
generic approach to information processing. This results in an explosion
of needless specificity, and a dearth of reuse.

This is why Clojure has always encouraged putting such information in
maps, and that advice doesn't change with datatypes. By using defrecord
you get generically manipulable information, plus the added benefits of
type-driven polymorphism, and the structural efficiencies of fields.
OTOH, it makes no sense for a datatype that defines a collection like
vector to have a default implementation of map, thus deftype is suitable
for defining such programming constructs.

Overall, records will be better than structmaps for all
information-bearing purposes, and you should move such structmaps to
defrecord. It is unlikely much code was trying to use structmaps for
programming constructs, but if so, you will find deftype much more
suitable.

AOT-compiled deftype/defrecord may be suitable for some of the use cases
of ~gen-class~, where their limitations are not prohibitive. In those
cases, they will have better performance than gen-class.

*** Datatypes and protocols are opinionated

While datatypes and protocols have well-defined relationships with host
constructs, and make for a great way to expose Clojure functionality to
Java programs, they are not primarily interop constructs. That is, they
make no effort to completely mimic or adapt to all of the OO mechanisms
of the host. In particular, they reflect the following opinions:

- Concrete derivation is bad
  - you cannot derive datatypes from concrete classes, only interfaces
- You should always program to protocols or interfaces
  - datatypes cannot expose methods not in their protocols or
    interfaces
- Immutability should be the default
  - and is the only option for records
- Encapsulation of information is folly
  - fields are public, use protocols/interfaces to avoid dependencies
- Tying polymorphism to inheritance is bad
  - protocols free you from that

If you use datatypes and protocols you will have a clean,
interface-based API to offer your Java consumers. If you are dealing
with a clean, interface-based Java API, datatypes and protocols can be
used to interoperate with and extend it. If you have a 'bad' Java API,
you will have to use gen-class. Only in this way can the programming
constructs you use to design and implement your Clojure programs be free
of the incidental complexities of OO.

*** reify

While deftype and defrecord define named types, [[clojure:core_deftype.clj::(defmacro reify][reify]] defines both an
anonymous type and creates an instance of that type. The use case is
where you need a one-off implementation of one or more protocols or
interfaces and would like to take advantage of the local context. In
this respect its use case is similar to proxy, or anonymous inner
classes in Java.

The method bodies of reify are lexical closures, and can refer to the
surrounding local scope. *reify* differs from *proxy* in that:

- Only protocols or interfaces are supported, no concrete superclass.
- The method bodies are true methods of the resulting class, not
  external fns.
- Invocation of methods on the instance is direct, not using map
  lookup.
- No support for dynamic swapping of methods in the method map.

The result is better performance than proxy, both in construction and
invocation. *reify* is preferable to proxy in all cases where its
constraints are not prohibitive.

*** Java annotation support
:PROPERTIES:
:CUSTOM_ID: content/reference/datatypes#java-annotation-support
:END:

Types created with deftype, defrecord, and definterface, can emit
classes that include Java annotations for Java interop. Annotations are
described as meta on:

- Type name (deftype/record/interface) - class annotations
- Field names (deftype/record) - field annotations
- Method names (deftype/record) - method annotations

Example:

#+BEGIN_SRC clojure
(import [java.lang.annotation Retention RetentionPolicy Target ElementType]
        [javax.xml.ws WebServiceRef WebServiceRefs])

(definterface Foo (foo []))

;; annotation on type
(deftype ^{Deprecated true
           Retention RetentionPolicy/RUNTIME
           javax.annotation.processing.SupportedOptions ["foo" "bar" "baz"]
           javax.xml.ws.soap.Addressing {:enabled false :required true}
           WebServiceRefs [(WebServiceRef {:name "fred" :type String})
                           (WebServiceRef {:name "ethel" :mappedName "lucy"})]}
  Bar [^int a
       ;; on field
       ^{:tag int
         Deprecated true
         Retention RetentionPolicy/RUNTIME
         javax.annotation.processing.SupportedOptions ["foo" "bar" "baz"]
         javax.xml.ws.soap.Addressing {:enabled false :required true}
         WebServiceRefs [(WebServiceRef {:name "fred" :type String})
                         (WebServiceRef {:name "ethel" :mappedName "lucy"})]}
       b]
  ;; on method
  Foo (^{Deprecated true
         Retention RetentionPolicy/RUNTIME
         javax.annotation.processing.SupportedOptions ["foo" "bar" "baz"]
         javax.xml.ws.soap.Addressing {:enabled false :required true}
         WebServiceRefs [(WebServiceRef {:name "fred" :type String})
                         (WebServiceRef {:name "ethel" :mappedName "lucy"})]}
       foo [this] 42))

(seq (.getAnnotations Bar))
(seq (.getAnnotations (.getField Bar "b")))
(seq (.getAnnotations (.getMethod Bar "foo" nil)))
#+END_SRC

** Sequences
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/sequences.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/sequences
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/datatypes
:NEXTPAGE_CUSTOM_ID: content/reference/transients
:CUSTOM_ID: content/reference/sequences
:END:

Clojure defines many algorithms in terms of sequences (seqs). A seq is
a logical list, and unlike most Lisps where the list is represented by
a concrete, 2-slot structure, Clojure uses the ISeq interface to allow
many data structures to provide access to their elements as sequences.
The [[clojure:core.clj::seq (fn ^:static seq][seq]] function yields an implementation of ISeq appropriate to the
collection.  Seqs differ from iterators in that they are persistent
and immutable, not stateful cursors into a collection. As such, they
are useful for much more than foreach - functions can consume and
produce seqs, they are thread safe, they can share structure etc.

Most of the sequence library functions are /lazy/, i.e. functions that
return seqs do so incrementally, as they are consumed, and thus
consume any seq arguments incrementally as well. Functions returning
lazy seqs can be implemented using the [[clojure:core.clj::(defmacro lazy-seq][lazy-seq]] macro. See also [[#content/reference/lazy][lazy]].

When [[clojure:core.clj::seq (fn ^:static seq][seq]] is used on objects that implement Iterable, the resulting
sequence is still immutable and persistent, and will represent a
single pass across the data. Because that pass might happen lazily,
the pass might see changes that happen after [[clojure:core.clj::seq (fn ^:static seq][seq]] has been
called. Also, if the backing iterator is subject to
ConcurrentModificationException, then so too is the resulting
seq. When seq is used on native Java arrays, changes to the underlying
array will be reflected in the seq - you must copy the source array to
get full immutability. That said, there is still a lot of utility to
using seq on Iterables and arrays since seqs support multi-pass and
lazy algorithms.  Robust programs should not mutate arrays or
Iterables that have seqs on them.

Many of the functions in the seq library take one or more collections,
call [[clojure:core.clj::seq (fn ^:static seq][seq]] on them, and then operate on the resulting seq. In other
words, many of these functions take collections but operate on their
seqs.

*** The Seq interface
**** (/first/ coll)

Returns the first item in the collection. Calls seq on its argument. If
coll is nil, returns nil.

**** (/rest/ coll)

Returns a sequence of the items after the first. Calls seq on its
argument. If there are no more items, returns a logical sequence for
which ~seq~ returns nil.

**** (/cons/ item seq)

Returns a new seq where item is the first element and seq is the rest.

For a discussion of ~rest~ vs. ~next~ and ~lazy-seq~ see [[#content/reference/lazy][lazy]].

*** The Seq library

This is a sampling of the primary sequence functions, grouped broadly by
their capabilities. Some functions can be used in different ways and so
appear in more than one group. There are many more listed in the
[[https://clojure.github.io/clojure/][API]] section.

Since Clojure 1.7, Clojure also provides [[#content/reference/transducers][transducers]], an alternate
model for composable transformations on collections. Transducers
decouple the input, processing, and output parts of transformation and
allow reuse of transformations in more contexts, such as core.async
channels. Many of the sequence functions in the list below will create
transducers if the input collection is omitted. See the Transducers
page for more details.

**** Seq in, Seq out

Shorter seq from a longer seq: [[clojure:core.clj::(defn distinct][distinct]], [[clojure:core.clj::(defn filter][filter]], [[clojure:core.clj::2830][remove]], [[clojure:core.clj::(defmacro for][for]], [[clojure:core.clj::(defn keep][keep]],
[[clojure:core.clj::(defn
keep-indexed][keep-indexed]].

Longer seq from a shorter seq: [[clojure:core.clj::cons (fn* ^:static cons][cons]], [[clojure:core.clj::(defn concat][concat]], [[clojure:core.clj::(defmacro lazy-cat][lazy-cat]], [[clojure:core.clj::(defn mapcat][mapcat]], [[clojure:core.clj::(defn cycle][cycle]],
[[clojure:core.clj::(defn
interleave][interleave]], [[clojure:core.clj::(defn interpose][interpose]].

Seq with head-items missing: [[clojure:core.clj::rest (fn ^:static rest][rest]], [[clojure:core.clj::next (fn ^:static next][next]], [[clojure:core.clj::fnext (fn ^:static fnext][fnext]], [[clojure:core.clj::nnext (fn ^:static nnext][nnext]], [[clojure:core.clj::(defn drop][drop]],
[[clojure:core.clj::(defn
drop-while][drop-while]], [[clojure:core.clj::(defn nthnext][nthnext]], [[clojure:core.clj::(defmacro for][for]].

Seq with tail-items missing: [[clojure:core.clj::(defn take][take]], [[clojure:core.clj::(defn take-nth][take-nth]], [[clojure:core.clj::(defn take-while][take-while]], [[clojure:core.clj::butlast (fn ^:static butlast][butlast]],
[[clojure:core.clj::(defn
drop-last][drop-last]], [[clojure:core.clj::(defmacro for][for]].

Rearrangment of a seq: [[clojure:core.clj::(defn flatten][flatten]], [[clojure:core.clj::(defn reverse][reverse]], [[clojure:core.clj::3090][sort]], [[clojure:core.clj::(defn sort-by][sort-by]], [[clojure:core.clj::(defn shuffle][shuffle]].

Create nested seqs: [[clojure:core.clj::(defn split-at][split-at]], [[clojure:core.clj::(defn split-with][split-with]], [[clojure:core.clj::(defn partition][partition]], [[clojure:core.clj::(defn partition-all][partition-all]],
[[clojure:core.clj::(defn
partition-by][partition-by]]

Process each item of a seq to create a new seq: [[clojure:core.clj::(defn map][map]], [[clojure:core.clj::(defn pmap][pmap]], [[clojure:core.clj::(defn mapcat][mapcat]],
[[clojure:core.clj::(defmacro
for][for]], [[clojure:core.clj::(defn replace][replace]], [[clojure:core.clj::(defn reductions][reductions]], [[clojure:core.clj::(defn map-indexed][map-indexed]], [[clojure:core.clj::5409][seque]]

**** Using a seq

Extract a specific-numbered item from a seq: [[clojure:core.clj::first (fn ^:static first][first]], [[clojure:core.clj::ffirst (fn ^:static ffirst][ffirst]], [[clojure:core.clj::nfirst (fn ^:static nfirst][nfirst]],
[[clojure:core.clj::second (fn ^:static
second][second]], [[clojure:core.clj::(defn nth][nth]], [[clojure:core.clj::(defmacro when-first][when-first]], [[clojure:core.clj::last (fn ^:static last][last]], [[clojure:core.clj::(defn rand-nth][rand-nth]].

Construct a collection from a seq: [[clojure:core.clj::(defn zipmap][zipmap]], [[clojure:core.clj::6928][into]], [[clojure:core.clj::(defn reduce][reduce]], [[clojure:core.clj::][set]], [[clojure:core.clj::369][vec]],
[[clojure:core.clj::(defn
into-array][into-array]], [[clojure:core.clj::(defn to-array-2d][to-array-2d]], [[clojure:core.clj::(defn frequencies][frequencies]], [[clojure:core.clj::(defn group-by][group-by]].

Pass items of a seq as arguments to a function: [[clojure:core.clj::(defn apply][apply]].

Compute a boolean from a seq: [[clojure:core.clj::(defn not-empty][not-empty]], [[clojure:core.clj::2696][some]], [[clojure:core.clj::(defn reduce][reduce]], [[clojure:core.clj::seq? (fn ^:static seq?][seq?]], [[clojure:core.clj::(defn every?][every?]],
[[clojure:core.clj:: not-every? (comp not
every?)][not-every?]], [[clojure:core.clj:: not-any? (comp not some))][not-any?]], [[clojure:core.clj::(defn empty?][empty?]].

Search a seq using a predicate: [[clojure:core.clj::2696][some]], [[clojure:core.clj::(defn filter][filter]].

Force evaluation of lazy seqs: [[clojure:core.clj::(defmacro doseq][doseq]], [[clojure:core.clj::(defn dorun][dorun]], [[clojure:core.clj::(defn doall][doall]].

Check if lazy seqs have been forcibly evaluated: [[clojure:core.clj::(defn realized?][realized?]].

**** Creating a seq

Lazy seq from collection: [[clojure:core.clj::seq (fn ^:static seq][seq]], [[clojure:core.clj::(defn vals][vals]], [[clojure:core.clj::(defn keys][keys]], [[clojure:core.clj::(defn rseq][rseq]], [[clojure:core.clj::(defn subseq][subseq]], [[clojure:core.clj::(defn rsubseq][rsubseq]].

Lazy seq from producer function: [[clojure:core.clj::(defmacro lazy-seq][lazy-seq]], [[clojure:core.clj::(defn repeatedly][repeatedly]], [[clojure:core.clj::(defn iterate][iterate]].

Lazy seq from constant: [[clojure:core.clj::(defn repeat][repeat]], [[clojure:core.clj::(defn range][range]].

Lazy seq from other objects: [[clojure:core.clj::(defn line-seq][line-seq]], [[clojure:core.clj::(defn resultset-seq][resultset-seq]], [[clojure:core.clj::(defn re-seq][re-seq]],
[[clojure:core.clj::(defn
tree-seq][tree-seq]], [[clojure:core.clj::(defn file-seq][file-seq]], [[clojure:core.clj::(defn xml-seq][xml-seq]], [[clojure:core.clj::(defn iterator-seq][iterator-seq]], [[clojure:core.clj::(defn enumeration-seq][enumeration-seq]].

** Transient Data Structures
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/transients.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/transients
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/sequences
:NEXTPAGE_CUSTOM_ID: content/reference/transducers
:CUSTOM_ID: content/reference/transients
:END:
*** Rationale

/If a tree falls in the woods, does it make a sound?/

/If a pure function mutates some local data in order to produce an
immutable return value, is that ok?/

It's an interesting question. Clojure data structures use mutation every
time you call, e.g. ~assoc~, creating one or more arrays and mutating
them, before returning them for immutable use thereafter. The reason is
performance - you simply can't get as fast using only pure functions and
immutable data. Once constructed and shared however, being immutable and
persistent is essential to robust programs. The things Clojure mutates
internally are small, newly allocated arrays that constitute the
internal nodes of its data structures. No one ever sees the arrays.

You run into a similar scenario, at a higher level, when you want to
initialize or transform a large persistent data structure using multiple
steps, none of which will be seen by any code other than the
constructing/transforming code. The challenge here is that the source of
a transformation will be an existing persistent data structure, and the
result of the function /will/ be shared. Copying into a traditional
mutable data structure and back involves O(n) copying, and the internal
code is an imperative mess quite unlike the rest of your Clojure code.
Furthermore, there are no guards against accidentally sharing or
aliasing the mutable data structure, especially if you need to call
helper functions to do the work. In short, it would be a shame if you
had to leave Clojure's model in order to speed up a piece of code like
this. Transient data structures are a solution to this optimization
problem that integrates with the Clojure model and provides the same
thread safety guarantees you expect of Clojure.

*** How they work

Transient data structures are always created from an existing persistent
Clojure data structure. As of Clojure 1.1.0, vectors, hash-maps, and
hash-sets are supported. Note that not all Clojure data structures can
support this feature, but most will. Lists will not, as there is no
benefit to be had.

You obtain a transient 'copy' of a data structure by calling
~transient~. This creates a new transient data structure that is a copy
of the source, and has the same performance characteristics. In fact, it
mostly /is/ the source data structure, and highlights the first feature
of transients - creating one is O(1). It shares structure with its
source, just as persistent copies share structure.

The second feature of transients is that creating one does not modify
the source, and the source cannot be modified via use of the transient.
Your source data is immutable and persistent as always.

Transients support the read-only interface of the source, i.e. you can
call ~nth~, ~get~, ~count~ and fn-call a transient vector, just like a
persistent vector.

Transients *do not* support the persistent interface of the source
data structure. ~assoc~, ~conj~ etc will all throw exceptions, because
transients are not persistent. Thus you cannot accidentally leak a
transient into a context requiring a persistent.

Transients support a parallel set of 'changing' operations, with similar
names followed by ~!~ - ~assoc!~, ~conj!~ etc. These do the same things
as their persistent counterparts except the return values are themselves
transient. Note in particular that transients are not designed to be
bashed in-place. You must capture and use the return value in the next
call. In this way, they support the same code structure as the
functional persistent code they replace. As the example will show, this
will allow you to easily enhance the performance of a piece of code
without structural change.

When you are finished building up your results, you can create a
persistent data structure by calling ~persistent!~ on the transient.
This operation is also O(1). Subsequent to calling ~persistent!~, the
transient should not be used, and all operations will throw exceptions.
This will be true also for any aliases you might have created.

*** Example

Here's a very typical example, some code that builds up a vector for
return, all 'changes' being local to the function. Note how the
transient-using version has exactly the same structure, just:

- Calling ~transient~ on the source vector
- Using ~conj!~ instead of ~conj~
- Calling ~persistent!~ on return

#+BEGIN_EXAMPLE
(defn vrange [n]
  (loop [i 0 v []]
    (if (< i n)
      (recur (inc i) (conj v i))
      v)))

(defn vrange2 [n]
  (loop [i 0 v (transient [])]
    (if (< i n)
      (recur (inc i) (conj! v i))
      (persistent! v))))

;; benchmarked (Java 1.8, Clojure 1.7)
(def v (vrange 1000000))    ;; 73.7 ms
(def v2 (vrange2 1000000))  ;; 19.7 ms
#+END_EXAMPLE

Oh, yeah, *transients are fast!*

*** Concurrent use

That's all there is to using transients, but they have another important
constraint: *Transients require thread isolation.* Because each result
of a transient operation shares (mutable) structure with the previous,
it is an error if more than one thread manipulates a transient at once.
Use of a particular transient instance should be controlled either by
using it in an single-threaded scope, or in a framework that enforces
this.

In Clojure 1.6 and earlier, transients would detect any (read or write)
use from a thread other than the one that created them and throw an
exception. That check was removed in 1.7 to allow for more flexible use
in frameworks like core.async go blocks that enforce the single-threaded
constraint via other means.

*** Summary

Transients provide a high-performance optimization of functional
data-structure-building code that works with Clojure's data structures
and provides critical safety guarantees.

- Single-path use
- O(1) creation from persistent data structures
- Shares structure with persistent source
- O(1) creation of persistent data structure when editing session
  finished
- Same code structure as functional version
  - Capture return value, use for next call
  - Don't bash in place
  - Not persistent, so you can't hang onto interim values or alias
- Can't use after returning a persistent version
- Fast

Transient persistent vectors, hash-maps, and hash-sets were added in
Clojure 1.1.

** Transducers
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/transducers.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/transducers
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/transients
:NEXTPAGE_CUSTOM_ID: content/reference/multimethods
:CUSTOM_ID: content/reference/transducers
:END:

Transducers are composable algorithmic transformations. They are
independent from the context of their input and output sources and
specify only the essence of the transformation in terms of an individual
element. Because transducers are decoupled from input or output sources,
they can be used in many different processes - collections, streams,
channels, observables, etc. Transducers compose directly, without
awareness of input or creation of intermediate aggregates.

Also see the introductory [[https://blog.cognitect.com/blog/2014/8/6/transducers-are-coming][blog post]], this [[https://www.youtube.com/watch?v=6mTbuzafcII][video]], and this section of
the FAQ [[https://clojure.org/guides/faq#transducers_vs_seqs][about good use cases for transducers]].

*** Terminology

A /reducing function/ is the kind of function you'd pass to ~reduce~ -
it is a function that takes an accumulated result and a new input and
returns a new accumulated result:

#+BEGIN_SRC clojure
;; reducing function signature
whatever, input -> whatever
#+END_SRC

A /transducer/ (sometimes referred to as xform or xf) is a
transformation from one reducing function to another:

#+BEGIN_SRC clojure
;; transducer signature
(whatever, input -> whatever) -> (whatever, input -> whatever)
#+END_SRC

*** Defining Transformations With Transducers

Most sequence functions included in Clojure have an arity that produces
a transducer. This arity omits the input collection; the inputs will be
supplied by the process applying the transducer. /Note: this reduced
arity is not currying or partial application./

For example:

#+BEGIN_SRC clojure
(filter odd?) ;; returns a transducer that filters odd
(map inc)     ;; returns a mapping transducer for incrementing
(take 5)      ;; returns a transducer that will take the first 5 values
#+END_SRC

Transducers compose with ordinary function composition. A transducer
performs its operation before deciding whether and how many times to
call the transducer it wraps. The recommended way to compose transducers
is with the existing ~comp~ function:

#+BEGIN_SRC clojure
(def xf
  (comp
    (filter odd?)
    (map inc)
    (take 5)))
#+END_SRC

The transducer xf is a transformation stack that will be applied by a
process to a series of input elements. Each function in the stack is
performed /before/ the operation it wraps. Composition of the
transformer runs right-to-left but builds a transformation stack that
runs left-to-right (filtering happens before mapping in this example).

As a mnemonic, remember that the ordering of transducer functions in
~comp~ is the same order as sequence transformations in ~->>~. The
transformation above is equivalent to the sequence transformation:

#+BEGIN_SRC clojure
(->> coll
     (filter odd?)
     (map inc)
     (take 5))
#+END_SRC

The following functions produce a transducer when the input collection
is omitted: [[clojure:core.clj::(defn map][map]], [[clojure:core.clj::(defn cat][cat]], [[clojure:core.clj::(defn mapcat][mapcat]], [[clojure:core.clj::(defn filter][filter]], [[clojure:core.clj::2830][remove]], [[clojure:core.clj::(defn take][take]], [[clojure:core.clj::(defn take-while][take-while]],
[[clojure:core.clj::(defn
take-nth][take-nth]], [[clojure:core.clj::(defn drop][drop]], [[clojure:core.clj::(defn drop-while][drop-while]], [[clojure:core.clj::(defn replace][replace]], [[clojure:core.clj::(defn partition-by][partition-by]], [[clojure:core.clj::(defn partition-all][partition-all]],
[[clojure:core.clj::(defn
keep][keep]], [[clojure:core.clj::(defn keep-indexed][keep-indexed]], [[clojure:core.clj::(defn map-indexed][map-indexed]], [[clojure:core.clj::(defn distinct][distinct]], [[clojure:core.clj::(defn interpose][interpose]], [[clojure:core.clj::(defn dedupe][dedupe]], [[clojure:core.clj::(defn
random-sample][random-sample]].

**** Using Transducers

Transducers can be used in many contexts (see below for how to create
new ones).

**** transduce

One of the most common ways to apply transducers is with the [[clojure:core.clj::(defn transduce][transduce]]
function, which is analogous to the standard reduce function:

#+BEGIN_SRC clojure
(transduce xform f coll)
(transduce xform f init coll)
#+END_SRC

~transduce~ will immediately (not lazily) reduce over ~coll~ with the
transducer ~xform~ applied to the reducing function ~f~, using init as
the initial value if supplied or (f) otherwise. f supplies the knowledge
of how to accumulate the result, which occurs in the (potentially
stateful) context of the reduce.

#+BEGIN_SRC clojure
(def xf (comp (filter odd?) (map inc)))
(transduce xf + (range 5))
;; => 6
(transduce xf + 100 (range 5))
;; => 106
#+END_SRC

The composed xf transducer will be invoked left-to-right with a final
call to the reducing function f. In the last example, input values will
be filtered, then incremented, and finally summed.

[[./assets/images/content/reference/transducers/xf.png]]

**** eduction

To capture the process of applying a transducer to a coll, use the
[[clojure:core.clj::(defn
eduction][eduction]] function. It takes any number of xforms and a final coll and
returns a reducible/iterable application of the transducer to the
items in coll.  These applications will be performed each time
reduce/iterator is called.

#+BEGIN_SRC clojure
(def iter (eduction xf (range 5)))
(reduce + 0 iter)
;; => 6
#+END_SRC

**** into

To apply a transducer to an input collection and construct a new
output collection, use [[clojure:core.clj::6928][into]] (which efficiently uses reduce and
transients if possible):

#+BEGIN_SRC clojure
(into [] xf (range 1000))
#+END_SRC

**** sequence

To create a sequence from the application of a transducer to an input
collection, use [[clojure:core.clj::(defn sequence][sequence]]:

#+BEGIN_SRC clojure
(sequence xf (range 1000))
#+END_SRC

The resulting sequence elements are incrementally computed. These
sequences will consume input incrementally as needed and fully realize
intermediate operations. This behavior differs from the equivalent
operations on lazy sequences.

*** Creating Transducers

Transducers have the following shape (custom code in "...​"):

#+BEGIN_SRC clojure
(fn [rf]
  (fn ([] ...)
      ([result] ...)
      ([result input] ...)))
#+END_SRC

Many of the core sequence functions (like map, filter, etc) take
operation-specific arguments (a predicate, function, count, etc) and
return a transducer of this shape closing over those arguments. In some
cases, like ~cat~, the core function /is/ a transducer function and does
not take an ~rf~.

The inner function is defined with 3 arities used for different
purposes:

- *Init* (arity 0) - should call the init arity on the nested transform
  *rf*, which will eventually call out to the transducing process.
- *Step* (arity 2) - this is a standard reduction function but it is
  expected to call the ~rf~ step arity 0 or more times as appropriate
  in the transducer. For example, filter will choose (based on the
  predicate) whether to call ~rf~ or not. map will always call it
  exactly once. cat may call it many times depending on the inputs.
- *Completion* (arity 1) - some processes will not end, but for those
  that do (like ~transduce~), the completion arity is used to produce a
  final value and/or flush state. This arity must call the ~rf~
  completion arity exactly once.

An example use of ~completion~ is ~partition-all~, which must flush any
remaining elements at the end of the input. The [[clojure:core.clj::(defn completing][completing]] function
can be used to convert a reducing function to a transducing function
by adding a default completion arity.

**** Early termination

Clojure has a mechanism for specifying early termination of a reduce:

- [[clojure:core.clj::(defn reduced][reduced]] - takes a value and returns a /reduced/ value indicating
  reduction should stop
- [[clojure:core.clj::(defn reduced?][reduced?]] - returns true if the value was created with /reduced/
- [[clojure:core.clj::(defn deref][deref]] or @ can be used to retrieve the value inside a /reduced/

A process that uses transducers must check for and stop when the step
function returns a reduced value (more on that in Creating Transducible
Processes). Additionally, a transducer step function that uses a nested
reduce must check for and convey reduced values when they are
encountered. (See the implementation of cat for an example.)

**** Transducers with reduction state

Some transducers (such as ~take~, ~partition-all~, etc) require state
during the reduction process. This state is created each time the
transducible process applies the transducer. For example, consider the
dedupe transducer that collapses a series of duplicate values into a
single value. This transducer must remember the previous value to
determine whether the current value should be passed on:

#+BEGIN_SRC clojure
(defn dedupe []
  (fn [xf]
    (let [prev (volatile! ::none)]
      (fn
        ([] (xf))
        ([result] (xf result))
        ([result input]
          (let [prior @prev]
            (vreset! prev input)
              (if (= prior input)
                result
                (xf result input))))))))
#+END_SRC

In dedupe, ~prev~ is a stateful container that stores the previous value
during the reduction. The prev value is a volatile for performance, but
it could also be an atom. The prev value will not be initialized until
the transducing process starts (in a call to ~transduce~ for example).
The stateful interactions are therefore contained within the context of
the transducible process.

In the completion step, a transducer with reduction state should flush
state prior to calling the nested transformer's completion function,
unless it has previously seen a reduced value from the nested step in
which case pending state should be discarded.

*** Creating Transducible Processes

Transducers are designed to be used in many kinds of processes. A
transducible process is defined as a succession of steps where each step
ingests an input. The source of the inputs is specific to each process
(from a collection, an iterator, a stream, etc). Similarly, the process
must choose what to do with the outputs produced by each step.

If you have a new context for applying transducers, there are a few
general rules to be aware of:

- If a step function returns a /reduced/ value, the transducible
  process must not supply any more inputs to the step function. The
  reduced value must be unwrapped with deref before completion.
- A completing process must call the completion operation on the final
  accumulated value exactly once.
- A transducing process must encapsulate references to the function
  returned by invoking a transducer - these may be stateful and unsafe
  for use across threads.

** Multimethods and Hierarchies
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/multimethods.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/multimethods
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/transducers
:NEXTPAGE_CUSTOM_ID: content/reference/protocols
:CUSTOM_ID: content/reference/multimethods
:END:

Clojure eschews the traditional object-oriented approach of creating a
new data type for each new situation, instead preferring to build a
large library of functions on a small set of types. However, Clojure
fully recognizes the value of runtime polymorphism in enabling flexible
and extensible system architecture. Clojure supports sophisticated
runtime polymorphism through a multimethod system that supports
dispatching on types, values, attributes and metadata of, and
relationships between, one or more arguments.

A Clojure multimethod is a combination of a /dispatching/ /function/, and
one or more /methods/. When a multimethod is defined, using ~defmulti~, a
dispatching function must be supplied. This function will be applied
to the arguments to the multimethod in order to produce a /dispatching
value/. The multimethod will then try to find the method associated
with the dispatching value or a value from which the dispatching value
is derived. If one has been defined (via [[clojure:core.clj::(defmacro defmethod][defmethod]]), it will then be
called with the arguments and that will be the value of the
multimethod call. If no method is associated with the dispatching
value, the multimethod will look for a method associated with the
default dispatching value (which defaults to ~:default~), and will use
that if present. Otherwise the call is an error.

The multimethod system exposes this API: [[clojure:core.clj::(defmacro defmulti][defmulti]] creates new
multimethods, [[clojure:core.clj::(defmacro defmethod][defmethod]] creates and installs a new method of
multimethod associated with a dispatch-value, [[clojure:core.clj::(defn remove-method][remove-method]] removes
the method associated with a dispatch-value and [[clojure:core.clj::(defn prefer-method][prefer-method]] creates
an ordering between methods when they would otherwise be ambiguous.

Derivation is determined by a combination of either Java inheritance
(for class values), or using Clojure's ad hoc hierarchy system. The
hierarchy system supports derivation relationships between names
(either symbols or keywords), and relationships between classes and
names. The [[clojure:core.clj::(defn derive][derive]] function creates these relationships, and the [[clojure:core.clj::(defn isa?][isa?]]
function tests for their existence. Note that [[clojure:core.clj::(defn isa?][isa?]]  is not [[clojure:core.clj::instance? (fn instance?][instance?]].

You can define hierarchical relationships with (derive child parent).
Child and parent can be either symbols or keywords, and must be
namespace-qualified:

/Note the :: reader syntax, ::keywords resolve namespaces./

#+BEGIN_SRC clojure
::rect
-> :user/rect
#+END_SRC

[[clojure:core.clj::(defn derive][derive]] is the fundamental relationship-maker

#+BEGIN_SRC clojure
(derive ::rect ::shape)
(derive ::square ::rect)
#+END_SRC

[[clojure:core.clj::(defn parents][parents]] / [[clojure:core.clj::(defn ancestors][ancestors]] / [[clojure:core.clj::(defn descendants][descendants]] and [[clojure:core.clj::(defn isa?][isa?]]  let you query the
hierarchy

#+BEGIN_SRC clojure
(parents ::rect)
-> #{:user/shape}

(ancestors ::square)
-> #{:user/rect :user/shape}

(descendants ::shape)
-> #{:user/rect :user/square}
#+END_SRC

~(= x y)~ implies ~(isa? x y)~

#+BEGIN_SRC clojure
(isa? 42 42)
-> true
#+END_SRC

~isa?~ uses the hierarchy system

#+BEGIN_SRC clojure
(isa? ::square ::shape)
-> true
#+END_SRC

You can also use a class as the child (but not the parent, the only way
to make something the child of a class is via Java inheritance).

This allows you to superimpose new taxonomies on the existing Java class
hierarchy:

#+BEGIN_SRC clojure
(derive java.util.Map ::collection)
(derive java.util.Collection ::collection)

(isa? java.util.HashMap ::collection)
-> true
#+END_SRC

[[clojure:core.clj::(defn isa?][isa?]]  also tests for class relationships:

#+BEGIN_SRC clojure
(isa? String Object)
-> true
#+END_SRC

as do [[clojure:core.clj::(defn parents][parents]] / [[clojure:core.clj::(defn ancestors][ancestors]] (but not [[clojure:core.clj::(defn descendants][descendants]], since class
descendants are an open set)

#+BEGIN_SRC clojure
(ancestors java.util.ArrayList)
-> #{java.lang.Cloneable java.lang.Object java.util.List
    java.util.Collection java.io.Serializable
    java.util.AbstractCollection
    java.util.RandomAccess java.util.AbstractList}
#+END_SRC

[[clojure:core.clj::(defn isa?][isa?]]  works with vectors by calling [[clojure:core.clj::(defn isa?][isa?]]  on their corresponding
elements:

#+BEGIN_SRC clojure
(isa? [::square ::rect] [::shape ::shape])
-> true
#+END_SRC

*** isa? based dispatch

Multimethods use [[clojure:core.clj::(defn isa?][isa?]]  rather than = when testing for dispatch value
matches. Note that the first test of [[clojure:core.clj::(defn isa?][isa?]]  is =, so exact matches
work.

#+BEGIN_SRC clojure
(defmulti foo class)
(defmethod foo ::collection [c] :a-collection)
(defmethod foo String [s] :a-string)

(foo [])
:a-collection

(foo (java.util.HashMap.))
:a-collection

(foo "bar")
:a-string
#+END_SRC

[[clojure:core.clj::(defn prefer-method][prefer-method]] is used for disambiguating in case of multiple matches
where neither dominates the other. You can just declare, per
multimethod, that one dispatch value is preferred over another:

#+BEGIN_SRC clojure
(derive ::rect ::shape)

(defmulti bar (fn [x y] [x y]))
(defmethod bar [::rect ::shape] [x y] :rect-shape)
(defmethod bar [::shape ::rect] [x y] :shape-rect)

(bar ::rect ::rect)
-> Execution error (IllegalArgumentException) at user/eval152 (REPL:1).
   Multiple methods in multimethod 'bar' match dispatch value:
   [:user/rect :user/rect] -> [:user/shape :user/rect]
   and [:user/rect :user/shape], and neither is preferred

(prefer-method bar [::rect ::shape] [::shape ::rect])
(bar ::rect ::rect)
-> :rect-shape
#+END_SRC

All of the examples above use the global hierarchy used by the
multimethod system, but entire independent hierarchies can also be
created with [[clojure:core.clj::(defn make-hierarchy][make-hierarchy]], and all of the above functions can take
an optional hierarchy as a first argument.

This simple system is extremely powerful. One way to understand the
relationship between Clojure multimethods and traditional Java-style
single dispatch is that single dispatch is like a Clojure multimethod
whose dispatch function calls getClass on the first argument, and whose
methods are associated with those classes. Clojure multimethods are not
hard-wired to class/type, they can be based on any attribute of the
arguments, on multiple arguments, can do validation of arguments and
route to error-handling methods etc.

Note: In this example, the keyword :Shape is being used as the dispatch
function, as keywords are functions of maps, as described in the
[[#content/reference/data_structures][Data Structures]] section.

#+BEGIN_SRC clojure
(defmulti area :Shape)
(defn rect [wd ht] {:Shape :Rect :wd wd :ht ht})
(defn circle [radius] {:Shape :Circle :radius radius})
(defmethod area :Rect [r]
    (* (:wd r) (:ht r)))
(defmethod area :Circle [c]
    (* (. Math PI) (* (:radius c) (:radius c))))
(defmethod area :default [x] :oops)
(def r (rect 4 13))
(def c (circle 12))
(area r)
-> 52
(area c)
-> 452.3893421169302
(area {})
-> :oops
#+END_SRC

** Protocols
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/protocols.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/protocols
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/multimethods
:NEXTPAGE_CUSTOM_ID: content/reference/metadata
:CUSTOM_ID: content/reference/protocols
:END:
*** Motivation

Clojure is written in terms of abstractions. There are abstractions
for sequences, collections, callability, etc. In addition, Clojure
supplies many implementations of these abstractions. The abstractions
are specified by host interfaces, and the implementations by host
classes.  While this was sufficient for bootstrapping the language, it
left Clojure without similar abstraction and low-level implementation
facilities. The [[#][protocols]] and [[#content/reference/datatypes][datatypes]] features add powerful and
flexible mechanisms for abstraction and data structure definition with
no compromises vs the facilities of the host platform.

There are several motivations for protocols:

- Provide a high-performance, dynamic polymorphism construct as an
  alternative to interfaces
- Support the best parts of interfaces
  - specification only, no implementation
  - a single type can implement multiple protocols
- While avoiding some of the drawbacks
  - Which interfaces are implemented is a design-time choice of the
    type author, cannot be extended later (although interface
    injection might eventually address this)
  - implementing an interface creates an isa/instanceof type
    relationship and hierarchy
- Avoid the 'expression problem' by allowing independent extension of
  the set of types, protocols, and implementations of protocols on
  types, by different parties
  - do so without wrappers/adapters
- Support the 90% case of multimethods (single dispatch on type) while
  providing higher-level abstraction/organization

#+BEGIN_QUOTE
*Note*

Protocols were introduced in Clojure 1.2.
#+END_QUOTE

**** Basics

A protocol is a named set of named methods and their signatures,
defined using [[clojure:core_deftype.clj::(defmacro defprotocol][defprotocol]]:

#+BEGIN_SRC clojure
(defprotocol AProtocol
  "A doc string for AProtocol abstraction"
  (bar [a b] "bar docs")
  (baz [a] [a b] [a b c] "baz docs"))
#+END_SRC

- No implementations are provided
- Docs can be specified for the protocol and the functions
- The above yields a set of polymorphic functions and a protocol object
  - all are namespace-qualified by the namespace enclosing the
    definition
- The resulting functions dispatch on the type of their first argument,
  and thus must have at least one argument
- defprotocol is dynamic, and does not require AOT compilation

[[clojure:core_deftype.clj::(defmacro defprotocol][defprotocol]] will automatically generate a corresponding interface,
with the same name as the protocol, e.g. given a protocol
my.ns/Protocol, an interface my.ns.Protocol. The interface will have
methods corresponding to the protocol functions, and the protocol will
automatically work with instances of the interface.

Note that you do not need to use this interface with [[clojure:core_deftype.clj::(defmacro deftype][deftype]],
[[clojure:core_deftype.clj::(defmacro
defrecord][defrecord]], or [[clojure:core_deftype.clj::(defmacro reify][reify]], as they support protocols directly:

#+BEGIN_SRC clojure
(defprotocol P
  (foo [x])
  (bar-me [x] [x y]))

(deftype Foo [a b c]
  P
  (foo [x] a)
  (bar-me [x] b)
  (bar-me [x y] (+ c y)))

(bar-me (Foo. 1 2 3) 42)
= > 45

(foo
 (let [x 42]
   (reify P
     (foo [this] 17)
     (bar-me [this] x)
     (bar-me [this y] x))))

> 17
#+END_SRC

A Java client looking to participate in the protocol can do so most
efficiently by implementing the protocol-generated interface.

External implementations of the protocol (which are needed when you
want a class or type not in your control to participate in the
protocol) can be provided using the [[clojure:core_deftype.clj::(defn extend][extend]] construct:

#+BEGIN_SRC clojure
(extend AType
  AProtocol
   {:foo an-existing-fn
    :bar (fn [a b] ...)
    :baz (fn ([a]...) ([a b] ...)...)}
  BProtocol
    {...}
...)
#+END_SRC

~extend~ takes a type/class (or interface, see below), a one or more
protocol + function map (evaluated) pairs.

- Will extend the polymorphism of the protocol's methods to call the
  supplied functions when an AType is provided as the first argument
- Function maps are maps of the keywordized method names to ordinary
  fns
  - this facilitates easy reuse of existing fns and maps, for code
    reuse/mixins without derivation or composition
- You can implement a protocol on an interface
  - this is primarily to facilitate interop with the host (e.g. Java)
  - but opens the door to incidental multiple inheritance of
    implementation
    - since a class can inherit from more than one interface, both of
      which implement the protocol
    - if one interface is derived from the other, the more derived is
      used, else which one is used is unspecified.
- The implementing fn can presume first argument is instanceof AType
- You can implement a protocol on ~nil~
- To define a default implementation of protocol (for other than nil)
  just use Object

Protocols are fully reified and support reflective capabilities via
[[clojure:core_deftype.clj::(defn
extends?][extends?]], [[clojure:core_deftype.clj::(defn extenders][extenders]], and [[clojure:core_deftype.clj::(defn satisfies?][satisfies?]].

- Note the convenience macros [[clojure:core_deftype.clj::(defmacro extend-type][extend-type]] and [[clojure:core_deftype.clj::(defmacro extend-protocol][extend-protocol]]
- If you are providing external definitions inline, these will be more
  convenient than using ~extend~ directly

#+BEGIN_SRC clojure
(extend-type MyType
  Countable
    (cnt [c] ...)
  Foo
    (bar [x y] ...)
    (baz ([x] ...) ([x y zs] ...)))

  ;expands into:

(extend MyType
  Countable
   {:cnt (fn [c] ...)}
  Foo
   {:baz (fn ([x] ...) ([x y zs] ...))
    :bar (fn [x y] ...)})
#+END_SRC

**** Guidelines for extension

Protocols are an open system, extensible to any type. To minimize
conflicts, consider these guidelines:

- If you don't own the protocol or the target type, you should only
  extend in app (not public lib) code, and expect to maybe be broken by
  either owner.
- If you own the protocol you get to provide some base versions for
  common targets as part of the package, subject to the dictatorial
  nature of doing so.
- If you are shipping a lib of potential targets you can provide
  implementations of common protocols for them, subject to the fact
  that you are dictating. You should take particular care when
  extending protocols included with Clojure itself.
- If you are a library developer, you should not extend if you own
  neither the protocol nor the target

Also see this [[https://groups.google.com/d/msg/clojure/vyX5-F3NiVg/Ti1apkxDFl0J][mailing list discussion]].

**** Extend via metadata

As of Clojure 1.10, protocols can optionally elect to be extended via
per-value metadata:

#+BEGIN_SRC clojure
(defprotocol Component
  :extend-via-metadata true
  (start [component]))
#+END_SRC

When :extend-via-metadata is true, values can extend protocols by adding
metadata where keys are fully-qualified protocol function symbols and
values are function implementations. Protocol implementations are
checked first for direct definitions (defrecord, deftype, reify), then
metadata definitions, then external extensions (extend, extend-type,
extend-protocol).

#+BEGIN_SRC clojure
(def component (with-meta {:name "db"} {`start (constantly "started")}))
(start component)
;;=> "started"
#+END_SRC

** Metadata
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/metadata.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/metadata
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/protocols
:NEXTPAGE_CUSTOM_ID: content/reference/namespaces
:CUSTOM_ID: content/reference/metadata
:END:

Symbols and collections support metadata, a map of data /about/ the
symbol or collection. The metadata system allows for arbitrary
annotation of data. It is used to convey information to the compiler
about types, but can also be used by application developers for many
purposes, annotating data sources, policy etc.

An important thing to understand about metadata is that it is not
considered to be part of the value of an object. As such, /metadata does
not impact equality (or hash codes)/. Two objects that differ only in
metadata are equal.

That said, metadata and its relationship to an object is immutable - an
object with different metadata is a different object. One consequence of
this is that applying metadata to a lazy sequence will realize the head
of the sequence so that both objects can share the same sequence.

*** (/meta/ obj)

Returns the metadata of obj, returns nil if there is no metadata.

#+BEGIN_SRC clojure
(pprint (meta #'+)) ;; #'+ is the + var

;; {:added "1.2",
;;  :name +,
;;  :file "clojure/core.clj",
;;  :column 1,
;;  :line 984,
;;  :arglists ([] [x] [x y] [x y & more]),
;;  ...
#+END_SRC

*** (/with-meta/ obj map)

Returns an object of the same type and value as obj, with map as its
metadata.

#+BEGIN_SRC clojure
(def m ^:hi [1 2 3])
(meta (with-meta m {:bye true}))
;; {:bye true}
#+END_SRC

*** /*print-meta*/

If set to logical true, when printing an object, its metadata will also
be printed in a form that can be read back by the reader.

#+BEGIN_SRC clojure
(def m ^:hi [1 2 3])
(binding [*print-meta* true]
  (prn m))

;; ^{:hi true} [1 2 3]
#+END_SRC

*** (/vary-meta/ obj f & args)

Returns an object of the same type and value as obj, with
~(apply f (meta obj) args)~ as its metadata.

#+BEGIN_SRC clojure
(def m ^:hi [1 2 3])
(meta (vary-meta m merge {:bye true}))
;; {:hi true, :bye true}
#+END_SRC

*** (/alter-meta!/ ref f & args) and (/reset-meta!/ ref map)

Modify or reset the metadata respectively for a
namespace/var/ref/agent/atom.

*** Metadata Reader Macros
:PROPERTIES:
:CUSTOM_ID: content/reference/metadata#metadata-reader-macros
:END:

In addition to with-meta, there are a number of reader macros ([[#content/reference/reader#macro-characters][The
Reader: Macro Characters]]) for applying metadata to the expression
following it at read-time:

- ~^{:doc "How it works!"}~ - adds the metadata map to the metadata of
  the next value read
- ~^:dynamic~ - like ~^{:dynamic true}~
- ~^String~ - like ~^{:tag java.lang.String}~
- ~^"java.lang.String"~ - like ~^{:tag java.lang.String}~

The ~:tag~ key is used to hint an objects type to the Clojure compiler.
See [[#content/reference/java_interop#type-hints][Java Interop: Type Hints]] for more information and a complete list
of special type hints.

It is possible to add multiple pieces of metadata by chaining the
metadata reader macros together. For example: ~^:dynamic ^ints obj~
would apply both the :dynamic flag and ints type-hint to obj. Metadata
chains from right to left (left takes precedence).

Note that metadata reader macros are applied at read-time, not at
evaluation-time, and can only be used with values that support metadata,
like symbols, vars, collections, sequences, namespaces, refs, atoms,
agents, etc. Some important exceptions that *don't* support metadata are
strings, numbers, booleans, Java objects, keywords (these are cached and
can be shared within the runtime), and deftypes (unless they explicitly
implement clojure.lang.IMeta).

** Namespaces
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/namespaces.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/namespaces
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/metadata
:NEXTPAGE_CUSTOM_ID: content/reference/libs
:CUSTOM_ID: content/reference/namespaces
:END:

Namespaces are mappings from simple (unqualified) symbols to Vars
and/or Classes. Vars can be interned in a namespace, using ~def~ or any
of its variants, in which case they have a simple symbol for a name
and a reference to their containing namespace, and the namespace maps
that symbol to the same var. A namespace can also contain mappings
from symbols to vars interned in other namespaces by using [[clojure:core.clj::(defn refer][refer]] or
[[clojure:core.clj::(defn
use][use]], or from symbols to Class objects by using [[clojure:core.clj::(defn import][import]].  Note that
namespaces are first-class, they can be enumerated etc.  Namespaces
are also dynamic, they can be created, removed and modified at
runtime, at the Repl etc.

The best way to set up a new namespace at the top of a Clojure source
file is to use the [[clojure:core.clj::(defmacro ns][ns macro]]. By default this will create a new
namespace that contains mappings for the classnames in java.lang plus
~clojure.lang.Compiler~, and the functions in ~clojure.core~.

At the Repl it's best to use [[clojure:core.clj::(alter-meta! #'in-ns][in-ns]], in which case the new namespace
will contain mappings only for the classnames in java.lang. In order
to access the names from the ~clojure.core~ namespace you must execute
(clojure.core/refer 'clojure.core). The ~user~ namespace at the Repl has
already done this.

The current namespace, ~*ns*~ can and should be set only with a call to
[[clojure:core.clj::(alter-meta!
#'in-ns][in-ns]] or the [[clojure:core.clj::(defmacro ns][ns macro]], both of which create the namespace if it
doesn't exist.

*** Related functions

Creating and switching to a namespace: [[clojure:core.clj::(alter-meta! #'in-ns][in-ns]], [[clojure:core.clj::(defmacro ns][ns]], [[clojure:core.clj::(defn create-ns][create-ns]].

Adding to a namespace: [[clojure:core.clj::(defn alias][alias]], [[#content/reference/special_forms#def][def]], [[clojure:core.clj::(defn import][import]], [[clojure:core.clj::(defn intern][intern]], [[clojure:core.clj::(defn refer][refer]].

Finding what namespaces exist: [[clojure:core.clj::(defn all-ns][all-ns]], [[clojure:core.clj::(defn find-ns][find-ns]].

Examining a namespace: [[clojure:core.clj::(defn ns-name][ns-name]], [[clojure:core.clj::(defn ns-aliases][ns-aliases]], [[clojure:core.clj::(defn ns-imports][ns-imports]], [[clojure:core.clj::(defn ns-interns][ns-interns]],
[[clojure:core.clj::(defn
ns-map][ns-map]], [[clojure:core.clj::(defn ns-publics][ns-publics]], [[clojure:core.clj::(defn ns-refers][ns-refers]].

Getting a namespace from a symbol: [[clojure:core.clj::(defn resolve][resolve]], [[clojure:core.clj::(defn ns-resolve][ns-resolve]], [[clojure:core.clj::(defn namespace][namespace]].

Removing things: [[clojure:core.clj::(defn ns-unalias][ns-unalias]], [[clojure:core.clj::(defn ns-unmap][ns-unmap]], [[clojure:core.clj::(defn remove-ns][remove-ns]].

*** More information

Also see:

- [[#content/guides/learn/namespaces][Learn Clojure - Namespaces]]
- [[#content/reference/vars][Reference - vars]]

** Using Libs
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/libs.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/libs
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/namespaces
:NEXTPAGE_CUSTOM_ID: content/reference/vars
:CUSTOM_ID: content/reference/libs
:END:

Clojure provides for code loading and dependency tracking via its "lib"
facility. A lib is a named unit of Clojure source code contained in a
Java resource within classpath. A lib will typically provide the
complete set of definitions that make up one Clojure namespace.

*** Lib Conventions

Clojure defines conventions for naming and structuring libs:

- A lib name is a symbol that will typically contain two or more parts
  separated by periods.
- A lib's container is a Java resource whose classpath-relative path is
  derived from the lib name:
  - The path is a string
  - Periods in the lib name are replaced by slashes in the path
  - Hyphens in the lib name are replaced by underscores in the path
  - The path may end with ".class", ".clj", or ".cljc" (see
    [[#content/reference/libs#lib-load-order][Lib load order]] below)
- A lib begins with an "ns" form that
  - creates the Clojure namespace that shares its name, and
  - declares its dependencies on Java classes, Clojure's core
    facilities, and/or other libs,

Clojure ensures that if the call to "ns" completes without throwing an
exception, the declared dependencies have been satisfied and the
capabilities they provide are available.

*** Example Lib

A simple lib:

#+BEGIN_SRC clojure
(ns com.my-company.clojure.examples.my-utils
  (:import java.util.Date)
  (:use [clojure.string :only (join)])
  (:require [clojure.java.io :as jio]))
#+END_SRC

- The ~ns~ form names the lib's namespace and declares its
  dependencies. Based on its name, this lib is typically defined in a
  source file at the classpath-relative path:
  ~com/my_company/clojure/examples/my_utils.clj~ (note the translations
  from period to slash and hyphen to underscore).
- The ~:import~ clause declares this lib's use of ~java.util.Date~ and
  makes it available to code in this lib using its unqualified name.
- The ~:use~ clause declares a dependency on the ~clojure.string~ lib
  for its ~join~ function only. join may be used in this lib's code
  using its unqualified name.
- The ~:require~ clause declares a dependency on the ~clojure.java.io~
  lib and enables using its members using the shorter namespace alias
  ~jio~.

*** Prefix Lists

It's common for a lib to depend on several other libs whose full names
share a common prefix. In calls to ~require~ and ~use~ (and in
~:require~ and ~:use~ clauses within an ns form), the common prefix can
be extracted and provided once using a prefix list. For example, these
two forms are equivalent:

#+BEGIN_SRC clojure
(require 'clojure.contrib.def 'clojure.contrib.except 'clojure.contrib.sql)
(require '(clojure.contrib def except sql))
#+END_SRC

*** Related functions

Creating a namespace: [[clojure:core.clj::(defmacro ns][ns]].

Ensuring a lib is loaded: [[clojure:core.clj::(defn require][require]], [[clojure:core.clj::(defn use][use]].

Listing loaded libs: [[clojure:core.clj::(defn loaded-libs][loaded-libs]].

*** Lib load order
:PROPERTIES:
:CUSTOM_ID: content/reference/libs#lib-load-order
:END:

Libs may exist in either compiled (~.class~) or source (~.clj~ or
~.cljc~) form. In some cases, one or even all of these might exist on
the classpath. The lib is loaded from one of them based on the following
rules:

- A ~.class~ file is always preferred over a source file, unless the
  source file's timestamp is newer than the ~.class~ file, in which
  case the source file is preferred.
- A ~.clj~ (platform-specific file) is always preferred over a ~.cljc~
  (common across platforms).

The second rule allows a library author to ship both a portable common
definition of a lib while also shipping platform-specific libs that
override the portable version to do something that leverages the host
platform.

** Vars and the Global Environment
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/vars.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/vars
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-01-14
:PREVPAGE_CUSTOM_ID: content/reference/libs
:NEXTPAGE_CUSTOM_ID: content/reference/refs
:CUSTOM_ID: content/reference/vars
:END:

Clojure is a practical language that recognizes the occasional need to
maintain a persistent reference to a changing value and provides 4
distinct mechanisms for doing so in a controlled manner - Vars, [[#content/reference/refs][Refs]],
[[#content/reference/agents][Agents]] and [[#content/reference/atoms][Atoms]]. Vars provide a mechanism to refer to a mutable
storage location that can be dynamically rebound (to a new storage
location) on a per-thread basis. Every Var can (but needn't) have a
root binding, which is a binding that is shared by all threads that do
not have a per-thread binding. Thus, the value of a Var is the value
of its per-thread binding, or, if it is not bound in the thread
requesting the value, the value of the root binding, if any.

The special form ~def~ creates (and [[#content/reference/vars#interning][interns]]) a Var. If the Var did not
already exist and no initial value is supplied, the var is unbound:

#+BEGIN_SRC clojure
user=> (def x)
#'user/x
user=> x
#object[clojure.lang.Var$Unbound 0x14008db3 "Unbound: #'user/x"]
#+END_SRC

Supplying an initial value binds the root (even if it was already
bound).

#+BEGIN_SRC clojure
user=> (def x 1)
#'user/x

user=> x
1
#+END_SRC

By default Vars are static, but Vars can be marked as dynamic to allow
per-thread bindings via the macro [[clojure:core.clj::(defmacro binding][binding]].  Within each thread they
obey a stack discipline:

#+BEGIN_SRC clojure
user=> (def ^:dynamic x 1)
user=> (def ^:dynamic y 1)
user=> (+ x y)
2

user=> (binding [x 2 y 3]
         (+ x y))
5

user=> (+ x y)
2
#+END_SRC

Bindings created with ~binding~ cannot be seen by any other thread.
Likewise, bindings created with ~binding~ can be assigned to, which
provides a means for a nested context to communicate with code before
it on the call stack. This capability is opt-in only by setting a
metadata tag: ~^:dynamic~ to true as in the code block above. There are
scenarios that one might wish to redefine static Vars within a context
and Clojure (since version 1.3) provides the functions [[clojure:core.clj::(defmacro with-redefs][with-redefs]] and
[[clojure:core.clj::(defn
with-redefs-fn][with-redefs-fn]] for such purposes.

Functions defined with [[clojure:core.clj::defn (fn defn][defn]] are stored in Vars, allowing for the
re-definition of functions in a running program. This also enables
many of the possibilities of aspect- or context-oriented
programming. For instance, you could wrap a function with logging
behavior only in certain call contexts or threads.

*** Binding conveyance

Some Clojure concurrency functions (futures, [[#content/reference/agents][agents]]) provide "binding
conveyance", which allows the current set of dynamic bindings to be
conveyed to another thread for the purpose of continuing work
asynchronously with the same environment.  This functionality is
provided by [[clojure:core.clj::(defmacro future][future]], [[clojure:core.clj::2115][send]], [[clojure:core.clj::(defn send-off][send-off]], and [[clojure:core.clj::(defn pmap][pmap]].

#+BEGIN_SRC clojure
(def ^:dynamic *num* 1)
(binding [*num* 2] (future (println *num*)))
;; prints "2", not "1"
#+END_SRC

*** (*set!* var-symbol expr)
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/vars.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/vars
:CUSTOM_ID: content/reference/vars#set!
:END:

Assignment special form.

When the first operand is a symbol, it must resolve to a global var. The
value of the var's current thread binding is set to the value of expr.
Currently, it is an error to attempt to set the root binding of a var
using set!, i.e. var assignments are thread-local. In all cases the
value of expr is returned.

Note - /you cannot assign to function params or local bindings. Only
Java fields, Vars, Refs and Agents are mutable in Clojure/.

Using [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/set!][set!]]  for Java fields is documented in [[java_interop#set!][Java Interop]].

*** Interning
:PROPERTIES:
:CUSTOM_ID: content/reference/vars#interning
:END:

The Namespace system maintains global maps of symbols to Var objects
/(see [[#content/reference/namespaces][Namespaces]])/. If a ~def~ expression does not find an interned entry
in the current namespace for the symbol being def-ed, it creates one,
otherwise it uses the existing Var. This find-or-create process is
called interning. This means that, unless they have been unmap-ed, Var
objects are stable references and need not be looked up every time. It
also means that namespaces constitute a global environment in which,
as described in [[#content/reference/evaluation][Evaluation]], the compiler attempts to resolve all free
symbols as Vars.

The [[#content/reference/special_forms#var][var]] special form or the ~#'~ reader macro /(see [[#content/reference/reader][Reader]])/ can be used
to get an interned Var object instead of its current value.

*** Non-interned Vars

It is possible to create vars that are not interned by using
[[clojure:core.clj::(defmacro with-local-vars][with-local-vars]].

These vars will not be found during free symbol resolution, and their
values have to be accessed manually. But they can serve as useful
thread-local mutable cells.

*** Var metadata

The forms that create vars ~def~, ~defn~, ~defmacro~, etc use a standard
set of var [[#content/reference/metadata][metadata]] to describe vars. Some of
these forms provide explicit places in the syntax to provide values
stored in the metadata, but generally you can also supply that metadata
as a map on the var symbol.

Common var metadata keys (all optional at var definition):

- ~:doc~ - a string documenting the var, usually set by the docstring
  parameter
- ~:added~ - a string documenting the version when this var was added
- ~:private~ a boolean flag, often set by ~defn-~, used by the author
  to state the intent that this var is an implementation detail.
  Private vars are globally accessible but will not be referred or
  listed in ~ns-~...​ functions which filter to non-private vars.
- ~:arglists~ - a coll of arglists, will be generated automatically if
  not supplied, most often used to document macro syntax
- ~:macro~ - a boolean flag added by ~defmacro~ automatically (not
  typically used directly)
- ~:tag~ - a type identifier (usually a class) for the type of the
  value in the var or the return type of a function held in the var.
  Note that var metadata is evaluated, so type hints like ~^long~ on
  the var will evaluate to the ~long~ function, not a ~long~ primitive
  type hint. Generally, it is preferred to use a type hint on the
  arglist for defn vars instead.
- ~:test~ - the ~clojure.test~ framework attaches unit tests to vars
  using this key (not typically used directly)
- ~:dynamic~ - indicates a var may be dynamically rebound in a thread
  context (see above). Dynamic vars will not be direct linked when
  compiling with direct linking.
- ~:redef~ - indicates that a var should not be direct linked when
  compiling with direct linking (thus allowing it to be redefined)
- ~:static~ - no longer used (originally vars were dynamic by default,
  now they are static by default)
- ~:const~ - indicates that a var is a compile-time constant and the
  compiler can inline the value into code that uses it. Note: this is
  rarely needed and only works with constants at compile time (read,
  but not evaluated), such as numbers, strings, etc (NOT classes,
  functions, ref types, etc). Redefining or dynamically binding a const
  var will not affect code that consumes the var that has already been
  compiled and loaded in the runtime.

Also see [[#content/reference/compilation#compiler-options][Compiler Options]] for more information about direct linking
and metadata elision during compilation.

*** Related functions

Variants of ~def~: [[clojure:core.clj::defn (fn defn][defn]], [[clojure:core.clj::(defn-][defn-]], [[clojure:core.clj::(defmacro definline][definline]], [[clojure:core.clj::defmacro (fn][defmacro]], [[clojure:core.clj::(defmacro defmethod][defmethod]],
[[clojure:core.clj::(defmacro
defmulti][defmulti]], [[clojure:core.clj::(defmacro defonce][defonce]], [[clojure:core.clj::(defmacro defstruct][defstruct]].

Working with interned Vars: [[clojure:core.clj::(defmacro declare][declare]], [[clojure:core.clj::(defn intern][intern]], [[clojure:core.clj::(defmacro binding][binding]], [[clojure:core.clj::(defn find-var][find-var]], [[#content/reference/special_forms#var][var]].

Working with Var objects: [[clojure:core.clj::(defmacro with-local-vars][with-local-vars]], [[clojure:core.clj::(defn var-get][var-get]], [[clojure:core.clj::(defn var-set][var-set]],
[[clojure:core.clj::(defn
alter-var-root][alter-var-root]], [[clojure:core.clj::(defn var?][var?]], [[clojure:core.clj::(defmacro with-redefs][with-redefs]], [[clojure:core.clj::(defn with-redefs-fn][with-redefs-fn]].

Var validators: [[clojure:core.clj::(defn set-validator!][set-validator!]], [[clojure:core.clj::(defn get-validator][get-validator]].

Using Var metadata: [[clojure:repl.clj::(defmacro doc][doc]], [[clojure:repl.clj::(defn find-doc][find-doc]], [[clojure:core.clj::(defn test][test]].
** Refs and Transactions
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/refs.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/refs
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/vars
:NEXTPAGE_CUSTOM_ID: content/reference/agents
:CUSTOM_ID: content/reference/refs
:END:

While [[#content/reference/vars][Vars]] ensure safe use of mutable storage locations via thread
/isolation/, transactional references (Refs) ensure safe /shared/ use of
mutable storage locations via a [[https://en.wikipedia.org/wiki/Software_transactional_memory][software transactional memory]] (STM)
system. Refs are bound to a single storage location for their
lifetime, and only allow mutation of that location to occur within a
transaction.

Clojure transactions should be easy to understand if you've ever used
database transactions - they ensure that all actions on Refs are atomic,
consistent, and isolated. Atomic means that every change to Refs made
within a transaction occurs or none do. Consistent means that each new
value can be checked with a validator function before allowing the
transaction to commit. Isolated means that no transaction sees the
effects of any other transaction while it is running. Another feature
common to STMs is that, should a transaction have a conflict while
running, it is automatically retried.

There are many ways to do STMs (locking/pessimistic,
lock-free/optimistic and hybrids) and it is still a research problem.
The Clojure STM uses [[https://en.wikipedia.org/wiki/Multiversion_concurrency_control][multiversion concurrency control]] with adaptive
history queues for [[https://en.wikipedia.org/wiki/Snapshot_isolation][snapshot isolation]], and provides a distinct [[clojure:core.clj::(defn commute][commute]]
operation.

In practice, this means:

1. All reads of Refs will see a consistent snapshot of the 'Ref world'
   as of the starting point of the transaction (its 'read point'). The
   transaction /will/ see any changes it has made. This is called the
   /in-transaction-value/.
2. All changes made to Refs during a transaction (via [[clojure:core.clj::(defn ref-set][ref-set]], [[clojure:core.clj::(defn alter][alter]]
   or [[clojure:core.clj::(defn commute][commute]]) will appear to occur at a single point in the 'Ref
   world' timeline (its 'write point').
3. No changes will have been made by any other transactions to any Refs
   that have been *ref-set* / *altered* / *ensured* by this transaction.
4. Changes /may have/ been made by other transactions to any Refs that
   have been commuted by this transaction. That should be okay since
   the function applied by *commute* should be commutative.
5. Readers and commuters will never block writers, commuters, or other
   readers.
6. Writers will never block commuters, or readers.
7. I/O and other activities with side-effects should be avoided in
   transactions, since transactions /will/ be retried. The [[clojure:core.clj::(defmacro io!][io!]]  macro
   can be used to prevent the use of an impure function in a
   transaction.
8. If a constraint on the validity of a value of a Ref that is being
   changed depends upon the simultaneous value of a Ref that is /not
   being changed/, that second Ref can be protected from modification
   by calling [[clojure:core.clj::(defn ensure][ensure]].  Refs 'ensured' this way will be protected (item
   #3), but don't change the world (item #2).
9. The Clojure MVCC STM is designed to work with the persistent
   collections, and it is strongly recommended that you use the
   Clojure collections as the values of your Refs. Since all work done
   in an STM transaction is speculative, it is imperative that there
   be a low cost to making copies and modifications. Persistent
   collections have free copies (just use the original, it can't be
   changed), and 'modifications' share structure efficiently. In any
   case:
10. The values placed in Refs /must be, or be considered, immutable/!!
    Otherwise, Clojure can't help you.

*** Example

In this example a vector of references to vectors is created, each
containing (initially sequential) unique numbers. Then a set of threads
are started that repeatedly select two random positions in two random
vectors and swap them, in a transaction. No special effort is made to
prevent the inevitable conflicts other than the use of transactions.

#+BEGIN_SRC clojure
(defn run [nvecs nitems nthreads niters]
  (let [vec-refs (vec (map (comp ref vec)
                           (partition nitems (range (* nvecs nitems)))))
        swap #(let [v1 (rand-int nvecs)
                    v2 (rand-int nvecs)
                    i1 (rand-int nitems)
                    i2 (rand-int nitems)]
                (dosync
                 (let [temp (nth @(vec-refs v1) i1)]
                   (alter (vec-refs v1) assoc i1 (nth @(vec-refs v2) i2))
                   (alter (vec-refs v2) assoc i2 temp))))
        report #(do
                 (prn (map deref vec-refs))
                 (println "Distinct:"
                          (count (distinct (apply concat (map deref vec-refs))))))]
    (report)
    (dorun (apply pcalls (repeat nthreads #(dotimes [_ niters] (swap)))))
    (report)))
#+END_SRC

When run, we see no values get lost or duplicated in the shuffle:

#+BEGIN_SRC clojure
(run 100 10 10 100000)

([0 1 2 3 4 5 6 7 8 9] [10 11 12 13 14 15 16 17 18 19] ...
 [990 991 992 993 994 995 996 997 998 999])
Distinct: 1000

([382 318 466 963 619 22 21 273 45 596] [808 639 804 471 394 904 952 75 289 778] ...
 [484 216 622 139 651 592 379 228 242 355])
Distinct: 1000
#+END_SRC

*** Related functions

Create a Ref: [[clojure:core.clj::(defn ref][ref]].

Examine a Ref: [[clojure:core.clj::(defn deref][deref]], /(see also the @ [[#content/reference/reader][reader]] macro)/.

Transaction macros: [[clojure:core.clj::(defmacro dosync][dosync]], [[clojure:core.clj::(defmacro io!][io!]].

Allowed only in a transaction: [[clojure:core.clj::(defn ensure][ensure]], [[clojure:core.clj::(defn ref-set][ref-set]], [[clojure:core.clj::(defn alter][alter]], [[clojure:core.clj::(defn commute][commute]].

Ref validators: [[clojure:core.clj::(defn set-validator!][set-validator!]], [[clojure:core.clj::(defn get-validator][get-validator]].

** Agents and Asynchronous Actions
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/agents.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/agents
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/refs
:NEXTPAGE_CUSTOM_ID: content/reference/atoms
:CUSTOM_ID: content/reference/agents
:END:

Like Refs, Agents provide shared access to mutable state. Where [[#content/reference/refs][Refs]]
support /coordinated/, /synchronous/ change of /multiple/ locations, Agents
provide /independent/, /asynchronous/ change of /individual/
locations. Agents are bound to a single storage location for their
lifetime, and only allow mutation of that location (to a new state) to
occur as a result of an action. Actions are functions (with,
optionally, additional arguments) that are asynchronously applied to
an Agent's state and whose return value becomes the Agent's new
state. Because actions are functions they can also be multimethods and
therefore actions are potentially polymorphic.  Also, because the set
of functions is open, the set of actions supported by an Agent is also
open, a sharp contrast to pattern matching message handling loops
provided by some other languages.

Clojure's Agents are /reactive/, not autonomous - there is no imperative
message loop and no blocking receive. The state of an Agent should be
itself immutable (preferably an instance of one of Clojure's
persistent collections), and the state of an Agent is always
immediately available for reading by any thread (using the [[clojure:core.clj::(defn deref][deref]]
function or [[#content/reference/reader][reader]] macro @) without any messages, i.e. observation
does not require cooperation or coordination.

Agent action dispatches take the form (send agent fn args*).  [[clojure:core.clj::2115][send]]
(and [[clojure:core.clj::(defn send-off][send-off]]) always returns immediately. At some point later, in
another thread, the following will happen:

1. The given fn will be applied to the /state/ of the Agent and the
   args, if any were supplied.
2. The return value of fn will be passed to the validator function, if
   one has been set on the Agent. See [[clojure:core.clj::(defn set-validator!][set-validator!]]  for details.
3. If the validator succeeds or if no validator was given, the return
   value of the given fn will become the new state of the Agent.
4. If any watchers were added to the Agent, they will be called.
   See [[clojure:core.clj::(defn
   add-watch][add-watch]] for details.
5. If during the function execution any other dispatches are made
   (directly or indirectly), they will be held until /after/ the state of
   the Agent has been changed.

If any exceptions are thrown by an action function, no nested
dispatches will occur, and the exception will be cached in the Agent
itself. When an Agent has errors cached, any subsequent interactions
will immediately throw an exception, until the agent's errors are
cleared. Agent errors can be examined with [[clojure:core.clj::(defn agent-error][agent-error]] and the agent
restarted with [[clojure:core.clj::(defn restart-agent][restart-agent]].

The actions of all Agents get interleaved amongst threads in a thread
pool. At any point in time, at most one action for each Agent is being
executed. Actions dispatched to an agent from another single agent or
thread will occur in the order they were sent, potentially interleaved
with actions dispatched to the same agent from other sources.  [[clojure:core.clj::2115][send]]
should be used for actions that are CPU limited, while [[clojure:core.clj::(defn send-off][send-off]] is
appropriate for actions that may block on IO.

Agents are integrated with the STM - any dispatches made in a
transaction are held until it commits, and are discarded if it is
retried or aborted.

As with all of Clojure's concurrency support, no user-code locking is
involved.

Note that use of Agents starts a pool of non-daemon background threads
that will prevent shutdown of the JVM. Use [[clojure:core.clj::(defn shutdown-agents][shutdown-agents]] to
terminate these threads and allow shutdown.

*** Example

This example is an implementation of the send-a-message-around-a-ring
test. A chain of m agents is created, then a sequence of n actions are
dispatched to the head of the chain and relayed through it.

#+BEGIN_SRC clojure
(defn relay [x i]
  (when (:next x)
    (send (:next x) relay i))
  (when (and (zero? i) (:report-queue x))
    (.put (:report-queue x) i))
  x)

(defn run [m n]
  (let [q (new java.util.concurrent.SynchronousQueue)
        hd (reduce (fn [next _] (agent {:next next}))
                   (agent {:report-queue q}) (range (dec m)))]
    (doseq [i (reverse (range n))]
      (send hd relay i))
    (.take q)))

; 1 million message sends:
(time (run 1000 1000))
->"Elapsed time: 2959.254 msecs"
#+END_SRC

*** Related functions

Create an Agent: [[clojure:core.clj::(defn agent][agent]]

Examine an Agent: [[clojure:core.clj::(defn deref][deref]], /(see also the @ [[#content/reference/reader][reader]] macro)/, [[clojure:core.clj::(defn agent-error][agent-error]],
[[clojure:core.clj::(defn
error-handler][error-handler]], [[clojure:core.clj::(defn error-mode][error-mode]].

Change Agent state: [[clojure:core.clj::2115][send]], [[clojure:core.clj::(defn send-off][send-off]], [[clojure:core.clj::(defn restart-agent][restart-agent]].

Block waiting for an Agent: [[clojure:core.clj::(defn await][await]], [[clojure:core.clj::(defn await-for][await-for]].

Ref validators: [[clojure:core.clj::(defn set-validator!][set-validator!]], [[clojure:core.clj::(defn get-validator][get-validator]].

Watchers: [[clojure:core.clj::(defn add-watch][add-watch]], [[clojure:core.clj::(defn remove-watch][remove-watch]].

Agent thread management: [[clojure:core.clj::(defn shutdown-agents][shutdown-agents]].

Agent error management: [[clojure:core.clj::(defn agent-error][agent-error]], [[clojure:core.clj::(defn restart-agent][restart-agent]],
[[clojure:core.clj::(defn
set-error-handler!][set-error-handler!]], [[clojure:core.clj::(defn error-handler][error-handler]], [[clojure:core.clj::(defn set-error-mode!][set-error-mode!]], [[clojure:core.clj::(defn error-mode][error-mode]].

** Atoms
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/atoms.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/atoms
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/agents
:NEXTPAGE_CUSTOM_ID: content/reference/reducers
:CUSTOM_ID: content/reference/atoms
:END:

Atoms provide a way to manage shared, synchronous, independent state.
They are a reference type like refs and vars. You create an atom with
[[clojure:core.clj::(defn
atom][atom]], and can access its state with [[clojure:core.clj::(defn deref][deref/@]].  Like refs and agents,
atoms support validators. To change the value of an atom, you can use
[[clojure:core.clj::(defn
swap!][swap!]].  A lower-level [[clojure:core.clj::(defn compare-and-set!][compare-and-set!]]  is also provided. Changes to
atoms are always free of race conditions.

As with all reference types, the intended use of atom is to hold one
of Clojure's immutable data structures. And, similar to ref's alter
and agent's send, you change the value by applying a function to the
old value. This is done in an atomic manner by [[clojure:core.clj::(defn swap!][swap!]]  Internally,
[[clojure:core.clj::(defn
swap!][swap!]]  reads the current value, applies the function to it, and
attempts to compare-and-set! it in. Since another thread may have
changed the value in the intervening time, it may have to retry, and
does so in a spin loop. The net effect is that the value will always
be the result of the application of the supplied function to a current
value, atomically.  However, because the function might be called
multiple times, it must be free of side effects.

Atoms are an efficient way to represent some state that will never need
to be coordinated with any other, and for which you wish to make
synchronous changes (unlike agents, which are similarly independent but
asynchronous). A typical usage might be for memoization:

#+BEGIN_SRC clojure
(defn memoize [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))

(defn fib [n]
  (if (<= n 1)
    n
    (+ (fib (dec n)) (fib (- n 2)))))

(time (fib 35))
user=> "Elapsed time: 941.445 msecs"

(def fib (memoize fib))

(time (fib 35))

user=> "Elapsed time: 0.044 msecs"
#+END_SRC

** Reducers
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/reducers.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/reducers
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/atoms
:NEXTPAGE_CUSTOM_ID: content/reference/java_interop
:CUSTOM_ID: content/reference/reducers
:END:

Reducers provide an alternative approach to using [[#content/reference/sequences][sequences]] to
manipulate standard Clojure collections. Sequence functions are
typically applied lazily, in order, create intermediate results, and
in a single thread. However, many sequence functions (like map and
filter) could conceptually be applied in parallel, yielding code that
will get faster automatically as machines get more cores. For more
details on the rationale for reducers, see the original [[https://clojure.org/news/2012/05/08/reducers][blog]] [[https://clojure.org/news/2012/05/15/anatomy-of-reducer][posts]].

A /reducer/ is the combination of a /reducible collection/ (a collection
that knows how to reduce itself) with a /reducing function/ (the
"recipe" for what needs to be done during the reduction). The standard
sequence operations are replaced with new versions that do not perform
the operation but merely transform the reducing function. Execution of
the operations is deferred until the final reduction is performed. This
removes the intermediate results and lazy evaluation seen with
sequences.

Additionally, some collections (persistent vectors and maps) are
/foldable/. The /fold/ operation on a reducer executes the reduction in
parallel by:

1. Partitioning the reducible collection at a specified granularity
   (default = 512 elements)
2. Applying reduce to each partition
3. Recursively combining each partition using Java's [[http://gee.cs.oswego.edu/dl/papers/fj.pdf][fork/join]]
   framework.

If a collection does not support folding, it will fall back to
non-parallel reduce instead.

*** reduce and fold

The ~clojure.core.reducers~ namespace (aliased here as ~r~) provides an
alternate [[clojure:core/reducers.clj::(defn reduce][r/reduce]] function.

- ~(r/reduce f coll)~
- ~(r/reduce f init coll)~

The reducers version differs in that:

- Map colls are reduced with reduce-kv
- When init is not provided, f is invoked with no arguments to produce
  an identity value
  - /Note: f may be invoked multiple times to provide the identity
      value/

In general most users will not call r/reduce directly and instead
should prefer [[clojure:core/reducers.clj::(defn fold][r/fold]], which implements parallel reduce and
combine. However, it may be useful to execute an eager reduce with
fewer intermediate results.

- ~(r/fold reducef coll)~
- ~(r/fold combinef reducef coll)~
- ~(r/fold n combinef reducef coll)~

r/fold takes a reducible collection and partitions it into groups of
approximately n (default 512) elements. Each group is reduced using the
reducef function. The reducef function will be called with no arguments
to produce an identity value /in each partition/. The results of those
reductions are then reduced with the combinef (defaults to reducef)
function. When called with no arguments, (combinef) must produce its
identity element - this will be called multiple times. Operations may be
performed in parallel. Results will preserve order.

The following functions (analogous to the sequence versions) create
reducers from a reducible or foldable collection: [[clojure:core/reducers.clj::(defcurried map][r/map]], [[clojure:core/reducers.clj::(defcurried mapcat][r/mapcat]],
[[clojure:core/reducers.clj::(defcurried
filter][r/filter]], [[clojure:core/reducers.clj::(defcurried remove][r/remove]], [[clojure:core/reducers.clj::(defcurried flatten][r/flatten]], [[clojure:core/reducers.clj::(defcurried take-while][r/take-while]], [[clojure:core/reducers.clj::(defcurried take][r/take]], and [[clojure:core/reducers.clj::(defcurried drop][r/drop]].

None of these functions actually transforms the source collection. To
produce an accumulated result, you must use r/reduce or r/fold. To
produce an output collection, use [[clojure:core.clj::6928][clojure.core/into]] to choose the
collection type or the provided [[clojure:core/reducers.clj::(defn foldcat][r/foldcat]] to produce a collection that
is reducible, foldable, seqable, and counted.

*** Using Reducers

Use fold to sum with +:

#+BEGIN_SRC clojure
(require '[clojure.core.reducers :as r])
(r/fold + (r/filter even? (r/map inc [1 1 1 2])))
;=> 6
#+END_SRC

Use [[clojure:core.clj::6928][into]] to produce a final collection:

#+BEGIN_SRC clojure
(into [] (r/filter even? (r/map inc (range 100000))))
#+END_SRC

Or [[clojure:core/reducers.clj::(defn foldcat][r/foldcat]]:

#+BEGIN_SRC clojure
(r/foldcat (r/filter even? (r/map inc (range 100000))))
#+END_SRC

Specify a reduce function and a combine function with fold:

#+BEGIN_SRC clojure
(defn count-words
  ([] {})
  ([freqs word]
    (assoc freqs word (inc (get freqs word 0)))))

(defn merge-counts
  ([] {})
  ([& m] (apply merge-with + m)))

(defn word-frequency [text]
  (r/fold merge-counts count-words (clojure.string/split text #"\s+")))
#+END_SRC

*** When to use

Use the reducer form of these operations for:

- Efficient eager application of a multi-step transformation
- Avoiding the dangling I/O resource issues (as seen with lazy seqs)

Use ~fold~ when:

- Source data can be generated and held in memory
- Work to be performed is computation (not I/O or blocking)
- Number of data items or work to be done is "large"

** Java Interop
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/java_interop.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/java_interop
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2016-02-25
:PREVPAGE_CUSTOM_ID: content/reference/reducers
:NEXTPAGE_CUSTOM_ID: content/reference/compilation
:CUSTOM_ID: content/reference/java_interop
:END:
*** Class access

- ~Classname~
- ~Classname$NestedClassName~

Symbols representing class names are resolved to the Class instance.
Inner or nested classes are separated from their outer class with a ~$~.
Fully-qualified class names are always valid. If a class is `import`ed
in the namespace, it may be used without qualification. All classes in
java.lang are automatically imported to every namespace.

#+BEGIN_EXAMPLE
String
-> java.lang.String
(defn date? [d] (instance? java.util.Date d))
-> #'user/date?
(.getEnclosingClass java.util.Map$Entry)
-> java.util.Map
#+END_EXAMPLE

*** Member access

- ~(.instanceMember instance args*)~
- ~(.instanceMember Classname args*)~
- ~(.-instanceField instance)~
- ~(Classname/staticMethod args*)~
- ~Classname/staticField~

#+BEGIN_EXAMPLE
(.toUpperCase "fred")
-> "FRED"
(.getName String)
-> "java.lang.String"
(.-x (java.awt.Point. 1 2))
-> 1
(System/getProperty "java.vm.version")
-> "1.6.0_07-b06-57"
Math/PI
-> 3.141592653589793
#+END_EXAMPLE

The preferred idiomatic forms for accessing field or method members are
given above. The instance member form works for both fields and methods.
The instanceField form is preferred for fields and required if both a
field and a 0-argument method of the same name exist. They all expand
into calls to the dot operator (described below) at macroexpansion time.
The expansions are as follows:

#+BEGIN_SRC clojure
(.instanceMember instance args*) ==> (. instance instanceMember args*)
(.instanceMember Classname args*) ==>
    (. (identity Classname) instanceMember args*)
(.-instanceField instance) ==> (. instance -instanceField)
(Classname/staticMethod args*) ==> (. Classname staticMethod args*)
Classname/staticField ==> (. Classname staticField)
#+END_SRC

*** The Dot special form
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/java_interop.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/java_interop
:CUSTOM_ID: content/reference/java_interop#dot
:END:

- ~(. instance-expr member-symbol)~
- ~(. Classname-symbol member-symbol)~
- ~(. instance-expr -field-symbol)~
- ~(. instance-expr (method-symbol args*))~ or ~(. instance-expr method-symbol args*)~
- ~(. Classname-symbol (method-symbol args*))~ or ~(. Classname-symbol method-symbol args*)~

Special form.

The ~.~ special form is the basis for access to Java. It can be
considered a member-access operator, and/or read as 'in the scope of'.

If the first operand is a symbol that resolves to a class name, the
access is considered to be to a static member of the named class. Note
that nested classes are named EnclosingClass$NestedClass, per the JVM
spec. Otherwise it is presumed to be an instance member and the first
argument is evaluated to produce the target object.

For the special case of invoking an instance member on a Class instance,
the first argument must be an expression that evaluates to the class
instance - note that the preferred form at the top expands ~Classname~
to ~(identity Classname)~.

If the second operand is a symbol and no args are supplied it is taken
to be a field access - the name of the field is the name of the symbol,
and the value of the expression is the value of the field, /unless/
there is a no argument public method of the same name, in which case it
resolves to a call to the method. If the second operand is a symbol
starting with ~-~, the member-symbol will resolve only as field access
(never as a 0-arity method) and should be preferred when that is the
intent.

If the second operand is a list, or args are supplied, it is taken to be
a method call. The first element of the list must be a simple symbol,
and the name of the method is the name of the symbol. The args, if any,
are evaluated from left to right, and passed to the matching method,
which is called, and its value returned. If the method has a void return
type, the value of the expression will be ~nil~. Note that placing the
method name in a list with any args is optional in the canonic form, but
can be useful to gather args in macros built upon the form.

Note that boolean return values will be turned into Booleans, chars will
become Characters, and numeric primitives will become Numbers unless
they are immediately consumed by a method taking a primitive.

The member access forms given at the top of this section are preferred
for use in all cases other than in macros.

- ~(/../ instance-expr member+)~
- ~(/../ Classname-symbol member+)~

member ⇒ fieldName-symbol or (instanceMethodName-symbol args*)

Macro. Expands into a member access (.) of the first member on the first
argument, followed by the next member on the result, etc. For instance:

~(.. System (getProperties) (get "os.name"))~

expands to:

~(. (. System (getProperties)) (get "os.name"))~

but is easier to write, read, and understand. See also the
[[clojure:core.clj::(defmacro ->][->]] macro which can be used similarly:

~(-> (System/getProperties) (.get "os.name"))~

- ~(doto instance-expr (instanceMethodName-symbol args*)*)~

Macro. Evaluates instance-expr then calls all of the methods/functions
with the supplied arguments in succession on the resulting object,
returning it.

#+BEGIN_SRC clojure
(doto (new java.util.HashMap) (.put "a" 1) (.put "b" 2))
-> {a=1, b=2}
#+END_SRC

<<java_interop#new>>

- ~(Classname. args*)~
- ~(new Classname args*)~

Special form.

The args, if any, are evaluated from left to right, and passed to the
constructor of the class named by Classname. The constructed object is
returned.

**** Alternative Macro Syntax

As shown, in addition to the canonic special form new, Clojure supports
special macroexpansion of symbols containing '.':

~(new Classname args*)~

can be written

~(Classname. args*) ;note trailing dot~

the latter expanding into the former at macro expansion time.

- ~(/instance?/ Class expr)~

Evaluates expr and tests if it is an instance of the class. Returns true
or false

<<java_interop#set!>>

- ~(/set!/ (. instance-expr instanceFieldName-symbol) expr)~
- ~(/set!/ (. Classname-symbol staticFieldName-symbol) expr)~

Assignment special form.

When the first operand is a field member access form, the assignment is
to the corresponding field. If it is an instance field, the instance
expr will be evaluated, then the expr.

In all cases the value of expr is returned.

Note - /you cannot assign to function params or local bindings. Only
Java fields, Vars, Refs and Agents are mutable in Clojure/.

- ~(memfn method-name arg-names*)~

Macro. Expands into code that creates a fn that expects to be passed an
object and any args and calls the named instance method on the object
passing the args. Use when you want to treat a Java method as a
first-class fn.

#+BEGIN_SRC clojure
(map (memfn charAt i) ["fred" "ethel" "lucy"] [1 2 3])
-> (\r \h \y)
#+END_SRC

Note it is almost always preferable to do this directly now, with syntax
like:

#+BEGIN_SRC clojure
(map #(.charAt %1 %2) ["fred" "ethel" "lucy"] [1 2 3])
-> (\r \h \y)
#+END_SRC

- ~(bean obj)~

Takes a Java object and returns a read-only implementation of the map
abstraction based upon its JavaBean properties.

#+BEGIN_SRC clojure
(bean java.awt.Color/black)
-> {:RGB -16777216, :alpha 255, :blue 0, :class java.awt.Color,
    :colorSpace #object[java.awt.color.ICC_ColorSpace 0x5cb42b "java.awt.color.ICC_ColorSpace@5cb42b"],
    :green 0, :red 0, :transparency 1}
#+END_SRC

*** Support for Java in Clojure Library Functions

Many of the Clojure library functions have defined semantics for objects
of Java types. contains? and get work on Java Maps, arrays, Strings, the
latter two with integer keys. count works on Java Strings, Collections
and arrays. nth works on Java Strings, Lists and arrays. seq works on
Java reference arrays, Iterables and Strings. Since much of the rest of
the library is built upon these functions, there is great support for
using Java objects in Clojure algorithms.

*** Implementing Interfaces and Extending Classes

Clojure supports the dynamic creation of objects that implement one or
more interfaces and/or extend a class with the [[clojure:core_proxy.clj::(defmacro proxy][proxy]] macro. The
resulting objects are of an anonymous class. You can also generate
statically-named classes and .class files with [[clojure:genclass.clj::(defmacro gen-class][gen-class]].  As of
Clojure 1.2, [[clojure:core_deftype.clj::(defmacro reify][reify]] is also available for implementing interfaces.

Java annotations may be attached to classes, constructors, and methods
via [[#content/reference/metadata][metadata]] on ~gen-class~ and Clojure type constructs, see the
[[#content/reference/datatypes#java-annotation-support][datatypes reference]] for an example.

- ~(proxy [class-and-interfaces] [args] fs+)~

class-and-interfaces - a vector of class names

args - a (possibly empty) vector of arguments to the superclass
constructor.

f ⇒ (name [params*] body) or (name ([params*] body) ([params+] body)
...​)

Macro

Expands to code which creates a instance of a proxy class that
implements the named class/interface(s) by calling the supplied fns. A
single class, if provided, must be first. If not provided it defaults to
Object. The interfaces names must be valid interface types. If a method
fn is not provided for a class method, the superclass method will be
called. If a method fn is not provided for an interface method, an
UnsupportedOperationException will be thrown should it be called. Method
fns are closures and can capture the environment in which proxy is
called. Each method fn takes an additional implicit first arg, which is
bound to this. Note that while method fns can be provided to override
protected methods, they have no other access to protected members, nor
to super, as these capabilities cannot be proxied.

*** Arrays

Clojure supports the creation, reading and modification of Java arrays.
It is recommended that you limit use of arrays to interop with Java
libraries that require them as arguments or use them as return values.

Note that many other Clojure functions work with arrays such as via the
[[#content/reference/sequences][seq library]]. The functions listed here exist for
initial creation of arrays, or to support mutation or higher performance
operations on arrays.

**** Vararg methods

Java vararg methods treat the trailing varargs parameter as an array.
They can be invoked from Clojure by passing an explicit array in place
of the vargs.

Depending on the varargs type, use the type-specific array constructors
for primitives or ~into-array~ to make an array of a specific type. See
the [[#content/guides/faq#varargs][FAQ]] for examples.

Create array from existing collection: [[clojure:core.clj::(defn aclone][aclone]], [[clojure:core.clj::(defmacro amap][amap]], [[clojure:core.clj::(defn to-array][to-array]],
[[clojure:core.clj::(defn
to-array-2d][to-array-2d]], [[clojure:core.clj::(defn into-array][into-array]].

Multi-dimensional array support: [[clojure:core.clj::(defn aget][aget]], [[clojure:core.clj::(defn aset][aset]], [[clojure:core.clj::(defn to-array-2d][to-array-2d]], [[clojure:core.clj::(defn make-array][make-array]].

Type-specific array constructors: [[clojure:core.clj::(defn boolean-array][boolean-array]], [[clojure:core.clj::(defn byte-array][byte-array]],
[[clojure:core.clj::(defn
 char-array][char-array]], [[clojure:core.clj::(defn double-array][double-array]], [[clojure:core.clj::(defn float-array][float-array]], [[clojure:core.clj::(defn int-array][int-array]], [[clojure:core.clj::(defn long-array][long-array]],
[[clojure:core.clj::(defn
object-array][object-array]], [[clojure:core.clj::(defn short-array][short-array]].

Primitive array casts: [[clojure:core.clj::(definline booleans][booleans]], [[clojure:core.clj::(definline bytes][bytes]], [[clojure:core.clj::(definline chars][chars]], [[clojure:core.clj::(definline doubles][doubles]], [[clojure:core.clj::(definline floats][floats]], [[clojure:core.clj::(definline ints][ints]],
[[clojure:core.clj::(definline
longs][longs]], [[clojure:core.clj::(definline shorts][shorts]].

Mutate an array: [[clojure:core.clj::(defn aset][aset]].

Process an existing array: [[clojure:core.clj::(defn aget][aget]], [[clojure:core.clj::(defn alength][alength]], [[clojure:core.clj::(defmacro amap][amap]], [[clojure:core.clj::(defmacro areduce][areduce]].

*** Type Hints
:PROPERTIES:
:CUSTOM_ID: content/reference/java_interop#type-hints
:END:

Clojure supports the use of type hints to assist the compiler in
avoiding reflection in performance-critical areas of code. Normally,
one should avoid the use of type hints until there is a known
performance bottleneck. Type hints are [[#content/reference/metadata#metadata-reader-macros][metadata tags]] placed on symbols
or expressions that are consumed by the compiler. They can be placed
on function parameters, let-bound names, var names (when defined), and
expressions:

#+BEGIN_SRC clojure
(defn len [x]
  (.length x))

(defn len2 [^String x]
  (.length x))

user=> (time (reduce + (map len (repeat 1000000 "asdf"))))
"Elapsed time: 3007.198 msecs"
4000000
user=> (time (reduce + (map len2 (repeat 1000000 "asdf"))))
"Elapsed time: 308.045 msecs"
4000000
#+END_SRC

Once a type hint has been placed on an identifier or expression, the
compiler will try to resolve any calls to methods thereupon at compile
time. In addition, the compiler will track the use of any return values
and infer types for their use and so on, so very few hints are needed to
get a fully compile-time resolved series of calls. Note that type hints
are not needed for static members (or their return values!) as the
compiler always has the type for statics.

There is a ~*warn-on-reflection*~ flag (defaults to false) which will
cause the compiler to warn you when it can't resolve to a direct call:

#+BEGIN_SRC clojure
(set! *warn-on-reflection* true)
-> true

(defn foo [s] (.charAt s 1))
-> Reflection warning, line: 2 - call to charAt can't be resolved.
-> #user/foo

(defn foo [^String s] (.charAt s 1))
-> #user/foo
#+END_SRC

For function return values, the type hint can be placed before the
arguments vector:

#+BEGIN_SRC clojure
(defn hinted-single ^String [])

-> #user/hinted-single

(defn hinted
  (^String [])
  (^Integer [a])
  (^java.util.List [a & args]))

-> #user/hinted
#+END_SRC

*** Aliases

Clojure provides aliases for primitive Java types and arrays which do
not have typical representations as Java class names. The types are
represented according to the specification of [[https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.2-200][Java Field Descriptors]].
For example, byte arrays (byte-array []) have a type of "[B".

- int - A primitive int
- ints - An int array
- long - A primitive long
- longs - A long array
- float - A primitive float
- floats - A float array
- double - A primitive double
- doubles - A double array
- void - A void return
- short - A primitive short
- shorts - A short array
- boolean - A primitive boolean
- booleans - A boolean array
- byte - A primitive byte
- bytes - A byte array
- char - A primitive character
- chars - A character array

*** Support for Java Primitives

Clojure has support for high-performance manipulation of, and arithmetic
involving, Java primitive types in local contexts. All Java primitive
types are supported: int, float, long, double, boolean, char, short, and
byte.

- ~let~ / ~loop~-bound locals can be of primitive types, having the
  inferred, possibly primitive type of their init-form.
- ~recur~ forms that rebind primitive locals do so without boxing,
  and do type-checking for same primitive type.
- Arithmetic (+,-,*,/,inc,dec,<,<=,>,>= etc) is overloaded for
  primitive types where semantics are same.
- [[clojure:core.clj::(defn aget][aget]] / [[clojure:core.clj::(defn aset][aset]] are overloaded for arrays of primitives
- [[clojure:core.clj::(defn aclone][aclone]], [[clojure:core.clj::(defn alength][alength]] functions for arrays of primitives
- constructor functions for primitive arrays: [[clojure:core.clj::(defn float-array][float-array]], [[clojure:core.clj::(defn int-array][int-array]],
  etc.
- Type hints for primitive arrays - \^ints, \^floats, etc.
- Coercion ops [[clojure:core.clj::(defn int][int]], [[clojure:core.clj::(defn float][float]], etc. produce primitives when consumer can
  take primitive
- The [[clojure:core.clj::(defn num][num]] coercion function boxes primitives to force generic
  arithmetic
- Array cast functions
  [[clojure:core.clj::(definline ints][ints]] [[clojure:core.clj::(definline longs][longs]], etc. which produce int[], long[], etc.
- A set of "unchecked" operations for utmost performing, but
  potentially unsafe, integer (int/long) ops: [[clojure:core.clj::1228][unchecked-multiply]]
  [[clojure:core.clj::1172][unchecked-dec]] [[clojure:core.clj::1158][unchecked-inc]] [[clojure:core.clj::1186][unchecked-negate]] [[clojure:core.clj::1200][unchecked-add]]
  [[clojure:core.clj::1214][unchecked-subtract]]
  # FIXME: not in the source code [[clojure:core.clj::(defn unchecked-remainder][unchecked-remainder]]
  # FIXME: not in the source code [[clojure:core.clj::(defn unchecked-divide][unchecked-divide]]
- A dynamic var to automatically swap safe operations with unchecked
  operations: [[clojure:core.clj::(add-doc-and-meta *unchecked-math*][*unchecked-math*]]
- [[clojure:core.clj::(defmacro amap][amap]] and [[clojure:core.clj::(defmacro areduce][areduce]] macros for functionally (i.e. non-destructively)
  processing one or more arrays in order to produce a new array or
  aggregate value respectively.

Rather than write this Java:

#+BEGIN_SRC java
static public float asum(float[] xs){
  float ret = 0;
  for(int i = 0; i < xs.length; i++)
    ret += xs[i];
  return ret;
}
#+END_SRC

you can write this Clojure:

#+BEGIN_SRC clojure
(defn asum [^floats xs]
  (areduce xs i ret (float 0)
    (+ ret (aget xs i))))
#+END_SRC

and the resulting code is exactly the same speed (when run with java
-server).

The best aspect of this is that you need not do anything special in your
initial coding. Quite often these optimizations are unneeded. Should a
bit of code be a bottleneck, you can speed it up with minor adornment:

#+BEGIN_SRC clojure
(defn foo [n]
  (loop [i 0]
    (if (< i n)
      (recur (inc i))
      i)))

(time (foo 100000))
"Elapsed time: 0.391 msecs"
100000

(defn foo2 [n]
  (let [n (int n)]
    (loop [i (int 0)]
      (if (< i n)
        (recur (inc i))
        i))))

(time (foo2 100000))
"Elapsed time: 0.084 msecs"
100000
#+END_SRC

Functions have limited support for primitive arguments and return type:
type hints for ~long~ and ~double~ (only these) generate primitive-typed
overloads. Note that this capability is restricted to functions of arity
no greater than 4.

Thus a function defined as

#+BEGIN_SRC clojure
(defn foo ^long [^long n])
#+END_SRC

both takes and returns values of primitive type ~long~ (invocations with
a boxed argument and indeed any object result in a cast and delegation
to the primitive-typed overload).

*** Coercions

At times it is necessary to have a value of a particular primitive
type.  These coercion functions yield a value of the indicated type as
long as such a coercion is possible: [[clojure:core.clj::(defn bigdec][bigdec]], [[clojure:core.clj::(defn bigint][bigint]], [[clojure:core.clj::1607][boolean]], [[clojure:core.clj::(defn byte][byte]],
[[clojure:core.clj::(defn
char][char]], [[clojure:core.clj::3480][double]], [[clojure:core.clj::(defn float][float]], [[clojure:core.clj::(defn int][int]], [[clojure:core.clj::(defn long][long]], [[clojure:core.clj::(defn num][num]], [[clojure:core.clj::(defn short][short]].

*** Some optimization tips

- All arguments are passed to Clojure fns as objects, so there's no
  point to putting arbitrary primitive type hints on fn args (excepting
  primitive array type hints, and long and double as noted). Instead,
  use the let technique shown to place args in primitive locals if they
  need to participate in primitive arithmetic in the body.
- (let [foo (int bar)] ...​) is the correct way to get a primitive
  local. Do not use \^Integer etc.
- Don't rush to unchecked math unless you want truncating operations.
  HotSpot does a good job at optimizing the overflow check, which will
  yield an exception instead of silent truncation. On a typical
  example, that has about a 5% difference in speed - well worth it.
  Also, people reading your code don't know if you are using unchecked
  for truncation or performance - best to reserve it for the former and
  comment if the latter.
- There's usually no point in trying to optimize an outer loop, in fact
  it can hurt you as you'll be representing things as primitives which
  just have to be re-boxed in order to become args to the inner call.
  The only exception is reflection warnings - you must get rid of them
  in any code that gets called frequently.
- Almost every time someone presents something they are trying to
  optimize with hints, the faster version has far fewer hints than the
  original. If a hint doesn't improve things in the end - take it out.
- Many people seem to presume only the unchecked- ops do primitive
  arithmetic - not so. When the args are primitive locals, regular +
  and * etc do primitive math with an overflow check - fast /and/ safe.
- So, the simplest route to fast math is to leave the operators alone
  and just make sure the source literals and locals are primitive.
  Arithmetic on primitives yields primitives. If you've got a loop
  (which you probably do if you need to optimize) make sure the loop
  locals are primitives first - then if you accidentally are producing
  a boxed intermediate result you'll get an error on recur. Don't solve
  that error by coercing your intermediate result, instead, figure out
  what argument or local is not primitive.

*** Simple XML Support

Included with the distribution is simple XML support, found in the
src/xml.clj file. All names from this file are in the xml namespace.

*(/parse/ source)*

Parses and loads the source, which can be a File, InputStream or String
naming a URI. Returns a tree of the xml/element struct-map, which has
the keys :tag, :attrs, and :content. and accessor fns tag, attrs, and
content.

#+BEGIN_SRC clojure
(xml/parse "/Users/rich/dev/clojure/build.xml")
-> {:tag :project, :attrs {:name "clojure", :default "jar"}, :content [{:tag :description, ...
#+END_SRC

*** Calling Clojure From Java

The [[https://clojure.github.io/clojure/javadoc][clojure.java.api]] package provides a minimal interface to bootstrap
Clojure access from other JVM languages. It does this by providing:

1. The ability to use Clojure's namespaces to locate an arbitrary var,
   returning the var's clojure.lang.IFn interface.
2. A convenience method read for reading data using Clojure's edn reader

IFns provide complete access to Clojure's APIs. You can also access any
other library written in Clojure, after adding either its source or
compiled form to the classpath.

The public Java API for Clojure consists of the following classes and
interfaces:

- [[https://clojure.github.io/clojure/javadoc/clojure/java/api/Clojure.html][clojure.java.api.Clojure]]
- [[https://clojure.github.io/clojure/javadoc/clojure/lang/IFn.html][clojure.lang.IFn]]

All other Java classes should be treated as implementation details, and
applications should avoid relying on them.

To lookup and call a Clojure function:

#+BEGIN_SRC java
IFn plus = Clojure.var("clojure.core", "+");
plus.invoke(1, 2);
#+END_SRC

Functions in clojure.core are automatically loaded. Other namespaces can
be loaded via require:

#+BEGIN_SRC java
IFn require = Clojure.var("clojure.core", "require");
require.invoke(Clojure.read("clojure.set"));
#+END_SRC

IFns can be passed to higher order functions, e.g. the example below
passes plus to read:

#+BEGIN_SRC java
IFn map = Clojure.var("clojure.core", "map");
IFn inc = Clojure.var("clojure.core", "inc");
map.invoke(inc, Clojure.read("[1 2 3]"));
#+END_SRC

Most IFns in Clojure refer to functions. A few, however, refer to
non-function data values. To access these, use deref instead of fn:

#+BEGIN_SRC java
IFn printLength = Clojure.var("clojure.core", "*print-length*");
IFn deref = Clojure.var("clojure.core", "deref");
deref.invoke(printLength);
#+END_SRC

** Ahead-of-time Compilation and Class Generation
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/compilation.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/compilation
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/java_interop
:NEXTPAGE_CUSTOM_ID: content/reference/other_libraries
:CUSTOM_ID: content/reference/compilation
:END:

Clojure compiles all code you load on-the-fly into JVM bytecode, but
sometimes it is advantageous to compile ahead-of-time (AOT). Some
reasons to use AOT compilation are:

- To deliver your application without source
- To speed up application startup
- To generate named classes for use by Java
- To create an application that does not need runtime bytecode
  generation and custom classloaders

The Clojure compilation model preserves as much as possible the dynamic
nature of Clojure, in spite of the code-reloading limitations of Java.

- Source and classfile pathing follows Java classpath conventions.
- The target of compile is a namespace
- Each file, fn and gen-class will produce a .class file
- Each file generates a loader class of the same name with "__init"
  appended.
- The static initializer for a loader class produces the same effects
  as does loading its source file
  - You generally shouldn't need to use these classes directly, as
    use, require and load will choose between them and more recent
    source
- The loader class is generated for each file referenced when a
  namespace is compiled, when its loader .class file is older than its source.
- A stand-alone [[clojure:genclass.clj::(defmacro gen-class][gen-class]] facility is provided to create named classes
  for direct use as Java classes, with facilities for:
  - Naming the generated class
  - Selecting the superclass
  - Specifying any implemented interfaces
  - Specifying constructor signatures
  - Specifying state
  - Declaring additional methods
  - Generating static factory methods
  - Generating main
  - Controlling the mapping to an implementing namespace
  - Exposing inherited protected members
  - Generating more than one named class from a single file, with
    implementations in one or more namespaces
- An optional [[clojure:genclass.clj::(defmacro gen-class][:gen-class]] directive can be used in the [[clojure:core.clj::(defmacro ns][ns]] declaration
  to generate a named class corresponding to a namespace.  (:gen-class
  ...​), when supplied, defaults to :name corresponding to the ns name,
  :main true, :impl-ns same as ns, and :init-impl-ns true.  All
  options of gen-class are supported.
- gen-class and the :gen-class directive are ignored when not
  compiling.
- A stand-alone [[clojure:genclass.clj::(defmacro gen-interface][gen-interface]] facility is provided for generating
  named interface classes for direct use as Java interfaces, with
  facilities for:
  - Naming the generated interface
  - Specifying any superintefaces
  - Declaring the signatures of interface methods

*** Compiling

To compile a lib, use the [[clojure:core.clj::(defn compile][compile]] function, and supply the namespace
name as a symbol. For some namespace my.domain.lib, defined in
my/domain/lib.clj, in the classpath, the following should occur:

- A loader classfile will be produced in ~my/domain/lib__init.class~,
  under ~*compile-path*~, which must be in the classpath
- A set of classfiles will be produced, one per fn in the namespace,
  with names such as ~my/domain/lib$fnname__1234.class~
- For each gen-class:
  - A stub classfile will be produced with the specified name

*** Compiler options
:PROPERTIES:
:CUSTOM_ID: content/reference/compilation#compiler-options
:END:

The Clojure compiler can be controlled via the use of several compiler
flags. At runtime these are stored in the dynamic var
~clojure.core/*compiler-options*~, which is a map with the following
optional keyword keys:

- ~:disable-locals-clearing~ (boolean)
- ~:elide-meta~ (vector of keywords)
- ~:direct-linking~ (boolean)

These compiler options can be changed in a dynamic binding around a call
to the ~compile~ function to change the compiler behavior.

Alternately, compiler options can also be set via the Java system
properties at startup:

- ~-Dclojure.compiler.disable-locals-clearing=true~
- ~"-Dclojure.compiler.elide-meta~[:doc :file :line :added]"=
- ~-Dclojure.compiler.direct-linking=true~

See below for more info on each of these options.

**** Locals clearing

By default, the Clojure compiler produces code that eagerly clears GC
references to local bindings. However, when using a debugger locals will
appear as nulls, which makes debugging difficult. Setting
~disable-locals-clearing=true~ will prevent locals clearing. It is not
recommended to disable locals clearing for production compilation.

**** Elide meta

Var meta (docstrings, file and line info, etc) will be compiled into
strings in the constant pool of the compiled classes. To decrease class
size and make classloading faster, meta can be elided. This option takes
a vector of meta keywords that should be removed - some common ones
include ~:doc~, ~:file~, ~:line~, and ~:added~. Note that eliding meta
may make certain features inoperable (for example, ~doc~ cannot return
docstrings if they have been elided).

**** Direct linking
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/compilation.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/compilation
:CUSTOM_ID: content/reference/compilation#direct-linking
:END:

Normally, invoking a function will cause a var to be dereferenced to
find the function instance implementing it, then invoking that function.
This indirection via the var is one of the ways that Clojure provides a
dynamic runtime environment. However, it has long been observed that the
majority of function invocations in a production environment are never
redefined in this way, incurring unnecessary redirection.

/Direct linking/ can be used to replace this indirection with a direct
static invocation of the function instead. This will result in faster
var invocation. Additionally, the compiler can remove unused vars from
class initialization and direct linking will make many more vars unused.
Typically this results in smaller class sizes and faster startup times.

One consequence of direct linking is that var redefinitions will not be
seen by code that has been compiled with direct linking (because direct
linking avoids dereferencing the var). Vars marked as ~^:dynamic~ will
never be direct linked. If you wish to mark a var as supporting
redefinition (but not dynamic), mark it with ~^:redef~ to avoid direct
linking.

As of Clojure 1.8, the Clojure core library itself is compiled with
direct linking.

*** Runtime

Classes generated by Clojure are highly dynamic. In particular, note
that no method bodies or other implementation details are specified in
gen-class - it specifies only a signature, and the class that it
generates is only a stub. This stub class defers all implementation to
functions defined in the implementing namespace. At runtime, a call to
some method foo of the generated class will find the current value of
the var implementing.namespace/prefixfoo and call it. If the var is not
bound or nil, it will call the superclass method, or if an interface
method, generate an UnsupportedOperationException.

*** gen-class Examples

In the simplest case, an empty :gen-class is supplied, and the compiled
class has only main, which is implemented by defining -main in the
namespace. The file should be saved in src/clojure/examples/hello.clj:

#+BEGIN_SRC clojure
(ns clojure.examples.hello
    (:gen-class))

(defn -main
  [greetee]
  (println (str "Hello " greetee "!")))
#+END_SRC

To compile, ensure the target output directory ~classes~ exists:

#+BEGIN_EXAMPLE
mkdir classes
#+END_EXAMPLE

And create a deps.edn file describing your classpath:

#+BEGIN_SRC clojure
{:paths ["src" "classes"]}
#+END_SRC

Then compile to generate the classes as follows:

#+BEGIN_SRC clojure
$ clj
Clojure 1.10.1
user=> (compile 'clojure.examples.hello)
clojure.examples.hello
#+END_SRC

And can be run like an ordinary Java app like so (be sure to include the
output classes directory):

#+BEGIN_SRC clojure
java -cp `clj -Spath` clojure.examples.hello Fred
Hello Fred!
#+END_SRC

Here's an example using both a more involved :gen-class, and stand-alone
calls to gen-class and gen-interface. In this case we are creating
classes we intend to create instances of. The clojure.examples.instance
class will implement java.util.Iterator, a particularly nasty interface,
in that it requires the implementation to be stateful. This class is
going to take a String in its constructor and implement the Iterator
interface in terms of delivering the characters from the string. The
:init clause names the constructor function. The :constructors clause is
a map of constructor signature to superclass constructor signature. In
this case, the superclass defaults to Object, whose constructor takes no
arguments. This object will have state, called state, and a main so we
can test it.

:init functions (-init in this case) are unusual, in that they always
return a vector, the first element of which is a vector of arguments for
the superclass constructor - since our superclass takes no args, this
vector is empty. The second element of the vector is the state for the
instance. Since we are going to have to mutate the state (and the state
is always final) we'll use a ref to a map containing the string and the
current index.

hasNext and next are implementations of methods in the Iterator
interface. While the methods take no args, the implementation functions
for instance methods will always take an additional first arg
corresponding to the object the method is called upon, called by
convention 'this' here. Note how the state can be obtained using an
ordinary Java field access.

The gen-interface call will create an interface called
clojure.examples.IBar, with a single method bar.

The stand-alone gen-class call will generate another named class,
clojure.examples.impl, whose implementing namespace will default to the
current namespace. It implements clojure.examples.IBar. The :prefix
option causes the implementation of methods to bind to functions
beginning with "impl-" rather than the default "-". The :methods option
defines a new method foo not present in any superclass/interfaces.

Note in main how an instances of the classes can be created, and methods
called, using ordinary Java interop. Using it would be similarly
ordinary from Java.

#+BEGIN_SRC clojure
(ns clojure.examples.instance
    (:gen-class
     :implements [java.util.Iterator]
     :init init
     :constructors {[String] []}
     :state state))

(defn -init [s]
  [[] (ref {:s s :index 0})])

(defn -hasNext [this]
  (let [{:keys [s index]} @(.state this)]
    (< index (count s))))

(defn -next [this]
  (let [{:keys [s index]} @(.state this)
        ch (.charAt s index)]
    (dosync (alter (.state this) assoc :index (inc index)))
    ch))

(gen-interface
 :name clojure.examples.IBar
 :methods [[bar [] String]])

(gen-class
 :name clojure.examples.impl
 :implements [clojure.examples.IBar]
 :prefix "impl-"
 :methods [[foo [] String]])

(defn impl-foo [this]
  (str (class this)))

(defn impl-bar [this]
  (str "I " (if (instance? clojure.examples.IBar this)
              "am"
              "am not")
       " an IBar"))

(defn -main [s]
  (let [x (new clojure.examples.instance s)
        y (new clojure.examples.impl)]
    (while (.hasNext x)
      (println (.next x)))
    (println (.foo y))
    (println (.bar y))))
#+END_SRC

Compile as above:

#+BEGIN_SRC clojure
$ clj
Clojure 1.10.1
user=> (compile 'clojure.examples.instance)
clojure.examples.instance
#+END_SRC

And run like an ordinary Java app:

#+BEGIN_SRC clojure
java -cp `clj -Spath` clojure.examples.instance asdf
a
s
d
f
class clojure.examples.impl
I am an IBar
#+END_SRC

** Other Included Libraries
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/other_libraries.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/other_libraries
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/compilation
:NEXTPAGE_CUSTOM_ID: content/reference/lisps
:CUSTOM_ID: content/reference/other_libraries
:END:
*** Java Utilities (clojure.java.*)

*[[clojure:java/io.clj][clojure.java.io]]*

Contains polymorphic I/O utility functions for Clojure backed by Java
classes.

*[[clojure:java/javadoc.clj][clojure.java.javadocs]]*

Provides the function [[clojure:java/javadoc.clj::(defn javadoc][javadoc]] that attempts to display the appropriate
Javadocs for a class or instance class.

*[[clojure:java/shell.clj][clojure.java.shell]]*

Provides a [[clojure:java/shell.clj::(defn sh][sh]] function that facilitates launching and managing
subprocesses. See the function documentation for details on its
expected arguments.

*** Parallel Processing (DEPRECATED)

The parallel library (namespace ~parallel~, in parallel.clj) wraps the
[[http://gee.cs.oswego.edu/dl/concurrency-interest/index.html][ForkJoin library]]. This lib is now deprecated.

You'll need ~jsr166y.jar~ in your classpath in order to use this
library. The basic idea is that Clojure collections, and most
efficiently vectors, can be turned into parallel arrays for use by this
library with the function par, although most of the functions take
collections and will call ~par~ if needed, so normally you will only
need to call par explicitly in order to attach bound/filter/map ops.

Parallel arrays support the attachment of bounds, filters and mapping
functions prior to realization/calculation, which happens as the result
of any of several operations on the array
(pvec/psort/pfilter-nils/pfilter-dupes). Rather than perform composite
operations in steps, as would normally be done with sequences, maps and
filters are instead attached and thus composed by providing ops to
~par~. Note that there is an order sensitivity to the attachments -
bounds precede filters precede mappings. All operations then happen in
parallel, using multiple threads and a sophisticated work-stealing
system supported by fork-join, either when the array is realized, or to
perform aggregate operations like preduce/pmin/pmax etc.

A parallel array can be realized into a Clojure vector using pvec

#+BEGIN_SRC clojure
(load-file "src/parallel.clj")
(refer 'parallel)

(def f (vec (take 20 (repeatedly #(rand-int 20)))))

f
-> [11 7 10 9 4 1 4 18 15 13 10 7 0 9 16 6 19 11 14 7]

;return value/index pairs of all entries < their index, in parallel

(pvec (par f :filter-index < :map-index vector))
-> [[1 5] [4 6] [7 11] [0 12] [9 13] [6 15] [11 17] [14 18] [7 19]]
#+END_SRC

*** Reflection Utilities ([[clojure:reflect.clj][clojure.reflect]])

Provides functions and protocols useful for gathering and building host
type reflection information as Clojure data.

*** REPL Utilities ([[clojure:repl.clj][clojure.repl]])

Utilities meant to be used interactively at the REPL.

*** Sets and Relational Algebra ([[clojure:set.clj][clojure.set]])

Functions useful for manipulating, building, and querying mathematical
sets using relational algebra.

*** String Handling ([[clojure:string.clj][clojure.string]])

Functions for manipulating strings.

*** Unit Testing ([[clojure:test.clj][clojure.test]])

A Clojure unit testing framework.

*** Walking Data Structures ([[clojure:walk.clj][clojure.walk]])

Utilities for traversing and manipulating nested data structures.

*** XML ([[clojure:xml.clj][clojure.xml]])

Utilities for reading and writing XML data.

*** Zippers - Functional Tree Editing ([[clojure:zip.clj][clojure.zip]])

Clojure includes purely functional, generic tree walking and editing,
using a technique called a zipper (in namespace /*zip*/) . For
background, see the [[https://www.google.com/search?q=huet%20functional%20zipper][paper by Huet]]. A zipper is a data structure
representing a location in a hierarchical data structure, and the path
it took to get there. It provides down/up/left/right navigation, and
localized functional 'editing', insertion and removal of nodes. With
zippers you can write code that looks like an imperative, destructive
walk through a tree, call [[clojure:zip.clj::(defn root][root]] when you are done and get a new tree
reflecting all the changes, when in fact nothing at all is mutated -
it's all thread safe and shareable. The [[clojure:zip.clj::(defn next][next]] function does a
depth-first walk, making for easy to understand loops:

#+BEGIN_SRC clojure
(def data '[[a * b] + [c * d]])
(def dz (zip/vector-zip data))

;find the second *
(-> dz zip/down zip/right zip/right zip/down zip/right zip/node)
-> *

;'remove' the first 2 terms
(-> dz zip/next zip/remove zip/next zip/remove zip/root)
-> <<c * d#,c * d>>


;'replace' * with /
(loop [loc dz]
  (if (zip/end? loc)
    (zip/root loc)
    (recur
     (zip/next
      (if (= (zip/node loc) '*)
        (zip/replace loc '/)
        loc)))))

-> [[a / b] + [c / d]]


;'remove' *
(loop [loc dz]
  (if (zip/end? loc)
    (zip/root loc)
    (recur
     (zip/next
      (if (= (zip/node loc) '*)
        (zip/remove loc)
        loc)))))

-> [[a b] + [c d]]


;original is intact
(zip/root dz)
-> [[a * b] + [c * d]]
#+END_SRC

Zipper constructors are provided for nested seqs, nested vectors, and
the xml elements generated by ~xml/parse~. All it takes is a 4-5 line
function to support other data structures.

** Differences with other Lisps
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/lisps.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/lisps
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:PREVPAGE_CUSTOM_ID: content/reference/other_libraries
:NEXTPAGE_CUSTOM_ID: content/reference/deps_and_cli
:CUSTOM_ID: content/reference/lisps
:END:

This information is provided for programmers familiar with Common Lisp
or Scheme.

- Clojure is case sensitive
- Clojure is a Lisp-1
- () is not the same as nil
- The reader is side-effect free
- Keywords are not Symbols
- Symbols are not storage locations (see Var)
- ~nil~ is not a Symbol
- t is not syntax, use ~true~
- The read table is currently not accessible to user programs
- ~let~ binds sequentially
- ~do~ is not a looping construct
- There is no tail-call optimization, use ~recur~.
- syntax-quote does symbol resolution, so `x is not the same as 'x.
- ` has auto-gensyms.
- ~ is unquote ',' is whitespace
- There is reader syntax for maps, vectors, and sets
- ~cons~, ~first~ and ~rest~ manipulate sequence abstractions,
  not concrete cons cells
- Most data structures are immutable
- lambda is ~fn~, and supports overloading by arity
- ~=~ is the equality predicate
- Global Vars can be dynamically rebound (if declared dynamic) without
  interfering with lexical local bindings. No special declarations are
  necessary to distinguish between dynamic and lexical bindings. Since
  Clojure is a Lisp-1, (global) functions can be dynamically rebound
  (if they are marked as dynamic).
- No letrec, labels or flet - use (fn name [args]...​) for
  self-reference, [[clojure:core.clj::(defmacro letfn][letfn]] for mutual reference.
- In Clojure ~nil~ means 'nothing'. It signifies the absence of a
  value, of any type, and is not specific to lists or sequences.
- Empty collections are distinct from ~nil~. Clojure does not equate
  ~nil~ and '().
- ~false~ means one of the two possible boolean values, the other
  being ~true~
- There is more to collections than lists. You can have instances of
  empty collections, some of which have literal support ([], {}, and
  ()). Thus there can be no sentinel empty collection value.
- Coming from Scheme, ~nil~ may map most closely to your notion of
  #f.
- A big difference in Clojure, is sequences. Sequences are not specific
  collections, esp. they are not necessarily concrete lists. When you
  ask an empty collection for a sequence of its elements (by calling
  ~seq~) it returns ~nil~, saying "I can't produce one". When you ask
  a sequence on its last element for the ~rest~ it returns *another
  logical sequence.* You can only tell if that sequence is empty by
  calling ~seq~ on it in turn. This enables sequences and the sequence
  protocol to be /lazy/.
- Some of the sequence functions correspond to functions from Scheme
  and CL that there manipulated only pairs/conses ('lists') and
  returned sentinel values ('() and nil) that represented 'empty'
  lists. The Clojure return values differ in not returning specific
  empty collections, but rather another logical sequence. Some of the
  sequence functions have no counterpart in Scheme/CL, and map to
  Haskell/ML-like functions. Some of those functions return infinite or
  calculated sequences, where the analogy to concrete data-structures
  like Scheme/CL lists is tenuous at best.
- It helps to distinguish collections/data-structures and
  seqs/iteration. In both CL and Scheme they are conflated, in Clojure
  they are separate.

|                             | Clojure                  | Common Lisp | Scheme     | Java              |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| Has nil?                    | nil - means 'nothing'    | nil - means | -          | null              |
|                             |                          | false or    |            |                   |
|                             |                          | empty list  |            |                   |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| Has true?                   | true                     | -           | #t         | true (primitive)  |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| Has false?                  | false                    | -           | #f         | false (primitive) |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| Conditionals distinguish:   | nil or false /           | nil/non-nil | #f/non-#f  | false/true        |
|                             | everything else          |             |            |                   |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| List/sequence library       | No - seq abstraction     | Yes - cons  | Yes - pair | No - Iterator     |
| manipulates distinguished   | with many collection     | and vector  |            | abstraction with  |
| concrete type(s)?           | implementations          |             |            | many collection   |
|                             |                          |             |            | implementations   |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| Singleton empty-list value? | No - can have distinct   | nil         | '()        | No                |
|                             | empty values of concrete |             |            |                   |
|                             | collection types         |             |            |                   |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| End-of-sequence returns:    | a logical sequence for   | nil         | '()        | false             |
|                             | which ~seq~ returns nil    |             |            |                   |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| Host null:                  | nil                      | NA          | NA         | NA                |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| Host true:                  | true (boxed)             | NA          | NA         | NA                |
|-----------------------------+--------------------------+-------------+------------+-------------------|
| Host false:                 | false (boxed)            | NA          | NA         | NA                |

** Deps and CLI Reference
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/deps_and_cli.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/deps_and_cli
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-09-04
:CUSTOM_ID: content/reference/deps_and_cli
:END:
*** Rationale

Clojure "endeavors to be a general-purpose language suitable in those
areas where Java is suitable" (from [[#content/about/rationale][Rationale]]). To effectively target
the JVM platform, Clojure needs to provide ready access to Java
libraries, ideally in a way suited for dynamic development. In
practice, this means meeting the JVM platform in two places:

- the classpath used when invoking JVM processes (and/or
  URLClassLoaders)
- transitive dependency download and resolution from providers like
  Maven

Clojure build tools have traditionally taken the approach of wrapping
the Maven ecosystem to gain access to Java libraries. However, they have
also forced this approach on Clojure code as well, requiring a focus on
artifacts that must be built and deployed (which Clojure does not
require). This approach has created friction for Clojure developers,
making it hard to e.g. work with libs not yet publishing artifacts, work
on speculative changes w/o artifacts or across multiple libs, or give
control to a 3rd party to manage shared dependencies.

To this end Clojure provides:

- [[https://github.com/clojure/tools.deps.alpha][tools.deps.alpha]] - a library providing an API for resolving
  dependency graphs and building classpaths that can utilize both
  Maven and other providers of code or artifacts
- Command line tools (~clojure~ and ~clj~) that enable users to make use
  of this capability at the terminal to declare dependencies, assemble
  classpaths, and launch Clojure programs with data
- System-specific installers for downloading the tools, improving the
  "Getting Started" experience

*** Overview

You use the Clojure tools (~clj~ or ~clojure~) to run Clojure programs
on the JVM, e.g. to start a REPL or invoke a specific function with
data. The Clojure tools will configure the JVM process by defining a
classpath (with desired libraries), an execution environment (JVM
options), the main class, and args.

Using a deps.edn file (or files), you tell Clojure where your source
code resides and what libraries you need. Clojure will then calculate
the full set of required libraries and a classpath, caching expensive
parts of this process for better performance.

The internal steps of the Clojure tools, as well as the Clojure
functions you intend to run, are parameterized by data structures, often
maps. Shell command lines are not optimized for passing nested data, so
instead you will put the data structures in your deps edn file and refer
to them on the command line via /aliases/ - keywords that name data
structures.

~clj~ and ~clojure~ differ in that ~clj~ has extra support for use as a
REPL in a terminal, and should be preferred unless you don't want that
support, then use ~clojure~. The invocation structure is the same for
both:

#+BEGIN_EXAMPLE
clj     [clj-opt*] [exec-opt]
clojure [clj-opt*] [exec-opt]
#+END_EXAMPLE

**** Start a REPL

To run a REPL, invoke ~clj~ without any exec-opt:

#+BEGIN_EXAMPLE
$ clj
Clojure 1.10.3
user=>
#+END_EXAMPLE

**** Execute a function

Use the following exec-opt to invoke a function that takes a map:

#+BEGIN_EXAMPLE
clojure [clj-opt*] -X[aliases] [a/fn] [kpath v]* kv-map?
#+END_EXAMPLE

~-X~ is configured with an arg map with ~:exec-fn~ and ~:exec-args~
keys, and stored under an alias in ~deps.edn~:

#+BEGIN_SRC clojure
;; deps.edn
{:aliases
 {:my-fn
  {:exec-fn my.qualified/fn
   :exec-args {:my {:data 123}
               :config 456}}}}
#+END_SRC

To invoke, pass the name of the alias to ~-X~:

#+BEGIN_EXAMPLE
clj -X:my-fn
#+END_EXAMPLE

You can supply additional keys, or override values stored in the
deps.edn file by passing pairs of key-path and value. The key-path
should either be a single key or a vector of keys to refer to a nested
key (as with ~assoc-in~). Each key-path will be used to ~assoc-in~ to
the original ~:exec-args~ map, overriding the value there.

#+BEGIN_EXAMPLE
# Top key override
clj -X:my-fn :config 789

# Nested key override
clj -X:my-fn '[:my :data]' 789
#+END_EXAMPLE

#+BEGIN_QUOTE
*Note*

See the later section on [[#content/reference/deps_and_cli#quoting-keys-and-values]["Quoting keys and values"]] for more details on
how to properly quote edn values on the command line.
#+END_QUOTE

If you want to execute an arbitrary function, you can pass it on the
command instead, along with pairs of key-path and value:

#+BEGIN_EXAMPLE
clj -X my.qualified/fn :config 789
#+END_EXAMPLE

#+BEGIN_QUOTE
*Note*

Alias arg maps can also include a default namespace or namespace
aliases for resolving the function (see [[#content/reference/deps_and_cli#namespace-resolution]["Namespace resolution"]] for
more details).
#+END_QUOTE

**** Running a main or script

You can use the ~-M~ exec-opt to invoke clojure.main, which supports
calling a namespace with a ~-main~ function or a Clojure script:

#+BEGIN_EXAMPLE
clojure [clj-opt*] -M[aliases] [main-opts]
#+END_EXAMPLE

The -M aliases are pulled from ~deps.edn~ and combined to form an arg
map. The arg map can modify the classpath or supply main options.

See the [[#content/reference/repl_and_main][clojure.main]] documentation for more
details on main options.

**** Running a tool

Use the ~-T~ exec-opt to invoke a tool that does not use the project
classpath:

#+BEGIN_EXAMPLE
clojure [clj-opt*] -T[name|aliases] a/fn [kpath v]* kv-map?
#+END_EXAMPLE

When running a tool, the project's ~:deps~ and ~:paths~ are not used.
The function is invoked with a map in the same way as -X execution,
built from :exec-args if found in aliases and key/vals provided on the
command line.

Tools are installed and referenced by a simpler local name, instead of
via an alias. See [[#content/reference/deps_and_cli#tool-installation-and-invocation][tool installation]] for more details.

*** Operation

When you execute the Clojure tool, there are a series of steps performed
to prepare and execute your command. This section is an overview of
those steps, see later sections for how to modify those steps in a
variety of ways.

*Locate deps edn sources*

Configuration is stored in one or more "deps edn" maps. These are edn
maps with the following primary top-level keys:

- ~:deps~ - map of lib (symbol) to coordinate
- ~:paths~ - vector of project source paths
- ~:aliases~ - map of alias name to alias data

The Clojure tools look for 4 potential deps edn sources:

- Root - part of the clj installation (a resource in the tools.deps
  library)
- User - cross-project configuration (typically tools), usually found
  at ~~/.clojure/deps.edn~
- Project - the ~deps.edn~ in the current directory
- External - a deps edn map passed on the command line

*Check cache*

The next several steps of this execution can be skipped if we have
already computed the classpath and cached it. Classpath and the runtime
basis files are cached in the current directory under ~.cpcache/~. The
key is based on the contents of the deps.edn files and some of the
command arguments passed and several files will be cached, most
importantly the classpath and runtime basis.

If the key is found, and the cached files are newer than all deps.edn
sources, they will be used and execution begins immediately.

*Replace project environment ("tool")*

When you execute a tool in the context of your project, the tool can use
its own paths and/or deps in place of the project's paths and/or deps.

*Merge sources*

All deps edn sources are merged into a single master edn file in the
order listed above - root, user, project (possibly with tool
replacements), external. This merged deps will be included in the
runtime basis and used after this point.

The merge is essentially ~merge-with merge~, except for the ~:paths~
key, where only the last ~:paths~ found is used (they replace, not
combine).

*Resolve dependencies*

Starting from the master edn's merged :deps, the full transitive
expansion of the dependency tree is computed. Dependency sources
(procurers) are used to obtain metadata and other dependency
information. At the completion of this step, all libraries to use in the
execution have been found and downloaded to local files if needed.

See [[#content/reference/dep_expansion][dep expansion]] for more details on the dep expansion algorithm.

*Prep libs*

Libs in the transitive expansion will be checked for whether they are
source libs that require prepping. If so, and prep is requested, prep
the libs. If unprepped libs remain, throw and stop.

*Make classpath*

JVM execution relies on computing the classpath for the execution. The
classpath will consist of the ~:paths~ in the merged ~deps.edn~ and the
locations of all resolved dependencies.

*Prepare JVM environment*

JVM arguments may either be passed on the command line (with ~-J~) or by
using data stored in an alias under ~:jvm-opts~ and passed with ~-X~ or
~-A~ or ~-M~

*Execute command*

Finally the command is executed - see the Overview above for the
execution options. The already computed (or loaded from cache)
classpath, JVM environment, and main arguments if relevant are used in
the execution.

*** deps.edn
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#deps.edn
:END:

The configuration file format (in ~deps.edn~ files) is an edn map with
top-level keys ~:deps~, ~:paths~, and ~:aliases~, plus provider-specific
keys for configuring dependency sources.

**** Paths

Paths are declared in a top level key ~:paths~ and are a vector of
string paths or alias names. Relative paths are resolved in relation to
the directory containing the deps.edn (the project root). These source
paths will be added to the classpath. Source paths should be at or under
the project root directory (where ~deps.edn~ is located).

Example:

#+BEGIN_SRC clojure
{:paths ["src"]}
#+END_SRC

If used, alias names should refer to a path vector in the alias data:

#+BEGIN_SRC clojure
{:paths [:clj-paths :resource-paths]
 :aliases
 {:clj-paths ["src/clj" "src/cljc"]
  :resource-paths ["resources"]}}
#+END_SRC

**** Dependencies

Dependencies are declared in deps.edn with a top level key ~:deps~ - a
map from library to coordinate. Libraries are symbols of the form
~<groupID>/<artifactId>~. To indicate a Maven classifier, use
~<groupId>/<artifactId>$<classifier>~.

Coordinates can take several forms depending on the coordinate type:

- Maven coordinate: ~{:mvn/version "1.2.3"}~
  - Other optional keys: ~:exclusions~
  - Note: ~:classifier~ is not supported - add to lib name as
    specified above
- Local project coordinate: ~{:local/root "/path/to/project"}~
  - Optional key ~:deps/manifest~
    - Specifies the project manifest type
    - Default is to auto-detect the project type (currently either
      ~:deps~ or ~:pom~)
- Local jar coordinate: ~{:local/root "/path/to/file.jar"}~
  - If the jar includes a pom.xml file, it will be used to find
    transitive deps
- Git coordinate:
  ~{:git/url "https://github.com/user/project.git", :git/sha "sha", :git/tag "tag"}~
  - Optional key ~:git/url~ will be inferred from lib, or can be one
    of the following:
    - https - secure anonymous access to public repos
    - ssh or user@host form urls (including GitHub) - ssh-based
      access (see Git configuration section)
  - Optional key ~:git/tag~ is used only to indicate the semantics of
    the sha (~:tag~ still supported for backwards compatibility)
  - Optional key ~:git/sha~ if tag provided, can be prefix sha,
    otherwise should be full sha (~:sha~ still supported for backwards
    compatibility)
  - Optional key ~:deps/root~
    - Specifies the relative path within the root to search for the
      manifest file
  - Optional key ~:deps/manifest~ - same as in ~:local~ deps

#+BEGIN_SRC clojure
{:deps
 {org.clojure/tools.reader {:mvn/version "1.1.1"}
  io.github.sally/awesome {:tag "v1.2.3" :sha "123abcd"}
  ;; ... add more here
 }}
#+END_SRC

**** Aliases

Aliases give a name to a data structure that can be used either by the
Clojure tool itself or other consumers of deps.edn. They are defined in
the ~:aliases~ section of the config file. These Clojure tool
subprocesses use data which can be read from aliases:

**** Other keys

Some other top-level keys you may encounter:

- ~:mvn/repos~ - a map of Maven repository names to maps of repo info
  (like ~:url~)
- ~:mvn/local-repo~ - a string path to a directory to use as the local
  Maven cache
- ~:tools/usage~ - exec argmap for a deps.edn-based tool
- ~:deps/prep-lib~ - a map describing how this source-based lib should
  be prepped

*** Basis and classpath

The core of the tools.deps library is a process to take a merged
deps.edn file, arg maps for the resolve-deps and make-classpath-map
steps, and produce the "runtime basis", or "basis" for short. The basis
is a superset of the deps.edn file also containing those args, the lib
map, and the classpath map.

The JVM classpath consists of a series of roots, either directory paths
or the path to a jar file. Classes (and Clojure files) map via package
or namespace to a path relative to a classpath root. For example, the
~java.lang.String~ class can be found at path ~java/lang/String.class~
and the ~clojure.set~ Clojure namespace may be found at paths
~clojure/set.class~ (for AOT), ~clojure/set.clj~, or ~clojure/set.cljc~.
When the JVM needs to load one of these files it searches each root for
the relative path and loads it when found.

We divide the process of building a classpath into two primary
operations: ~resolve-deps~ and ~make-classpath-map~.

**** resolve-deps

~(resolve-deps deps args-map)~

~resolve-deps~ takes an initial map of required dependencies and a map
of args that modify the resolution process. It builds a full graph of
transitive dependencies, resolves any version differences, and flattens
that graph to a full list of libraries to be included on the classpath.

The deps from the merged deps.edn is a map of library to coordinate. The
library is (in Maven terms) the groupId and artifactId, which are
sufficient to locate the desired project. The coordinate is used to
describe a particular version that is being requested from a particular
provider (like Maven or git).

For example, this deps map specifies a (Maven-based) dependency:

#+BEGIN_SRC clojure
{org.clojure/core.cache {:mvn/version "0.6.5"}}
#+END_SRC

~resolve-deps~ expands these dependencies to include all transitive
dependencies, cut cycles, resolve version differences, download required
artifacts from the provider, and produce a *lib map* of the flattened
set of all needed dependencies and where to find their artifacts:

#+BEGIN_SRC clojure
{org.clojure/core.cache        {:mvn/version "0.6.5",
                                :deps/manifest :mvn,
                                :paths [".../core.cache-0.6.5.jar"]}
 org.clojure/data.priority-map {:mvn/version "0.0.7",
                                :deps/manifest :mvn,
                                :dependents [org.clojure/core.cache],
                                :paths [".../data.priority-map-0.0.7.jar"]}
 ... }
#+END_SRC

The lib map lists all libraries, their selected coordinates, the
~:paths~ on disk, and a list of dependents that caused it to be
included. Here you can see that ~data.priority-map~ was included as a
dependency of core.cache.

The second ~args-map~ is a map of optional modifications to the standard
expansion to account for common use cases: adding extra dependencies,
overriding deps, and default deps. These can be used separately or
together, or not at all:

#+BEGIN_SRC clojure
{:extra-deps { ... }
 :override-deps { ... }
 :default-deps { ... }}
#+END_SRC

~:extra-deps~ is the most common modification - it allows you to
optionally add extra dependencies to the base dependency set. The value
is a map of library to coordinate:

#+BEGIN_SRC clojure
{:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}
#+END_SRC

~:override-deps~ overrides the coordinate version chosen by the version
resolution to force a particular version instead. This also takes a map
of library to coordinate:

#+BEGIN_SRC clojure
{:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
#+END_SRC

~:default-deps~ provides a set of default coordinate versions to use if
no coordinate is specified. The default deps can be used across a set of
shared projects to act as a dependency management system:

#+BEGIN_SRC clojure
{:default-deps {org.clojure/core.cache {:mvn/version "0.6.4"}}}
#+END_SRC

**** make-classpath-map

~(make-classpath-map lib-map paths args-map)~

The ~make-classpath-map~ step takes the lib map (the result of
~resolve-deps~), the internal source paths of the project ~["src"]~, an
args-map of optional modifications, and produces a classpath string for
use in the JVM.

The args-map includes support for modifications to be applied while
making the classpath: adding extra paths, and overriding the location of
libraries specified in the lib map. These modifications can be used
separately or together or not at all in a map like this:

#+BEGIN_SRC clojure
{:extra-paths [ ... ]
 :classpath-overrides { ... }}
#+END_SRC

~:extra-paths~ is used to include source paths in addition to your
standard source paths, for example to include directories of test
source:

#+BEGIN_SRC clojure
{:extra-paths ["test" "resources"]}
#+END_SRC

Note that external paths should be at or under the root directory of the
project (location of the ~deps.edn~ file).

~:classpath-overrides~ specify a location to pull a dependency that
overrides the path found during dependency resolution, for example to
replace a dependency with a local debug version. Many of these use cases
are ones where you would be tempted to prepend the classpath to
"override" something else.

#+BEGIN_SRC clojure
{:classpath-overrides
 {org.clojure/clojure "/my/clojure/target"}}
#+END_SRC

*** Clojure tools usage
**** deps.edn sources

The Clojure tools will use the following deps.edn map sources, in this
order:

- Root - found in the installation of clj (or as a resource in
  tools.deps)
- User - cross-project configuration (typically tools)
  - Locations used in this order:
    - If ~$CLJ_CONFIG~ is set, then use ~$CLJ_CONFIG~ (explicit
      override)
    - If ~$XDG_CONFIG_HOME~ is set, then use
      ~$XDG_CONFIG_HOME/clojure~ (Freedesktop conventions)
    - Else use ~$HOME/.clojure~ (most common)
- Project - the ~deps.edn~ in the current directory
- External - a ~deps.edn~ map passed on the command line

The deps.edn sources can be modified or inspected by the following
options:

- ~-Sverbose~ - print all source locations
- ~-Sdeps~ - pass the config data on the command line
- ~-Srepro~ - omit the user deps source (other sources will be used if
  found)

**** Classpath caching

The cached classpath file is used for execution when:

- It exists and
- It is newer than all ~deps.edn~ sources

Classpath and basis files are cached in a directory computed as follows:

- If there is a project deps.edn
  - Use ~./.cpcache~
- Else (no project deps.edn)
  - If ~$CLJ_CACHE~ is set, then use ~$CLJ_CACHE~ (explicit override)
  - If ~$XDG_CACHE_HOME~ is set, then use ~$XDG_CACHE_HOME/clojure~
    (Freedesktop conventions)
  - Else use ~config_dir/.cpcache~ (see deps.edn sources for
    ~config_dir~ logic, usually ~~/.clojure~)

A hash is computed based on the config file paths, the resolve-aliases,
and the classpath aliases.

Files cached (if needed):

- ~<hash>.libs~ - a ~::lib-map~ in the [[https://github.com/clojure/tools.deps.alpha/blob/master/src/main/clojure/clojure/tools/deps/alpha/specs.clj][specs]], the output of running
  ~resolve-deps~
- ~<hash>.cp~ - a classpath string, the output of ~make-classpath-map~
- ~<hash>.jvm~ - jvm options for main execution
- ~<hash>.main~ - main options for main execution
- ~<hash>.basis~ - the runtime basis, passed to the program

Caching can be modified by the following options:

- ~-Sforce~ - ignore cache and force recomputation
- ~-Scp CP~ - don't use cache or compute, use the provided classpath
  instead

**** Replace project environment (tool)

The ~tool~ process is used when executing a tool that should not use the
project classpath environment. This process takes the project deps.edn
and the following modifier args and replaces them (if provided) before
the project deps is merged:

- ~:replace-deps~ - a deps map from lib to coordinate of deps to
  REPLACE the project ~:deps~
- ~:replace-paths~ a collection of string paths to REPLACE project
  ~:paths~ (note these should be under the project root)

This tool map should be provided as an alias in one of the deps sources
and provided to the Clojure tools using -A (for REPL invocation), -X
(for function execution), or -M (for clojure.main execution). Multiple
aliases can be provided by concatentating the alias names.

**** Merging deps.edn

The ~deps.edn~ files found from the source locations (with Clojure tool
modifications by any options) are merged to form one master deps map.
The merge is done in the order above root/user/project/config, last one
wins. The operation is essentially ~merge-with merge~, except for the
~:paths~ key, where only the last one found is used (they are not
combined).

**** Resolve deps modifiers

The resolve-deps modifiers are provided in a map that was described in a
prior section:

- ~:extra-deps~ - a deps map from lib to coordinate of deps to add to
  the deps
- ~:override-deps~ - a deps map from lib to coordinate of override
  versions to use
- ~:default-deps~ - a deps map from lib to coordinate of versions to
  use if none is found
- If multiple alias maps with these keys are activated, all of them are
  merge-with merged

The resolve-deps args should be provided as an alias in one of the deps
sources and provided to the Clojure tools using -A (for REPL
invocation), -X (for function execution), or -M (for clojure.main
execution). Multiple aliases can be provided by concatentating the alias
names.

**** Make classpath modifiers

The make-classpath-map modifiers are provided in a map that was
described in a prior section:

- ~:extra-paths~ - a collection of string paths to add to ~:paths~
  (should be in the project)
- ~:classpath-overrides~ - a map of lib to string path to replace the
  location of the lib
- If multiple maps with these keys are activated, ~:extra-paths~
  concatenate and ~:classpath-overrides~ merge-with merge

The resolve-deps args should be provided as an alias in one of deps
sources and provided to the Clojure tools using -A (for REPL
invocation), -X (for function execution), or -M (for clojure.main
execution). Multiple aliases can be provided by concatentating the alias
names.

**** Prepare JVM environment

The JVM has many options and some programs also take configuration via
Java system properties. JVM options can be passed on the command line
for any execution specfier by prefixing with ~-J~. If multiple options
are specified, each must be prefixed.

Additionally, main execution can take a map with key ~:jvm-opts~:

- ~:jvm-opts~ - a collection of string JVM options
- If multiple maps with these keys are activated, ~:jvm-opts~
  concatenate
- If -J JVM options are also specified on the command line, they are
  concatenated after the alias options

This map is stored in alias data and provided to the Clojure tools using
-A (for REPL invocation), -X (for function execution), or -M (for
clojure.main execution). Multiple aliases can be provided by
concatentating the alias names.

**** Execution
***** Main execution

One additional option for main execution is a map with key ~:main-opts~:

- ~:main-opts~ - a collection of clojure.main options
- If multiple maps with these keys are activated, only the last one
  will be used
- If command line clojure.main arguments are supplied on the command
  line, they are concatenated after the last main alias map

This map is stored in alias data and provided to the Clojure tools using
~-M:an-alias~. Multiple aliases can be provided by concatentating the
alias names.

***** Prepare for execution

The ~-P~ flag can be used with any other execution mode to "prepare" but
not execute. Importantly, this flag will cause the Clojure tool to
resolve deps, download libraries, make and cache classpaths. This may be
useful in containers, continuous integration systems, etc where an
environment can be prepared to execute and do necessary network activity
first, and then later execute without that activity.

**** Other programs
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#other-programs
:END:

There are some options that can be provided to ~clj~ that short circuit
normal execution and run an alternate program instead:

- ~-Sdescribe~ - print environment and command parsing info as data
- ~-Spath~ - compute classpath and echo to stdout only

The ~:deps~ alias is built into the root deps.edn and provides a default
namespace with several additional programs:

- ~-X:deps tree~ - print dependency tree (also see [[#content/reference/dep_expansion#tree-printing][tree printing]])
- ~-X:deps mvn-pom~ - generate (or update an existing) pom.xml with
  deps and paths
- ~-X:deps git-resolve-tags~ - resolve git coordinate tags to shas and
  update deps.edn

***** Help functions

The ~help/doc~ and ~help/dir~ functions introspect how a tool can be
used. Because the ~:deps~ alias does not include the project classpath,
these are not currently useful when executing functions in your own
project.

- ~-X:deps help/doc~ - show the doc strings and parameter lists of the
  functions given with key ~:ns~ or function specified by an additional
  key ~:fn~; if neither given then ~:ns-default~ is used
- ~-X:deps help/dir~ - prints the public functions in namespace
  provided with key ~:ns~ or ~:ns-default~ if not given

Example for listing the set of functions in the ~:ns-default~ for the
built in ~tools~ tool:

#+BEGIN_SRC clojure
clojure -A:deps -Ttools help/dir
#+END_SRC

Example for listing the set of functions in an alias:

#+BEGIN_SRC clojure
clojure -X:deps:my-alias help/dir
#+END_SRC

Print the docstrings for the help namespace itself (note that ~help~ is
defined in the ~:ns-aliases~ map for ~:deps~):

#+BEGIN_SRC clojure
clojure -X:deps help/doc :ns help
#+END_SRC

- Also see: [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.help-api.html][API docs]]

***** Prep libs
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#prep-libs
:END:

Source libs with Clojure source can immediately be added to the
classpath of a project using it. However, some source libs require some
preparation before they can be added, for example due to needing Java
compilation, or copying / replacing resource files, etc. The Clojure CLI
will now detect projects that need preparation and prevent the program
from being run from source unless the prep step has been completed.

If your library needs preparation, add the ~:deps/prep-lib~ key to your
~deps.edn~:

#+BEGIN_SRC clojure
{:paths ["src" "target/classes"]
 :deps/prep-lib
 {:ensure "target/classes"
  :alias :build
  :fn compile-java}}
#+END_SRC

The keys under ~:deps/prep-lib~ are:

- ~:ensure~ - directory existence determines whether prep is needed (if
  it exists, prep has been done)
- ~:alias~ - alias to invoke with ~-T~ during prep
- ~:fn~ - function to invoke with ~-T~ during prep

Thus, the deps.edn should also have an alias that can execute the fn
specified. See the [[#content/guides/tools_build][tools.build Guide]] for how to use tools.build to
define a build script with an invokable function.

If you add this git library as a dependency and try to run a program,
the Clojure CLI will download it, detect that it needs preparation, and
that it has not been prepared ("target/classes" path does not exist),
and exit.

To find and "prepare" libs in the dependency tree you can use the ~prep~
tool provided with the built-in ~:deps~ alias:

#+BEGIN_EXAMPLE
clj -X:deps prep
#+END_EXAMPLE

The prep task will find all libs in the dependency expansion and look
for libs that are source libs, need prep (based on their
~:deps/prep-lib~ key), and are not yet prepped (based on the ~:ensure~
dir in their ~:deps/prep-lib~ map). Those libs will run the command
specified there by alias and function, as if: ~clj -T:<alias> <fn>~.

Once a library has been prepped, it does not need to be prepped again by
other users of this git library version.

#+BEGIN_QUOTE
*Note*

Should you use a prep step that compiles your Clojure code? Generally,
no. All users of this git library on a machine will share the prepared
classpath created by the prep step. The choice of Clojure compiler and
dependent libraries is better left to each application making using of
this lib. For more on using dev-time compilation, see the [[#content/guides/dev_startup_time][Dev Startup
Time]] guide.
#+END_QUOTE

***** Find versions
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#find-versions
:END:

To search for available versions of a git lib use the ~find-versions~
tool provided with the built-in ~:deps~ alias:

#+BEGIN_EXAMPLE
clj -X:deps find-versions ...
#+END_EXAMPLE

The params that can be provided are:

- ~:lib~ - git or Maven lib name. The git url will be automatically
  constructed from the git library name. For example, a ~:git/lib~ of
  ~io.github.clojure/tools.deps.graph~ will construct the git url
  ~https://github.com/clojure/tools.deps.graph.git~. For Maven, use the
  Maven lib name like ~org.clojure/tools.deps.graph~.
- ~:tool~ - a tool name if the tool has already been installed

~find-versions~ will print the git or Maven coordinates, one per line,
to the console.

***** Local Maven install

The ~-X:deps mvn-install~ program is provided with the Clojure tools for
convenience and can be executed with ~-X~ to install a jar into your
local Maven cache.

The install params include the following options:

#+BEGIN_EXAMPLE
Required:
:jar - path to jar file, use pom inside jar by default

To supply an explicit pom file:
:pom - path to pom file (used instead of pom inside the jar)

To generate a minimal pom file:
:lib - qualified symbol like my.org/lib
:version - string
:classifier - string

Other options:
:local-repo - path to local repo (default = ~/.m2/repository)
#+END_EXAMPLE

You can pass overrides on the command line for these as needed:

#+BEGIN_EXAMPLE
clj -X:deps mvn-install :jar '"/path/to.jar"'
#+END_EXAMPLE

As mentioned above, edn strings must be in double quotes, and then
single-quoted for the shell.

A pom file must be either provided explicitly, generated from
:lib/:version, or found inside the .jar file (the default).

*** Procurers

Coordinates are interpreted by procurers, which know how to determine
dependencies for a library and download artifacts. tools.deps.alpha is
designed to support an extensible set of procurers that can expand over
time. Currently the available procurers are: ~mvn~, ~local~, and ~git~.

The procurer to use is determined by examining the attributes of the
coordinate and using the first attribute qualifier that's found
(ignoring the reserved qualifier "deps"). For example, a Maven
coordinate contains a ~:mvn/version~ attribute and a local coordinate
contains a ~:local/root~ attribute.

Procurers may also have configuration attributes stored at the root of
the configuration map under the same qualifier.

**** Maven

The ~mvn~ procurer will look for two keys at the root of the deps.edn:

- ~:mvn/repos~ - map of repository name to repository descriptor, a map
  currently taking only the key ~:url~
- ~:mvn/local-repo~ - a path (string) to the local repo cache. If none
  supplied, Maven uses ~~/.m2/repository~.

The installation deps.edn configures these default Maven repos:

#+BEGIN_SRC clojure
{:mvn/repos
 {"central" {:url "https://repo1.maven.org/maven2/"}
  "clojars" {:url "https://clojars.org/repo"}}}
#+END_SRC

***** Modifying the default repositories

The ~:mvn/repos~ map is ~merge-with~ ~merge~ across the deps.edn
sources, so you can modify the default repositories by specifying a new
definition or remove it by specifying ~nil~.

tools.deps guarantees that the ~"central"~ and ~"clojars"~ repositories
will be checked first, in that order, for Maven libraries.

***** Maven authenticated repos

For Maven deps in authenticated repositories, existing Maven
infrastructure is used to convey credentials.

In your ~~/.m2/settings.xml~:

#+BEGIN_EXAMPLE
<settings>
  ...
  <servers>
    <server>
      <id>my-auth-repo</id>
      <username>zango</username>
      <password>123</password>
    </server>
    ...
  </servers>
  ...
</settings>
#+END_EXAMPLE

Then in your ~deps.edn~ include a repo with a name matching the server
id (here ~my-auth-repo~):

#+BEGIN_SRC clojure
{:deps
 {authenticated/dep {:mvn/version "1.2.3"}}
 :mvn/repos
 {"my-auth-repo" {:url "https://my.auth.com/repo"}}}
#+END_SRC

Then just refer to your dependencies as usual in the ~:deps~.

***** Maven S3 repos

The tools also provide support for connecting to public and private S3
Maven repositories.

Add a ~:mvn/repos~ that includes the s3 repository root:

#+BEGIN_SRC clojure
{:deps
 {my/library {:mvn/version "0.1.2"}}
 :mvn/repos
 {"my-private-repo" {:url "s3://my-bucket/maven/releases"}}}
#+END_SRC

S3 buckets are specific to the AWS region they were created in. The s3
transporter will attempt to determine the bucket's location. If that
doesn't work, you can specify the bucket region in the url explicitly:
~"s3://my-bucket/maven/releases?region=us-west-2"~.

For authenticated repos, AWS credentials can be set in the
~~/.m2/settings.xml~ on a per-server basis or will be loaded ambiently
from the AWS credential chain (env vars, etc). The repository name in
~deps.edn~ must match the server id in ~settings.xml~:

#+BEGIN_EXAMPLE
<settings>
  ...
  <servers>
    <server>
      <id>my-private-repo</id>
      <username>AWS_ACCESS_KEY_HERE</username>
      <password>AWS_SECRET_ACCESS_KEY_HERE</password>
    </server>
    ...
  </servers>
  ...
</settings>
#+END_EXAMPLE

AWS S3 credentials can be set in the environment using one of these
mechanisms:

1. Set the environment variables ~AWS_ACCESS_KEY_ID~ and
   ~AWS_SECRET_ACCESS_KEY~.
2. Create a default profile in the AWS credentials file
   ~~/.aws/credentials~ (older ~~/.aws/config~ also supported).
3. Create a named profile in the AWS credentials file and set the
   environment variable ~AWS_PROFILE~ with its name.
4. Amazon ECS container and instance profile credentials should also
   work, but have not been tested.

For more information, most of the advice in [[https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html][this AWS document]]
describes how credentials are located. Note however that the Java
system properties options will NOT work with the command line tools
(but would work if using the tools.deps.alpha library directly).

***** Maven proxies

In environments where the internet is accessed via a proxy, existing
Maven configuration in ~~/.m2/settings.xml~ is used to set up the proxy
connection:

#+BEGIN_EXAMPLE
<settings>
  ...
  <proxies>
    <proxy>
      <id>my-proxy</id>
      <host>proxy.my.org</host>
      <port>3128</port>
      <nonProxyHosts>localhost|*.my.org</nonProxyHosts>
    </proxy>
  </proxies>
  ...
</settings>
#+END_EXAMPLE

Refer to the Maven [[https://maven.apache.org/guides/mini/guide-proxies.html][Guide to using proxies]] for further details.

***** Maven HTTP headers

For adding custom headers to outgoing HTTP requests, existing Maven
configuration in ~~/.m2/settings.xml~ is used.

#+BEGIN_EXAMPLE
<settings>
  ...
  <servers>
    <server>
      <id>my-token-repo</id>
      <configuration>
        <httpHeaders>
          <property>
            <name>Private-Token</name>
            <value>abc123</value>
          </property>
        </httpHeaders>
      </configuration>
    </server>
    ...
  </servers>
  ...
</settings>
#+END_EXAMPLE

The server id in ~settings.xml~ must match the repository name in
~deps.edn~:

#+BEGIN_SRC clojure
{:mvn/repos
 {"my-token-repo" {:url "https://my.auth.com/repo"}}}
#+END_SRC

This mechanism is used by repositories that authenticate using a token,
rather than by username and password.

**** Git
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#git
:END:

The Clojure CLI supports using source-based libs directly from Git
repositories. Git libs are downloaded by default to the ~~/.gitlibs~
directory. The working tree is checked out and cached for each sha
included as a dependency.

***** Coord attributes

Git deps are declared with the following info:

- lib name - a qualified symbol
- coordinate - a map of:
  - ~:git/url~ - Git url
  - ~:git/sha~ - a full 40-char sha or possibly a sha prefix if tag
    provided (~:sha~ is also accepted for backwards compatibility)
  - ~:git/tag~ - git tag name

To download a git lib, two pieces of information must be known - the Git
repo url and the sha. These can be provided in several ways. If the lib
name follows the conventions below, the Git repo URL will be inferred
and does not need to be specified. Otherwise, it can be supplied with
~:git/url~ in the coordinate.

Lib to url convention:

| Lib format                   | Inferred ~:git/url~                              |
|------------------------------+------------------------------------------------|
| io.github.ORG/PROJECT        | ~"https://github.com/ORG/PROJECT.git"~           |
| com.github.ORG/PROJECT       | ~"https://github.com/ORG/PROJECT.git"~           |
| io.gitlab.ORG/PROJECT        | ~"https://gitlab.com/ORG/PROJECT.git"~           |
| com.gitlab.ORG/PROJECT       | ~"https://gitlab.com/ORG/PROJECT.git"~           |
| io.bitbucket.ORG/PROJECT     | ~"https://bitbucket.org/ORG/PROJECT.git"~        |
| org.bitbucket.ORG/PROJECT    | ~"https://bitbucket.org/ORG/PROJECT.git"~        |
| io.beanstalkapp.ORG/PROJECT  | ~"https://ORG.git.beanstalkapp.com/PROJECT.git"~ |
| com.beanstalkapp.ORG/PROJECT | ~"https://ORG.git.beanstalkapp.com/PROJECT.git"~ |

The supported git url protocols are https and ssh. https repos will be
accessed anonymously and require no additional authentication
information. This approach is recommended for public repos. ssh repos
may be either public or private.

For more information on creating keys and using the ssh-agent to manage
your ssh identities, GitHub provides excellent info:

- [[https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/]]
- [[https://help.github.com/articles/working-with-ssh-key-passphrases/]]

Either a full ~:git/sha~ must be provided or a ~:git/tag~ with at least
a prefix ~:git/sha~. The latter is preferred as it provides both a
meaningful version (via the tag) and the means to verify the tag has not
been moved (via the sha). The CLI will verify that both the tag and
prefix sha point to the same full sha commit, and error if not.

***** Version selection

When selecting a version from between sha A and sha B where B has A as
an ancestor, then B will be preferred (the "most descendant" one). If A
and B do not have an ancestor/descendant relationship (commits in
parallel branches for example), this is an error and classpath
construction will fail.

***** Configuration and debugging

Support for git deps occurs via shelling out to command-line git (and
ssh). git >= 2.5 is required. In general, if access works at the command
line, it should work via ~clj~. Git is expected to be installed and by
default, ~git~ is expected to be on the path. For ssh access, refer to
documentation for your system (typically you will register your ssh keys
in ~~/.ssh/id_rsa~).

The following environment variables can be set to control the git
integration:

- ~GITLIBS~ - the path to the gitlibs storage directory (default =
  ~~/.gitlibs~)
- ~GITLIBS_COMMAND~ - the command to run for git access (default =
  ~git~)
- ~GITLIBS_DEBUG~ - set ~true~ to see a log of the actual git commands
  being run and their output (default = ~false~)

**** Clojure CLI installers

For tools installation, see the instructions in the [[#content/guides/getting_started][Getting Started]] guide.

*** Tool installation and invocation
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#tool-installation-and-invocation
:END:

The Clojure CLI supports the idea of running tools, which are programs
that don't use the project classpath, with the -T exec option. Tools are
often (but not exclusively) external, defined with their own
dependencies. Tools are expected to be invoked similar to -X style
functions, which take a map of key/val arguments which can be provided
on the CLI.

**** Using named tools

The Clojure CLI comes with programs to search for available versions of
a tool (either maven or git), and to install a tool under a local name
for subsequent execution. Tools additionally may provide their usage
configuration as part of the tool, rather than every user needing to
define that as an alias.

***** Find versions

See [[#content/reference/deps_and_cli#find-versions][find-versions]] for more on finding versions of a
lib or tool (Maven or git).

***** Tool installation

A tool for managing tools is automatically installed by the Clojure CLI
under the name "tools". There are several useful functions provided:

- install - Installs or reinstalls a tool
- list - Lists all installed tools
- remove - Removes an installed tool

When you've determined which version of a tool to install, use the
~install~ function to install the tool by name.

#+BEGIN_EXAMPLE
clj -Ttools install ...
#+END_EXAMPLE

The args to ~install-tool~ are:

- lib - val is coord map, as per deps.edn
- ~:as~ - tool name, will be used for later invocations

For example:

#+BEGIN_EXAMPLE
clj -Ttools install io.github.clojure/tools.deps.graph '{:git/tag "v1.0.63"}' :as deps-graph
#+END_EXAMPLE

Note that git deps can be fully described at tool installation time by
using only a git lib name (which will be used to form a git url by
convention), and a git tag.

To list all installed tools:

#+BEGIN_EXAMPLE
clj -Ttools list
#+END_EXAMPLE

To remove an installed tool:

#+BEGIN_EXAMPLE
clj -Ttools remove :tool name
#+END_EXAMPLE

Other functions will likely be added in the future.

***** Tool usage

Tools may include a top-level key ~:tools/usage~ in their deps.edn file
to publish how the tool can be used with respect to namespace context.
The value is a map which may have the following keys that are the same
as their usage in deps.edn aliases:

- ~:ns-default~ - a lib symbol indicating the default namespace when
  resolving functions
- ~:ns-aliases~ - a map of alias to lib symbol

For example, the tools.deps.graph tool can publish the following usage
in deps.edn:

#+BEGIN_SRC clojure
{:tools/usage
 {:ns-default clojure.tools.deps.graph}}
#+END_SRC

***** Invoke a tool by name

Once you've installed a named tool, you can invoke it with ~-T~ using
just the tool name.

#+BEGIN_EXAMPLE
clj -Ttool f args...
#+END_EXAMPLE

The function will be resolved using the ~:ns-default~ and ~:ns-aliases~
found in the tool's deps.edn.

For example, for the tools.deps.graph tool declared above, it can be
invoked as follows:

#+BEGIN_EXAMPLE
clj -Tdeps-graph graph :output '"graph.png"'
#+END_EXAMPLE

**** Aliased tool execution

Tools declared with an alias can also be executed with -T, just as they
can be executed with -X. The only difference is that -T implies
~{:replace-deps {}, :replace-paths ["."]}~, so the project deps/paths
will not be included, by default.

**** Best practices for tool authors

Best practices:

- Provide your tool as a public git library
- Define your tool api in one or more Clojure namespaces as functions
  that take a map
- Create a ~:tools/usage~ key in the root of your deps.edn with either
  an ~:ns-default~ and/or an ~:ns-aliases~ key for your api namespaces
- Tag your git repo to create a release, using a scheme that makes
  sequencing obvious to users. A common convention is to use versions
  strings like "v1.2.3".

Tools can provide these instructions for users:

- Find tool versions:
  ~clj -X:deps find-versions :lib io.github.USER/TOOL~
- Install tool with
  ~clj -Ttools install io.github.USER/TOOL '{:git/tag "VERSION"}' :as NAME~
- Invoke tool with ~clj -TNAME f args…​~

*** Command line reference
**** Arg map keys

This section summarizes all of the available arg map keys that ~clj~
uses and that can be conveyed via alias data in deps.edn. For clarity,
these are separated by category, but in general, all of them can be used
with ~-X~ (exec), ~-A~ (repl), and ~-M~ (main).

- tool
  - ~:replace-deps~ - map of lib to coords that should *replace* the
    project deps
  - ~:replace-paths~ - vector of path strings that should *replace*
    the project paths
- resolve-deps
  - ~:extra-deps~ - map of lib to coords that should be added to the
    root deps
  - ~:override-deps~ - map of lib to coords that should *replace* deps
    in the root deps
  - ~:default-deps~ - map of lib to coords that should be used if the
    coord is nil in root or transitive deps
- make-classpath-map
  - ~:extra-paths~ - vector of string paths (or keyword aliases to
    same) to add to base paths
  - ~:classpath-overrides~ - map of lib to string path to replace lib
    on classpath
- jvm opts
  - ~:jvm-opts~ - vector of strings to pass as jvm args
- namespace aliasing
  - ~:ns-aliases~ - map of alias symbol to namespace symbol, used to
    resolve symbols (such as :exec-fn)
  - ~:ns-default~ - default namespace for unqualified symbols (such as
    :exec-fn)
- execution (-X only)
  - ~:exec-fn~ - function to execute with -X
  - ~:exec-args~ - function args to pass to -X (can be overridden at
    command line)
- main (-M only)
  - ~:main-opts~ - vector of string args to pass to clojure.main

**** Namespace resolution
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#namespace-resolution
:END:

Symbols in the exec-opts or argmaps (like ~:exec-fn~) are resolved with
the following rules:

- If function is unqualified, use the namespace in the ~:ns-default~
  key in the arg map (if none, this is an error)
- If function is qualified, and the qualifier is an alias in the arg
  map under ~:ns-aliases~, use that namespace
- Else use the fully qualified function symbol

**** Keys and key paths

With the -X exec-opt you can supply key-path/value pairs on the command
line. The key-path is either a single key or a vector of keys to refer
to a nested key (as with ~assoc-in~). Each key-path will be used to
~assoc-in~ to the original ~:exec-args~ map, overriding the value there.

#+BEGIN_EXAMPLE
# Top key override
clj -X:my-fn :val 789

# Nested key override
clj -X:my-fn '[:my :data]' 789
#+END_EXAMPLE

**** Trailing map argument
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#trailing-map-argument
:END:

In addition to passing key-path/value pairs and key paths in the command
line, an optional map providing value mappings may be passed as the
final argument. This map will merge with and perhaps override the
previously provided key-path/value mappings:

#+BEGIN_EXAMPLE
# Augment the arguments to my-fn
clj -X:a-tool my-fn :val 789 '{:val2 123}'

# Override the arguments to my-fn
clj -X:a-tool my-fn :val 789 '{:val 123}'

# Single map (no kvs) provides arguments to my-fn
clj -X:a-tool my-fn '{:val 789}'
#+END_EXAMPLE

**** Quoting keys and values
:PROPERTIES:
:CUSTOM_ID: content/reference/deps_and_cli#quoting-keys-and-values
:END:

Keys and values on the command line are read as edn. The following data
can be used without quoting:

- Numbers - ~123~, ~12.4~
- Booleans - ~true~, ~false~
- Nil - ~nil~
- Symbols - ~name~, ~foo/bar~
- Keywords - ~:id~, ~:company/name~

These data types need to be surrounded by single quotes:

- Strings - ~'"hi there"'~ - note use of both single quotes for the
  shell and double quotes to be read as an edn string
- Vectors - ~'[1 2 3]'~
- Maps - ~'{:a 1, :b 2}'~
- Sets - ~'#{:a :b}'~
- Lists - ~'(1 2 3)'~

**** Glossary

*Library*

A collection of Clojure or other code that solves some problem, managed
under a single directory root. In typical (but not exclusive) usage,
most GitHub repos hold a single library. Each library has a distinct
namespaced name - in Maven this is determined by the
group-id/artifact-id.

*Artifact*

A library released in a container file, capturing the state of the
library at a point in time, possibly subjected to some build process,
labeled with a version, containing some manifest documenting its
dependencies, and packaged in e.g. a jar.

*Coordinate*

A particular version of a library chosen for use, with information
sufficient to obtain and use the library.

*Dependency*

An expression, at the project/library level, that the declaring library
needs the declared library in order to provide some of its functions.
Must at least specify library name, might also specify version and other
attrs. Actual (functional) dependencies are more fine-grained.

Dependency types:

- maven artifacts (artifact-based)
- git libraries (source-based)
- local library (source-based) - a local directory
- local artifact (artifact-based) - a local jar file

*Classpath (and roots/paths)*

An ordered list of local 'places' (filesystem directories and/or jars)
that will form the root paths for searches of requires/imports at
runtime, supplied as an argument to Java which controls the semantics.
We discourage order-dependence in the classpath, which implies a
namespace or resource file is duplicated (and thus likely broken).

*Expansion*

Given a set of root dependencies, a full closure of the transitive
dependency set.

*Resolution*

Given a collection of root dependencies and additional modifications,
creates a fully-expanded dependency tree, then produces a mapping from
each library mentioned to a single version to be used that would satisfy
all dependents, as well as the local path to that source or artifact. We
will also include those dependents for each entry. Conflicts arise only
if libraries depend on different major versions of a library.

*Classpath creation*

Creates a classpath from a resolved lib-map and optional extra local lib
paths. Current plan for lib-map does not provide for control over
resulting order.

*Version*

A human numbering system whose interpretation is determined by
convention. Often x.y.z. Must protect against 'semver' interpretation,
which allows libraries to break users while keeping the name the same.
Ascending by convention - higher numbers are 'later', vague
compatibility with lower/earlier.

*Version difference*

This occurs when the dependency expansion contains the same library with
more than one "version" specified but where there is a relative ordering
(either by number or by sha etc). Version differences can be resolved by
choosing the "later" or "newest" version when that relationship can be
established.

*Version conflict*

A version conflict occurs when the dependency expansion contains the
same library with more than one "version" such that the best choice
cannot be automatically chosen:

- semver version breakage (major version changed)
- github shas that do not contain any common root or ancestry (two shas
  on different branches or unrelated repos, for example)
- versions that cross different repos or repo types such that no
  relative relationship can be established

*Maven Repo*

A repository of library artifacts - e.g. Maven central or Clojars

*** Tools

See the project's wiki for a
[[https://github.com/clojure/tools.deps.alpha/wiki/Tools][list of tools
that use or work with tools.deps.alpha (or the clojure tools)]] - tools
for project creation, packaging, and much more.

** ----
** Documentation
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/documentation.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/documentation
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/reference/documentation
:END:
*** Reference Documentation

- [[#content/reference/reader][The Reader]]
- [[#content/reference/repl_and_main][The REPL and main]]
- [[#content/reference/evaluation][Evaluation]]
- [[#content/reference/special_forms][Special Forms]]
- [[#content/reference/macros][Macros]]
- [[#content/reference/other_functions][Other Functions]]
- [[#content/reference/data_structures][Data Structures]]
- [[#content/reference/datatypes][Datatypes]]
- [[#content/reference/sequences][Sequences]]
- [[#content/reference/transients][Transients]]
- [[#content/reference/transducers][Transducers]]
- [[#content/reference/multimethods][Multimethods and Hierarchies]]
- [[#content/reference/protocols][Protocols]]
- [[#content/reference/metadata][Metadata]]
- [[#content/reference/namespaces][Namespaces]]
- [[#content/reference/libs][Libs]]
- [[#content/reference/vars][Vars and Environments]]
- [[#content/reference/refs][Refs and Transactions]]
- [[#content/reference/agents][Agents]]
- [[#content/reference/atoms][Atoms]]
- [[#content/reference/reducers][Reducers]]
- [[#content/reference/java_interop][Java Interop]]
- [[#content/reference/compilation][Compilation and Class Generation]]
- [[#content/reference/other_libraries][Other Libraries]]
- [[#content/reference/lisps][Differences with Lisps]]

*** API Documentation

- [[#content/api/api][Clojure API documentation]]

** Dep Expansion
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/dep_expansion.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/dep_expansion
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-12-22
:CUSTOM_ID: content/reference/dep_expansion
:END:

This page is a deep dive into how the Clojure tools and tools.deps
expand a set of root deps into a transitive set of dependencies. This
algorithm is similar to Maven dep expansion (both are breadth-first tree
expansions), they make different choices about version selection.

*** Expansion

Expansion inputs:

- initial dependencies - each dependency is defined as a lib (symbol)
  and coordinate (maven, git, local, etc)
- default-deps - a map of lib to coord to use if no coordinate is
  supplied
- override-deps - a map of lib to coord to use if lib is found

The expansion process is a loop over a queue of paths in the tree. The
initial queue consists of the single paths to the root deps.

For each step of the loop we pull a path (ending in a dep) off of the
queue for consideration. The default and override deps are used (if
needed) to replace the coordinate to be used with the dep. We then
consider this lib/coord and decide whether to include or exclude in the
selection and record a reason code for later understanding. If the node
has child nodes they are added to the queue.

Throughout the loop, we track all libs, versions seen, and selection
choices in the version map and exclusions in the exclusions map. If
desired, each consideration and whether the node was included and why is
recorded in an expansion trace.

All choices are made during a single pass through the tree. The mainline
expansion is single-threaded, however retrieving the child nodes of a
dep may require fetching them from an external network source (like
requesting the pom from a Maven repository). For improved performance, a
thread pool is used to fetch metadata in parallel in advance of needing
it.

**** Dep selection

When a node is being considered for selection, the lib will be included
if:

- It is a top dep (top dep versions always win) or it is a new lib or a
  newer version of a known lib (Maven keeps only the first found
  version regardless of new/old)
- and it is not excluded in one of the parents of this node's path (see
  the following Exclusions section)
- and all parent nodes in the path are selected (see the following
  Orphans section)

If the lib/version is included, it will marked as selected in the
version map.

**** Exclusions

Exclusions are marked on child nodes at nodes in the tree and apply to
that child dependency and its sub nodes. Exclusions are recorded in the
exclusions map and used when checking whether to include a lib below
that point in the tree.

One particularly thorny case occurs when the same lib and version occurs
at different points in the tree with different exclusion sets. In these
cases, the exclusions used for that lib will be the *intersection* of
the two exclusion sets.

For example, given a tree like:

#+BEGIN_EXAMPLE
A
  B
    C (excl X, Y)
      X
      Y
      Z
  D
    C (excl X)
      X
      Y
      Z
#+END_EXAMPLE

then C will exclude only X (the intersection of #{X Y} and #{X}) because
the A-D-C branch needs that dependency!

Also of importance, when path A-B-C is considered it will enqueue only Z
as a child dependency (because X and Y are excluded). When A-D-C is
considered, it narrows the exclusion set for C and marks Y to be
included as a new child of C to be expanded. Note that whether A-B-C or
A-D-C is considered first, the expansion order may differ, but the same
final choices will be made about inclusion.

**** Orphans

While expanding a large tree, we may enqueue the children of a
particular lib version, then later find and select a newer version of
the lib that has a different set of dependencies. In this case, the
original lib version node is deselected, but its children may still be
in the queue.

When those children are encountered, they will only be included if all
parent nodes are still selected.

For example, given a tree like:

#+BEGIN_EXAMPLE
A
  B
    C1
      X
  D
    C2
      Y
#+END_EXAMPLE

A trace might show:

- A - include A, top dep
- A-B - include B, new lib
- A-D - include D, new lib
- A-B-C1 - include C1, new lib (enqueue X, Y)
- A-D-C2 - include C2, newer version (+ deselect C1)
- A-B-C1-X - exclude X, parent omitted
- A-D-C2-Y - include Y

In some cases, the child nodes may already have been selected in the
version map before the parent node is deselected. To catch these cases,
an orphan check is done after expansion to ensure all selected libs have
included parent nodes. If that's not the case, the orphaned nodes are
cut.

#+BEGIN_EXAMPLE
A
  B1
    X
  C
    B2
      Z
#+END_EXAMPLE

Trace:

- A - include A, top dep
- A-B1 - include B1, new lib
- A-C - include C, new lib
- A-B1-X - include X, new lib
- A-C-B2 - include B2, newer version (+ deselect B1)
- A-C-B2-Z - include Z

After expansion, we would have selected A, X, C, B2, and Z . However,
upon checking each node we will find X's parent B1 was not included so X
will be cut.

*** Trace data

When using the command line tools, you can use the option ~-Strace~ to
activate dep tracing, which will emit a trace data file ~trace.edn~ in
the current directory. If you inspect that data you will find a map with
the keys:

- ~:log~ - a log of the lib nodes considered, whether they were
  included, and the reason for each. The log will be a vector of maps,
  one per considered node with the following keys: ~:lib~, ~:coord~,
  ~:coord-id~, ~:paths~, ~:include~, ~:reason~, and possibly other
  keys.
- ~:vmap~ - the version map (format subject to change)
- ~:exclusions~ - the exclusions map (format subject to change)

*** Tree printing
:PROPERTIES:
:CUSTOM_ID: content/reference/dep_expansion#tree-printing
:END:

A dependency can be printed using either ~clj -Stree~ or the program ~clj
-X:deps tree~ which [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.api-api.html#clojure.tools.cli.api/tree][has more options]].

Trees are built from the trace log and include all considered nodes.
Included nodes are prefixed with ~.~. Excluded nodes are prefixed with
~X~. The end of the line will contain the reason code (some codes are
suppressed). The current set of reason codes (subject to change) are:

- ~:new-top-dep~ - included as top dep (suppressed)
- ~:new-dep~ - included as new dep (suppressed)
- ~:same-version~ - excluded, same as currently selected dep
  (suppressed)
- ~:newer-version~ - included, newer version than previously selected
- ~:use-top~ - excluded, same as top lib but not at top
- ~:older-version~ - excluded, older version than previously selected
- ~:excluded~ - excluded, node in parent path excluded this lib
- ~:parent-omitted~ - excluded, parent node deselected
- ~:superseded~ - excluded, this version was deselected

** Making Clojure Lazier
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/reference/lazy.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/reference/lazy
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/reference/lazy
:END:

(Note: this page describes the changes made in the last large update to
sequences, when Rich was also exploring an alternative called streams.
Treat this page as a useful historical record of these design decisions,
rather than as reference documentation.)

In working on streams a few things became evident:

- stream code is ugly and imperative
  - even when made safe, still ugly, stateful
- streams support full laziness
  - this ends up being extremely nice
- Integrating streams transparently (i.e. not having both map and
  map-stream) would require a change, to relax the contract of the core
  sequence functions (map, filter etc)
  - If I am going to do that, could I achieve the same full laziness
    while keeping the beautiful recursive style of Clojure?
    - while being substantially compatible with existing code
    - Yes!
      - but - ideally some names should change

*** The current seq model

- Originally modeled on Common Lisp's cons
- Either you have a seq, with a valid first, or nothing (nil)
- A seq is like a logical cursor
- rest is fundamentally eager
  - returns another seq or nil
  - needs to determine if there is any more in order to determine if
    return value is nil
  - lazy-cons can delay the calculation of first/rest, but not the
    determination if there is a rest
    - determining that often requires 'pulling' on an inner seq,
      reducing effective laziness
- sequence functions currently return a seq or nil

The eagerness of ~rest~ means the sequence functions are not fully lazy,
they need to at least determine if there is a first.

*** Enhancing the seq model - a third operation on seqs - 'next'

- *Changed:* (*rest* aseq) - returns a possibly empty seq, /never
  nil/
  - calls seq on arg if not already a seq
  - the returned seq may be empty
    - will print (), but not a single sentinel object
  - never returns nil
    - currently not enforced on 3rd-party seqs
  - a (possibly) delayed path to the remaining items, if any
- *Changed*: seqs can be empty
  - always an ISeq
- *Changed*: the *seq* function - no longer an identity for ISeqs
  - still returns either a seq or nil
  - (seq aseq) → *no longer an identity, if aseq empty returns nil*
  - still works on nil
- the *first* function doesn't change
  - calls seq on arg if not already a seq
  - returns first item
  - still works on nil
- *New*: the ~next~ function does what ~rest~ used to do
  - returns the next seq, if any, else nil
  - calls seq on arg if not already a seq
  - (next aseq) ~=~ (seq (rest aseq))
  - works on nil
- *Changed*: seq?
  - (seq? ()) → true
- *Changed:* Sequence fns (map, filter etc) return seqs, but not nil
  - You'll need to call seq on their return value in order to get a
    seq/nil
    - seq also serves as test for end, already idiomatic

      #+BEGIN_SRC clojure
       (when (seq coll)
         ...)
      #+END_SRC

  - allows full laziness
  - doesn't support nil punning
    - since sequence fns no longer return seq/nil

*** Recipe - How to write lazy sequence functions in new model

- Goodbye lazy-cons, hello lazy-seq
  - lazy-cons is gone
  - new laziness macro - ~lazy-seq~
    - takes a body that yields a seq, nil or anything seq-able
    - returns a logical collection that implements seq by calling the
      body
      - invokes the body only the first time seq is called on it,
          caches result
      - will call seq on the body's return value if not already a
          seq or nil
  - The net effect is the creation of a virtual collection that does
    no work until seq is called upon it - fully delayed
  - Supports all collection ops
  - Can be empty - e.g. calling seq on it can return nil
    - when empty will print as ()
- lazy-seq goes at top level of lazy sequence function
  - instead of nested lazy-cons
- inside, use a normal cons call
  - won't be created until needed
- if consuming another seq, use rest instead of next

The old way:

#+BEGIN_SRC clojure
(defn map
  ([f coll]
   (when (seq coll)
     (lazy-cons (f (first coll)) (map f (rest coll)))))
...
#+END_SRC

The new way:

#+BEGIN_SRC clojure
(defn map
  ([f coll]
   (lazy-seq
    (when-let [s (seq coll)]
      (cons (f (first s)) (map f (rest s))))))
...
#+END_SRC

Note the use of when-let, which grabs the seq once, for subsequent use
in first and rest, even though first/rest call seq on their argument.
This has a performance benefit in this new model.

*** The victim - nil punning

One of the nice things about CL's cons using nil for end-of-list is
that, when coupled with nil's testability in conditionals,
cons-returning functions could be used like predicates. Now only ~seq~
and ~next~ can be used in that manner - map, filter etc cannot. Note
that much of the economy of the seq/nil dyad still applies, e.g. the use
of when in map above.

*** Extension ISeqs

If you are extending ISeq you'll need to support ~ISeq.more()~ (the
underpinnings of rest). Fortunately, most ISeq extenders derive from
ASeq, which defines ~more()~ in terms of ~next~. If you derive your seq
from ASeq, /don't define more()/, use the version supplied by ASeq. Just
rename your rest() method to next().

*** Recipe - Porting

To move to the new model you'll need to take the following steps, in
this order:

- Rename all your calls to ~rest~ to call ~next~
- If you were defining your own lazy sequence functions, using
  ~lazy-cons~, switch them over to ~lazy-seq~ using the recipe above.
  Make sure to call ~rest~ and not ~next~ in your recursive call.
- Audit your code for nil-punning. The lazy branch has supports
  compilation in a debug mode that asserts if you try to test the truth
  value of a lazy sequence in a conditional, and will throw an
  exception if you do. Just build clojure like so:
  - ant -Dclojure.assert-if-lazy-seq=true
  - Then, nil puns like the following will throw exceptions:
    - (when (filter neg? [1 2]) :all-pos)
    - (not (concat))
    - (if (rest (seq [])) 1 2)
  - In all cases you can fix a nil pun by wrapping the sequence with a
    seq call:

    #+BEGIN_SRC clojure
    (when (seq (filter neg? [1 2])) :all-pos)
    -> nil
    #+END_SRC

  - After you are done, rebuild without the flag, as it will slow
    things down.

*** Don't hang (onto) your head

Recursively defined lazy sequence functions are elegant and easy to
understand. They can be very memory efficient, allowing you to work with
data sources that might not fit in memory, because only the part of the
data structure in current use need be in memory. It could be tricky at
times to determine which parts were currently in use, as they might
still be referenced by local variables. Clojure does local-variable
clearing on tail calls to ensure that no lingering references remain on
the stack, but there was one remaining case - closed-over locals, that
was difficult to control, especially when using a macro like lazy-seq
which creates a closure on your behalf.

Consider the original, not fully lazy, definition of filter:

#+BEGIN_SRC clojure
(defn filter
  "Returns a lazy seq of the items in coll for which
  (pred item) returns true. pred must be free of side-effects."
  [pred coll]
    (when (seq coll)
      (if (pred (first coll))
        (lazy-cons (first coll) (filter pred (rest coll)))
        (recur pred (rest coll)))))
#+END_SRC

By recurring to the fn itself, it is effectively erasing the coll
argument each iteration, so it looks like it wouldn't retain coll while
skipping elements not matching the predicate. The problem is that
sometimes the call to filter is in the lazy-cons, which expands into a
closure that closes over coll, thus retaining it while the looping
occurs, and there is nothing the called function can do about it. This
means that expressions like:

#+BEGIN_SRC clojure
(filter #(= % 20) (map inc (range 10000000)))
#+END_SRC

could cause out of memory exceptions. The only way to avoid it was to
rewrite filter using mutation. Bleh.

The new filter looks like this:

#+BEGIN_SRC clojure
(defn filter
  "Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects."
  [pred coll]
  (let [step (fn [p c]
                 (when-let [s (seq c)]
                   (if (p (first s))
                     (cons (first s) (filter p (rest s)))
                     (recur p (rest s)))))]
    (lazy-seq (step pred coll))))
#+END_SRC

The body of the old filter has been put in a helper fn, and lazy-cons
replaced with cons, then the whole call is wrapped in a lazy-seq,
following the recipe above. However lazy-seq also creates a closure
which closes over coll. Without some enhancement, this filter, while
lazier, will have the same memory footprint as the old. The new lazy
branch contains a compiler enhancement for this and similar scenarios.
~lazy-seq~ and ~delay~ both perform closed-over local clearing on the
tail call of their body, ensuring no references remain in the closure
itself when the tail-call executes. They can do this because they cache
the results, and thus know the closure will be invoked only once. Thus
the lazy branch has no problems with the filter expression above, and
you can use similar techniques to control memory usage in your own lazy
functions.

* Releases
** Dev Changelog
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/releases/devchangelog.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/releases/devchangelog
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-04-28
:CUSTOM_ID: content/releases/devchangelog
:END:

The official [[https://github.com/clojure/clojure/blob/master/changes.md][changelog]] tracks deltas between major stable
versions. This page gathers the interim dev release announcements
during development.

*** Dev release naming guide

- Alpha - new feature work and enhancements in development
- Beta - bug fixing only, no new feature work is expected
- RC - a release candidate, which will be released as a final release
  unless critical issues are found

Note: All dev releases are subject to breaking changes for new work
since the prior release.

*** Release 1.11.0
**** 1.11.0-alpha2 (Sep 14, 2021)

- [[https://clojure.atlassian.net/browse/CLJ-2123][CLJ-2123]] Add :as-alias option to require like :as but not load
- [[https://clojure.atlassian.net/browse/CLJ-1959][CLJ-1959]] Add implementation of update-keys
- [[https://clojure.atlassian.net/browse/CLJ-2651][CLJ-2651]] Add implementation of update-vals
- [[https://clojure.atlassian.net/browse/CLJ-1908][CLJ-1908]] Add clojure.test api run-test and run-test-var to run
  single test with fixtures and report
- [[https://clojure.atlassian.net/browse/CLJ-1879][CLJ-1879]] IKVReduce - make old slow path (IPersistentMap) faster and
  extend to Object, detaching it from any fully enumerable set of
  types
- [[https://clojure.atlassian.net/browse/CLJ-2600][CLJ-2600]] Don't block realized? of delay on pending result
- [[https://clojure.atlassian.net/browse/CLJ-2649][CLJ-2649]] Fix order of checks in some-fn and every-pred for 3
  predicate case to match other unrollings
- [[https://clojure.atlassian.net/browse/CLJ-2636][CLJ-2636]] Get rid of reflection on java.util.Properties when defining
  *clojure-version*
- [[https://clojure.atlassian.net/browse/CLJ-2350][CLJ-2350]] Improve keyword arity exception message
- [[https://clojure.atlassian.net/browse/CLJ-2444][CLJ-2444]] Fix typo in test-vars docstring
- [[https://clojure.atlassian.net/browse/CLJ-1509][CLJ-1509]] AOT compile more Clojure namespaces
- [[https://clojure.atlassian.net/browse/CLJ-2387][CLJ-2387]] Fix off-by-one in socket server port validation
- Update dep to core.specs.alpha (0.2.62)

**** 1.11.0-alpha1 (Mar 18, 2021)

- [[https://clojure.atlassian.net/browse/CLJ-2603][CLJ-2603]] Clojure keyword argument functions now also accept a map,
  see [[#content/news/2021/03/18/apis-serving-people-and-programs][details]]

*** Release 1.10.3
**** 1.10.3-rc1 (Feb 16, 2021)

- [[https://clojure.atlassian.net/browse/CLJ-2564][CLJ-2564]] Revert prior error message change
- [[https://clojure.atlassian.net/browse/CLJ-2453][CLJ-2453]] Allow reader conditionals in prepl

*** Release 1.10.2
**** 1.10.2-rc3 (Jan 15, 2021)

- [[https://clojure.atlassian.net/browse/CLJ-2602][CLJ-2602]] Make printing test changes platform-independent

**** 1.10.2-rc2 (Jan 6, 2021)

- [[https://clojure.atlassian.net/browse/CLJ-2597][CLJ-2597]] Proxy should emit Java 1.8 bytecode
- [[https://clojure.atlassian.net/browse/CLJ-2599][CLJ-2599]] Bump spec.alpha dep to 0.2.194 and core.specs.alpha dep to
  0.2.56

**** 1.10.2-rc1 (Dec 11, 2020)

- [[https://clojure.atlassian.net/browse/CLJ-1005][CLJ-1005]] Use transient map in zipmap
- [[https://clojure.atlassian.net/browse/CLJ-2585][CLJ-2585]] nth with not-found on regex matcher returns not-found on
  last group index
- [[https://clojure.atlassian.net/browse/CLJ-1445][CLJ-1445]] pprint doesn't print collection metadata when ~*print-meta*~
  is true
- [[https://clojure.atlassian.net/browse/CLJ-2495][CLJ-2495]] prepl docstring is incorrect
- [[https://clojure.atlassian.net/browse/CLJ-2169][CLJ-2169]] conj has out-of-date :arglists
- [[https://clojure.atlassian.net/browse/CLJ-2459][CLJ-2459]] ExceptionInInitializerError if jars executed with java -jar

**** 1.10.2-alpha4 (Nov 5, 2020)

- [[https://clojure.atlassian.net/browse/CLJ-2587][CLJ-2587]] Fix reflection warning in gvec from CLJ-1364

**** 1.10.2-alpha3 (Nov 2, 2020)

- [[https://clojure.atlassian.net/browse/CLJ-2492][CLJ-2492]] Remove uses of deprecated Class.newInstance()
- [[https://clojure.atlassian.net/browse/CLJ-2534][CLJ-2534]] Fix javadoc urls for JDK 11+
- [[https://clojure.atlassian.net/browse/CLJ-1364][CLJ-1364]] vector-of does not implement equals or hashing methods
- [[https://clojure.atlassian.net/browse/CLJ-2549][CLJ-2549]] vector-of does not implement IObj for metadata
- [[https://clojure.atlassian.net/browse/CLJ-1187][CLJ-1187]] quoted metadata on empty literal colls is lost

**** 1.10.2-alpha2 (Sep 25, 2020)

- [[https://clojure.atlassian.net/browse/CLJ-2571][CLJ-2571]] Add Throwable return type hint to ex-cause
- [[https://clojure.atlassian.net/browse/CLJ-2572][CLJ-2572]] Avoid reflection in clojure.data
- [[https://clojure.atlassian.net/browse/CLJ-2295][CLJ-2295]] Eliminate duplicate doc string printing for special forms
- [[https://clojure.atlassian.net/browse/CLJ-2564][CLJ-2564]] Improve error message for ~case~
- [[https://clojure.atlassian.net/browse/CLJ-2580][CLJ-2580]] Fix case expression branch analysis that resulted in
  compilation error
- [[https://clojure.atlassian.net/browse/CLJ-2469][CLJ-2469]] Fix errors in printing some maps with namespace syntax

**** 1.10.2-alpha1 (Mar 5, 2020)

- [[https://clojure.atlassian.net/browse/CLJ-1472][CLJ-1472]] Ensure monitor object is on stack, for verifiers
- [[https://clojure.atlassian.net/browse/CLJ-2502][CLJ-2502]] Fix reflection warnings in
  clojure.stacktrace/print-stack-trace
- [[https://clojure.atlassian.net/browse/CLJ-2517][CLJ-2517]] More fixes for invocation of static interface methods with
  primitive args

*** Release 1.10.1
**** 1.10.1-RC1 (May 21, 2019)

- Updated changelog for 1.10.1

**** 1.10.1-beta3 (May 16, 2019)

- [[https://clojure.atlassian.net/browse/CLJ-2504][CLJ-2504]] Provide more options for error reporting in clojure.main

**** 1.10.1-beta2 (Apr 11, 2019)

- [[https://clojure.atlassian.net/browse/CLJ-2497][CLJ-2497]] Put error report location on its own line
- [[https://clojure.atlassian.net/browse/CLJ-2499][CLJ-2499]] Some compiler expr evals report as wrong phase

**** 1.10.1-beta1 (Mar 21, 2019)

- [[https://clojure.atlassian.net/browse/CLJ-2484][CLJ-2484]] Move user.clj initialization out of RT<clinit>
- [[https://clojure.atlassian.net/browse/CLJ-2463][CLJ-2463]] clojure.main uncaught exception handling
- [[https://clojure.atlassian.net/browse/CLJ-2491][CLJ-2491]] Make fragile tests work under Java 12 and less fragile

*** Release 1.10
**** 1.10.0-RC5 (Dec 11, 2018)

- [[https://clojure.atlassian.net/browse/CLJ-2454][CLJ-2454]] - fix IllegalAccessException from invoking matching
  reflective call

**** 1.10.0-RC4 (Dec 7, 2018)

- [[https://clojure.atlassian.net/browse/CLJ-2449][CLJ-2449]] - make serialized-require private

**** 1.10.0-RC3 (Dec 3, 2018)

- [[https://clojure.atlassian.net/browse/CLJ-2447][CLJ-2447]] - clojure.datafy docstring is missing
- [[https://clojure.atlassian.net/browse/CLJ-2448][CLJ-2448]] - change name of async-require to serialized-require

**** 1.10.0-RC2 (Nov 26, 2018)

No changes other than changelog updates.

**** 1.10.0-beta8 (Nov 21, 2018)

- [[https://clojure.atlassian.net/browse/CLJ-2438][CLJ-2438]] - demunge source location in execution error messages
- [[https://clojure.atlassian.net/browse/CLJ-2437][CLJ-2437]] - add async-require and use it from requiring-resolve
- [[https://clojure.atlassian.net/browse/CLJ-2436][CLJ-2436]] - fix reflection warning in reflect.java

**** 1.10.0-beta7 (Nov 19, 2018)

- [[https://clojure.atlassian.net/browse/CLJ-2435][CLJ-2435]] - include root cause class name in compilation and
  macroexpansion errors

**** 1.10.0-beta6 (Nov 16, 2018)

Changes in 1.10.0-beta6:

- The metadata protocol extension added in 1.10.0-beta5 now requires
  opt-in when the protocol is defined, using :extend-via-metadata.
- The JavaReflector under clojure.reflect has been datafied
- [[https://clojure.atlassian.net/browse/CLJ-2432][CLJ-2432]] - Added clojure.core/requiring-resolve which is like
  ~resolve~ but will ~require~ the symbol's namespace if needed.
- [[https://clojure.atlassian.net/browse/CLJ-2427][CLJ-2427]] - fix bug in CompilerException.toString() that could cause
  a secondary exception to be thrown while making the exception
  string, obscuring the original exception.
- [[https://clojure.atlassian.net/browse/CLJ-2430][CLJ-2430]] - more work on error phases, ex-triage, and allowing prepl
  to better use the new error reporting infrastructure

**** 1.10.0-beta5 (Nov 6, 2018)

Changes in 1.10.0-beta5:

- In addition to prior methods of extension, values can now extend
  protocols by adding metadata where keys are fully-qualified symbols
  naming protocol functions and values are function implementations.
  Protocol implementations are checked first for direct definitions
  (defrecord, deftype, reify), then metadata definitions, then external
  extensions (extend, extend-type, extend-protocol). datafy has been
  updated to use this mechanism.
- ~symbol~ can now be passed vars or keywords to obtain the
  corresponding symbol
- [[https://clojure.atlassian.net/browse/CLJ-2420][CLJ-2420]] - error reporting enhancements - more refined phase
  reporting, new clojure.main/ex-triage split out of
  clojure.main/ex-str, execution errors now report the top *user* line
  in the stack trace omitting frames from core, enhancements to
  providing file and line via meta on a form
- [[https://clojure.atlassian.net/browse/CLJ-2425][CLJ-2425]] add java 11 javadoc url
- [[https://clojure.atlassian.net/browse/CLJ-2424][CLJ-2424]] fix test bug from [[https://clojure.atlassian.net/browse/CLJ-2417][CLJ-2417]]

**** 1.10.0-beta4 (Oct 22, 2018)

1.10.0-beta4 includes the following changes since 1.10.0-beta3:

- [[https://clojure.atlassian.net/browse/CLJ-2417][CLJ-2417]] sort and sort-by should retain meta

**** 1.10.0-beta3 (Oct 12, 2018)

1.10.0-beta3 includes the following changes since 1.10.0-RC1:

- datafy - add :name to datafied classes and namespaces, :class to
  meta of all if datafied
- [[https://clojure.atlassian.net/browse/CLJ-1079][CLJ-1079]] - Reader should retain rather than overwrite :line :column
  meta on lists and seqs. Also make clojure.main bind ~*file*~ based on
  :file meta.

**** 1.10.0-RC1 (Oct 11, 2018)

1.10.0-RC1 is the same code as 1.10.0-beta2 (just minor changelog updates).

**** 1.10.0-beta2 (Oct 9, 2018)

1.10.0-beta2 includes the following changes since 1.10.0-beta1:

- [[https://clojure.atlassian.net/browse/CLJ-2414][CLJ-2414]] - Regression in reflectively finding default methods
- [[https://clojure.atlassian.net/browse/CLJ-2415][CLJ-2415]] - Error cause should always be on 2nd line of error message
- Added clojure.datafy:
  - clojure.datafy is a facility for object to data transformation.
    The ~datafy~ and ~nav~ functions can be used to transform and (lazily)
    navigate through object graphs. The data transformation process
    can be influenced by consumers using protocols or metadata. datafy
    is alpha and subject to change.

**** 1.10.0-beta1 (Oct 5, 2018)

1.10.0-beta1 includes the following changes since 1.10.0-alpha9:

- Revert change for [[https://clojure.atlassian.net/browse/CLJ-1550][CLJ-1550]] - Classes generated by deftype and
  defrecord don't play nice with .getPackage
- Revert change for [[https://clojure.atlassian.net/browse/CLJ-1435][CLJ-1435]] - 'numerator and 'denominator fail to
  handle integral values (i.e. N/1)
- Add changelog since 1.9
- Mark prepl as alpha

**** 1.10.0-alpha9 (Oct 4, 2018)

1.10.0-alpha9 includes the following changes since 1.10.0-alpha8:

- [[https://clojure.atlassian.net/browse/CLJ-2374][CLJ-2374]] - Add type hint to address reflection ambiguity in JDK 11
- [[https://clojure.atlassian.net/browse/CLJ-1209][CLJ-1209]] - Print ex-data in clojure.test error reports
- [[https://clojure.atlassian.net/browse/CLJ-1120][CLJ-1120]] - Add ex-cause and ex-message as in CLJS for portabile
  error handling
- [[https://clojure.atlassian.net/browse/CLJ-2385][CLJ-2385]] - Delay start of tap-loop thread (addresses graal
  native-image issue)
- [[https://clojure.atlassian.net/browse/CLJ-2407][CLJ-2407]] - Fix errors in unit tests
- [[https://clojure.atlassian.net/browse/CLJ-2066][CLJ-2066]] - Add reflection fallback for --illegal-access warnings in
  Java 9+
- [[https://clojure.atlassian.net/browse/CLJ-2375][CLJ-2375]] - Fix usage of deprecated JDK apis
- [[https://clojure.atlassian.net/browse/CLJ-2358][CLJ-2358]] - Fix invalid arity of read+string

**** 1.10.0-alpha8 (Sept 14, 2018)

1.10.0-alpha8 includes the following changes since 1.10.0-alpha7:

- [[https://clojure.atlassian.net/browse/CLJ-2297][CLJ-2297]] - PersistentHashMap leaks memory when keys are removed with
  ~without~
- [[https://clojure.atlassian.net/browse/CLJ-1587][CLJ-1587]] - PersistentArrayMap's assoc doesn't respect
  HASHTABLE_THRESHOLD
- [[https://clojure.atlassian.net/browse/CLJ-2050][CLJ-2050]] - Remove redundant key comparisons in HashCollisionNode
- [[https://clojure.atlassian.net/browse/CLJ-2349][CLJ-2349]] - report correct line number for uncaught ExceptionInfo in
  clojure.test
- [[https://clojure.atlassian.net/browse/CLJ-1403][CLJ-1403]] - ns-resolve might throw ClassNotFoundException but should
  return nil
- [[https://clojure.atlassian.net/browse/CLJ-1654][CLJ-1654]] - Reuse seq in some
- [[https://clojure.atlassian.net/browse/CLJ-1764][CLJ-1764]] - partition-by runs infinite loop when one element of
  infinite partition is accessed
- [[https://clojure.atlassian.net/browse/CLJ-2044][CLJ-2044]] - add arglist meta for functions in clojure.instant
- [[https://clojure.atlassian.net/browse/CLJ-1797][CLJ-1797]] - Mention cljc in error when require fails
- [[https://clojure.atlassian.net/browse/CLJ-1832][CLJ-1832]] - unchecked-* functions have different behavior on
  primitive longs vs boxed Longs
- [[https://clojure.atlassian.net/browse/CLJ-1366][CLJ-1366]] - The empty map literal is read as a different map each
  time
- [[https://clojure.atlassian.net/browse/CLJ-1550][CLJ-1550]] - Classes generated by deftype and defrecord don't play
  nice with .getPackage
- [[https://clojure.atlassian.net/browse/CLJ-2031][CLJ-2031]] - clojure.walk/postwalk does not preserve MapEntry type
  objects
- [[https://clojure.atlassian.net/browse/CLJ-1435][CLJ-1435]] - 'numerator and 'denominator fail to handle integral
  values (i.e. N/1)
- [[https://clojure.atlassian.net/browse/CLJ-2257][CLJ-2257]] - docstring: fix typo in ~proxy~
- [[https://clojure.atlassian.net/browse/CLJ-2332][CLJ-2332]] - docstring: fix repetition in ~remove-tap~
- [[https://clojure.atlassian.net/browse/CLJ-2122][CLJ-2122]] - docstring: describe result of ~flatten~ as lazy

**** 1.10.0-alpha7 (Sept 5, 2018)

Clojure 1.10.0-alpha7 is now available.

1.10.0-alpha7 includes the following changes since 1.10.0-alpha6:

- Update deps to latest spec.alpha (0.2.176) and core.specs.alpha
  (0.2.44)
- [[https://clojure.atlassian.net/browse/CLJ-2373][CLJ-2373]] - categorize and overhaul printing of exception messages at
  REPL
- [[https://clojure.atlassian.net/browse/CLJ-1279][CLJ-1279]] - report correct arity count for function arity errors
  inside macros
- [[https://clojure.atlassian.net/browse/CLJ-2386][CLJ-2386]] - omit ex-info construction stack frames
- [[https://clojure.atlassian.net/browse/CLJ-2394][CLJ-2394]] - warn in pst that stack trace for syntax error failed
  before execution
- [[https://clojure.atlassian.net/browse/CLJ-2396][CLJ-2396]] - omit :in clauses when printing spec function errors if
  using default explain printer

**** 1.10.0-alpha6 (July 4, 2018)

Clojure 1.10.0-alpha6 is now available.

1.10.0-alpha6 includes the following changes since 1.10.0-alpha5:

- [[https://clojure.atlassian.net/browse/CLJ-2367][CLJ-2367]] - Incorporate fix for ASM regression and add case tests -
  thanks Sean Corfield for the patch and Daniel Sutton and Ghadi
  Shayban for the help in tracking it down.

**** 1.10.0-alpha5 (June 27, 2018)

Clojure 1.10.0-alpha5 is now available.

1.10.0-alpha5 includes the following changes since 1.10.0-alpha4:

- [[https://clojure.atlassian.net/browse/CLJ-2363][CLJ-2363]] - make Java 8 the minimum requirement for Clojure (also
  bumps embedded ASM to latest) - thanks Ghadi Shayban!
- [[https://clojure.atlassian.net/browse/CLJ-2284][CLJ-2284]] - fix invalid bytecode generation for static interface
  method calls in Java 9+ - thanks Ghadi Shayban!
- [[https://clojure.atlassian.net/browse/CLJ-2330][CLJ-2330]] - fix brittle test that fails on Java 10 build due to
  serialization drift
- [[https://clojure.atlassian.net/browse/CLJ-2362][CLJ-2362]] - withMeta() should return identity when new meta is
  identical to prior
- [[https://clojure.atlassian.net/browse/CLJ-1130][CLJ-1130]] - when unable to match static method, improve error
  messages
- [[https://clojure.atlassian.net/browse/CLJ-2289][CLJ-2089]] - sorted colls with default comparator don't check that
  first element is Comparable
- [[https://clojure.atlassian.net/browse/CLJ-2163][CLJ-2163]] - add test for var serialization
- Bump dependency version for spec.alpha to latest, 0.2.168 (see
  [[https://github.com/clojure/spec.alpha/blob/master/CHANGES.md][changes]])
- Bump dependency version for core.specs.alpha to latest, 0.2.36 (see
  [[https://github.com/clojure/core.specs.alpha/blob/master/CHANGES.md][changes]])

#+BEGIN_QUOTE
*Note*

1.10.0-alpha5 drops support for Java 6 and 7 and makes Java 8 the
minimum requirement. Compilation will produce Java 8 level bytecode
(which will not run on earlier versions of Java). This is the first
change in bytecode version since Clojure 1.6. We would greatly
appreciate it if you tried this release with your library or project
and provided feedback about errors, performance differences (good or
bad), compatibility, etc.
#+END_QUOTE

When using the ~clj~ tool and deps.edn, we recommend adding an alias to
your ~/.clojure/deps.edn:

#+BEGIN_SRC clojure
{:aliases
 {:clj/next
  {:override-deps
   {org.clojure/clojure {:mvn/version "1.10.0-alpha5"}}}}}
#+END_SRC

You can then run any of your projects with the latest Clojure dev
release by activating the alias with ~clj~:

#+BEGIN_EXAMPLE
clj -A:clj/next
#+END_EXAMPLE

**** 1.10.0-alpha4 (Feb 9, 2018)

- Fix 0-arity bug for read+string

**** 1.10.0-alpha3 (Feb 8, 2018)

- prepl - programmatic REPL

**** 1.10.0-alpha2 (Jan 19, 2018)

- [[https://clojure.atlassian.net/browse/CLJ-2313][CLJ-2313]] - Fix for string capture mode

**** 1.10.0-alpha1 (Jan 18, 2018)

- Add string capture mode to LineNumberingPushbackReader

*** Release 1.9
**** [[https://groups.google.com/d/msg/clojure/Pz_Kzg-k2Ac/ACVoLkXYDwAJ][1.9.0-RC2]] (Nov 27, 2017)

- There is a new Maven profile and Ant target in the build to build an
  executable Clojure jar with deps included (and test.check). This can be useful for doing dev on Clojure itself or for just cloning the repo and doing a quick build to get something runnable.
- The readme.txt has been updated to include information about how to
  create and run a local jar.
- Stopped publishing the clojure-VERSION.zip file as part of the
  release.

**** [[https://groups.google.com/d/msg/clojure/tWcLAhnEzIs/OnwSSXFsBAAJ][1.9.0-RC1]] (Nov 7, 2017)

- Same as 1.9.0-beta4

**** [[https://groups.google.com/d/msg/clojure/X_A6B_LiGvQ/I-bDODILAgAJ][1.9.0-beta4]] (Oct 31, 2017)

- [[https://clojure.atlassian.net/browse/CLJ-2259][CLJ-2259]] - Remove unnecessary bigdec? predicate added in 1.9
- Bumped spec.alpha dependency to 0.1.143

**** [[https://groups.google.com/d/msg/clojure/jKsa9asMFm4/Uqf1m6ENAQAJ][1.9.0-beta3]] (Oct 25, 2017)

- [[https://clojure.atlassian.net/browse/CLJ-2254][CLJ-2254]] - add System property clojure.spec.skip-macros
  (default=false) that can be used to turn off spec checking in macros

**** [[https://groups.google.com/d/msg/clojure/hJqYgzEOJ8s/IH0pogtQAgAJ][1.9.0-beta2]] (Oct 6, 2017)

1.9.0-beta2 includes the following changes since 1.9.0-beta1:

- [[https://clojure.atlassian.net/browse/CLJ-700][CLJ-700]] - (fix) ~contains?~, ~get~, and ~find~ broken for transient
  collections
- [[https://clojure.atlassian.net/browse/CLJ-2247][CLJ-2247]] - (regression) restore and doc last match semantics of
  {min,max}-key
- [[https://clojure.atlassian.net/browse/CLJ-2239][CLJ-2239]] - (regression) fix Guava javadoc location
- Updated dep to spec.alpha 0.1.134 - see [[https://github.com/clojure/spec.alpha/blob/master/CHANGES.md][changes]]

**** [[https://groups.google.com/d/msg/clojure/UEtE1K9C7XE/5p5BJe2tAQAJ][1.9.0-beta1]] (Sep 18, 2017)

1.9.0-beta1 includes the following changes since 1.9.0-alpha20:

- [[https://clojure.atlassian.net/browse/CLJ-2077][CLJ-2077]] - Clojure can't be loaded from the boot classpath under
  java 9

**** [[https://groups.google.com/d/msg/clojure/IB2CaORBMnM/a0f66eC1DAAJ][1.9.0-alpha20]] (Sep 7, 2017)

1.9.0-alpha20 includes the following changes since 1.9.0-alpha19:

- [[https://clojure.atlassian.net/browse/CLJ-1074][CLJ-1074]] - (new) add new ## reader macro for symbolic values, and
  read/print support for double vals ##Inf, ##-Inf, ##NaN
- [[https://clojure.atlassian.net/browse/CLJ-1454][CLJ-1454]] - (new) add swap-vals! and reset-vals! that return both old
  and new values
- [[https://clojure.atlassian.net/browse/CLJ-2184][CLJ-2184]] - (errors) propagate meta in doto forms to improve error
  reporting
- [[https://clojure.atlassian.net/browse/CLJ-2210][CLJ-2210]] - (perf) cache class derivation in compiler to improve
  compiler performance
- [[https://clojure.atlassian.net/browse/CLJ-2070][CLJ-2070]] - (perf) clojure.core/delay - improve performance
- [[https://clojure.atlassian.net/browse/CLJ-1917][CLJ-1917]] - (perf) reducing seq over string should call String/length
  outside of loop
- [[https://clojure.atlassian.net/browse/CLJ-1901][CLJ-1901]] - (perf) amap - should call alength only once
- [[https://clojure.atlassian.net/browse/CLJ-99][CLJ-99]] - (perf) min-key and max-key - evaluate k on each arg at most
  once
- [[https://clojure.atlassian.net/browse/CLJ-2188][CLJ-2188]] - (perf) slurp - mark return type as String
- [[https://clojure.atlassian.net/browse/CLJ-2108][CLJ-2108]] - (startup time) delay loading of spec and core specs
  (still more to do on this)
- [[https://clojure.atlassian.net/browse/CLJ-2204][CLJ-2204]] - (security) disable serialization of proxy classes to
  avoid potential issue when deserializing
- [[https://clojure.atlassian.net/browse/CLJ-2048][CLJ-2048]] - (fix) specify type to avoid ClassCastException when stack
  trace is elided by JVM
- [[https://clojure.atlassian.net/browse/CLJ-1887][CLJ-1887]] - (fix) IPersistentVector.length() - implement missing
  method
- [[https://clojure.atlassian.net/browse/CLJ-1841][CLJ-1841]] - (fix) bean - iterator was broken
- [[https://clojure.atlassian.net/browse/CLJ-1714][CLJ-1714]] - (fix) using a class in a type hint shouldn't load the
  class
- [[https://clojure.atlassian.net/browse/CLJ-1398][CLJ-1398]] - (fix) clojure.java.javadoc/javadoc - update doc urls
- [[https://clojure.atlassian.net/browse/CLJ-1371][CLJ-1371]] - (fix) Numbers.divide(Object, Object) - add checks for NaN
- [[https://clojure.atlassian.net/browse/CLJ-1358][CLJ-1358]] - (fix) doc - does not expand special cases properly (try,
  catch)
- [[https://clojure.atlassian.net/browse/CLJ-1705][CLJ-1705]] - (fix) vector-of - fix NullPointerException if given
  unrecognized type
- [[https://clojure.atlassian.net/browse/CLJ-2170][CLJ-2170]] - (doc) fix improperly located docstrings
- [[https://clojure.atlassian.net/browse/CLJ-2156][CLJ-2156]] - (doc) clojure.java.io/copy - doc char[] support
- [[https://clojure.atlassian.net/browse/CLJ-2051][CLJ-2051]] - (doc) clojure.instant/validated docstring - fix typo
- [[https://clojure.atlassian.net/browse/CLJ-2104][CLJ-2104]] - (doc) clojure.pprint docstring - fix typo
- [[https://clojure.atlassian.net/browse/CLJ-2028][CLJ-2028]] - (doc) filter, filterv, remove, take-while - fix
  docstrings
- [[https://clojure.atlassian.net/browse/CLJ-1873][CLJ-1873]] - (doc) require, ~*data-readers*~ - add .cljc files to
  docstrings
- [[https://clojure.atlassian.net/browse/CLJ-1159][CLJ-1159]] - (doc) clojure.java.io/delete-file - improve docstring
- [[https://clojure.atlassian.net/browse/CLJ-2039][CLJ-2039]] - (doc) deftype - fix typo in docstring
- [[https://clojure.atlassian.net/browse/CLJ-1918][CLJ-1918]] - (doc) await - improve docstring re shutdown-agents
- [[https://clojure.atlassian.net/browse/CLJ-1837][CLJ-1837]] - (doc) index-of, last-index-of - clarify docstrings
- [[https://clojure.atlassian.net/browse/CLJ-1826][CLJ-1826]] - (doc) drop-last - fix docstring
- [[https://clojure.atlassian.net/browse/CLJ-1859][CLJ-1859]] - (doc) zero?, pos?, neg? - fix docstrings

**** [[https://groups.google.com/d/msg/clojure/oy2O_akFJ2U/w6-C0hPoAQAJ][1.9.0-alpha19]] (Aug 24, 2017)

- Make the default import set public in RT

**** [[https://groups.google.com/d/msg/clojure/rb22V98rPLM/MFBBcz-gAQAJ][1.9.0-alpha18]] (Aug 23, 2017)

- Can now bind ~*reader-resolver*~ to an impl of LispReader$Resolver to
  control the reader's use of namespace interactions when resolving
  autoresolved keywords and maps.
- Tighten autoresolved keywords and autoresolved namespace map syntax
  to support *only* aliases, as originally intended
- Updated to use core.specs.alpha 0.1.24

**** [[https://groups.google.com/d/msg/clojure/iceDBL5q4CY/GM6LryxpAQAJ][1.9.0-alpha17]] (May 26, 2017)

- [[https://clojure.atlassian.net/browse/CLJ-1793][CLJ-1793]] - Clear 'this' before calls in tail position
- [[https://clojure.atlassian.net/browse/CLJ-2091][CLJ-2091]] clojure.lang.APersistentVector#hashCode is not thread-safe
- [[https://clojure.atlassian.net/browse/CLJ-1860][CLJ-1860]] Make -0.0 hash consistent with 0.0
- [[https://clojure.atlassian.net/browse/CLJ-2141][CLJ-2141]] Return only true/false from qualified-* predicates
- [[https://clojure.atlassian.net/browse/CLJ-2142][CLJ-2142]] Fix check for duplicate keys with namespace map syntax
- [[https://clojure.atlassian.net/browse/CLJ-2128][CLJ-2128]] spec error during macroexpand no longer throws compiler
  exception with location
- Updated to use spec.alpha 0.1.123

**** [[https://groups.google.com/forum/#!topic/clojure/nB4qnDNGS2A][1.9.0-alpha16]] (Apr 27, 2017)

1.9.0-alpha16 includes the following changes since 1.9.0-alpha15:

- The namespaces clojure.spec, clojure.spec.gen, clojure.spec.test have
  been moved to the external library spec.alpha which Clojure includes
  via dependency
- These namespaces have been changed and now have an appended ".alpha":
  clojure.spec.alpha, clojure.spec.gen.alpha, clojure.spec.test.alpha
- All keyword constants in clojure.spec (like :clojure.spec/invalid)
  follow the same namespace change (now :clojure.spec.alpha/invalid)
- spec-related system properties related to assertions did NOT change
- The specs for clojure.core itself in namespace clojure.core.specs
  have been moved to the external library core.specs.alpha which
  Clojure now depends on
- The clojure.core.specs namespace has changed to
  clojure.core.specs.alpha. All qualified spec names in that namespace
  follow the same namespace change (most people were not using these
  directly)

In most cases, you should be able to update your usage of Clojure
1.9.0-alphaX to Clojure 1.9.0-alpha16 by:

1. Updating your Clojure dependency to [org.clojure/clojure
   "1.9.0-alpha16"] - this will automatically pull in the 2 additional
   downstream libraries

2. Changing your namespace declarations in namespaces that declare or
   use specs to:

#+BEGIN_SRC clojure
(:require [clojure.spec.alpha :as s]
          [clojure.spec.gen.alpha :as gen]
          [clojure.spec.test.alpha :as stest])
#+END_SRC

**** [[https://groups.google.com/d/msg/clojure/10dbF7w2IQo/ec37TzP5AQAJ][1.9/spec split]] (Apr 26, 2017)

We are moving spec out of the Clojure repo/artifact and into a library
to make it easier to evolve spec independently from Clojure. While we
consider spec to be an essential part of Clojure 1.9, there are a number
of design concerns to resolve before it can be finalized. This allows us
to move towards a production Clojure release (1.9) that depends on an
alpha version of spec. Users can also pick up newer versions of the spec
alpha library as desired. Additionally, this is a first step towards
increased support for leveraging dependencies within Clojure.

We will be creating two new contrib libraries that will contain the
following (renamed) namespaces:

#+BEGIN_EXAMPLE
org.clojure/spec.alpha
    clojure.spec.alpha          (previously clojure.spec)
    clojure.spec.gen.alpha      (previously clojure.spec.gen)
    clojure.spec.test.alpha     (previously clojure.spec.test)

org.clojure/core.specs.alpha
    clojure.core.specs.alpha    (previously clojure.core.specs)
#+END_EXAMPLE

In most cases, we expect that users have aliased their reference to the
spec namespaces and updating to the changed namespaces will only require
a single change at the point of the require.

*How will ClojureScript's spec implementation change?*

ClojureScript will also change namespace names to match Clojure.
Eventually, the ClojureScript implementation may move out of
ClojureScript and into the spec.alpha library - this is still under
discussion.

*Why do the libraries and namespaces end in alpha?*

The "alpha" indicates that the spec API and implementation is still
subject to change.

*What will happen when the spec api is no longer considered alpha?*

At that point we expect to release a non-alpha version of the spec
library (with non-alpha namespaces). Users may immediately begin to use
that version of spec along with whatever version of Clojure it depends
on. Clojure itself will depend on it at some later point. Timing of all
these actions is TBD.

*Will the library support Clojure 1.8 or older versions?*

No. spec uses new functions in Clojure 1.9 and it has never been a goal
to provide spec for older versions. Rather, we are trying to accelerate
the release of a stable Clojure 1.9 so that users can migrate forward to
a stable production release with access to an alpha version of spec, and
access to ongoing updated versions as they become available.

**** [[https://groups.google.com/d/msg/clojure/7ZqGTjJoQEQ/RkUYCCbeAwAJ][1.9.0-alpha15]] (Mar 14, 2017)

1.9.0-alpha15 includes the following changes since 1.9.0-alpha14:

- [[https://clojure.atlassian.net/browse/CLJ-2043][CLJ-2043]] - s/form of conformer is broken
- [[https://clojure.atlassian.net/browse/CLJ-2035][CLJ-2035]] - s/form of collection specs are broken
- [[https://clojure.atlassian.net/browse/CLJ-2100][CLJ-2100]] - s/form of s/nilable should include the original spec, not
  the resolved spec

Specs:

- [[https://clojure.atlassian.net/browse/CLJ-2062][CLJ-2062]] - added specs for ~import~ and ~refer-clojure~
- [[https://clojure.atlassian.net/browse/CLJ-2114][CLJ-2114]] - ::defn-args spec incorrectly parses map body as a prepost
  rather than function body
- [[https://clojure.atlassian.net/browse/CLJ-2055][CLJ-2055]] - binding-form spec parses symbol-only maps incorrectly

Infrastructure:

- [[https://clojure.atlassian.net/browse/CLJ-2113][CLJ-2113]] - Clojure maven build updated

**** [[https://groups.google.com/d/msg/clojure/w-1h7_xO2R0/Lp_ks-BSAQAJ][1.9.0-alpha14]] (Oct 28, 2016)

1.9.0-alpha14 includes the following changes since 1.9.0-alpha13:

- NEW ~into~ now has a 0-arity (returns []) and 1-arity (returns the
  coll you pass)
- NEW ~halt-when~ is a transducer that ends transduction when pred is
  satisfied. It takes an optional fn that will be invoked with the
  completed result so far and the input that triggered the predicate.
- [[https://clojure.atlassian.net/browse/CLJ-2042][CLJ-2042]] - clojure.spec/form of clojure.spec/? now resolves pred
- [[https://clojure.atlassian.net/browse/CLJ-2024][CLJ-2024]] - clojure.spec.test/check now fully resolves aliased fspecs
- [[https://clojure.atlassian.net/browse/CLJ-2032][CLJ-2032]] - fixed confusing error if fspec is missing :args spec
- [[https://clojure.atlassian.net/browse/CLJ-2027][CLJ-2027]] - fixed 1.9 regression with printing of ~bean~ instances
- [[https://clojure.atlassian.net/browse/CLJ-1790][CLJ-1790]] - fixed error extending protocols to Java arrays
- [[https://clojure.atlassian.net/browse/CLJ-1242][CLJ-1242]] - = on sorted sets or maps with incompatible comparators
  now returns false rather than throws

**** [[https://groups.google.com/d/msg/clojure/QWPUWG9BwbE/9a7ymJb9AQAJ][1.9.0-alpha13]] (Sept 26, 2016)

1.9.0-alpha13 includes the following changes since 1.9.0-alpha12:

- s/conform of nilable was always returning the passed value, not the
  conformed value
- s/nilable now creates a generator that returns nil 10% of the time
  (instead of 50% of the time)
- s/nilable now delays realizing the predicate spec until first use
  (better for creating recursive specs)
- clojure.spec.gen now provides a dynload version of
  clojure.test.check.generators/frequency

**** [[https://groups.google.com/d/msg/clojure/lQ5beZB6QYE/ZLSPo023CgAJ][1.9.0-alpha12]] (Sept 7, 2016)

1.9.0-alpha12 includes the following changes since 1.9.0-alpha11:

- spec performance has been improved for many use cases
- spec explain printer is now pluggable via the dynamic var
  ~clojure.spec/*explain-out*~ which should be a function that takes an
  explain-data and prints to ~*out*~
- when a macro spec fails during macroexpand, throw ex-info with
  explain-data payload rather than IllegalArgumentException
- pprint prints maps with namespace literal syntax when
  ~*print-namespace-maps*~ is true
- [[https://clojure.atlassian.net/browse/CLJ-1988][CLJ-1988]] - coll-of, every extended to conform sequences properly
- [[https://clojure.atlassian.net/browse/CLJ-2004][CLJ-2004]] - multi-spec form was missing retag
- [[https://clojure.atlassian.net/browse/CLJ-2006][CLJ-2006]] - fix old function name in docstring
- [[https://clojure.atlassian.net/browse/CLJ-2008][CLJ-2008]] - omit macros from checkable-syms
- [[https://clojure.atlassian.net/browse/CLJ-2012][CLJ-2012]] - fix ns spec on gen-class signatures to allow class names
- [[https://clojure.atlassian.net/browse/CLJ-1224][CLJ-1224]] - record instances now cache hasheq and hashCode like maps
- [[https://clojure.atlassian.net/browse/CLJ-1673][CLJ-1673]] - clojure.repl/dir-fn now works on namespace aliases

**** [[https://groups.google.com/d/msg/clojure/_slHTn-Ej1Y/M_IVRODtCQAJ][1.9.0-alpha11]] (Aug 19, 2016)

1.9.0-alpha11 includes the following changes since 1.9.0-alpha10:

Clojure now has specs for the following clojure.core macros: let,
if-let, when-let, defn, defn-, fn, and ns. Because macro specs are
checked during macroexpansion invalid syntax in these macros will now
fail at compile time whereas some errors were caught at runtime and some
were not caught at all.

- [[https://clojure.atlassian.net/browse/CLJ-1914][CLJ-1914]] - Fixed race condition in concurrent range realization
- [[https://clojure.atlassian.net/browse/CLJ-1870][CLJ-1870]] - Fixed reloading a defmulti removes metadata on the var
- [[https://clojure.atlassian.net/browse/CLJ-1744][CLJ-1744]] - Clear unused locals, which can prevent memory leaks in
  some cases
- [[https://clojure.atlassian.net/browse/CLJ-1423][CLJ-1423]] - Allow vars to be invoked with infinite arglists (also,
  faster)
- [[https://clojure.atlassian.net/browse/CLJ-1993][CLJ-1993]] - Added ~*print-namespace-maps*~ dynamic var that controls
  whether to use namespace map syntax for maps with keys from the same
  namespace. The default is false, but standard REPL bindings set this
  to true.
- [[https://clojure.atlassian.net/browse/CLJ-1985][CLJ-1985]] - Fixed with-gen of conformer losing unform fn
- Fixed clojure.spec.test/check to skip spec'ed macros
- Fixed regression from 1.9.0-alpha8 where type hints within
  destructuring were lost
- Fixed clojure.spec/merge docstring to note merge doesn't flow
  conformed values
- Fixed regex ops to use gen overrides if they are used

**** [[https://groups.google.com/d/msg/clojure/MrwAx8DCjK8/rQSq8U5qCAAJ][1.9.0-alpha10]] (Jul 11, 2016)

1.9.0-alpha10 includes the following changes since 1.9.0-alpha9:

- NEW clojure.core/any? - a predicate that matches anything. any? has
  built-in gen support. The :clojure.spec/any spec has been removed.
  Additionally, gen support has been added for some?.
- keys* will now gen
- gen overrides (see c.s/gen, c.s./exercise, c.s.t/check,
  c.s.t/instrument) now expect no-arg functions that return gens,
  rather than gens
- [[https://clojure.atlassian.net/browse/CLJ-1977][CLJ-1977]] - fix regression from alpha9 in data conversion of
  Throwable when stack trace is empty

**** [[https://groups.google.com/d/msg/clojure/M-zC83YJl10/-zN-b2ekBgAJ][1.9.0-alpha9]] (Jul 5, 2016)

1.9.0-alpha9 includes the following changes since 1.9.0-alpha8:

- NEW clojure.spec/assert - a facility for adding spec assertions to
  your code. See the docs for ~*compile-asserts*~ and assert for more
  details.
- clojure.spec/merge - now merges rather than flows in conform/unform
- clojure.spec.test/instrument now reports the caller that caused an
  :args spec failure and ignores spec'ed macros
- clojure.spec.test - ~test~, ~test-fn~, ~testable-syms~ renamed to
  ~check~, ~check-fn~, and ~checkable-syms~ to better reflect their
  purpose. Additionally, some of the return value structure of ~check~
  has been further improved.
- clojure.core/Throwable→map formerly returned StackTraceElements which
  were later handled by the printer. Now the StackTraceElements are
  converted to data such that the return value is pure Clojure data, as
  intended.

**** [[https://groups.google.com/d/msg/clojure/vF3RuDWuX8I/pvn4IUuUAwAJ][1.9.0-alpha8]] (Jun 28, 16)

1.9.0-alpha8 includes the following changes since 1.9.0-alpha7:

The collection spec support has been greatly enhanced, with new controls
for conforming, generation, counts, distinct elements and collection
kinds. See the docs for every, every-kv, coll-of and map-of for details.

instrumenting and testing has been streamlined and made more composable,
with powerful new features for spec and gen overrides, stubbing, and
mocking. See the docs for these functions in clojure.spec.test:
instrument, test, enumerate-ns and summarize-results.

Namespaced keyword reader format, printing and destructuring have been
enhanced for lifting namespaces up for keys, supporting more succinct
use of fully-qualified keywords. Updated docs will be added to
clojure.org soon.

Many utilities have been added, for keys spec merging, fn exercising,
Java 1.8 timestamps, bounded-count and more.

Changelog:

clojure.spec:

- [changed] map-of - now conforms all values and optionally all keys,
  has additional kind, count, gen options
- [changed] coll-of - now conforms all elements, has additional kind,
  count, gen options. No longer takes init-coll param.
- [added] every - validates a collection by sampling, with many
  additional options
- [added] every-kv - validates a map by sampling, with many additional
  options
- [added] merge
- [changed] gen overrides can now be specified by either name or path
- [changed] fspec generator - creates a function that generates return
  values according to the :ret spec and ignores :fn spec
- [added] explain-out - produces an explain output string from an
  explain-data result
- [changed] explain-data - output is now a vector of problems with a
  :path element, not a map keyed by path
- [added] get-spec - for looking up a spec in the registry by keyword
  or symbol
- [removed] fn-spec - see get-spec
- [added] exercise-fn - given a spec'ed function, returns generated
  args and the return value
- All instrument functions moved to clojure.spec.test

clojure.spec.test:

- [changed] instrument - previously took a var, now takes either a
  symbol, namespace symbol, or a collection of symbols or namespaces,
  plus many new options for stubbing or mocking. Check the docstring
  for more info.
- [removed] instrument-ns - see instrument
- [removed] instrument-all - see instrument
- [changed] unstrument - previously took a var, now takes a symbol,
  namespace symbol, or collection of symbol or namespaces
- [removed] unstrument-ns - see unstrument
- [removed] unstrument-all - see unstrument
- [added] instrumentable-syms - syms that can be instrumented
- [added] with-instrument-disabled - disable instrument's checking of
  calls within a scope
- [changed] check-var renamed to test and has a different signature,
  check docs
- [changed] run-tests - see test
- [changed] run-all-tests - see test
- [changed] check-fn - renamed to test-fn
- [added] abbrev-result - returns a briefer description of a test
- [added] summarize-result - returns a summary of many tests
- [added] testable-syms - syms that can be tested
- [added] enumerate-namespace - provides symbols for vars in namespaces

clojure.core:

- [changed] - inst-ms now works with java.time.Instant instances when
  Clojure is used with Java 8
- [added] bounded-count - if coll is counted? returns its count, else
  counts at most first n elements of coll using its seq

**** [[https://groups.google.com/d/msg/clojure/3wmGJ5B4b6c/YgCJCtN8CQAJ][1.9.0-alpha7]] (Jun 15, 2016)

1.9.0-alpha7 includes the following changes since 1.9.0-alpha6 (all
BREAKING vs alpha5/6):

clojure.core: - long? ⇒ int? - now checks for all Java fixed precision
integer types (byte,short,integer,long) - pos-long? ⇒ pos-int? -
neg-long? ⇒ neg-int? - nat-long? ⇒ nat-int?

clojure.spec: - long-in-range? ⇒ int-in-range? - long-in ⇒ int-in

If you are interested in checking specifically for long?, please use
#(instance? Long %).

Sorry for the switcheroo and welcome to alphatown!

**** [[https://groups.google.com/d/msg/clojure/JIgmEFhAlq8/6UXO_rUpCQAJ][1.9.0-alpha6]] (Jun 14, 2016)

1.9.0-alpha6 includes the following changes since 1.9.0-alpha5:

- & regex op now fails fast when regex passes but preds do not
- returns from alt/or are now map entries (supporting key/val) rather
  than 2-element vector
- [BREAKING] fn-specs was renamed to fn-spec and returns either the
  registered fspec or nil
- fspec now accepts ifn?, not fn?
- fspec impl supports keyword lookup of its :args, :ret, and :fn specs
- fix fspec describe which was missing keys and improve describe of
  :args/ret/fn specs
- instrument now checks *only* the :args spec of a var - use the
  clojure.spec.test functions to test :ret and :fn specs
- Added generator support for bytes? and uri? which were accidentally
  left out in alpha5

**** [[https://groups.google.com/d/msg/clojure/D_s9Drua6D4/CTWk12cXDQAJ][1.9.0-alpha5]] (Jun 7, 2016)

1.9.0-alpha5 includes the following changes since 1.9.0-alpha4:

Fixes: - doc was printing "Spec" when none existed - fix ? explain

New predicates in core (all also now have built-in generator support in
spec): - seqable? - boolean? - long?, pos-long?, neg-long?, nat-long? -
double?, bigdec? - ident?, simple-ident?, qualified-ident? -
simple-symbol?, qualified-symbol? - simple-keyword?, qualified-keyword?
- bytes? (for byte[]) - indexed? - inst? (and new inst-ms) - uuid? -
uri?

New in spec: - unform - given a spec and a conformed value, returns the
unconformed value - New preds: long-in-range?, inst-in-range? - New
specs (with gen support): long-in, inst-in, double-in

**** [[https://groups.google.com/d/msg/clojure/TR-qUFVJwj0/aZspfZ3XBAAJ][1.9.0-alpha4]] (May 31, 2016)

1.9.0-alpha4 includes the following changes since 1.9.0-alpha3:

- fix describe empty cat
- improve update-in perf
- optimize seq (&) destructuring

**** [[https://groups.google.com/d/msg/clojure/WxT9kPIwlYI/r5PJpAP_CwAJ][1.9.0-alpha3]] (May 26, 2016)

1.9.0-alpha3 includes the following changes since 1.9.0-alpha2:

- Macro fdef specs should no longer spec the implicit &form or &env
  [BREAKING CHANGE]
- multi-spec includes dispatch values in path
- multi-spec no longer requires special default method
- fix for rep* bug
- added explain-str (explain that returns a string)
- improved s/+ explain
- explain output tweaked
- fix test reporting

**** [[https://groups.google.com/d/msg/clojure/ZBD5-Nhruc4/dntP8iQDAwAJ][1.9.0-alpha2]] (May 25, 2016)

1.9.0-alpha2 includes the following changes since 1.9.0-alpha1:

- Better describe for s/+
- Capture ~recursion-limit~ on gen call
- explain-data now contains :in key for the input path
- [[https://clojure.atlassian.net/browse/CLJ-1931][CLJ-1931]] - with-gen throws AbstractMethodError

**** [[https://groups.google.com/d/msg/clojure/7jbL34IjNzw/dejSpHefAwAJ][1.9.0-alpha1]] (May 24, 2016)

1.9.0-alpha1 includes the first release of clojure.spec.

A usage guide for spec is now available:
[[https://clojure.org/guides/spec]].

** Clojure Download Key
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/releases/download_key.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/releases/download_key
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-07-27
:CUSTOM_ID: content/releases/download_key
:END:
*** Signature files

All Clojure and Clojure contrib jars are signed when they are uploaded
to the Maven Central repo. A typical url in Maven Central will look
something like:

#+BEGIN_EXAMPLE
https://repo1.maven.org/maven2/org/clojure/clojure/1.10.3/clojure-1.10.3.jar
#+END_EXAMPLE

Your dependency manager / build tool will download that file to your
local Maven cache, usually:

#+BEGIN_EXAMPLE
~/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar
#+END_EXAMPLE

You can append .asc to any jar or pom url in Maven to obtain the
signature for that file:

#+BEGIN_EXAMPLE
curl -O https://repo1.maven.org/maven2/org/clojure/clojure/1.10.3/clojure-1.10.3.jar.asc
#+END_EXAMPLE

*** Verification

The Clojure key used to sign all jars is registered in the MIT key
server (pgp.mit.edu):

- ID: ~8D06684A958AE602~
- Fingerprint: ~9356 B31F 638B 658F B4DD  F228 8D06 684A 958A E602~
- Description:
  ~Clojure/core (build.clojure.org Release Key version 2) <core@clojure.com>~

You can check this by verifying the jar with the signature:

#+BEGIN_EXAMPLE
$ gpg --verify clojure-1.10.3.jar.asc ~/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar
gpg: Signature made Thu Jun  6 08:43:47 2019 CDT
gpg:                using RSA key 8D06684A958AE602
gpg: Good signature from "Clojure/core (build.clojure.org Release Key version 2) <core@clojure.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 9356 B31F 638B 658F B4DD  F228 8D06 684A 958A E602
#+END_EXAMPLE

This reports a good signature (the content is what was signed) but warns
that this key is not trusted in your GPG configuration. Marking the key
as trusted is beyond the scope of this page but you can manually verify
by comparing to the official key above.

#+BEGIN_QUOTE
*Note*

To run gpg --verify, you may need to update your version of GPG and
use a DNS server that can find the MIT key server (pgp.mit.edu).
#+END_QUOTE

** Older Downloads
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/releases/downloads_older.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/releases/downloads_older
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/releases/downloads_older
:END:
*** Older Clojure Releases

- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.10.2/][Clojure 1.10.3]] (Mar, 2021)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.10.2/][Clojure 1.10.2]] (Jan, 2021)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.10.1/][Clojure 1.10.1]] (June, 2019)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.10.0/][Clojure 1.10.0]] (December, 2018)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/][Clojure 1.9.0]] (December, 2017)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/][Clojure 1.8.0]] (January, 2016)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.7.0/][Clojure 1.7.0]] (June, 2015)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.6.0/][Clojure 1.6.0]] (March, 2014)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.5.1/][Clojure 1.5.1]] (March, 2013)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.4.0/][Clojure 1.4.0]] (April, 2012)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.3.0/][Clojure 1.3.0]] (September, 2011)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.2.1/][Clojure 1.2.1]] (September, 2010)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.2.0/][Clojure 1.2.0]] (August, 2010)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.1.0/][Clojure 1.1.0]] (January, 2010)
- [[https://repo1.maven.org/maven2/org/clojure/clojure/1.0.0/][Clojure 1.0.0]] (July, 2009)
- [[https://github.com/downloads/clojure/clojure/clojure-20090320.zip][Clojure 20090320]] (pre 1.0)
- [[https://github.com/downloads/clojure/clojure/clojure-20081217.zip][Clojure 20081217]] (pre 1.0)

*** Old Clojure Contrib Releases

- [[https://repo1.maven.org/maven2/org/clojure/clojure-contrib/1.2.0/][Clojure Contrib 1.2.0]] (February, 2011)
- [[https://repo1.maven.org/maven2/org/clojure/clojure-contrib/1.1.0/][Clojure Contrib 1.1.0]] (January, 2010)
- [[https://repo1.maven.org/maven2/org/clojure/clojure-contrib/1.0.0/][Clojure Contrib 1.0.0]]

*** Where did Clojure Contrib go?

If you are migrating from a pre-1.3 version of Clojure, please see
[[#content/dev/contrib_history][this page]] for migration help regarding old contrib libraries.

** Clojure Downloads
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/releases/downloads.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/releases/downloads
:CLOJURE_SITE_AUTHOR: Rich Hickey
:CLOJURE_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/releases/downloads
:END:

#+BEGIN_QUOTE
*Note*

New to Clojure? Head to the [[#content/guides/getting_started][Getting Started]] guide instead for
information on how to install the Clojure tools!

These tools allow you to start a REPL for interactive use, download
Clojure libraries (including Clojure itself), and run Clojure
programs.
#+END_QUOTE

*** Stable Release: 1.10.3 (Mar 4, 2021)

Include the release in your project using the following coordinates:

deps.edn coordinate:

#+BEGIN_SRC clojure
org.clojure/clojure {:mvn/version "1.10.3"}
#+END_SRC

Leiningen dependency:

#+BEGIN_SRC clojure
[org.clojure/clojure "1.10.3"]
#+END_SRC

**** Dependencies

Clojure 1.10.3 depends on the following core libraries:

- ~org.clojure/spec.alpha {:mvn/version "0.2.194"}~
- ~org.clojure/core.specs.alpha {:mvn/version "0.2.56"}~

Including Clojure with a tool like ~clj~ or ~Leiningen~ will
automatically include these libraries as transitive dependencies.

**** Java compatibility

Clojure depends on Java and all Clojure code is compiled to Java 8
compatible bytecode (newer versions of Java can load this as well).

- Minimum runtime dependency: Java 8
- Supported: LTS (long term support) releases, currently Java 8 and
  Java 11
- Others: likely work, but not officially supported

**** Changelog

Read the [[https://github.com/clojure/clojure/blob/master/changes.md][Changelog]] for detailed release information.

*** Development Release: 1.11.0-alpha2 (Sep 14, 2021)

- Clojure 1.11.0-alpha2
- [[https://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.clojure%22%20AND%20a%3A%22clojure%22%20AND%20v%3A1.11.0*][Clojure 1.11.0 pre-release builds]]
- [[#content/releases/devchangelog][Dev changelog]]
- Dependencies:
  - ~org.clojure/spec.alpha {:mvn/version "0.2.194"}~
  - ~org.clojure/core.specs.alpha {:mvn/version "0.2.62"}~
- Requirements: Java 8 or higher (recommended: Java 8 or Java 11)

*** Older Releases

- For older releases, see [[#content/releases/downloads_older][Older Releases]]

*** Clojure Source

Clojure source code is hosted at [[https://github.com/clojure/clojure][github.com/clojure/clojure]].  Builds
of the very latest version of Clojure's master branch are available at
[[https://oss.sonatype.org/content/repositories/snapshots/org/clojure/clojure/1.11.0-master-SNAPSHOT/][oss.sonatype.org]].

*** Get Clojure
**** Via deps.edn

Specify the version of Clojure that you want in your deps.edn:

#+BEGIN_SRC clojure
{:deps
 {org.clojure/clojure {:mvn/version "1.10.3"}}}
#+END_SRC

**** Via Leiningen

Modify the dependencies and repositories sections of your [[https://leiningen.org/][Leiningen]]
project.clj file, specifying the version of Clojure that you want:

#+BEGIN_SRC clojure
; under dependencies, select the release of clojure that you want
:dependencies [[org.clojure/clojure "1.10.3"]]
#+END_SRC

*** Using Clojure SNAPSHOT releases

Most tools do not automatically include the sonatype snapshot
repositories. To use SNAPSHOT releases, you must add this to your
configuration:

**** In deps.edn

Add an additional repository in deps.edn:

#+BEGIN_SRC clojure
{:mvn/repos
 {"sonatype-oss-public" {:url "https://oss.sonatype.org/content/groups/public/"}}}
#+END_SRC

**** In Leiningen

Add a snapshot repository in Leiningen in project.clj:

#+BEGIN_SRC clojure
:repositories {"sonatype-oss-public" "https://oss.sonatype.org/content/groups/public/"}
#+END_SRC

**** In Maven

In pom.xml:

#+BEGIN_EXAMPLE
<repositories>
  <repository>
    <id>sonatype-oss-public</id>
    <url>https://oss.sonatype.org/content/groups/public/</url>
    <releases>
      <enabled>true</enabled>
    </releases>
    <snapshots>
      <enabled>true</enabled>
    </snapshots>
  </repository>
</repositories>
#+END_EXAMPLE

*** Download verification

See the [[#content/releases/download_key][download key]] page for more on verifying Maven downloads
against the Clojure public key.

** Tools Releases
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/releases/tools.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/releases/tools
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-09-25
:CUSTOM_ID: content/releases/tools
:END:

The Clojure command line tools can be used to start a Clojure repl, use
Clojure and Java libraries, and start Clojure programs.

*** Installation and Docs

For more information see the following docs:

- [[#content/guides/getting_started][Getting Started]] guide installation instructions
- [[#content/guides/deps_and_cli][Deps and CLI guide]]
- [[#content/reference/deps_and_cli][Deps and CLI reference]]
- [[https://github.com/clojure/homebrew-tools][Clojure Homebrew tap]]

*** Releases

Recent official releases are described here. Prereleases and older versions can be found in the [[https://github.com/clojure/brew-install/blob/1.10.3/CHANGELOG.md][repo changelog]].

**** 1.10.3.1020 (Nov 5, 2021)

- [[https://clojure.atlassian.net/browse/TDEPS-83][TDEPS-83]]
  Invalidate classpath cache when local dep manifests change
- Add new ~clj -X:deps list~ program to list the full lib set on the
  classpath, see [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.api-api.html#clojure.tools.cli.api/list][API docs]] for more info
- Bump deps to more recent versions - aws-api, jetty-client, etc
- Clean up exception handling for -X/-T
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.12.1067

**** 1.10.3.998 (Oct 26, 2021)

- Remove ~bottle :unneeded~ from brew formulas (no longer needed)
- [[https://clojure.atlassian.net/browse/TDEPS-209][TDEPS-209]] Include only jar files in classpath from Maven artifacts
- Update to tools.tools v0.2.1 (minor improvements in ~clj -Ttools list~)
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.12.1058

**** 1.10.3.986 (Sep 22, 2021)

- Fix nested session cache computation for local pom model building
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.12.1048

**** 1.10.3.981 (Sep 21, 2021)

- Update to latest AWS API libs
- Downgrade Maven resolver libs to better match Maven core libs
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.12.1041

**** 1.10.3.967 (Sep 1, 2021)

- Refine exec exceptions for missing namespace vs missing function in
  namespace
- Replace Maven-based build process with tools.build
- Compile entry points in tools.deps used for building classpaths for
  performance
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.12.1036

**** 1.10.3.943 (Aug 13, 2021)

- [[https://clojure.atlassian.net/browse/TDEPS-199][TDEPS-199]] Use default http-client in S3 transporter
- Cache S3 transporter for a repo
- Fixed session cache to work properly across threads / binding stacks
  for better perf
- Replace specific maven version range requests with non-range request
  to reduce repo metadata lookups
- Load and cache Maven settings once for perf
- Cache version range resolution results for perf
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.12.1019

**** 1.10.3.933 (July 28, 2021)

- deps.edn
  - [[#content/reference/deps_and_cli#git][git deps]]
    - If a git library name follows the repo convention names, the
      ~:git/url~ can now be inferred (~:git/url~ can also be specified explicitly and takes precedence)
    - ~:git/tag~ and prefix ~:git/sha~ can now be specified instead
      of the full sha. Both must point to the same commit.
    - ~:sha~ has been renamed to ~:git/sha~ but the original is still
      supported for backwards compatibility
  - ~:deps/prep-lib~ - a new top-level key can be used to say how a
    source lib should be prepared before being added to the classpath.
    This key's value is a map with ~:alias~, ~:fn~, and ~:ensures~.  See
    [[#content/reference/deps_and_cli#prep-libs][prep docs]] for more info.
  - ~:tools/usage~ - a new top-level key can be used to provide the
    ~:ns-default~ and ~:ns-aliases~ context for a tool
- [[#content/reference/deps_and_cli#tool-installation-and-invocation][Tools]] - git-based programs that can be installed with a local
  name. Tools can provide their own usage context in deps.edn.
  - Added new auto-installed tool named ~tools~ with
    [[https://clojure.github.io/tools.tools][functions]] ~install~, ~list~, ~remove~. See [[#content/reference/deps_and_cli#tool-installation-and-invocation][reference]].
  - Install a tool with
    ~clojure -Ttools install <lib> <coord> :as <toolname>~
  - Run a tool with ~clojure -T<toolname> fn~ (also takes -X style
    args)
- [[#content/reference/deps_and_cli][Clojure CLI]]
  - New ~-T~ option is like ~-X~ (executes a function) but does not
    use the project classpath, instead uses tool classpath (and adds
    ~:paths ["."]~ by default). ~-T:aliases~ is otherwise same as
    ~-X~. ~-Ttoolname~ resolves named tool by name and uses that tool
    lib.
  - [[https://clojure.atlassian.net/browse/TDEPS-198][TDEPS-198]] - -X and -T will not wait to exit if futures/agents have
    been used
  - [[https://clojure.atlassian.net/browse/TDEPS-182][TDEPS-182]] - Improve deprecation messages to be more accurate
  - [[https://clojure.atlassian.net/browse/TDEPS-183][TDEPS-183]] - Fix -Sdescribe output to be valid EDN on Windows
  - [[https://clojure.atlassian.net/browse/TDEPS-179][TDEPS-179]] - Fix incorrect classpath when :classpath-overrides
    removes path
  - Delay computation of local-repo path (don't compute at load time)
  - Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.12.1003
- New -X:deps programs:
  - [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.api-api.html#clojure.tools.cli.api/find-versions][find-versions]] - to find versions of Maven or git libs or tools
  - [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.api-api.html#clojure.tools.cli.api/prep][prep]] - use to [[#content/reference/deps_and_cli#prep-libs][prep]] source libs
  - [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.help-api.html#clojure.tools.cli.help/dir][help/dir]] - to list available functions in a tool namespace
  - [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.help-api.html#clojure.tools.cli.help/doc][help/doc]] - to list docs for a tool namespace or function

Read more at [[#content/news/2021/07/09/source-libs-builds][Source Libs and Builds]].

**** 1.10.3.855 (May 25, 2021)

- Fix in applying :jvm-opts with -X execution on Windows

**** 1.10.3.849 (May 21, 2021)

- Adds support for a [[#content/reference/deps_and_cli#trailing-map-argument][trailing map of kvs]] in -X calls (similar to
  Clojure 1.11 trailing map to vararg calls)
- Updates all Maven deps to latest (maven-resolver 1.7.0, maven core
  1.8.3) to address these [[https://maven.apache.org/docs/3.8.1/release-notes.html][security concerns]]
  - CVE-2020-13956 - bumps deps on Apache HttpClient used by Maven
  - CVE-2021-26291 - potential security problems regarding Maven
    repositories:
    - Due to the possibility of MITM (man in the middle) attacks,
      http repo access is now blocked by default. tools.deps/Clojure
      CLI has always used https repos in the default repository list
      (central and clojars), so this mostly impacts any explicit http
      repositories defined in deps.edn
    - Concerns over the "hijacking" of repository urls by transitive
      pom deps (or their super poms) to download artifacts from
      malicious repos. Maven made no changes here, but did clarify how
      repos are resolved on [[https://maven.apache.org/guides/mini/guide-multiple-repositories.html#repository-order][this page]]. From a deps perspective, we
      only use repositories declared in the top-level deps.edn (if
      transitive deps need a custom repo, you will need to add it at
      top-level too). For tools.deps use of pom dependencies, we are
      providing the repos of the top deps.edn file (which should
      always put Maven Central and Clojars first), then deferring to
      Maven for the rest.
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.11.922

**** 1.10.3.839 (May 12, 2021)

- Fix Linux installer breakage in 1.10.3.833

**** 1.10.3.833 (May 11, 2021)

- [[https://clojure.atlassian.net/browse/TDEPS-177][TDEPS-177]] - Fix Maven mirrors to look up by id, not name
- Remove flag when fetching git deps so that older git versions work
- Tweak some warning messages
- Clean up scripts to simplify variable replacement
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.11.918

**** 1.10.3.822 (Apr 3, 2021)

- Fix issue with git deps where new commits on branches were not
  fetched

**** 1.10.3.814 (Mar 16, 2021)

- git deps: switch from using jgit to shelling out to git (must be git
  >= 2.5)
  - New env vars for control:
    - ~GITLIBS_COMMAND~ - command to invoke when shelling out to git,
      default = ~git~
    - ~GITLIBS_DEBUG~ - set to ~true~ to print git commands and
      output to stderr, default = ~false~
- Made git fetch only when shas can't be resolved to improve
  performance
- Bump dep versions for tools.cli and aws api to latest
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.11.905

**** 1.10.2.796 (Feb 23, 2021)

- Fix ~clj -X:deps git-resolve-tags~ to update the sha to match the tag
- Perf improvements for git or local deps using pom.xml
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.884

**** 1.10.2.790 (Feb 19, 2021)

- Add -version and --version options
- [[https://clojure.atlassian.net/browse/TDEPS-56][TDEPS-56]] - Fix main-opts and jvm-opts word splitting on spaces
- [[https://clojure.atlassian.net/browse/TDEPS-125][TDEPS-125]] - Use JAVA_CMD if set (thanks Gregor Middell!)
- Add warning if ~:paths~ or ~:extra-paths~ refers to a directory
  outside the project root (in the future will become an error)
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.871

**** 1.10.2.774 (Jan 26, 2021)

- Improve error when git dep version relationship can't be determined
- Switch to 1.10.2 for default Clojure version
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.863

**** 1.10.1.763 (Dec 10, 2020)

- Set exit code for -X ex-info error
- Sync up cli syntax for aliases in help
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.857

**** 1.10.1.754 (Dec 7, 2020)

- New, more informative tree format for ~clj -Stree~ /
  ~clj -X:deps tree~
- Added [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.api-api.html#clojure.tools.cli.api/tree][options]] for use with ~clj -X:deps tree~
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.857

**** 1.10.1.739 (Nov 23, 2020)

- Fix use of jdk profile activation in local deps with pom files
- Fix error handling for -X to avoid double throw
- Add error handling for -A used without an alias
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.840

**** 1.10.1.727 (Oct 21, 2020)

- Fix clj -X:deps tree adding tools.deps.alpha to tree
- Fix clj -X:deps mvn-pom adding tools.deps.alpha to pom deps
- Fix clj -X:deps git-resolve-tags not working
- [[https://clojure.atlassian.net/browse/TDEPS-169][TDEPS-169]] - Fix clj -X:deps mvn-install on jar to also install
  embedded pom
- Fix clj -Spom not respecting dep modifications from -A (regression)
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.833

**** 1.10.1.716 (Oct 10, 2020)

- Make edn reading tolerant of unknown tagged literals
- Update to latest dependencies for maven-resolver and aws-api
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.821

**** 1.10.1.708 (Oct 7, 2020)

- Fixes to handling transitive deps when newer versions of a dep are
  found in the dep expansion
- [[https://clojure.atlassian.net/browse/TDEPS-168][TDEPS-168]] - Improvements to -X error message handling
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.816

**** 1.10.1.697 (Sept 25, 2020)

- Added [[https://clojure.org/reference/deps_and_cli#_executing_a_function][execution mode]] (-X)
- Added [[https://clojure.org/reference/deps_and_cli#_prepare_for_execution][prepare mode]] (-P)
- Expanded [[https://clojure.org/reference/deps_and_cli#_running_a_main_or_script][main execution]] (-M) to support all argmap arguments
- Added new argmap attributes for [[https://clojure.org/reference/deps_and_cli#namespaces][namespace resolution]]:
  - :ns-aliases and :ns-default
- Added new [[https://clojure.github.io/tools.deps.alpha/clojure.tools.cli.api-api.html][clojure.tools.cli.api]] available via -X:deps alias:
  - clj -X:deps git-resolve-tags
  - clj -X:deps mvn-install
  - clj -X:deps mvn-pom
  - clj -X:deps tree
- Deprecated -R, -C (use -X, -M, or -A instead)
- Deprecated unqualified lib names in deps.edn (use fully qualified lib
  names)
- Deprecated alias tool args :deps and :paths (use :replace-deps and
  :replace-paths)
- Removed -O (use -X, -M, or -A)
- Removed -Sresolve-tags (use -X:deps git-resolve-tags)
- [[https://clojure.atlassian.net/browse/TDEPS-152][TDEPS-152]] - Fixes to -Spom generation with srcDirectory
- [[https://clojure.atlassian.net/browse/TDEPS-155][TDEPS-155]] - Better error handling for bad coordinates
- [[https://clojure.atlassian.net/browse/TDEPS-167][TDEPS-167]] - Handle absolute resource paths in pom deps
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.9.810

**** 1.10.1.561 (July 17, 2020)

- Rework exclusion handling when exclusion sets differ for same
  lib/version
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.8.709

**** 1.10.1.547 (June 11, 2020)

- (Windows) Write -Spath to output, not to host
- [[https://clojure.atlassian.net/browse/TDEPS-152][TDEPS-152]] - Fix bad addition of srcDirectory in pom gen
- [[https://clojure.atlassian.net/browse/TDEPS-155][TDEPS-155]] - Add error checking for missing :mvn/version
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.8.695

**** 1.10.1.536 (Feb 28, 2020)

- Release automation work, no tool changes

**** 1.10.1.510 (Feb 14, 2020)

- [[https://clojure.atlassian.net/browse/TDEPS-150][TDEPS-150]] - Fix regression in supporting -Scp flag (avoid resolving
  deps)
- [[https://clojure.atlassian.net/browse/TDEPS-148][TDEPS-148]] - Fix incorrect path resolution for git/local dep without
  deps.edn
- Use [[https://github.com/clojure/tools.deps.alpha/blob/master/CHANGELOG.md][tools.deps.alpha]] 0.8.677

* Stories
** AnyChart
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/anychart.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/anychart
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-03-16
:CUSTOM_ID: content/stories/anychart
:END:

[[./assets/images/content/stories/anychart.png]]

*How long have you been working with Clojure or ClojureScript?*

[[https://www.anychart.com/][AnyChart]] started in 2003 as a provider of Flash-based solutions for
interactive data visualization. Then, in several years, we moved to
JavaScript HTML5 as a more promising technology. Not having stopped
further developing, AnyChart started working with Clojure in early
2014 and with ClojureScript in 2015, and we are glad to say they've
been among the technologies fueling our global leadership in data
visualization tools for all these years.

*How big is the team you have using Clojure or ClojureScript?*

Currently, two of our developers code in Clojure on a regular basis. Now
that our team is growing, the number of Clojure programmers is expected
to increase.

*What product or service are you building with Clojure or ClojureScript?*

AnyChart is a lightweight and robust [[https://www.anychart.com][JavaScript charting library]] with
great, detailed [[https://docs.anychart.com][chart documentation]] and [[https://api.anychart.com][JS API reference]], as well as
enterprise-grade [[https://www.anychart.com/support][support]]. Our component smoothly runs on any platform
and finely works with any database. The source code of AnyChart is
[[https://www.anychart.com/blog/2017/02/28/anychart-javascript-charting-libraries-7-13-0-released-source-code-opened/][open]], so anyone can download and modify it, which gives a great
flexibility.  Thousands of out-of-the-box chart code samples in our
[[https://playground.anychart.com][playground]], [[https://www.anychart.com/technical-integrations/][plugins and integrations]] for all major stacks, and
ready-to-use [[https://www.anychart.com/solutions/][HTML5 dashboards as business solutions]] allow
industry-standard data visualizations to be deployed literally in
minutes.

Our goal has been to create a universal engine for data visualization
in order to let anyone easily make any charts and dashboards from any
data, and to ensure their great look and feel in any web projects
regardless of the platform and the browser. And we are happy to be on
the right track, currently being trusted to power data visualization
for thousands of our [[https://www.anychart.com/company/customers/][customers]], from startups to over 70% of the
Fortune 1000 companies. By the way, we are proud to have been named
the [[https://www.anychart.com/blog/2018/02/06/best-javascript-technology-anychart-js-charts-library-devies-award/][best in JavaScript technologies]] and received a prestigious 2018
DEVIES award earlier this year.

Clojure and ClojureScript are essential parts of our projects such as
AnyChart JS API reference, documentation, playground, [[https://docs.anychart.com/Common_Settings/Server-side_Rendering][export
server]]. Without Clojure, they wouldn't be as awesome as they are now.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

We employ [[https://reagent-project.github.io/][Reagent]] and [[https://github.com/Day8/re-frame][re-frame]], and think that they are amazing
ClojureScript libraries which make complex things easy and
enjoyable. In addition to that, we use Component, Hiccup, Selmer,
Enlive and Yesql on the server side.

*What about working with Clojure or ClojureScript gives you the most
value?*

Clojure itself is a value for us. We take delight in its syntax, the
ability to write HTML code by means of the language itself, work with
streams, and write macros. Edn format and immutability in Clojure also
should be noted here as they are good for data presentation and its
better understanding.

*What is your favorite feature of Clojure or ClojureScript?*

Our favorite feature of Clojure is that it is thought-out to the
smallest detail as a functional language. So we take great pleasure in
using it.

*What is your stack?*

We use a lot of different technologies. Our main product, the AnyChart
library for interactive data visualization, is written in JavaScript.
Most of our projects are built on Clojure on the backend and
ClojureScript or JavaScript on the frontend. We also have services
written in Python, PHP, and NodeJS.

*Why is using Clojure or ClojureScript valuable to your business?*

Clojure and ClojureScript together make our product better and its
development process faster and more convenient. And the fact that we are
dealing with the Java platform here allows us to use a large number of
various libraries, which is very helpful. Clojure implementation
definitely contributes to the continuing growth of our company and its
leadership in the segment of cross-platform interactive data
visualization solutions. And it is a great joy for us to be a part of
the Clojure community.

** CloudRepo
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/cloudrepo.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/cloudrepo
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-04-27
:CUSTOM_ID: content/stories/cloudrepo
:END:

[[./assets/images/content/stories/cloudrepo.png]]

*What product or service are you building with Clojure or ClojureScript?*

[[https://www.cloudrepo.io/][CloudRepo]] is a fully managed, cloud
repository manager. We store software artifacts for software development
teams that use tools like Leiningen, Boot, and Maven for dependency
management.

*What Clojure library have you enjoyed working with the most?*

There are a bunch of libraries that have really been solid and helped
our development process. We use Faraday for very simple AWS Dynamo DB
access. clj-http for all of our http client needs (testing, etc) and
cheshire works like a charm for JSON Parsing.

However, the most eye opening and educational library we have used is
Ring - it was a paradigm shift to see how http requests could be
modeled as simple data and then passed through the system. Once we
realized that requests could be modeled as data, we were able to just
let the requests flow through our system making transformations as
needed. That was a key learning for us and really helped us to
understand more about designing systems based on data flow, which I
detail further in [[https://medium.com/@chris.shellenbarger/key-lesson-building-cloudrepo-with-clojure-99bc1c1c405e][this post]]

Most recently, using spec has been really great. The idea of
generational tests has been game changing for us. It also has provided
us with, what we think is, an improvement over static typed system for
defining functional contracts and validating programs. We can now
validate based on the 'shape' of the data or even specific values - this
goes miles beyond the limits of what traditional type systems provide.

*What is your favorite feature of Clojure?*

We absolutely love the power that comes with passing around maps and
letting them flow through the system. When we can implement an endpoint
by simply using the ~->~ function and a chain of functions we are always
pleasantly surprised at how elegant programming can really be with
Clojure.

Modeling our system state as maps has also been enlightening. It allows
us to understand our system better by looking at maps of data rather
than a large object hierarchy. Combined with immutability, this makes
Clojure a joy to work with.

*What is your stack?*

We're built 100% in AWS. We leverage Amazon S3 for storage of artifacts
and DynamoDB for metadata.

In order to achieve high availability for our customers, we run
CloudRepo in Docker containers distributed across multiple hosts running
in Amazon Elastic Container Services. Our backend services are written
100% in Clojure. It's great that we can leverage the reliability of the
JVM along with the power of a language like Clojure.

*Why is Clojure valuable to your business?*

Clojure is valuable to our business because we can do so much more with
less. We have a very small team and we are usually able to add features
within a couple of hours. We achieve this power because we flow data
through the system and adding new features tends to be just about
figuring out where best to plug into that flow. Once that's decided, we
can hook in and not worry about impacting state in other areas of the
code thanks to immutability.

** Cognician
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/cognician.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/cognician
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-12-20
:CUSTOM_ID: content/stories/cognician
:END:

[[./assets/images/content/stories/cognician.jpg]]

*How long have you been working with Clojure or ClojureScript?*

Since early 2012.

At that point, [[https://www.cognician.com/][Cognician]] had spent a couple of years proving that we
had something worth building a business around, and then we actually
had to build that business.

Our previous stack was a Flash/AIR app (remember those?) with a PHP/SQL
backend. I had built enough of those sorts of apps to know that I wasn't
smart enough or skilled enough to build large OO projects that scaled
well. I knew I needed a fresh perspective.

Thanks to [[http://www.clojurebook.com][clojurebook.com]] and several great talks by Rich and the
fantastic folks in the Clojure IRC channel and Google Groups, I had
enough support to switch paradigms and learn to program all over
again.

It's nearly seven years later, and I'm utterly convinced we wouldn't
still be in business if we had chosen something more traditional.

*How big is the team you have using Clojure or ClojureScript?*

10 people regularly commit Clojure/ClojureScript to git, but almost all
40 of us know EDN. :-)

*What product or service are you building with Clojure or ClojureScript?*

Cognician aims to provide delightful, life-changing learning experiences
to people in the world of work all over the world.

The platform and the learning experiences it enables are built on the
idea that people are capable of great things when their behavior is
inspired by powerful ideas and deeply felt emotions.

At its heart, Cognician is a digital coaching SaaS platform. You could
think of it as ‘the Socratic method, at scale.'

We've built a catalog of learning experiences, the components that make
up these experiences, and a platform that allows us to configure these
experiences to suit our clients' learning needs.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

[[https://www.datomic.com/][Datomic]] has been tremendous fun to learn, to use, and to teach. It's
such a fitting design for the problems it solves for, and it's a great
pleasure to work with.

Thanks to Datomic's architecture, we have been able to avoid two major
headaches:

1. Concurrency -- our web server instances only share browser cookies,
   and Datomic. Our backend services only share the Datomic database
   with the web servers. Programming with databases as values has made
   doing all of this a pleasure.
2. View caching -- we haven't had to worry about this at all since every
   view on our system is rendered live from source data!

There are so many other libraries that we use daily and have learned
from!

*What about working with Clojure or ClojureScript gives you the most value?*

The data orientation of Clojure forces you to deal with naming things
properly, which in turn forces you to deal with understanding your
domain well. Its composable nature allows you to decide when to use the
tools that support the definition of data vs. the implementation of
behavior, rather than forcing you to use ‘The One True Way.'

Being able to think in a single language everywhere -- i.e., browser,
server, network, and database -- has tremendous value. It feels a little
like getting to choose your own physics. Something interesting happens
after you've worked like this for some time -- you stop seeing the
language and you see the domain directly. It's a little like being able
to understand The Matrix. :-)

On the people side, Clojure has attracted some of the most amazing
creators and problem solvers we have had -- and continue to have -- the
honor to work with!

*What is your favorite feature of Clojure or ClojureScript?*

Programming with a REPL is life-changing. It's so suited to the business
of using software to solve real-world problems today.

After that, Clojure has two ways of mitigating the downsides of its
dynamic nature. There's [[https://clojure.org/guides/destructuring][destructuring]], which helps you to be explicit
about how you'll use the data at hand, and then there's [[https://clojure.org/about/spec][spec]], which
has many different points of leverage to enjoy (all opt-in!) for a
relatively minor up-front investment.

*Why is using Clojure or ClojureScript valuable to your business?*

It's about our velocity when we use it. Using Clojure had allowed us to:

Deal with a rapid rate of change -- there have been many linchpin
moments in our history where we had to be able to ‘turn on a dime' and
totally change our approach. Having less code to begin with helps, but
also not having to fight assumptions in the language, the database, or
some framework we're using has helped us to ‘wipe the slate clean' and
begin again.

Get to a working system quickly -- thanks to its dynamic, immutable, and
Lispy nature, you don't have to write a lot of Clojure to get something
working. Once the needs are clear, building the system is quick to do.

Here are two fun factoids:

- We have about 100k lines of code of production Clojure/ClojureScript.
  Given all the things this code is doing, that's very little.
- Around 400 of the 1600 or so Datomic idents in our database are
  marked deprecated, which helps to illustrate how much we've built and
  since discarded.

*What is your stack?*

We develop regularly with Clojure, ClojureScript, Datomic, and Sass.

We have a derived data SQL store for BI tooling to interact with.

We host on AWS, using their ‘paved road': Route 53, EC2, ALB, S3,
CloudFront. Nothing surprising!

We use Buildkite for CI, Datadog for monitoring, and Sentry for error
logging.

Probably the most interesting thing about our stack is our CI system --
we have invested a lot of energy into making it easy to do the right
thing. We have duplicate environments based on common configuration
code, we can create test servers for git branches, and we can restore
production data to a sandbox to test with -- all available at the click
of a button.

We can get new code live in under 15 minutes, sometimes in only 5
minutes. For situations that require a quicker turnaround, we have a
remote REPL. :-)

** CollBox
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/collbox.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/collbox
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-04-06
:CUSTOM_ID: content/stories/collbox
:END:

We talked with Cameron Desautels about his use of Clojure and
ClojureScript at [[https://collbox.co/][CollBox]].

[[./assets/images/content/stories/collbox.png]]

*How long have you been working with Clojure and ClojureScript?*

I've been using Clojure for about five years, and ClojureScript for one
year. I discovered Lisps early in my programming career (probably via
Emacs) and thus have been a Lisp fan for about 15 years, so Clojure felt
like coming home.

*What product or service are you building?*

We're using Clojure and ClojureScript to build the next generation of
debt collection services. We integrate with cloud accounting software to
conveniently ingest and validate debt, manage a network of reputable
debt collectors behind the scenes, and intelligently match debt with
collectors to optimize for the best rates and odds of collection. At the
same time, we're working to raise the bar on accountability and
transparency in an industry that has historically not been known for
those things.

*How big is your team?*

Just me! We're a small startup, and I comprise the engineering team (for
now). But I consider it a testament to Clojure that a sole developer can
build and maintain a production web application. In fact, the roots of
our company trace back to winning the grand prize at the at 2015
QuickBooks Connect Hackathon, where we beat out teams with five
professional engineers who work together every day---again, with Clojure
and one engineer. A good tool is a force multiplier.

*What about working with Clojure and ClojureScript gives you the most value?*

The single most valuable aspect of working with Clojure, for me, is the
language's commitment to reusing a small number of readable, immutable
data structures. I configure my application with basic data structures;
I wire my application's dependencies together with basic data
structures; I write my database queries in them, I log metrics with
them, and when I have to diagnose a web exception at 2am, I'm very
fortunate that that request came in as a familiar data structure that I
can print, log, inspect, or update with the same tools I've spent years
getting comfortable with.

I can't stress enough how superior this is to having a reference to an
opaque Foo object and wondering "what can this thing do? What's inside
of it? Can I serialize it? How do I create one? Is it going to change
out from under me?"

*What is your stack?*

Our frontend is all ClojureScript using [[https://github.com/Day8/re-frame][re-frame]]. The backend is
Clojure running on AWS backed by [[http://www.datomic.com/][Datomic]] (on DynamoDB). Our web
framework is custom-built, but makes heavy use of [[https://github.com/ztellman/aleph][aleph]], [[https://github.com/juxt/bidi][bidi]],
[[https://github.com/stuartsierra/component][component]], and [[https://github.com/cognitect/transit-format][transit]].

** cstap
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/cstap.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/cstap
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-04-07
:CUSTOM_ID: content/stories/cstap
:END:

This interview is with Ikuru Kanuma, a developer for Cybozu Startups in
Japan.

[[./assets/images/content/stories/cstap.png]]

*What product or service are you building with Clojure or ClojureScript?*

We built a [[https://anpi.cstap.com/anpi2.html][safety confirmation service]] with Clojure and ClojureScript.

The main features are:

- Trigger emails/notifications through disaster reports (earthquake,
  tsunami, etc) from the Japanese Meteorological Agency, or user
  action.
- The users can access a questionnaire from the email/notification and
  answer their status, such as whether they are safe, can work/commute
  etc.
- Provide a summarized view of the responses which can be used to make
  business continuity decisions in case of a disaster.

The overall system is composed of:

- A main user facing web application (Clojure/ClojureScript)
- A worker that sends out the emails/notifications (Clojure)
- An API server for the mobile app (Clojure)
- An API server that allows external systems to update user data
  (Clojure)
- A backend Admin application (Clojure/ClojureScript)
- Mainly deployed on AWS Elastic Beanstalk.

*How big is the team you have using Clojure or ClojureScript?*

We are a team of 3, and all of us use Clojure for the server side, and
ClojureScript for the frontend. All 3 of us develop in Emacs + Cider. 2
of us use a Linux machine, and 1 uses a Mac.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

I would like to mention 2 libraries:

- [[https://github.com/cognitect/transit-clj][transit-clj]] - because it removes much of the friction when passing
  data between the server and the browser, which is a common problem
  in most other languages.
- [[https://github.com/juxt/bidi][bidi]] - we cannot imagine life without it! Our app has quite a few
  dynamically generated URLs, and creating those without bidirectional
  routing would have been a nightmare.

*What about working with Clojure or ClojureScript gives you the most value?*

- Interactive development with the REPL and the excellent tools such as
  Cider and figwheel, which allows for extremely quick iteration.
- Immutable data structures, for making the programs really simple and
  easy to understand
- Ability to share code between the frontend and backend

*Why is using Clojure or ClojureScript valuable to your business?*

Apart from the technical benefits, we are focusing and investing on
Clojure for tech branding, which in turn the ultimate goal is to recruit
talented engineers. The factors that were important for branding were:

- Something that is going to stay around for a long time (So a
  programing language over some library/framework)
- Something that helps an engineer grow
- Something that makes an engineer excited
- Something that engineers interested in it tend to be talented
- Did not have to be something popular as we wanted to keep a small
  team
- Less competition in terms of recruitment
- Something that we can be the best in Japan

Clojure matches these factors really well, and so far we are happy with
the results. That is how we gathered the 3 members of our team (all
loving Clojure), and we constantly receive 1 or 2 applications every
month. (FYI: We're hiring in Japan! →
[[https://cstap.com/jobs/dev-engineer.html]])

** Empear
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/empear.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/empear
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-04-24
:CUSTOM_ID: content/stories/empear
:END:

This interview is a discussion with Adam Tornhill about
[[http://www.empear.com/][Empear]] and their code analysis tool
[[https://codescene.io/][CodeScene]].

[[./assets/images/content/stories/empear.png]]

*How long have you been working with Clojure or ClojureScript?*

Empear launched in 2015 and we used Clojure from the start. Prior to
that I used Clojure for some of my side projects. Clojure was a natural
step. I've been a big fan of Lisp for a decade and to be able to use a
Lisp together with the ecosystem of the JVM was attractive.

*How big is the team you have using Clojure or ClojureScript?*

We're three developers at the moment and look to expand. All of us code
in Clojure on a daily basis. We also have a few small components written
in Haskell and Python.

*What product or service are you building with Clojure or ClojureScript?*

Our main product is CodeScene. CodeScene is a tool that helps software
projects improve their efficiency by identifying and prioritizing
technical debt. We take a different approach to software analysis since
we base the results on behavioral and social data.

Our main data source is version-control repositories, which CodeScene
views as a behavioral log of how the developers interact with the
codebase. This means we can prioritize based on how the system grows and
also include a social dimension of code that lets our customers discover
team productivity bottlenecks and save on- and off-boarding costs.

We maintain two versions of CodeScene. One is our cloud version,
[[https://codescene.io/]], which is the analyses as a service. The other
is our on-premises version of CodeScene, which our customers install
in their own data centers.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

The nature of Clojure and its tight integration with Java makes using
Clojure libraries more of an optional convenience. Some high-quality
libraries that we enjoy are [[https://github.com/ptaoussanis/carmine][Carmine]], [[https://github.com/ptaoussanis/timbre][Timbre]], and [[https://github.com/dakrone/cheshire][Cheshire]]. We also
found [[https://github.com/weavejester/ragtime][Ragtime]] helpful for database migrations. In addition, we use
several libraries for statistics and machine learning, although we
often end-up implementing our core algorithms ourselves.

*What about working with Clojure or ClojureScript gives you the most value?*

The most rewarding aspect of Clojure is that the language lets you focus
on the problem domain. "What does the data look like? How should we
filter and transform it before we pass it on? Let's run this in the REPL
and see what happens. OK, now put that in a function. Write a spec for
it and stabilize it with tests." That workflow ties in really nice to
how human problem solving works. In practice it lets us implement new
features at a rapid pace.

*What is your favorite feature of Clojure or ClojureScript?*

The most important feature is Clojure's persistent immutable data
structures. They remove a whole class of problems. No more worries that
something else will change your data.

We also like Clojure spec. Prior to spec we'd reached a point where
certain functions got hard to reason about in isolation. That meant we
had to look at the calling context to find out what data structures the
code operated on and what it actually did. This is of course something
that hits you in all dynamically typed languages, but the issue seemed
more pronounced due to the high abstraction levels that Clojure
encourages. spec helped a lot by making the code easier to reason about,
which IMHO is the single most important aspect to optimize when it comes
to software development.

*What is your stack?*

Our web systems use a traditional stack based on [[https://github.com/ring-clojure/ring][Ring]] and
[[https://github.com/weavejester/compojure][Compojure]]. The rendering is mostly server-side using [[https://github.com/yogthos/Selmer][Selmer]], with a
thin layer of JavaScript on top. We use D3 for visualizations. Our
cloud solution runs on Amazon Web Services.

*Why is using Clojure or ClojureScript valuable to your business?*

There are two main reasons. First of all, when we started up I was the
only programmer and I knew we had to iterate fast to build something
useful. That meant I had to use my time as efficiently as possible.
Clojure was an enabler that allowed me to quickly prototype a new idea,
evaluate it, and then iterate until we had a stable solution. This is an
aspect of Clojure that we still benefit from since we're exploring a new
domain with our analyses.

The second reason isn't technical at all. One of the main reasons I
chose Clojure for Empear was because the language looked fun. And fun is
a much underestimated motivator in the software industry; Fun is
virtually a guarantee that things get done.

** Freshcode
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/freshcode.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/freshcode
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-12-16
:CUSTOM_ID: content/stories/freshcode
:END:

[[./assets/images/content/stories/freshcode.png]]

*How long have you been working with Clojure or ClojureScript?*

[[https://freshcodeit.com/][Freshcode]] has been using Clojure since 2013 and we never were
disappointed. We help SMBs to achieve Clojure's unique approaches
which we sincerely appreciate.

*How big is the team you have using Clojure or ClojureScript?*

Over 10 Clojure developers and 6 successful projects.

*What product or service are you building with Clojure or ClojureScript?*

We started developing our own product in Clojure in January 2013. It was
an eCommerce platform for smart buying --- the choice was between
Clojure and Ruby on Rails, and our founder decided to go with Clojure as
it offered concise syntax, speed of development, and a new paradigm.

One year later we won our first commercial client in Clojure from
Australia. As early as January 2015, our Clojure team grew to 4 people
and we integrated Clojure into 3 of our projects as it was fit to solve
specific tasks and challenges.

2016 --- through the year we've worked with 3 clients for education,
politics, and e-commerce. Next year we embarked on a project for a
biotechnology company and have grown to have 6 team members.

Nov 2019 --- another product in finance in our portfolio and the team
rises to 11 people and combined experience of more than 100 years in
Clojure. In March 2020 we started a Clojure and functional programming
community in our city and we keep growing it.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

We talked to one of our Clojure developers, Vladimir Pavlyuk, about how
he uses Clojure and ClojureScript at Freshcode.

What Clojure or ClojureScript library have you enjoyed working with the
most?

There are a couple of them. I love
[[https://github.com/reagent-project/reagent][Reagent]], as it allows me
to easily manage React state using native ClojureScript atom API.
[[https://github.com/ingesolvoll/kee-frame][kee-frame]] is another
library I believe I would prefer to go, especially for route management.

Love the [[https://clojure.org/guides/spec][clojure.spec]] with its
handy and functional interface to provide specifications.

*What about working with Clojure or ClojureScript gives you the most value?*

It's probably working with a highly skilled community, which acts like a
small family of people loving what they're doing. Still it's much more
to learn from them.

*What is your favorite feature of Clojure or ClojureScript?*

Macros, thread-safe binding, and laziness, in order of importance.

*What is your stack?*

As I got used to implement web-servers & clients, my stack mostly
includes Clojurescript + [[https://github.com/reagent-project/reagent][reagent]], [[https://github.com/day8/re-frame][re-frame]], [[https://github.com/metosin/reitit][reitit]] on the front end,
and Clojure + [[https://github.com/http-kit/http-kit][http-kit]], [[https://github.com/tolitius/mount][tolitius/mount]], [[https://github.com/juxt/bidi][bidi]] on the backend. Got used
to work with [[https://github.com/seancorfield/honeysql][honeysql]] and [[https://github.com/layerware/hugsql][HugSQL]] libraries.

*Why is using Clojure or ClojureScript valuable to your business?*

It's quite easy to start an app using Clojure, as long as you are aware
with its syntax. Clojure does not force you to stick to a certain
paradigm, as Java tries to do; however you can use all JVM facilities.
It is easier to code, but still is a powerful instrument. Besides,
macros allow creating custom DSLs, to facilitate project interaction
with your business partners.

** Kidblog
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/kidblog.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/kidblog
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-07-28
:CUSTOM_ID: content/stories/kidblog
:END:

We talked with Matt Hardy about their use of Clojure at [[https://kidblog.org][Kidblog]].

[[./assets/images/content/stories/kidblog.jpg]]

*How long have you been working with Clojure?*

Kidblog has been using Clojure in production since 2013 when we
refactored our Java REST api to use an early version of Compojure.

*How big is your team?*

Kidblog's product team includes three engineers and a project manager.

*What product or service are you building with Clojure?*

Kidblog provides safe student publishing for K-12 teachers and schools
in over 70 countries around the world. Our web-based blogging platform
offers teachers unique privacy and moderation tools, while giving
students an opportunity to share their voice with an authentic audience.

*What is your stack?*

Elasticsearch, Clojure, Java, Hazelcast, AngularJS

*What Clojure library have you enjoyed working with the most?*

- [[https://github.com/ptaoussanis/tufte][Tufte]] has helped us understand inefficient areas of our code to
  drive performance improvements.
- Switching from Spring to [[https://github.com/tolitius/mount][Mount]] has made managing app state much
  easier and more testable.
- [[https://github.com/scgilardi/slingshot][Slingshot]] enables clojure-centric exception handling.
- [[https://github.com/KirinDave/clj-time][clj-time]] is non-glamourous, but an extremely useful utility library.

*What about working with Clojure gives you the most value?*

Persistent data structures reduce cognitive load and eliminate an entire
class of errors caused by mutation. REPL-driven development provides
immediate feedback and is more enjoyable, helping us rapidly deliver
features to customers. Java interop lets us leverage existing libraries
and benefit from the maturity of the JVM. The standard library is built
around simple, powerful, and composable data manipulation functions.
Overall, Clojure makes our code more enjoyable to write, pleasant to
read, and easier to review.

** LendUp
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/lendup.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/lendup
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-08-07
:CUSTOM_ID: content/stories/lendup
:END:

We talked to [[https://www.lendup.com][LendUp]] about their use of Clojure.

[[./assets/images/content/stories/lendup.jpg]]

*How long have you been working with Clojure?*

We have been using Clojure in production since 2016.

*How big is your team?*

Currently we have around 5 engineers from the data platform and core
services teams developing tools and services entirely in Clojure.

*What product or service are you building with Clojure?*

The LendUp data engineering team started using Clojure in production to
bootstrap some tooling around a few existing ETL pipelines. This
experiment proved to be quite successful and as we started to evolve our
architecture and move to a more services oriented pattern, we started to
adopt Clojure more widely across other parts of our system as well. We
now have Clojure services and tooling powering our data pipelines and
core real-time decisioning & servicing infrastructure.

*What Clojure library have you enjoyed working with the most?*

We have been using [[https://github.com/ring-clojure/ring][Ring]] and [[https://github.com/plumatic/schema][Schema]] extensively at LendUp.  Ring is an
elegant web framework that enables us to quickly start up a web
application and leverage a large selection of pre-written
middlewares. Coming from a Java background, we definitely miss the
static type checking. The Schema library is a solid alternative to a
full-blown type system, and it has helped us ensure the contracts over
data from internal functions and external services.

*What is your favorite feature of Clojure or ClojureScript?*

Some of the language features, especially the ability to express "code
as data" and macro support, has enabled to create pretty effective DSLs
to express pretty complex business logic. The built in support for
immutability in the language and data structures have also fundamentally
changed our code base and data architecture as well.

*What is your stack?*

LendUp backend is primarily built on Java. We also have production
services written in Python and Clojure. On the frontend side, the
company started with Backbone, and has been gradually migrating to React
+ GraphQL.

*Why is using Clojure or ClojureScript valuable to your business?*

At LendUp, we have a set of engineering values that guide us as
individuals and teams: pragmatism, simplicity, relentlessness,
collaboration, ownership and excellence. Clojure fits nicely into our
value system. It's made enterprise software development a lot more fun.
We're able to iterate on changes faster, build composable and focused
components, leverage massive amount of battle-tested, production-ready
Java libraries, and we have a much smaller code base to maintain.

** Ona
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/ona.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/ona
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-04-13
:CUSTOM_ID: content/stories/ona
:END:

Today we talk to Peter Lubell-Doughtie about [[https://ona.io][Ona]].

[[./assets/images/content/stories/ona-logo.png]]

*How long have you been working with Clojure and ClojureScript?*

Ona has been working with Clojure and ClojureScript for three years. We
started using it when we built an updated version of the front-end to
our data collection and management platform. I was introduced to Clojure
about five years ago through Cascalog. I've had an affinity for LISPs
ever since learning it in undergrad and using it in a genetic
programming research project that generated s-expressions to evolve an
agent communication language.

*How big is the team you have using Clojure or ClojureScript?*

At any one time we have about 4-6 team members working full-time on
projects in Clojure and ClojureScript; this comes out to about a third
of our engineering team. We use a number of different editors,
including [[https://github.com/onaio/meow][Meow]], an emacs config created by one of our engineers.

*What product or service are you building with Clojure or
ClojureScript?*

We are building a data collection, management, and visualization
platform targeted at humanitarian and international development
organizations. These organizations, e.g. the World Food Program and
UNICEF, use our platform to conduct on-going surveys in the
field. Field data is merged with historic data in real-time to
construct a comprehensive view of projects they have invested in or
are running.  This allows organizations to see problems as they occur
and make adjustments, e.g. directing health workers to understaffed
clinics or inspectors to buildings with more severe damage. The
Clojure and ClojureScript component is a stateless layer with all data
persistence and retrieval mediated through our API client, [[https://github.com/onaio/milia/][Milia]], and
visualization in our ClojureScript data viewers, [[https://github.com/onaio/hatti][Hatti]] and
[[https://github.com/onaio/vega-viewer][Vega-viewer]].

*What Clojure or ClojureScript library have you enjoyed working with the most?*

On the Clojure side, we've benefited a lot from the Ring middleware
[[https://github.com/magnars/optimus][Optimus]], which bundles and
optimizes all our assets.

On the ClojureScript side, we were early adopters of Om and use it
extensively to render reactive views. We use it with Hiccup-based
markup, some of which is shared with Clojure (we'd like to share more).

For libraries we use in both Clojure and ClojureScript, we make heavy
use of the i18n library [[https://github.com/ptaoussanis/tempura][Tempura]] combined with [[https://github.com/onaio/chimera/blob/master/src/chimera/i18n.cljc][custom helpers]] to load
all text from translation files. We also run a lot of static analyzers
in our build step including [[https://github.com/jonase/kibit][Kibit]] and [[https://github.com/dakrone/lein-bikeshed][Bikeshed]] to catch duplication
and enforce uniform code-style.

*What about working with Clojure or ClojureScript gives you the most value?*

Consistency and an approximation of purity give us the most value. When
using Clojure and ClojureScript we can look at the front-end or
back-end---really anywhere in our codebase---and know it's following the
same set of simple rules. We can trace through the data flow and
explicitly see how transformations are happening.

These features also help us when working with less experienced engineers
or engineers without a functional programming background. Working in
Clojure, with strict static analyzers, significantly limit the possible
approaches to solve a problem, and rules out a bunch of anti-patterns.

*What is your stack?*

We use NGINX as a reverse-proxy to hand-off requests to our
application server which runs a [[https://github.com/ring-clojure/ring][Ring]] based Jetty server and routes
requests to a set of views using [[https://github.com/weavejester/compojure][Compojure]]. We render views on the
server side using [[https://github.com/cgrand/enlive][Enlive]] and occasionally [[https://github.com/weavejester/hiccup][Hiccup]]. All styles are
written in SCSS. The client side uses [[https://github.com/omcljs/om][Om]] to render React views with
[[https://github.com/gf3/secretary][Secretary]] for routing and [[https://github.com/r0man/sablono][Sablono]] for markup. We use our [[https://github.com/clojure/core.async][core.async]]
based API client [[https://github.com/onaio/milia][Milia]] to interact with API data from the client side.

For testing, we self-host [[https://github.com/drone/drone][Drone]] to run continuous integration
builds. Code must get past [[https://github.com/sasstools/sass-lint][Sass-lint]], [[https://github.com/dakrone/lein-bikeshed][Bikeshed]], [[https://github.com/weavejester/cljfmt][cljfmt]], [[https://github.com/jonase/eastwood][Eastwood]],
[[https://github.com/jonase/kibit][Kibit]], and a production ClojureScript build (which will alert us to
any issues with advanced compilation), before we run the tests
suites. We write Clojure tests in [[https://github.com/marick/Midje][Midje]] and ClojureScript tests in
[[https://github.com/clojure/clojurescript/wiki/Testing][cljs.test]].

*Why is using Clojure or ClojureScript valuable to your business?*

Because our platform is used globally to improve child and maternal
health, governance, agriculture, access to infrastructure, and
government accountability, mistakes in our platform have serious
consequences. E.g. fewer vaccinations given and fewer essential
resources distributed (think water and blankets). In a very literal way,
our mistakes mean fewer lives saved. Using Clojure and ClojureScript
simplifies how we process real-time data streams from around the world,
and helps us minimize our mistakes. If you're interested in working with
us please [[https://ona.io/contact.html][get in touch]].

** Pisano
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/pisano.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/pisano
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2019-11-06
:CUSTOM_ID: content/stories/pisano
:END:

[[./assets/images/content/stories/pisano.png]]

*How long have you been working with Clojure or ClojureScript?*

We've been using Clojure and ClojureScript at [[https://www.pisano.co][Pisano]] in production for
a year. It is now our main language and we are very happy to work with
it.

*How big is the team you have using Clojure or ClojureScript?*

We have 6 full-stack developers working on our frontend and backend
services in Clojure/Script.

*What product or service are you building with Clojure or ClojureScript?*

At Pisano, we develop an elegant and innovative enterprise customer
experience management platform where we enable businesses to better
understand their customers and provide an exceptional experience with
the art of collecting feedback from various channels, analyzing their
behavior and engaging with them. Since our motto is speed and
reliability, we choose robust, scalable and productive tools to build
the platform, so we had to choose Clojure.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

On ClojureScript side, we love [[https://github.com/day8/re-frame][re-frame]] / [[http://reagent-project.github.io/][reagent]] / [[http://shadow-cljs.org/][shadow.cljs]]
combination. It's really easy to work with. Frontend development never
got easier before. We can rapidly develop features we want and
whenever we want, it's a real pleasure.

On Clojure side, we use [[http://clojure-liberator.github.io/liberator/][liberator]], [[https://github.com/ring-clojure/ring][ring]], [[https://github.com/weavejester/compojure][compojure]], [[https://github.com/tolitius/mount][mount]], etc. It's
cool to see changes when you pass code to REPL. Also, [[https://github.com/redplanetlabs/specter][Specter]] library
(both Clojure and ClojureScript) saves our days when it comes to data
manipulation.

*What about working with Clojure or ClojureScript gives you the most value?*

First of all: Clojure itself. There is no incidental complexity
(language design) so we can focus on the main problem; business logic.
REPL also very cool so interactive development helps us to go fast.
Large library/framework ecosystem of JVM and JavaScript that we can not
avoid, especially when developing an enterprise platform.

*What is your favorite feature of Clojure or ClojureScript?*

Modeling our system state with data structures is a delightful
experience, it looks natural and this is how it is supposed to be. This
approach allows us to understand/test our system better. Immutability,
pure functions, REPL, host interop, and macros, etc. great things to
have.

*What is your stack?*

We use [[http://www.http-kit.org/][http-kit]] as our web servers.  Postgres for RDS also using Redis
for caching. We also have services written in Ruby (large Ruby
codebase). In the frontend, reagent/re-frame/shadow.cljs combination
for some of our apps.

*Why is using Clojure or ClojureScript valuable to your business?*

Clojure allows us to develop applications that are robust, simpler,
smaller and easier to understand. We could not find any language besides
Clojure to provide this kinda thing. It is valuable to us because we can
do so much more with less. We have a very small team and we are usually
able to add features within a short period (mostly hours).
Clojure/Script allows us to develop code more quickly via REPL driven
development. It makes our product better and development process much
faster. Now enterprise software development a lot more fun with Clojure.

** Reify Health
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/reify.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/reify
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2020-11-30
:CUSTOM_ID: content/stories/reify
:END:

[[./assets/images/content/stories/reify.png]]

*How long have you been working with Clojure or ClojureScript?*

We've been using Clojure and ClojureScript at [[https://www.reifyhealth.com/][Reify Health]] in
production for four years. It is the primary language for existing
capabilities and all new features development.

*How big is the team you have using Clojure or ClojureScript?*

We have over 20 developers working on our frontend and backend services
in Clojure and ClojureScript.

*What product or service are you building with Clojure or ClojureScript?*

We provide cloud-based products to help accelerate the development of
new, life-saving therapies. We serve the global drug development
industry: hundreds of clinical research sites and many of the top 20
pharmaceutical companies.

Our flagship solution StudyTeam™ was developed with the understanding
that both sites and sponsors rely on one another to run clinical trials
effectively. For sites, StudyTeam makes enrollment workflows simpler and
more intuitive. For sponsors, StudyTeam delivers rich and actionable
insights into recruitment and enrollment performance. For both,
StudyTeam accelerates enrollment, improves site-sponsor relationships,
and helps teams reach their enrollment goals quickly, predictably, and
confidently.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

We've gotten a tremendous amount of leverage from Clojure [[https://clojure.org/about/spec][spec]]. Aside
from data validation and testing, we use custom generators to seed
databases with sample data and to populate UIs with realistic
information, enabling our design team to work on the user experience
without standing up a backend.

*What about working with Clojure or ClojureScript gives you the most value?*

There's a lot of expressive power in Clojure. It's Lisp heritage means
there's a very narrow gap between an idea and its expression to begin
with. The sequence abstraction with its expansive standard library,
immutable data structures, first-rate host platform interop, and a
dynamic, REPL-driven workflow all make Clojure incredibly productive.
But all those productivity gains might easily be lost with language
churn and breaking API changes, were it not for Clojure's steadfast
commitment to stability.

*What is your favorite feature of Clojure or ClojureScript?*

There is a lot to like in Clojure/Script that all boils down to good
design. It was designed from the experience gained working in industry
and being on the hook to deliver efficiently and reliably. There is a
lot of interesting programming language research ongoing, but it's rare
to find it so aware of the day to day of a software engineer. This shows
up in immutability and concurrency as first class citizens, the sequence
pattern of operations working intuitively across all data structures,
the REPL for providing fast feedback loops, and the care taken to
maintain backwards compatibility.

*What is your stack?*

We've tried a few configurations. On the front-end we've used both
om.next and [[https://github.com/day8/re-frame][re-frame]], eventually standardizing on the latter. We've
used [[https://github.com/weavejester/compojure][Compojure]], [[https://github.com/clojure-liberator/liberator][Liberator]], and [[https://github.com/http-kit/http-kit][http-kit]] on the back-end, though these
days we prefer [[http://pedestal.io/][Pedestal]]. We make pretty significant use of
clojure.spec, and our databases are mostly Postgres. The role of Kafka
is also growing within the organization.

*Why is using Clojure or ClojureScript valuable to your business?*

Clojure is expressive. As a Lisp, the language itself is small; there is
very little syntax or boilerplate required to express ideas as code. We
believe that difference matters. We appreciate the high signal-to-noise
ratio and think that it makes for smaller programs and fewer defects.

Clojure is practical. The first-class interop between the language and
the hosting platform gives us access to literally thousands of
high-quality libraries written for JavaScript or the JVM. The fact that
essentially the same language runs in the browser as on the server means
we can reap the benefits twice over.

Clojure is functional. We mean not only to say that it encourages a
particular style of programming with immutable values that is inherently
easier to reason about, but also that it is well suited for building the
kinds of software we need to write. We have yet to find a tool that is
better suited to the processing of information.

In summary, Clojure is a language for working programmers, and we've got
work to do.

** Radio Television Suisse
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/rts.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/rts
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-04-04
:CUSTOM_ID: content/stories/rts
:END:

Welcome to the first in an ongoing series of interviews with companies
using Clojure and ClojureScript!

[[./assets/images/content/stories/rts.jpeg]]

This first interview is with Frédéric Vergez about his work at [[https://rts.ch/][RTS
(Radio Télévision Suisse)]], the Swiss national TV and radio
broadcaster, and the [[https://www.rts.ch/info][national news website]].

*How long have you been working with Clojure and ClojureScript?*

For the last 3 years with Clojure, a bit more than a year with
ClojureScript.

*How are you using Clojure and ClojureScript?*

Mainly data processing and visualisation for news articles, maps, and
web-services in the data-journalism domain. Some examples include a
map of events during the 5 year period after the "Arab Spring" and
[[https://www.rts.ch/sweethome/][$weethome]], a "quality of life" simulator in Switzerland.

*What libraries have you enjoyed working with the most?*

We use a lot of libraries, but the most important ones would be:

- [[https://github.com/clojure/core.async][core.async]]: everywhere, backend, front-end. It definitely changed
  the way we're addressing concurrency/parallelism concerns,
  especially with ClojureScript
- [[http://reagent-project.github.io/][reagent]]: absolute must on frontend for SPA
- [[http://incanter.org/][incanter]]: really useful for data processing (we confess, we're also
  using python)
- [[http://cascalog.org/][cascalog]]: sometimes we're not far from big data
- [[https://github.com/weavejester/compojure][compojure]], [[https://github.com/ring-clojure/ring][ring]] & [[http://immutant.org/][immutant]]: as core REST backend
- [[https://github.com/cgrand/enlive/wiki][enlive]]: we do scraping, a lot
- [[http://www.http-kit.org/][clj(s)-http/http-kit]]
- [[https://github.com/plumatic/dommy][dommy]]
- [[https://github.com/weavejester/environ][environ]]

We're still evaluating [[https://clojure.org/about/spec][clojure.spec]], and use it mainly on
backends. Also considering [[http://www.datomic.com/][Datomic]] (still in early phases / P.O.C).

*What about working with Clojure gives you the most value?*

- functional
- pragmatism
- readability
- performance
- one language/philosophy from backend to frontend

*What is your favorite feature of Clojure/ClojureScript?*

- LISP
- JVM/Node/V8/CLR : omnipresence
- REPL based
- Good IDE support

*What is your stack?*

Mainly based on AWS (S3, EC2, Beanstalk, EMR, RDS...​) for backend. We
use PostgreSQL and PostGIS a lot but are considering Datalog on some
projects. We're currently evaluating using AWS Lambda with Clojure, and
seriously considering using it with ClojureScript + Node.

*Why is using Clojure/ClojureScript valuable to your business?*

- sustainability
- relative simplicity
- coherence of the language/stack/community
- time to market
- fun!

** Signal
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/signal.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/signal
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-06-07
:CUSTOM_ID: content/stories/signal
:END:

We talked with Luca Grulla about their use of Clojure and ClojureScript
at [[http://signalmedia.co/][Signal]].

[[./assets/images/content/stories/signal.jpg]]

*How long have you been working with Clojure and ClojureScript?*

Signal has been working with Clojure since 2014 and with ClojureScript
since 2016.

*How big is your team?*

We are a team of 14 (between developers and researchers) using Clojure
and ClojureScript on different parts of our system.

*What product or service are you building?*

Signal is an AI company. We ingest unstructured text and make sense of
it via a text analytics pipeline. A large part of our ingestion pipeline
is written in Clojure. We also extensively use Clojure for some of our
internal APIs. Over the last year we've been using Clojurescript to
build a new product for search and retrieval of legal data on large
scale.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

Reagent is really nice. We use Ring and Compojure in anger and we find
them very valuable. Recently we also started using http-kit more and
more.

*What about working with Clojure and ClojureScript gives you the most value?*

Elegance of code, composability, implicit parallelisation and access to
a great community.

*What is your favorite feature of Clojure or ClojureScript?*

The Clojure core is just brilliant. It's small enough to be easy to
remember but it has pretty much all you need to compose functions in
more sophisticated ones.

*What is your stack?*

Right now the majority of our stack is written in a mix of Clojure,
Python and Javascript. A core component of our system is Elasticsearch:
we self-host and manage a 20TB cluster. All our infrastructure is on AWS
and we use Terraform to manage it. We're also experimenting with Golang
and Erlang.

*Why is using Clojure or ClojureScript valuable to your business?*

The nature of the language allows us to express complex concepts in a
very terse way. The fact that us running over the JVM is an incredible
added value; JVM is easy to monitor and it's incredibly resilient. The
Clojure community is also very strong and it's a great source for
talented people to join our team!

** Stitch
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/stitch.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/stitch
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-04-19
:CUSTOM_ID: content/stories/stitch
:END:

[[./assets/images/content/stories/stitch.jpg]]

*What product or service are you building with Clojure or ClojureScript?*

[[https://www.stitchdata.com/?utm_medium=partner&utm_campaign=clojure.org][Stitch]] is an extract-transform-load (ETL) service that connects to
tools like Salesforce and Facebook Ads and consolidates data from
those platforms into a central location -- a data warehouse -- where
it's available for analysis.

*How long have you been working with Clojure?*

We've been using Clojure in production since our company's inception in
2016. Many of our early team members had worked with Clojure in prior
roles, so it was an obvious choice.

*How big is your team?*

We have 12 engineers working on our back-end services in Clojure.

*What Clojure library have you enjoyed working with the most?*

We use a few different native Clojure libraries, such as ring,
compojure, and http-kit. However, when a well-supported Java library
exists for a particular purpose, we tend to use the Java version and
rely on Clojure's excellent [[https://clojure.org/reference/java_interop][Java interop]] support.  For example, we use
Java client libraries for various AWS services, Apache ZooKeeper, and
Apache Kafka.

*What is your favorite feature of Clojure or ClojureScript?*

There are many, but a couple stand out:

- Immutability. We try to rely on referential transparency as much as
  possible, which makes our applications easier to test and understand.
- Interactive development. Many of us use Emacs with CIDER, which
  allows us to develop, debug, and test things interactively.

*What is your stack?*

Our web services run on AWS EC2 instances behind an ELB load balancer.
We use ring and Jetty as our web servers. Most of our newer databases
are Postgres RDS. Some of our applications use Redis for caching.

Our actual data pipeline is fronted by a Clojure web service that stores
data to Kafka, and then several more small Clojure services that route,
transform, and load the data to its destination.

*Why is using Clojure or ClojureScript valuable to your business?*

Clojure allows us to develop robust applications that are simpler,
smaller, and easier to understand than they would be if we wrote them in
some other languages. We have the entire ecosystem of Java libraries at
our disposal. It allows our developers to debug problems quickly by
connecting to a running JVM and executing code. And using clojure.test
combined with the interactivity of an nREPL connection lets us prototype
quickly with a tight iterative TDD loop.

** Swing Education
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/swing.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/swing
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2018-01-24
:CUSTOM_ID: content/stories/swing
:END:

[[./assets/images/content/stories/swing-logo.png]]

*How long have you been working with Clojure or ClojureScript?*

[[http://www.swingeducation.com/][Swing Education]] has been working with Clojure and Clojurescript since
being founded in early 2015.  Personally I've been working with
Clojure since late 2013.

*How big is the team you have using Clojure or ClojureScript?*

Our current engineering team currently consist of three full-time
engineers. Our codebase is essentially 100% Clojure. We are actively
hiring for Q1 2018 and hope to grow the team to five engineers and one
person that is more designer/UI-UX-focused but will still likely end up
working with Clojure.

*What product or service are you building with Clojure or ClojureScript?*

Our primary product is an online marketplace for schools to issue
requests for subsitute teachers. We help schools access more subs and
try to automate via software tedious work associated with managing a
pool of substitute teachers (recruiting, screening, payroll, etc.). Our
network provides subs with a wider range of work opportunities to gain
experience and build their professional network.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

Strictly speaking perhaps not a library, but regardless [[https://www.datomic.com/][Datomic]] has
been extremely enjoyable to work with. A small subset of the
highlights:

- Being able to treat the database as a value has made most of our code
  extremely deterministic and removes many different classes of
  potential errors due to "oh this value changed during execution"
  since the db value is consistent.
- d/transact returns the resulting db value after transacting which
  removes issues that traditionally occur with reads after writes with
  read-replicas.
- tx-data being represented as simple vectors and maps allows us to
  compose transactions elegantly and makes it much easier to
  programatically generate code that either creates or modifies
  multiple entities at once.
- The transaction listener queue is an elegant way to listen for data
  changes that require notifications to get triggered without tight
  coupling to the point at which the transaction was executed. If our
  notification process needs to shut-down or restart, we can use
  d/tx-log to walk through the log again (lazily no less!) from our
  last known notification point.
- d/as-of and d/since have been used to help time-travel to understand
  what a user was seeing at a particular time or what the system saw
  when it was executing. Both bugs and correct behavior have been
  confirmed this way in production when used in combination with code
  that expects the database as an argument.
- Transaction metadata allows us to easily record who did what when how
  and why and then both query against as well as use the corresponding
  tx-log entities as arguments for d/as-of and d/since to understand
  what happened in the system.
- Testing and developer setup is massively simplified with speculative
  transactions via d/with and the in-memory database allowing us to not
  have an external process to manage or setup.
- Database filtering via d/filter provides an elegant way to re-use
  queries. For instance, we have queries that report on total activity
  on our system, and then re-use the exact same query but with a
  database filter applied to a breakdown by geographical region or
  scoped by time (requested created within past 7 days, past month,
  etc).

  Note that this is somewhat less efficient than writing a separate
  function to do the aggregation on a per-region level during a single
  pass, but for us the total dataset is still fairly small so the CPU
  processing time is irrelevant. It is more important to us to be able
  to flexibly filter out data from the query and can't beat the ease of
  implementation ...
- Lazy iteration via d/datoms and d/index-range based off of a db
  value! Most of our data processing operates on one small subset of
  data at a time or merely requires minimial aggregation state.

  Doing this via a traditional SQL based system is difficult since
  while you can write Clojure functions to generate a lazy sequence of
  LIMIT/OFFSET calls your view of the world isn't consistent.

*What about working with Clojure or ClojureScript gives you the most value?*

The most valuable property to us is that there is only one programming
language that is used everywhere and allows us to share code between the
database (either via jars loaded onto the transactor classpath or via
transaction functions), web server, and client.

*What is your favorite feature of Clojure or ClojureScript?*

Probably host inter-op. The ability to leverage existing libaries in
both ecosystems via interop if necessary allows Clojure/Script to
piggyback off of these huge ecosystems while providing additional value
on top.

*Why is using Clojure or ClojureScript valuable to your business?*

Clojure allows us to develop code more quickly via REPL-driven
development. The resulting code is typically less bug-prone because
everything is immutable and functions are re-entrant, and also makes
testing much easier. The facilities provided for reducing boilerplate
via macros and emphasis on data allow for better re-use and results in
less code duplication and higher order programming.

Our code has been fairly easy to maintain because of the emphasis on
simplicity and stability from both the core language and the wider
Clojure open-source community.

*What is your stack?*

On the server side, we use Datomic with DynamoDB as the underlying
storage. Our web servers run [[http://www.http-kit.org/][http-kit]]. We use [[https://github.com/weavejester/compojure][Compojure]] for routing
and [[https://github.com/ptaoussanis/sente][Sente]] for real-time communication.

On the client side, we use [[https://github.com/tonsky/datascript][DataScript]] and [[https://github.com/reagent-project/reagent][Reagent]] for web clients, and
also have a mobile app implemented in [[https://clojurescript.org][ClojureScript]] on top of [[https://facebook.github.io/react-native/][React
Native]] for iOS.

** University Health Network
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/uhn.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/uhn
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-04-11
:CUSTOM_ID: content/stories/uhn
:END:

This interview is a discussion with Dmitri Sotnikov about his use of
Clojure and ClojureScript at University Health Network (UHN).

[[./assets/images/content/stories/logo-uhn.png]]

*How long have you been working with Clojure and ClojureScript?*

My team started using Clojure about six years ago, and we integrated
ClojureScript into our stack last year with our latest project.

*How big is the team you have using Clojure or ClojureScript?*

We have a team of about 30 developers, some of them are using Clojure
while others are using other languages such as Java and C#. The number
of people using Clojure has been steadily increasing as the benefits
have become evident. My immediate team consists of eight developers
working exclusively with Clojure.

*What products or services are you building?*

The clinicians at the University Health Network (UHN) operate in a
complex healthcare environment where many aspects of patient care have
to be coordinated between multiple disciplines. Our team builds products
that help clinicians streamline their workflow.

An example of such a workflow is the one found at the Bariatric Clinic,
where obese patients require assessments for weight loss surgery. Let's
take a look at the problem we faced and how we addressed it.

Assessments are conducted by professionals from across five disciplines.
The assessment starts with a nurse consultation, followed by a visit
with a social worker, then a dietitian, and then the psych team.
Finally, patient is scheduled for the surgeon interview. The surgeon
must have the information collected by other disciplines in condensed
form.

The assessments must be completed in a specific order with each
assessment being dependent on the results from the previous ones.

The task is further complicated by the fact that all the assessments
work with a common set of data. Each discipline requires to see a subset
of the data and uses a different set of terminologies when referring to
the data elements.

When a piece of data is modified, it may trigger updates in the data
model including those that aren't part of the view that the user is
working on. Since multiple users may be working on different parts of
the assessment concurrently, we have to take extra care to ensure data
integrity within the application.

The project aimed to provide a new kind of workflow for the users, and
this implied having evolving requirements as we continued to receive
user feedback.

The project team chose to use an agile development approach to allow for
greater flexibility. The workflow was broken up into modules for each
discipline. We would deploy each module as it was finished, and
integrate user feedback into design of the system as further modules
were developed.

The team created a Clojure DSL for writing screens and business logic
for the application. These definitions are stored in a database, and are
used to generate the views at runtime.

This model provides us with the ability to modify any aspect of the
assessment without the need to redeploy either the client or the server
portions of the application.

*Why is using Clojure or ClojureScript valuable to your business?*

Clojure allowed us to deliver an innovative product that provided the
best possible workflow for the users. Our application was ultimately
the recipient of the [[http://www.itworldcanada.com/article/university-health-network-transforms-patient-care/387156][2016 ITAC Ingenious Award]].

Through the use of the of the application, the clinic dramatically
reduced wait times for the patients from 128 to 63 days. While the
dictation time used by clinicians fell by 80%, representing a total
savings so far of $240,000.

*What about working with Clojure and ClojureScript gives you the most value?*

We really like working with the JVM, and wish to continue leveraging
this platform for our projects. However, we also recognized the need for
a language that facilitated both rapid development and prototyping while
allowing us to produce robust and maintainable applications.

Our prior experience with Java projects showed that it was a poor fit
for these requirements. Meanwhile, Clojure stood out as a strong
technology choice for a variety of reasons.

The language lets us seamlessly use existing Java libraries and tools in
our projects. This allowed for a gentle transition from our legacy stack
towards a modern one based around Clojure.

Clojure allows us to develop the system interactively, and to quickly
respond to changing needs of the project. The team is able to quickly
prototype solutions without sacrificing code quality. The dynamic nature
of the language allows for a cheaper and faster development process than
what was available to us with Java.

REPL driven development provides us with the ability to explore the
problem space interactively and come up with the best solution through
experimentation. We find that the REPL workflow results in a better
feedback loop than unit testing.

Clojure based solutions end up having a fraction of the code seen in the
projects of similar scope that we previously built in Java. Not only
that, but Clojure makes it much easier to separate the intent of the
code from the implementation details. The ability to separate what is
being done from how it is done results in code that's much easier to
maintain.

Clojure's focus on immutability facilitates a natural decoupling between
parts of the application. In absence of shared global state, it becomes
possible to work on parts of the application in isolation. The resulting
code requires fewer tests since the functions are pure and do not depend
on the overall application state.

Since Clojure is a small and focused language, it made it easy to train
new developers to become productive with it. Our partner CyLogix was
able to train their contractors to work with Clojure in a short time.

Macros provided us with the ability to create domain specific
abstractions. This let us express domain specific logic using the
semantics of that domain.

Finally, Clojure proved to be a stable and reliable platform. We were
able to upgrade the project to new versions of the language without any
changes throughout the development cycle.

*What is your stack?*

We use the [[http://www.luminusweb.net/][Luminus]] stack as the base for our projects. Some of the
libraries that I'd like to mention specifically are:

- [[http://www.hugsql.org/][HugSQL]]
- [[http://immutant.org/][Immutant]]
- [[https://github.com/Day8/re-frame][re-frame]]
- [[https://github.com/ring-clojure/][Ring]]
- [[https://github.com/ptaoussanis/sente][Sente]]

** Zimpler
:PROPERTIES:
:CLOJURE_SITE_FILE: [[./clojure-site/content/stories/zimpler.adoc]]
:CLOJURE_SITE_PAGE: https://clojure.org/stories/zimpler
:CLOJURE_SITE_AUTHOR: Alex Miller
:CLOJURE_SITE_DATE: 2017-11-15
:CUSTOM_ID: content/stories/zimpler
:END:

[[./assets/images/content/stories/zimpler.png]]

This story is about [[https://www.zimpler.com/][Zimpler]] and their use
of Clojure and ClojureScript,

*How long have you been working with Clojure and ClojureScript?*

We started working with ClojureScript in 2015 and Clojure from 2016.
Today we see it as our main language moving forward.

*How big is the team you have using Clojure and ClojureScript?*

Today we are 12 people working in Clojure/ClojureScript but we are
constantly looking to grow the team further.

*What product or service are you building?*

Zimpler is a payment solution. All user facing part of the product, such
as the checkout is written in ClojureScript. Most of the future
applications will be written in Clojure/ClojureScript.

*What Clojure or ClojureScript library have you enjoyed working with the most?*

For ClojureScript, [[https://reagent-project.github.io/][Reagent]] and [[https://github.com/Day8/re-frame][re-frame]] are just really nice to work
with, enabling to express complex logic in a very simple way. On the
backend side, [[https://www.hugsql.org/][HugSQL]] is also a very neat library allowing us to write
SQL queries without adding unnecessary layers of complexity.

*What about working with Clojure and ClojureScript gives you the most value?*

Namespaces and immutability by default makes everything more explicit
and allows us to understand where everything is coming from. This in
turns allows us to collaborate more easily and iterate faster. Also
thanks to the seamless interop with Java and JavaScript, we have access
to a large ecosystem of well tested libraries, making Clojure(Script) a
safe bet.

*What is your favorite feature of Clojure or ClojureScript?*

The focus on values and a REPL driven development makes for a very
interactive experience that many of us enjoy.

*What is your stack?*

In the front-end, reagent + re-frame for all our apps. In the backend,
we have a large Ruby codebase and a growing number of Clojure projects,
with a bit of Haskell (gasp!) here and there.

*Why is using Clojure or ClojureScript valuable to your business?*

Besides the technological benefits discussed above, we also really
like being a part of the Clojure community where we feel that we share
a lot of common values. As a result of this we have had the fortune to
be able to help out supporting both conferences such as [[http://euroclojure.org/][EuroClojure]]
and also local communities like [[https://www.meetup.com/got-lambda/][Got.lambda]] in Gothenburg and
[[http://clojurebridge-berlin.org/][ClojureBridge in Berlin]].
